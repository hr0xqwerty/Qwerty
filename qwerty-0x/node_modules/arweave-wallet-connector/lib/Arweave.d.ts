import type { AsVerifier, Override, Null, ConnectionConstructor, PostMessageOptions } from './types.js';
import type Transaction from 'arweave/web/lib/transaction.js';
import type { TransactionInterface } from 'arweave/web/lib/transaction.js';
import type { ApiConfig } from 'arweave/web/lib/api.js';
interface SerializedTx extends Override<TransactionInterface, {
    data: any;
    tags: {
        name: string;
        value: string;
    }[];
}> {
}
interface DataItemCreateOptions {
    data?: never;
    target?: string;
    anchor?: string;
    tags?: {
        name: string;
        value: string;
    }[];
}
export interface DataItemParams extends Override<DataItemCreateOptions, {
    data?: string;
    signature: string;
}> {
}
declare type DataItemParamsUnsigned = Omit<DataItemParams, 'signature'>;
declare type SignAlgorithm = {
    signAlgorithm?: 'RSA';
};
declare type HashAlgorithm = {
    hashAlgorithm?: 'SHA-256' | 'SHA-384' | 'SHA-512';
};
declare type DecryptOptions = AlgorithmIdentifier | Algorithm;
declare type SignMessageOptions = HashAlgorithm;
declare type VerifyMessageOptions = HashAlgorithm & SignAlgorithm;
export declare type DispatchResult = {
    id?: string;
    type?: 'BASE' | 'BUNDLED';
};
export interface ArweaveInterface {
    getPublicKey(): Promise<string>;
    getArweaveConfig(): Promise<Omit<ApiConfig, 'logger'>>;
    signTransaction(tx: Transaction, options?: object | Null): Promise<Transaction>;
    signDataItem(tx: DataItemParamsUnsigned): Promise<ArrayBuffer>;
    signMessage(message: ArrayBufferView, options: SignMessageOptions): Promise<ArrayBufferView>;
    verifyMessage(message: ArrayBufferView, signature: ArrayBufferView, publicKey: string, options: VerifyMessageOptions): Promise<boolean>;
    dispatch(tx: Transaction, options?: object | Null): Promise<DispatchResult>;
    encrypt(message: ArrayBufferView, publicKey: string, options: DecryptOptions): Promise<ArrayBufferView>;
    decrypt(message: ArrayBufferView, options: DecryptOptions): Promise<ArrayBufferView>;
    privateHash(message: ArrayBufferView, options: HashAlgorithm): Promise<ArrayBufferView>;
}
export interface ArweaveProviderInterface extends Override<ArweaveInterface, {
    getArweaveConfig(): Promise<Override<ApiConfig, {
        logger?: any;
    }>>;
    signTransaction(tx: Partial<SerializedTx>, options?: object | Null): Promise<{
        id: string;
        owner?: string | Null;
        tags?: SerializedTx['tags'] | Null;
        signature: string;
        reward?: string | Null;
    }>;
    dispatch(tx: Partial<SerializedTx>, options?: object | Null): Promise<DispatchResult>;
}> {
}
export declare function ArweaveApi<TBase extends ConnectionConstructor>(Base: TBase): {
    new (...args: any[]): {
        namespaces: {
            arweaveWallet: {
                walletName: string;
                connect: () => any;
                disconnect: () => any;
                getActiveAddress: () => string | undefined;
                getActivePublicKey: () => Promise<string>;
                getAllAddresses: () => never;
                getWalletNames: () => never;
                signature: () => never;
                sign: (tx: Transaction, options?: any) => Promise<Transaction>;
                dispatch: (tx: Transaction, options?: any) => Promise<DispatchResult>;
                encrypt: (data: Uint8Array, options: any) => Promise<Uint8Array>;
                decrypt: (data: Uint8Array, options: any) => Promise<Uint8Array>;
                getPermissions: () => string[];
                getArweaveConfig: () => Promise<Omit<ApiConfig, "logger"> & {
                    logger?: any;
                }>;
            };
        };
        postMessage(method: string, params?: any[], options?: PostMessageOptions): any;
        getPublicKey(): Promise<string>;
        getArweaveConfig(): Promise<Omit<ApiConfig, "logger"> & {
            logger?: any;
        }>;
        signTransaction(tx: Transaction, options?: object | Null): Promise<Transaction>;
        signDataItem(tx: DataItemParamsUnsigned): Promise<ArrayBufferLike>;
        dispatch(tx: Transaction, options?: object | Null): Promise<DispatchResult>;
        signMessage<T extends ArrayBufferView>(message: T, options: SignMessageOptions): Promise<T>;
        verifyMessage(message: ArrayBufferView, signature: ArrayBufferView | string, publicKey: string, options: VerifyMessageOptions): Promise<boolean>;
        encrypt<T_1 extends ArrayBufferView>(message: T_1, publicKey: string, options: DecryptOptions): Promise<T_1>;
        decrypt<T_2 extends ArrayBufferView>(message: T_2, options: DecryptOptions): Promise<T_2>;
        privateHash<T_3 extends ArrayBufferView>(message: T_3, options: HashAlgorithm): Promise<T_3>;
        address?: string | undefined;
        connect(): any;
        disconnect(): any;
    };
} & TBase;
export declare class ArweaveVerifier implements AsVerifier<ArweaveProviderInterface> {
    getPublicKey(): boolean;
    getArweaveConfig(): boolean;
    signTransaction(tx: Partial<SerializedTx>, options?: object | Null): boolean;
    signDataItem(tx: DataItemParamsUnsigned): boolean;
    dispatch(tx: Partial<SerializedTx>, options?: object | Null): boolean;
    signMessage(message: ArrayBufferView, options: SignMessageOptions): boolean;
    verifyMessage(message: ArrayBufferView, signature: ArrayBufferView, publicKey: string, options: VerifyMessageOptions): boolean;
    encrypt(message: ArrayBufferView, publicKey: string, options: DecryptOptions): boolean;
    decrypt(message: ArrayBufferView, options: DecryptOptions): boolean;
    privateHash(message: ArrayBufferView, options: HashAlgorithm): boolean;
}
export {};
