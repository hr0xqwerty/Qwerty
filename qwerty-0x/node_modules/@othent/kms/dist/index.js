"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DEFAULT_APP_INFO: () => DEFAULT_APP_INFO,
  DEFAULT_COOKIE_KEY: () => DEFAULT_COOKIE_KEY,
  DEFAULT_DISPATCH_NODE: () => DEFAULT_DISPATCH_NODE,
  DEFAULT_GATEWAY_CONFIG: () => DEFAULT_GATEWAY_CONFIG,
  DEFAULT_LOCAL_STORAGE_KEY: () => DEFAULT_LOCAL_STORAGE_KEY,
  DEFAULT_OTHENT_CONFIG: () => DEFAULT_OTHENT_CONFIG,
  DEFAULT_OTHENT_OPTIONS: () => DEFAULT_OTHENT_OPTIONS,
  Othent: () => Othent,
  OthentError: () => OthentError,
  OthentErrorID: () => OthentErrorID,
  PROVIDER_LABELS: () => PROVIDER_LABELS,
  b64ToUint8Array: () => b64ToUint8Array,
  b64UrlDecode: () => b64UrlDecode,
  b64UrlEncode: () => b64UrlEncode,
  binaryDataTypeOrStringToBinaryDataType: () => binaryDataTypeOrStringToBinaryDataType,
  binaryDataTypeOrStringTob64String: () => binaryDataTypeOrStringTob64String,
  binaryDataTypeToString: () => binaryDataTypeToString,
  binaryDataTypeTob64Url: () => binaryDataTypeTob64Url,
  hash: () => hash,
  isBufferObject: () => isBufferObject,
  isLegacyBufferObject: () => isLegacyBufferObject,
  stringOrUint8ArrayToUint8Array: () => stringOrUint8ArrayToUint8Array,
  stringToUint8Array: () => stringToUint8Array,
  stringTob64Url: () => stringTob64Url,
  uint8ArrayTob64: () => uint8ArrayTob64,
  uint8ArrayTob64Url: () => uint8ArrayTob64Url
});
module.exports = __toCommonJS(src_exports);

// src/lib/auth/auth0.ts
var import_auth0_spa_js = require("@auth0/auth0-spa-js");

// src/lib/config/config.constants.ts
var DEFAULT_OTHENT_CONFIG = {
  debug: false,
  inject: false,
  auth0Domain: "auth.othent.io",
  auth0ClientId: "uXkRmJoIa0NfzYgYEDAgj6Rss4wR1tIc",
  auth0Strategy: "refresh-tokens",
  auth0Cache: "memory",
  auth0RefreshTokenExpirationMs: 1296e6,
  // 2 weeks
  auth0LogInMethod: "popup",
  auth0RedirectURI: null,
  auth0ReturnToURI: null,
  serverBaseURL: "https://kms-server.othent.io",
  autoConnect: "lazy",
  cookieKey: null,
  localStorageKey: null,
  throwErrors: true,
  tags: []
};
var DEFAULT_APP_INFO = {
  name: "",
  version: "",
  env: typeof location === "undefined" ? "production" : location.hostname === "localhost" ? "development" : "production"
};
var DEFAULT_GATEWAY_CONFIG = {
  host: "arweave.net",
  protocol: "https",
  port: 443
};
var DEFAULT_OTHENT_OPTIONS = {
  ...DEFAULT_OTHENT_CONFIG,
  appInfo: DEFAULT_APP_INFO,
  gatewayConfig: DEFAULT_GATEWAY_CONFIG,
  persistCookie: false,
  persistLocalStorage: false,
  auth0Cache: "memory"
};
var DEFAULT_DISPATCH_NODE = "https://turbo.ardrive.io";
var DEFAULT_COOKIE_KEY = "othentUserDetails";
var DEFAULT_LOCAL_STORAGE_KEY = "othentUserDetails";
var CLIENT_NAME = "Othent KMS";
var CLIENT_VERSION = "2.1.1";
var ANALYTICS_TAGS = [
  {
    name: "Client",
    value: CLIENT_NAME
  },
  {
    name: "Client-Version",
    value: CLIENT_VERSION
  }
];

// src/lib/utils/events/event-listener-handler.ts
var EventListenersHandler = class {
  constructor(options) {
    this.listeners = /* @__PURE__ */ new Set();
    this.initializedListeners = /* @__PURE__ */ new Set();
    this.lastEmittedUpdateId = "";
    this.lastEmittedParams = null;
    this.options = {
      diffParams: false,
      replyOnListen: false
    };
    this.options = {
      ...this.options,
      ...options
    };
  }
  getUpdateId(parameters) {
    const serializer = (_, value) => {
      return value && value === "oject" && !Array.isArray(value) ? Object.entries(value).sort((a, b) => a[0].localeCompare(b[0])) : value;
    };
    const { getUpdateIdTransform } = this.options;
    const transformedParameters = getUpdateIdTransform ? getUpdateIdTransform(parameters) : parameters;
    return JSON.stringify(transformedParameters, serializer);
  }
  get hasListeners() {
    return this.listeners.size > 0;
  }
  add(listener) {
    this.listeners.add(listener);
    if (this.options.replyOnListen && this.lastEmittedParams)
      this.emit(...this.lastEmittedParams);
  }
  delete(listener) {
    this.listeners.add(listener);
  }
  emit(...parameters) {
    const { initializedListeners, lastEmittedUpdateId } = this;
    const updateId = this.getUpdateId(parameters);
    const updatedAlreadyEmitted = lastEmittedUpdateId === updateId;
    this.lastEmittedUpdateId = updateId;
    this.lastEmittedParams = parameters;
    this.listeners.forEach((listenerFn) => {
      if (updatedAlreadyEmitted && initializedListeners.has(listenerFn)) return;
      initializedListeners.add(listenerFn);
      try {
        listenerFn(...parameters);
      } catch (err) {
      }
    });
    return updatedAlreadyEmitted;
  }
};

// src/lib/utils/options/options.utils.ts
var import_extend = __toESM(require("extend"));
function mergeOptions(options, defaults) {
  return (0, import_extend.default)(true, {}, defaults, options);
}

// src/lib/utils/cookies/cookie-storage.ts
var DEFAULT_COOKIE_OPTIONS = {
  secure: true,
  domain: true,
  ttlHours: 360
};
var _CookieStorage = class _CookieStorage {
  // 2 weeks
  constructor(cookieOptions = DEFAULT_COOKIE_OPTIONS) {
    this.secureParam = null;
    this.domainParam = null;
    this.ttlMs = 1296e6;
    const { secureParam, domainParam, ttlMs } = this.parseCookieOptions(
      mergeOptions(cookieOptions, DEFAULT_COOKIE_OPTIONS)
    );
    this.secureParam = secureParam;
    this.domainParam = domainParam;
    this.ttlMs = ttlMs;
    return new Proxy(this, {
      get(target, prop) {
        return prop in target || typeof prop !== "string" ? target[prop] : target.getItem(prop);
      },
      ownKeys(target) {
        return document.cookie.split(_CookieStorage.COOKIE_SEPARATOR).map(
          (cookieStr) => cookieStr.split(_CookieStorage.COOKIE_VALUE_SEPARATOR)[0]
        );
      },
      getOwnPropertyDescriptor() {
        return {
          enumerable: true,
          configurable: true
        };
      }
    });
  }
  parseCookieOptions({
    secure,
    domain,
    ttlHours
  } = {}) {
    const secureParam = secure ? "secure" : secure === void 0 ? this.secureParam : null;
    const domainParam = domain ? `domain=${domain === true ? location.host : domain}` : domain === void 0 ? this.domainParam : null;
    const ttlMs = ttlHours ? ttlHours * 36e5 : ttlHours === void 0 ? this.ttlMs : 0;
    return {
      secureParam,
      domainParam,
      ttlMs
    };
  }
  getCookieParams(cookieOptions) {
    const { secureParam, domainParam, ttlMs } = this.parseCookieOptions(cookieOptions);
    const expirationDate = new Date(Date.now() + ttlMs);
    const expiresParam = `expires=${expirationDate.toUTCString()}`;
    const pathParam = "path=/";
    const cookieParams = [expiresParam, secureParam, domainParam, pathParam].filter(Boolean).join("; ");
    return cookieParams ? ` ${cookieParams};` : "";
  }
  get length() {
    return document.cookie ? document.cookie.split(_CookieStorage.COOKIE_SEPARATOR).length : 0;
  }
  key(index) {
    const cookieStrAtIndex = document.cookie.split(_CookieStorage.COOKIE_SEPARATOR)[index] || "";
    const cookieKey = cookieStrAtIndex.split(
      _CookieStorage.COOKIE_VALUE_SEPARATOR
    )[0];
    return cookieKey || null;
  }
  getItem(name) {
    const targetCookie = document.cookie.split(_CookieStorage.COOKIE_SEPARATOR).find((item) => {
      return item.split(_CookieStorage.COOKIE_VALUE_SEPARATOR)[0] === name;
    });
    return targetCookie && targetCookie.split(_CookieStorage.COOKIE_VALUE_SEPARATOR)[1] || null;
  }
  setItem(key, value, cookieOptions) {
    const serializedValue = typeof value === "string" ? value : JSON.stringify(value);
    const cookieParams = this.getCookieParams(cookieOptions);
    if (process.env.NODE_ENV === "development") {
      const actionLabel = ((cookieOptions == null ? void 0 : cookieOptions.ttlHours) || 1) < 0 ? "Removing" : "Setting";
      console.info(`${actionLabel} cookie ${key}=<VALUE>;${cookieParams}`);
    }
    const cookieStr = `${key}=${serializedValue};${cookieParams}`;
    document.cookie = cookieStr;
    return cookieStr;
  }
  removeItem(key, cookieOptions) {
    return this.setItem(key, "", { ...cookieOptions, ttlHours: -1 });
  }
  clear() {
    document.cookie.split(_CookieStorage.COOKIE_SEPARATOR).forEach((item) => {
      this.removeItem(item.split(_CookieStorage.COOKIE_VALUE_SEPARATOR)[0]);
    });
  }
};
_CookieStorage.COOKIE_SEPARATOR = /\s*;\s*/;
_CookieStorage.COOKIE_VALUE_SEPARATOR = /\s*=\s*/;
var CookieStorage = _CookieStorage;
var cookieStorage = null;
function getCookieStorage() {
  if (!cookieStorage) {
    const hostname = typeof location === "undefined" ? "" : location.hostname;
    const isDevelopment = process.env.NODE_ENV === "development" && hostname === "localhost";
    cookieStorage = new CookieStorage({
      secure: !isDevelopment,
      domain: isDevelopment ? void 0 : hostname
    });
  }
  return cookieStorage;
}

// src/lib/utils/ans/ans.utils.ts
var import_axios = __toESM(require("axios"));
async function getAnsProfile(address) {
  try {
    const response = await import_axios.default.get(
      "https://api.mem.tech/api/state/Tih8T1uESATJNzdwBIY3rpe25kWTzjw8uNiMRYe9I5M",
      {
        // Because this will return the whole contract's state, it could get quite large in the future. Therefore, we set
        // a timeout of 2 seconds to make sure this request doesn't slow down the SDK due to the big download size.
        timeout: 2e3
      }
    );
    const balances = response.data.balances || [];
    const balanceMatch = balances.find(
      (balance) => balance.address === address
    );
    const domain = balanceMatch ? balanceMatch.primary_domain || balanceMatch.ownedDomains[0].domain || null : null;
    return domain ? `${domain}.ar` : null;
  } catch (err) {
    console.warn(`Error resolving ANS domain for ${address} =
`, err);
    return null;
  }
}

// src/lib/auth/auth0.constants.ts
var PROVIDER_LABELS = {
  apple: "Apple",
  auth0: "E-Mail",
  "google-oauth2": "Google",
  // TODO: Complete these values:
  "<Twitch>": "Twitch",
  twitter: "X",
  "<Meta>": "Meta",
  "<LinkedIn>": "LinkedIn",
  github: "GitHub"
};
var CRYPTO_OPERATION_BINARY_DATA_KEYS = [
  "wrappedSignKey",
  "wrappedEncryptDecryptKey",
  "data",
  "plaintext",
  "ciphertext"
];

// src/lib/utils/arweaveUtils.ts
var B64js = __toESM(require("base64-js"));
function binaryDataTypeToUint8Array(buffer) {
  if (buffer instanceof Buffer || buffer instanceof DataView || ArrayBuffer.isView(buffer)) {
    return new Uint8Array(buffer.buffer);
  } else if (buffer instanceof ArrayBuffer) {
    return new Uint8Array(buffer);
  }
  throw new Error("Unknown buffer type.");
}
function binaryDataTypeToString(buffer) {
  return new TextDecoder().decode(buffer);
}
function binaryDataTypeTob64Url(buffer) {
  return uint8ArrayTob64Url(binaryDataTypeToUint8Array(buffer));
}
function binaryDataTypeOrStringTob64String(source) {
  return typeof source === "string" ? stringTob64Url(source) : binaryDataTypeTob64Url(source);
}
function binaryDataTypeOrStringToBinaryDataType(source) {
  return typeof source === "string" ? stringToUint8Array(source) : source;
}
function stringTob64Url(str) {
  return uint8ArrayTob64Url(stringToUint8Array(str));
}
function stringToUint8Array(str) {
  return new TextEncoder().encode(str);
}
function stringOrUint8ArrayToUint8Array(str) {
  return typeof str === "string" ? new TextEncoder().encode(str) : str;
}
function uint8ArrayTob64(buffer) {
  return B64js.fromByteArray(new Uint8Array(buffer));
}
function uint8ArrayTob64Url(buffer) {
  return b64UrlEncode(uint8ArrayTob64(buffer));
}
function b64ToUint8Array(str) {
  return B64js.toByteArray(b64UrlDecode(str));
}
function b64UrlEncode(str) {
  return str.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function b64UrlDecode(str) {
  const padding = str.length % 4 == 0 ? 0 : 4 - str.length % 4;
  return str.replace(/\-/g, "+").replace(/\_/g, "/").concat("=".repeat(padding));
}
async function hash(data, algorithm = "SHA-256") {
  let digest = await crypto.subtle.digest(algorithm, data);
  return new Uint8Array(digest);
}

// src/lib/auth/auth0.utils.ts
function transactionInputReplacer(key, value) {
  if (!CRYPTO_OPERATION_BINARY_DATA_KEYS.includes(key)) return value;
  if (key === "data" && value.hasOwnProperty("path")) return value;
  return binaryDataTypeOrStringTob64String(value);
}

// src/lib/othent-kms-client/operations/import-key.ts
var import_arweave_mnemonic_keys = require("arweave-mnemonic-keys");

// src/lib/utils/errors/error.utils.ts
var import_axios2 = require("axios");

// src/lib/utils/errors/error.ts
var OthentErrorID = /* @__PURE__ */ ((OthentErrorID2) => {
  OthentErrorID2["Unexpected"] = "Unexpected";
  OthentErrorID2["Validation"] = "Validation";
  OthentErrorID2["UserCreation"] = "UserCreation";
  OthentErrorID2["Encryption"] = "Encryption";
  OthentErrorID2["Decryption"] = "Decryption";
  OthentErrorID2["Signing"] = "Signing";
  OthentErrorID2["PublicKey"] = "PublicKey";
  return OthentErrorID2;
})(OthentErrorID || {});
var OthentError = class extends Error {
  constructor(id, developerMessage, error, fromServer = false) {
    super();
    this.name = id;
    this.message = developerMessage || "";
    if (fromServer) {
      this.stack = `${id} (from server): ${developerMessage}
`;
    } else {
      Error.captureStackTrace(this);
    }
    this.id = id;
    this.developerMessage = developerMessage;
    if (error instanceof Error) {
      this.cause = error;
    } else if (typeof error === "string" || typeof error === "number") {
      this.cause = new Error(`${error}`);
    }
  }
};

// src/lib/utils/errors/error.utils.ts
function isErrorResponseData(data) {
  return typeof data === "object" && data.error === true && !!data.id && !!OthentErrorID[data.id];
}
function parseErrorResponse(error) {
  var _a;
  if ((0, import_axios2.isAxiosError)(error)) {
    const data = (_a = error.response) == null ? void 0 : _a.data;
    if (!isErrorResponseData(data)) {
      return error;
    }
    const { id, developerMessage, cause } = data;
    let causeError;
    if (cause) {
      causeError = new Error(cause.message);
      causeError.name = cause.name;
      causeError.stack = cause.stack;
    }
    return new OthentError(id, developerMessage || "", causeError, true);
  }
  if (error instanceof Error) {
    return error;
  }
  return new Error("Unknown error");
}

// src/lib/utils/promises/promises.utils.ts
function isPromise(obj) {
  return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
}

// src/lib/othent-kms-client/operations/import-key.ts
function pemToUint8Array(pem) {
  const pemBufferString = pem.replaceAll("\n", "").replace("-----BEGIN PUBLIC KEY-----", "").replace("-----END PUBLIC KEY-----", "");
  return b64ToUint8Array(pemBufferString);
}

// src/lib/auth/auth0.ts
var OthentAuth0Client = class _OthentAuth0Client {
  constructor({
    debug,
    domain,
    clientId,
    strategy,
    cache,
    loginMethod,
    redirectURI,
    returnToURI,
    refreshTokenExpirationMs,
    appInfo,
    initialUserDetails,
    cookieKey,
    localStorageKey
  }) {
    this.debug = false;
    this.overriddenPublicKey = null;
    this.auth0ClientPromise = Promise.resolve(null);
    this.authEventListenerHandler = new EventListenersHandler({
      diffParams: true,
      replyOnListen: true
    });
    this.userDetails = null;
    this.userDetailsExpirationTimeoutID = 0;
    this.cookieKey = null;
    this.localStorageKey = null;
    this.refreshTokenExpirationMs = +DEFAULT_OTHENT_CONFIG.auth0RefreshTokenExpirationMs;
    this.appInfo = DEFAULT_APP_INFO;
    this.isReady = false;
    this.isAuthenticated = false;
    this.debug = debug;
    this.loginMethod = loginMethod;
    this.redirectURI = redirectURI;
    this.returnToURI = returnToURI;
    this.auth0ClientPromise = (0, import_auth0_spa_js.createAuth0Client)({
      domain,
      clientId,
      useRefreshTokens: strategy === "refresh-tokens",
      cacheLocation: typeof cache === "string" ? cache : void 0,
      cache: typeof cache === "object" ? cache : void 0,
      authorizationParams: {
        redirect_uri: this.redirectURI
        // scope: "openid profile email offline_access"
        // audience
      }
    }).then((Auth0Client2) => {
      this.isReady = true;
      return Auth0Client2;
    });
    this.cookieKey = cookieKey;
    this.localStorageKey = localStorageKey;
    this.refreshTokenExpirationMs = refreshTokenExpirationMs;
    this.appInfo = appInfo;
    this.restoreUserDetails(initialUserDetails || null);
    this.handleStorage = this.handleStorage.bind(this);
  }
  static isIdTokenValidUser(idToken) {
    return !!(idToken && idToken.sub && idToken.owner && idToken.walletAddress && idToken.authSystem === "KMS");
  }
  async getUserDetails(idToken) {
    const { email = "", nickname = "", walletAddress } = idToken;
    const sub = idToken.sub || "";
    const authProvider = sub.split("|")[0];
    let walletAddressLabel = await getAnsProfile(walletAddress);
    if (!walletAddressLabel) {
      const providerLabel = PROVIDER_LABELS[authProvider] || "Unknown Provider";
      walletAddressLabel = `${providerLabel} (${email || (nickname ? `@${nickname}` : "")})`;
    }
    return {
      sub,
      name: idToken.name || "",
      givenName: idToken.given_name || "",
      middleName: idToken.middle_name || "",
      familyName: idToken.family_name || "",
      nickname: idToken.nickname || "",
      preferredUsername: idToken.preferred_username || "",
      profile: idToken.profile || "",
      picture: idToken.picture || "",
      website: idToken.website || "",
      locale: idToken.locale || "",
      updatedAt: idToken.updated_at || "",
      email,
      emailVerified: !!idToken.email_verified,
      owner: this.overriddenPublicKey || idToken.owner,
      walletAddress: idToken.walletAddress,
      walletAddressLabel,
      authSystem: idToken.authSystem,
      authProvider
    };
  }
  // Getters / Setters:
  getAuthEventListenerHandler() {
    return this.authEventListenerHandler;
  }
  setAppInfo(appInfo) {
    this.appInfo = appInfo;
  }
  // Storage listeners:
  initStorageSyncing() {
    if (!this.localStorageKey || typeof window === "undefined") return;
    window.addEventListener("storage", this.handleStorage);
  }
  stopStorageSyncing() {
    if (typeof window === "undefined") return;
    window.removeEventListener("storage", this.handleStorage);
  }
  handleStorage(event) {
    if (event.key !== this.localStorageKey) return;
    if (event.newValue) {
      this.restoreUserDetails();
    } else {
      this.logOut();
    }
  }
  persistUserDetails(userDetails) {
    const { cookieKey, localStorageKey } = this;
    if (cookieKey) {
      const cookieStorage2 = getCookieStorage();
      if (userDetails) {
        cookieStorage2.setItem(cookieKey, JSON.stringify(userDetails), {
          ttlHours: this.refreshTokenExpirationMs / 36e5
        });
      } else if (cookieStorage2.getItem(cookieKey) !== null) {
        cookieStorage2.removeItem(cookieKey);
      }
    }
    if (localStorageKey) {
      if (userDetails) {
        const now = /* @__PURE__ */ new Date();
        const serializedUserDetails = JSON.stringify({
          userDetails,
          createdAt: now.toUTCString(),
          expiredBy: new Date(
            now.getTime() + this.refreshTokenExpirationMs
          ).toUTCString()
        });
        localStorage.setItem(localStorageKey, serializedUserDetails);
      } else {
        this.clearStoredUserDetails();
      }
    }
  }
  // `userDetails` setters:
  setUserDetails(userDetails, updateAuth = true) {
    if (typeof window !== "undefined") {
      window.clearTimeout(this.userDetailsExpirationTimeoutID);
      if (userDetails) {
        this.userDetailsExpirationTimeoutID = window.setTimeout(
          this.logOut,
          this.refreshTokenExpirationMs
        );
      }
    }
    const updatedAlreadyEmitted = this.authEventListenerHandler.emit(
      userDetails,
      updateAuth ? !!userDetails : this.isAuthenticated
    );
    if (!updatedAlreadyEmitted) {
      this.userDetails = userDetails;
    }
    if (updateAuth) {
      this.isAuthenticated = !!userDetails;
      this.persistUserDetails(userDetails);
    }
    return userDetails;
  }
  restoreUserDetails(userDetails) {
    let initialUserDetails = userDetails || null;
    if (!initialUserDetails && this.localStorageKey) {
      try {
        const storedUserDetails = JSON.parse(
          localStorage.getItem(this.localStorageKey) || "null"
        );
        if (storedUserDetails) {
          const expiredBy = new Date(storedUserDetails.expiredBy).getTime();
          if (!isNaN(expiredBy) && expiredBy > Date.now()) {
            initialUserDetails = storedUserDetails.userDetails;
          } else {
            this.clearStoredUserDetails();
          }
        }
      } catch (err) {
      }
    }
    this.setUserDetails(initialUserDetails, false);
  }
  clearStoredUserDetails() {
    Object.keys(localStorage).forEach((key) => {
      if (key.startsWith("othent")) localStorage.removeItem(key);
    });
  }
  async updateUserDetails(idToken) {
    const nextUserDetails = idToken && _OthentAuth0Client.isIdTokenValidUser(idToken) ? await this.getUserDetails(idToken) : null;
    return this.setUserDetails(nextUserDetails);
  }
  getAuthorizationParams(authorizationParamsOrData = {}) {
    const { authorizationParams, data } = authorizationParamsOrData.hasOwnProperty("path") ? {
      authorizationParams: null,
      data: authorizationParamsOrData
    } : {
      authorizationParams: authorizationParamsOrData,
      data: null
    };
    const { appInfo } = this;
    const transactionInput = {
      othentFunction: "KMS",
      othentSDKVersion: CLIENT_NAME,
      othentAPIVersion: CLIENT_VERSION,
      appName: appInfo.name,
      appVersion: appInfo.version,
      appEnv: appInfo.env
    };
    if (data) {
      transactionInput.data = data;
    }
    return {
      ...authorizationParams,
      transaction_input: JSON.stringify(
        transactionInput,
        transactionInputReplacer
      )
    };
  }
  // Wrappers around Auth0's native client with some additional functionality:
  async getTokenSilently(data) {
    const auth0Client = await this.auth0ClientPromise;
    if (!auth0Client) throw new Error("Missing Auth0 Client");
    const authorizationParams = this.getAuthorizationParams(data);
    if (this.debug) {
      try {
        const parsedTransactionInput = JSON.parse(
          authorizationParams.transaction_input
        );
        if (Object.keys(authorizationParams).length === 1 && Object.keys(authorizationParams)[0] === "transaction_input") {
          console.log(
            "getTokenSilently().transaction_input =",
            parsedTransactionInput
          );
        } else {
          console.log("getTokenSilently() =", {
            ...authorizationParams,
            transaction_input: parsedTransactionInput
          });
        }
      } catch (err) {
        console.error("Error logging/parsing `authorizationParams`:", err);
      }
    }
    try {
      const getTokenSilentlyResponse = await auth0Client.getTokenSilently({
        detailedResponse: true,
        authorizationParams,
        cacheMode: "off"
        // Forces the client to get a new token, as we actually include data in them, it cannot be done any other way.
      });
      const idToken = await auth0Client.getUser();
      if (!idToken) throw new Error("Could not get the user's details");
      const userDetails = await this.updateUserDetails(idToken);
      return {
        ...getTokenSilentlyResponse,
        idToken,
        userDetails
      };
    } catch (err) {
      throw err;
    }
  }
  async logIn() {
    const auth0Client = await this.auth0ClientPromise;
    if (!auth0Client) throw new Error("Missing Auth0 Client");
    if (this.debug) console.log("logIn()");
    const isAuthenticated = await auth0Client.isAuthenticated();
    if (isAuthenticated) {
      throw new Error("Already logged in");
    }
    const authorizationParams = this.getAuthorizationParams({
      redirect_uri: this.redirectURI
      // TODO: This doesn't seem to change anything. It could be used to remember the last provider the user used.
      // connection: "auth0",
    });
    if (this.loginMethod === "popup") {
      await auth0Client.loginWithPopup(
        {
          authorizationParams
        },
        {
          // { popup: <POPUP> } // This might be useful to provide an already-created popup in platforms like iOS.
        }
      );
    } else {
      auth0Client.loginWithRedirect({
        authorizationParams
        // openUrl(url) { }, // This might be useful to control the redirect in mobile platforms.
      });
      throw new Error("Redirecting...");
    }
    return this.getTokenSilently();
  }
  async handleRedirectCallback(callbackUrlWithParams) {
    if (this.debug)
      console.log(`handleRedirectCallback(${callbackUrlWithParams})`);
    const auth0Client = await this.auth0ClientPromise;
    if (!auth0Client) throw new Error("Missing Auth0 Client");
    await auth0Client.handleRedirectCallback(callbackUrlWithParams);
    const idToken = await auth0Client.getUser() || null;
    const userDetails = await this.updateUserDetails(idToken);
    return { idToken, userDetails };
  }
  async logOut() {
    this.setUserDetails(null);
    const auth0Client = await this.auth0ClientPromise;
    if (!auth0Client) throw new Error("Missing Auth0 Client");
    return auth0Client.logout({
      logoutParams: {
        returnTo: this.returnToURI
      }
    }).catch((err) => {
      console.warn(err instanceof Error ? err.message : err);
      if (typeof location !== "undefined") location.reload();
    });
  }
  async encodeToken(data) {
    const accessToken = await this.getTokenSilently(data);
    return accessToken.id_token;
  }
  // Getters for cached user data:
  getCachedUserDetails() {
    return this.userDetails;
  }
  getCachedUserPublicKey() {
    var _a;
    return ((_a = this.userDetails) == null ? void 0 : _a.owner) || null;
  }
  getCachedUserSub() {
    var _a;
    return ((_a = this.userDetails) == null ? void 0 : _a.sub) || null;
  }
  getCachedUserAddress() {
    var _a;
    return ((_a = this.userDetails) == null ? void 0 : _a.walletAddress) || null;
  }
  getCachedUserAddressLabel() {
    var _a;
    return ((_a = this.userDetails) == null ? void 0 : _a.walletAddressLabel) || null;
  }
  getCachedUserEmail() {
    var _a;
    return ((_a = this.userDetails) == null ? void 0 : _a.email) || null;
  }
  // DEVELOPMENT:
  async overridePublicKey(publicKeyPEM) {
    this.overriddenPublicKey = uint8ArrayTob64Url(
      pemToUint8Array(publicKeyPEM)
    );
  }
};

// src/lib/othent/othent.ts
var import_warp_arbundles = require("warp-arbundles");

// src/lib/othent-kms-client/client.ts
var import_axios3 = __toESM(require("axios"));

// src/lib/othent-kms-client/operations/createUser.ts
async function createUser(api, auth0, options) {
  const encodedData = await auth0.encodeToken({
    path: "/create-user" /* CREATE_USER */,
    ...options
  });
  let idTokenWithData = null;
  try {
    const createUserResponse = await api.post(
      "/create-user" /* CREATE_USER */,
      { encodedData }
    );
    idTokenWithData = createUserResponse.data.idTokenWithData;
  } catch (err) {
    throw parseErrorResponse(err);
  }
  if (!idTokenWithData) {
    throw new Error("Error creating user on server.");
  }
  return idTokenWithData;
}

// src/lib/othent-kms-client/operations/common.types.ts
function isLegacyBufferObject(legacyBufferData) {
  return !!legacyBufferData && typeof legacyBufferData === "object" && legacyBufferData.type === "Buffer" && Array.isArray(legacyBufferData.data);
}
function isBufferObject(obj) {
  return isLegacyBufferObject(obj);
}
function normalizeBufferDataWithNull(data) {
  if (data === null || data === void 0) return null;
  if (typeof data === "string") {
    return b64ToUint8Array(data);
  }
  if (isLegacyBufferObject(data)) {
    return new Uint8Array(data.data);
  }
  return new Uint8Array(Object.values(data));
}

// src/lib/othent-kms-client/operations/decrypt.ts
async function decrypt(api, auth0, ciphertext) {
  const encodedData = await auth0.encodeToken({
    path: "/decrypt" /* DECRYPT */,
    ciphertext
  });
  let decryptedData = null;
  try {
    const decryptResponse = await api.post("/decrypt" /* DECRYPT */, {
      encodedData
    });
    decryptedData = normalizeBufferDataWithNull(
      decryptResponse.data.decryptedData
    );
  } catch (err) {
    throw parseErrorResponse(err);
  }
  if (decryptedData === null) {
    throw new Error("Error decrypting on server.");
  }
  return decryptedData;
}

// src/lib/othent-kms-client/operations/encrypt.ts
async function encrypt(api, auth0, plaintext) {
  const encodedData = await auth0.encodeToken({
    path: "/encrypt" /* ENCRYPT */,
    plaintext
  });
  let encryptedData = null;
  try {
    const encryptResponse = await api.post("/encrypt" /* ENCRYPT */, {
      encodedData
    });
    encryptedData = normalizeBufferDataWithNull(
      encryptResponse.data.encryptedData
    );
  } catch (err) {
    throw parseErrorResponse(err);
  }
  if (encryptedData === null) {
    throw new Error("Error encrypting on server.");
  }
  return encryptedData;
}

// src/lib/othent-kms-client/operations/sign.ts
async function sign(api, auth0, data) {
  const encodedData = await auth0.encodeToken({
    path: "/sign" /* SIGN */,
    data
  });
  let signature = null;
  try {
    const signResponse = await api.post("/sign" /* SIGN */, {
      encodedData
    });
    signature = normalizeBufferDataWithNull(signResponse.data.signature);
  } catch (err) {
    throw parseErrorResponse(err);
  }
  if (signature === null) {
    throw new Error("Error signing data on server.");
  }
  return signature;
}

// src/lib/othent-kms-client/operations/server-info.ts
async function serverInfo(api, auth0, options) {
  const encodedData = (options == null ? void 0 : options.includeToken) ? await auth0.encodeToken() : null;
  let serverInfo2 = null;
  try {
    const serverInfoResponse = encodedData ? await api.post("/" /* HOME */, {
      encodedData
    }) : await api.get("/" /* HOME */);
    serverInfo2 = serverInfoResponse.data;
  } catch (err) {
    throw parseErrorResponse(err);
  }
  if (!serverInfo2) {
    throw new Error("Error requesting the API status.");
  }
  return serverInfo2;
}

// src/lib/othent-kms-client/client.ts
var OthentKMSClient = class {
  constructor(baseURL, auth0) {
    this.api = import_axios3.default.create({ baseURL });
    this.auth0 = auth0;
  }
  async serverInfo(options) {
    return serverInfo(this.api, this.auth0, options);
  }
  async createUser(options) {
    return createUser(this.api, this.auth0, options);
  }
  async decrypt(ciphertext) {
    return decrypt(this.api, this.auth0, ciphertext);
  }
  async encrypt(plaintext) {
    return encrypt(this.api, this.auth0, plaintext);
  }
  async sign(data) {
    return sign(this.api, this.auth0, data);
  }
  getSignerSignFn() {
    return async (data) => {
      const signatureBuffer = await this.sign(data);
      return signatureBuffer;
    };
  }
};

// src/lib/othent/othent.ts
var import_axios4 = __toESM(require("axios"));
var import_arweave = __toESM(require("arweave"));
var import_auth0_spa_js2 = require("@auth0/auth0-spa-js");
var import_buffer2 = require("buffer");

// src/lib/utils/bufferUtils.ts
var import_buffer = require("buffer");
function padString(input) {
  let segmentLength = 4;
  let stringLength = input.length;
  let diff = stringLength % segmentLength;
  if (!diff) {
    return input;
  }
  let position = stringLength;
  let padLength = segmentLength - diff;
  let paddedStringLength = stringLength + padLength;
  let buffer = import_buffer.Buffer.alloc(paddedStringLength);
  buffer.write(input);
  while (padLength--) {
    buffer.write("=", position++);
  }
  return buffer.toString();
}
function encode(input, encoding = "utf8") {
  if (import_buffer.Buffer.isBuffer(input)) {
    return fromBase64(input.toString("base64"));
  }
  return fromBase64(import_buffer.Buffer.from(input, encoding).toString("base64"));
}
function decode(base64url2, encoding = "utf8") {
  return import_buffer.Buffer.from(toBase64(base64url2), "base64").toString(encoding);
}
function toBase64(base64url2) {
  base64url2 = base64url2.toString();
  return padString(base64url2).replace(/\-/g, "+").replace(/_/g, "/");
}
function fromBase64(base64) {
  return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBuffer(base64url2) {
  return import_buffer.Buffer.from(toBase64(base64url2), "base64");
}
var base64url = encode;
base64url.encode = encode;
base64url.decode = decode;
base64url.toBase64 = toBase64;
base64url.fromBase64 = fromBase64;
base64url.toBuffer = toBuffer;

// src/lib/othent/othent.ts
function initArweave(apiConfig) {
  const ArweaveClass = import_arweave.default.hasOwnProperty("default") ? import_arweave.default.default : import_arweave.default;
  return ArweaveClass.init(apiConfig);
}
var _Othent = class _Othent {
  /**
   * Instantiate `Othent`.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/constructor|constructor() docs}
   */
  constructor(options = DEFAULT_OTHENT_OPTIONS) {
    this.errorEventListenerHandler = new EventListenersHandler();
    this.tokens = /* @__PURE__ */ new Set();
    this.walletName = CLIENT_NAME;
    this.walletVersion = CLIENT_VERSION;
    this.config = DEFAULT_OTHENT_CONFIG;
    this.appInfo = DEFAULT_APP_INFO;
    this.gatewayConfig = DEFAULT_GATEWAY_CONFIG;
    if (!globalThis.Buffer) {
      globalThis.Buffer = import_buffer2.Buffer;
      console.warn(
        "`globalThis.Buffer` has been polyfilled for you. Note this could have side-effect and affect other libraries."
      );
    }
    const crypto2 = globalThis.crypto || null;
    if (!crypto2) {
      throw new Error(
        "A Crypto module is needed for Othent to work. If your environment doesn't natively provide one, you should polyfill it."
      );
    }
    this.crypto = crypto2;
    let {
      appInfo,
      gatewayConfig,
      persistCookie,
      persistLocalStorage,
      initialUserDetails,
      auth0Cache = DEFAULT_OTHENT_CONFIG.auth0Cache,
      auth0RedirectURI,
      auth0ReturnToURI,
      ...configOptions
    } = options;
    const defaultRedirectURI = typeof location === "undefined" ? null : location.origin;
    this.config = {
      ...mergeOptions(configOptions, DEFAULT_OTHENT_CONFIG),
      cookieKey: typeof persistCookie === "string" ? persistCookie : persistCookie ? DEFAULT_COOKIE_KEY : null,
      localStorageKey: typeof persistLocalStorage === "string" ? persistLocalStorage : persistLocalStorage ? DEFAULT_COOKIE_KEY : null,
      auth0Cache: typeof auth0Cache === "object" ? "custom" : auth0Cache,
      auth0RedirectURI: auth0RedirectURI || defaultRedirectURI,
      auth0ReturnToURI: auth0ReturnToURI || defaultRedirectURI
    };
    this.setAppInfo(appInfo);
    this.setGatewayConfig(gatewayConfig);
    const { config } = this;
    const { cookieKey, localStorageKey } = config;
    if (typeof cookieKey === "string" && !cookieKey.startsWith("othent")) {
      throw new Error(
        '`persistCookie` / `cookieKey` must start with "othent".'
      );
    }
    if (typeof localStorageKey === "string" && !localStorageKey.startsWith("othent")) {
      throw new Error(
        '`persistLocalStorage` / `localStorageKey` must start with "othent".'
      );
    }
    if (!config.auth0RedirectURI) {
      throw new Error("`auth0RedirectURI` is required.");
    }
    if (!config.auth0ReturnToURI) {
      throw new Error("`auth0ReturnToURI` is required.");
    }
    if (config.autoConnect === "eager" && config.auth0LogInMethod === "popup" && config.auth0Strategy === "refresh-tokens" && auth0Cache === "memory") {
      throw new Error(
        'The browser cannot open the authentication modal automatically before an user interaction. Use `autoConnect = "lazy"` or change any of these other options: `auth0LogInMethod`, `auth0Strategy` or `auth0Cache`.'
      );
    }
    this.auth0 = new OthentAuth0Client({
      debug: config.debug,
      domain: config.auth0Domain,
      clientId: config.auth0ClientId,
      strategy: config.auth0Strategy,
      cache: auth0Cache,
      loginMethod: config.auth0LogInMethod,
      redirectURI: config.auth0RedirectURI,
      returnToURI: config.auth0ReturnToURI,
      refreshTokenExpirationMs: config.auth0RefreshTokenExpirationMs,
      appInfo: this.appInfo,
      initialUserDetails,
      cookieKey: config.cookieKey,
      localStorageKey: config.localStorageKey
    });
    if (config.autoConnect === "eager") {
      if (typeof location === "undefined") {
        this.connect();
      } else {
        const url = new URL(location.href);
        const { searchParams } = url;
        if (!searchParams.has("code") && !searchParams.has("state")) {
          this.connect();
        }
      }
    }
    if (config.inject) {
      globalThis.arweaveWallet = this;
    }
    if (!config.throwErrors) {
      const walletMethods = [
        "connect",
        "disconnect",
        "getActiveAddress",
        "getActivePublicKey",
        "getAllAddresses",
        "getWalletNames",
        "getUserDetails",
        "getSyncActiveAddress",
        "getSyncActivePublicKey",
        "getSyncAllAddresses",
        "getSyncWalletNames",
        "getSyncUserDetails",
        "sign",
        "dispatch",
        "encrypt",
        "decrypt",
        "signature",
        "signDataItem",
        "signMessage",
        "verifyMessage",
        "privateHash",
        "getArweaveConfig",
        "getPermissions"
      ];
      walletMethods.forEach((walletMethod) => {
        let fn = this[walletMethod];
        if (typeof fn !== "function") return;
        fn = fn.bind(this);
        this[walletMethod] = (...args) => {
          try {
            let result = fn(...args);
            if (isPromise(result)) {
              result = result.catch((err) => {
                this.onError(err);
                return null;
              });
            }
            return result;
          } catch (err) {
            this.onError(err);
          }
          return null;
        };
      });
    }
    this.api = new OthentKMSClient(this.config.serverBaseURL, this.auth0);
  }
  /**
   * @param appInfo Setter and validator for `appInfo`.
   *
   * @returns `Othent.appInfo`
   */
  setAppInfo(appInfo) {
    const nextAppInfo = {
      ...appInfo,
      env: appInfo.env || DEFAULT_APP_INFO.env
    };
    if (!nextAppInfo.name || !nextAppInfo.version || !nextAppInfo.env) {
      throw new Error(
        "Incomplete `appInfo`: `name`, `version` and `env` are required."
      );
    }
    if (this.auth0) this.auth0.setAppInfo(nextAppInfo);
    return this.appInfo = nextAppInfo;
  }
  /**
   * @param appInfo Setter and validator for `gatewayConfig`.
   *
   * @returns `Othent.gatewayConfig`
   */
  setGatewayConfig(gatewayConfig) {
    const nextGatewayConfig = gatewayConfig || DEFAULT_GATEWAY_CONFIG;
    if (!nextGatewayConfig.host || !nextGatewayConfig.port || !nextGatewayConfig.protocol) {
      throw new Error(
        "Incomplete `gatewayConfig`: `host`, `port` and `protocol` are required."
      );
    }
    return this.gatewayConfig = nextGatewayConfig;
  }
  /**
   * Start listening for `storage` events to sync user details across tabs. Only needed if `persistLocalStorage = true`.
   *
   * @returns A cleanup function that must be called whenever Othent needs to stop listening for `storage` events (e.g.
   * to be used in React's `useEffects`'s cleanup function).
   *
   * @see {@link https://docs.othent.io/js-sdk-api/start-tab-synching|startTabSynching() docs}
   */
  startTabSynching() {
    if (!this.config.localStorageKey) {
      console.warn(
        "Calling `Othent.startTabSynching()` is a NOOP unless the `persistLocalStorage` option is used."
      );
    }
    this.auth0.initStorageSyncing();
    return () => {
      this.auth0.stopStorageSyncing();
    };
  }
  // ERROR EVENT / ERROR HANDLING:
  onError(error) {
    if (!(error instanceof Error)) {
      console.warn("Unknown error type", error);
      return;
    }
    if (this.errorEventListenerHandler.hasListeners) {
      this.errorEventListenerHandler.emit(error);
    } else {
      console.warn(
        "Unhandled unthrown error:\n",
        error,
        '\nWhen using `throwErrors = false`, you must add at least one error event listener with `othent.addEventListener("error", () => { ... })`'
      );
    }
  }
  /**
   * Add an event listener for the specific error type.
   *
   * @param type `"auth"` or `error`.
   * @param listener Function of type `AuthListener` or `ErrorListener`.
   *
   * @returns A cleanup function that will remove the error listener when called.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/events|Events docs}
   */
  addEventListener(type, listener) {
    let eventListenerHandler = null;
    if (type === "auth") {
      eventListenerHandler = this.auth0.getAuthEventListenerHandler();
    } else if (type === "error") {
      if (this.config.throwErrors)
        throw new Error(
          "You can only listen for `error` events if `throwErrors = false`."
        );
      eventListenerHandler = this.errorEventListenerHandler;
    }
    if (!eventListenerHandler) throw new Error("Unknown event type");
    eventListenerHandler.add(listener);
    return () => {
      eventListenerHandler.delete(listener);
    };
  }
  /**
   * Remove an error listener of the specified error type.
   *
   * @param type `"auth"` or `error`.
   * @param listener Function of type `AuthListener` or `ErrorListener`.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/events|Events docs}
   */
  removeEventListener(type, listener) {
    let eventListenerHandler = null;
    if (type === "auth") {
      eventListenerHandler = this.auth0.getAuthEventListenerHandler();
    } else if (type === "error") {
      eventListenerHandler = this.errorEventListenerHandler;
    }
    if (!eventListenerHandler) throw new Error("Unknown event type");
    eventListenerHandler.delete(listener);
  }
  // AUTH LOADING:
  /**
   * @returns `true` if the user is authenticated; `false` otherwise.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/is-authenticated|isAuthenticated docs}
   */
  get isAuthenticated() {
    return this.auth0.isAuthenticated;
  }
  /**
   * Automatically checks if the user is authenticated. If they are not, and...
   *
   * - `autoConnect === "eager"`: Prompts them to sign in/up again. It throws an error if authentication fails.
   * - `autoConnect === "lazy"`: Authenticates them automatically, either from an existing session or by prompting them
   *   to sign in/up again. It throws an error if authentication fails.
   * - `autoConnect === "off"`: It throws an error.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/require-auth|requireAuth() docs}
   */
  requireAuth() {
    return this.requireUserDataOrThrow().then(() => {
    });
  }
  /**
   * Automatically checks if the user is authenticated. If they are not, and...
   *
   * - `autoConnect === "eager"`: Prompts them to sign in/up again. It throws an error if authentication fails.
   * - `autoConnect === "lazy"`: Authenticates them automatically, either from an existing session or by prompting them
   *   to sign in/up again. It throws an error if authentication fails.
   * - `autoConnect === "off"`: It throws an error.
   *
   * @returns `Promise<{ sub, publicKey }>` to get these 2 properties required in most Othent functions.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/require-auth|requireAuth() docs}
   */
  async requireUserDataOrThrow() {
    if (this.config.autoConnect !== "off" && !this.auth0.isAuthenticated) {
      await this.connect(void 0, void 0, this.gatewayConfig);
    }
    const { sub, owner } = this.auth0.getCachedUserDetails() || {};
    if (!sub || !owner) throw new Error("Missing cached user.");
    return {
      sub,
      publicKey: owner
    };
  }
  // CONNECT / DISCONNECT / USER CREATION:
  async completeConnectionOrCreateAuth0User(userDetails, hasIdToken) {
    if (userDetails && hasIdToken) return userDetails;
    const importOnly = false;
    if (!(userDetails == null ? void 0 : userDetails.walletAddress) && hasIdToken) {
      const idTokenWithData = await this.api.createUser({ importOnly });
      const userDetailsFromCreateUserResponse = await this.auth0.updateUserDetails(idTokenWithData);
      if (userDetailsFromCreateUserResponse)
        return userDetailsFromCreateUserResponse;
    }
    this.auth0.logOut();
    throw new Error("Unexpected authentication error");
  }
  /**
   * If and only if you set the [`auth0LogInMethod = "redirect"`](./constructor.md#auth0loginmethod-auth0loginmethod) option,
   * users will be redirected to Auth0 to authenticate and then back to your application. When they land back in your
   * application, you must call `completeConnectionAfterRedirect()` to complete the authentication process.
   *
   * By default, `callbackUriWithParams = location.href`, if you environment supports it. Otherwise, you'll have to manually
   * pass an URI with the `code` and `state` params provided by Auth0, which handles the redirect callback.
   *
   * See [Auth0's `handleRedirectCallback`](https://auth0.github.io/auth0-spa-js/classes/Auth0Client.html#handleRedirectCallback).
   *
   * @param callbackUriWithParams
   *
   * @returns A Promise with the `UserDetails` or `null` if the log in modal was closed, could not even be opened or
   * authentication failed.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/complete-connection-after-redirect|completeConnectionAfterRedirect() docs}
   */
  async completeConnectionAfterRedirect(callbackUriWithParams) {
    if (this.config.auth0LogInMethod !== "redirect") {
      console.warn(
        'Calling `Othent.completeConnectionAfterRedirect()` is a NOOP unless the `auth0LogInMethod` options is `"redirect"`.'
      );
    }
    const urlString = callbackUriWithParams || (typeof location === "undefined" ? "" : location.href);
    const urlObject = new URL(urlString.replace(/.+\.auth0:\/\//, "https://"));
    const { searchParams } = urlObject;
    if (!searchParams.has("code") || !searchParams.has("state") || !urlString)
      return null;
    let idToken = null;
    let userDetails = null;
    try {
      const urlStringData = await this.auth0.handleRedirectCallback(urlString);
      idToken = urlStringData.idToken;
      userDetails = urlStringData.userDetails;
    } catch (err) {
      console.warn(
        "The connection could not be completed. There was an error during the redirect flow:\n",
        err
      );
    } finally {
      if (typeof location !== "undefined" && typeof history !== "undefined") {
        searchParams.delete("code");
        searchParams.delete("state");
        history.replaceState(null, "", urlObject);
      }
    }
    return this.completeConnectionOrCreateAuth0User(userDetails, !!idToken);
  }
  /**
   * Prompts the user to sign in/up using Auth0's modal. This function cannot be called programmatically before the user
   * interacts with the page (e.g. by clicking on a button), as that will result in a `Unable to open a popup` error.
   *
   * @returns A Promise with the `UserDetails` or `null` if the log in modal was closed, could not even be opened or
   * authentication failed.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/connect|connect() docs}
   */
  async connect(permissions, appInfo, gateway) {
    if (permissions && permissions.toSorted().join("-") !== _Othent.ALL_PERMISSIONS.join("-")) {
      throw new Error(
        "Othent implicitly has access to all available permissions. You should pass `permissions = undefined` or include all of them."
      );
    }
    if (appInfo) this.setAppInfo(appInfo);
    if (gateway) this.setGatewayConfig(gateway);
    let id_token = "";
    let userDetails = null;
    try {
      const response = await this.auth0.getTokenSilently();
      id_token = response.id_token;
      userDetails = response.userDetails;
    } catch (err) {
      if (!(err instanceof Error)) throw err;
      if (err.message !== "Login required" && !(err instanceof import_auth0_spa_js2.MissingRefreshTokenError)) {
        throw err;
      }
      console.warn(err.message);
    }
    if (!id_token) {
      try {
        const response = await this.auth0.logIn();
        id_token = response.id_token;
        userDetails = response.userDetails;
      } catch (err) {
        if (!(err instanceof Error)) throw err;
        if (err.message === "Redirecting...") await new Promise(() => {
        });
        if (err.message.startsWith("Unable to open a popup") || err instanceof import_auth0_spa_js2.PopupCancelledError || err instanceof import_auth0_spa_js2.PopupTimeoutError) {
          if (err instanceof import_auth0_spa_js2.PopupTimeoutError) err.popup.close();
          console.warn(err.message);
          return null;
        }
        throw err;
      }
    }
    return this.completeConnectionOrCreateAuth0User(userDetails, !!id_token);
  }
  /**
   * Logs out the user (disconnect the user's wallet). This will require the user to log back in after called.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/disconnect|disconnect() docs}
   */
  async disconnect() {
    return this.auth0.logOut();
  }
  // GET DATA (ASYNC):
  /**
   * Returns the Arweave wallet address associated with the active (authenticated) user account.
   *
   * The wallet address is derived from the corresponding public key (see [`getActivePublicKey()`](get-active-public-key.md)).
   *
   * This function assumes (and requires) a user is authenticated.
   *
   * @returns A Promise with the active wallet address of the users wallet.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-active-address|getActiveAddress() docs}
   */
  getActiveAddress() {
    return Promise.resolve(this.getSyncActiveAddress());
  }
  /**
   * Returns the public key (`jwk.n` field) associated with the active (authenticated) user account.
   *
   * This function assumes (and requires) a user is authenticated.
   *
   * @returns A Promise with the owner (jwk.n field) of the users wallet.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-active-public-key|getActivePublicKey() docs}
   */
  getActivePublicKey() {
    return Promise.resolve(this.getSyncActivePublicKey());
  }
  /**
   * Returns an array of Arweave wallet addresses associated with the active (authenticated) user account.
   *
   * However, note that Othent does not currently support creating/storing more than one wallet associated to the same
   * account, so this function will always return exactly one wallet address.
   *
   * This function assumes (and requires) a user is authenticated.
   *
   * @returns A Promise with an array of all wallet addresses of the users wallet.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-all-addresses|getAllAddresses() docs}
   */
  getAllAddresses() {
    return Promise.resolve(this.getSyncAllAddresses());
  }
  /**
   * Similarly to ArConnect, each wallet in Othent has a nickname. This is either:
   *
   * - The user's [ANS](https://ans.gg) name.
   * - A platform + email identifying label (e.g. `Google (email@gmail.com)`, `Twitter (email@outlook.com)`...).
   *
   * To provide better UX, you can retrieve these names and display them to the user, so that they can easily recognize
   * which wallet they're using.
   *
   * However, note that Othent does not currently support creating/storing more than one wallet associated to the same
   * account, so this function will always return exactly one wallet address.
   *
   * This function assumes (and requires) a user is authenticated.
   *
   * @returns A Promise containing an object that maps each wallet addresses to their nickname.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-wallet-names|getWalletNames() docs}
   */
  getWalletNames() {
    return Promise.resolve(this.getSyncWalletNames());
  }
  /**
   * Returns an object with all the user details of the active (authenticated) user account.
   *
   * @returns A Promise containing all the user details of the active user, or `null` if the user is not authenticated.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-user-details|getUserDetails() docs}
   */
  getUserDetails() {
    return Promise.resolve(this.getSyncUserDetails());
  }
  // GET DATA (SYNC):
  /**
   * Get the active wallet address of the users wallet. This function assumes (and requires) a user is authenticated.
   *
   * @returns The active wallet address of the users wallet.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-sync-active-address|getSyncActiveAddress() docs}
   */
  getSyncActiveAddress() {
    return this.auth0.getCachedUserAddress() || "";
  }
  /**
   * Get the owner (jwk.n) field of the users wallet. This function assumes (and requires) a user is authenticated.
   *
   * @returns The owner (jwk.n) field of the users wallet.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-sync-active-public-key|getSyncActivePublicKey() docs}
   */
  getSyncActivePublicKey() {
    return this.auth0.getCachedUserPublicKey() || "";
  }
  /**
   * Get all addresses of the users wallet. This function assumes (and requires) a user is authenticated.
   *
   * @returns All wallet addresses of the users wallet.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-sync-all-addresses|getSyncAllAddresses() docs}
   */
  getSyncAllAddresses() {
    const address = this.auth0.getCachedUserAddress();
    return address ? [address] : [];
  }
  /**
   * Get the wallets (users) email. This function assumes (and requires) a user is authenticated.
   *
   * @returns The wallets (users) email.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-sync-wallet-names|getSyncWalletNames() docs}
   */
  getSyncWalletNames() {
    const address = this.auth0.getCachedUserAddress();
    const addressLabel = this.auth0.getCachedUserAddressLabel();
    return Promise.resolve(
      address && addressLabel ? {
        [address]: addressLabel
      } : {}
    );
  }
  /**
   * Get user details. This function assumes (and requires) a user is authenticated.
   *
   * @returns The user's details.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-sync-user-details|getSyncUserDetails() docs}
   */
  getSyncUserDetails() {
    return this.auth0.getCachedUserDetails();
  }
  addCommonTags(transactionOrTags = []) {
    const { appInfo } = this;
    if (Array.isArray(transactionOrTags)) {
      const appInfoTags = [
        { name: "App-Name", value: appInfo.name },
        { name: "App-Version", value: appInfo.version },
        { name: "App-Env", value: appInfo.env }
      ];
      return [
        ...transactionOrTags,
        ...this.config.tags,
        ...appInfoTags,
        ...ANALYTICS_TAGS
      ];
    }
    for (const { name, value } of this.config.tags) {
      transactionOrTags.addTag(name, value);
    }
    transactionOrTags.addTag("App-Name", appInfo.name);
    transactionOrTags.addTag("App-Version", appInfo.version);
    transactionOrTags.addTag("App-Env", appInfo.env);
    for (const { name, value } of ANALYTICS_TAGS) {
      transactionOrTags.addTag(name, value);
    }
  }
  /**
   * To submit a transaction to the Arweave Network, it first has to be signed using a private key. Othent creates a private
   * key / Arweave wallet for every account and stores it in Google KMS. The wallet associated with the active user account
   * is used to sign transactions using the `sign()` function.
   *
   * The `sign()` function is meant to replicate the behavior of the `transactions.sign()` function of
   * [`arweave-js`](https://github.com/arweaveTeam/arweave-js#sign-a-transaction), but instead of mutating the transaction
   * object, it returns a new and signed transaction instance.
   *
   * This function assumes (and requires) a user is authenticated and a valid arweave transaction.
   *
   * @param transaction The transaction to sign.
   *
   * @returns A Promise containing a new signed transaction.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/sign|sign() docs}
   * @see {@link https://docs.arweave.org/developers/arweave-node-server/http-api#transaction-format|Transaction Format docs}
   */
  async sign(transaction) {
    const { publicKey } = await this.requireUserDataOrThrow();
    const arweave = initArweave(this.gatewayConfig);
    const transactionTags = transaction.get("tags").map(
      (tag) => ({
        name: tag.get("name", { decode: true, string: true }),
        value: tag.get("value", { decode: true, string: true })
      })
    );
    const tags = this.addCommonTags(transactionTags);
    const transactionToSign = await arweave.createTransaction({
      format: transaction.format,
      owner: publicKey,
      reward: transaction.reward,
      // This value is added automatically when creating a transaction, so instead of propagating the one from the one
      // the user sends, we'll just leave it to the new `createTransaction` to fill this in:
      // last_tx: transaction.last_tx,
      // To transfer AR:
      target: transaction.target,
      quantity: transaction.quantity,
      // To send data:
      data: transaction.data,
      data_root: transaction.data_root,
      data_size: transaction.data_size
    });
    tags.forEach((tagData) => {
      transactionToSign.addTag(tagData.name, tagData.value);
    });
    const dataToSign = await transactionToSign.getSignatureData();
    const signatureBuffer = await this.api.sign(dataToSign);
    const id = await hash(signatureBuffer);
    transactionToSign.setSignature({
      id: uint8ArrayTob64Url(id),
      owner: publicKey,
      signature: uint8ArrayTob64Url(signatureBuffer),
      tags: transactionToSign.tags,
      reward: transactionToSign.reward
    });
    return transactionToSign;
  }
  /**
   * The `dispatch()` function allows you to quickly sign and send a transaction to the network in a bundled format. It is
   * best for smaller datas and contract interactions. If the bundled transaction cannot be submitted, it will fall back to a
   * base layer transaction. The function returns the [result](dispatch.md#dispatch-result) of the API call.
   *
   * This function assumes (and requires) a user is authenticated and a valid arweave transaction.
   *
   * @param transaction The transaction to sign and dispatch.
   *
   * @returns The signed version of the transaction.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/dispatch|dispatch() docs}
   */
  async dispatch(transaction, options) {
    var _a;
    const transactionTags = transaction.get("tags").map(
      (tag) => ({
        name: tag.get("name", { decode: true, string: true }),
        value: tag.get("value", { decode: true, string: true })
      })
    );
    const signedDataItemBuffer = await this.signDataItem({
      // Not used for now as `transaction.last_tx` is not 32 bytes, as required by `DataItem`:
      // anchor: transaction.last_tx,
      target: transaction.target,
      data: transaction.data,
      tags: transactionTags
    });
    const url = `${(options == null ? void 0 : options.node) || DEFAULT_DISPATCH_NODE}/tx`;
    try {
      const res = await import_axios4.default.post(
        url,
        signedDataItemBuffer,
        {
          headers: {
            "Content-Type": "application/octet-stream"
          },
          maxBodyLength: Infinity,
          maxContentLength: Infinity,
          responseType: "json"
        }
      );
      if (res.status >= 400) {
        throw new Error(`${res.status} - ${JSON.stringify(res.data)}`);
      }
      return {
        ...res.data,
        type: "BUNDLED"
      };
    } catch (err) {
      console.warn(`Error dispatching transaction to ${url} =
`, err);
      const signedTransaction = await this.sign(transaction);
      const arweave = (_a = options == null ? void 0 : options.arweave) != null ? _a : initArweave(this.gatewayConfig);
      const uploader = await arweave.transactions.getUploader(signedTransaction);
      while (!uploader.isComplete) {
        await uploader.uploadChunk();
      }
      return {
        id: signedTransaction.id,
        signature: signedTransaction.signature,
        owner: signedTransaction.owner,
        type: "BASE"
      };
    }
  }
  // ENCRYPT/DECRYPT:
  /**
   * Encrypt data with the users JWK.
   *
   * This function assumes (and requires) a user is authenticate.
   *
   * @param plaintext The data in string format to sign.
   *
   * @returns The encrypted data.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/encrypt|encrypt() docs}
   */
  async encrypt(plaintext) {
    await this.requireUserDataOrThrow();
    const ciphertextBuffer = await this.api.encrypt(plaintext);
    return ciphertextBuffer;
  }
  /**
   * Decrypt data with the users JWK.
   *
   * This function assumes (and requires) a user is authenticated.
   *
   * @param ciphertext The data to decrypt.
   *
   * @returns The decrypted data.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/decrypt|decrypt() docs}
   */
  async decrypt(ciphertext) {
    await this.requireUserDataOrThrow();
    const plaintextBuffer = await this.api.decrypt(ciphertext);
    return plaintextBuffer;
  }
  // SIGN:
  /**
   * Generate a signature. This function assumes (and requires) a user is authenticated.
   *
   * @deprecated Use `sign`, `signDataItems` or `signMessage` instead.
   *
   * @param data The data to sign.
   *
   * @returns The {@linkcode Buffer} format of the signature.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/signature|signature() docs}
   */
  async signature(data) {
    await this.requireUserDataOrThrow();
    const signatureBuffer = await this.api.sign(data);
    return signatureBuffer;
  }
  /**
   * The signDataItem() function allows you to create and sign a data item object, compatible with arbundles. These data
   * items can then be submitted to an ANS-104 compatible bundler.
   *
   * @param dataItem The data to sign.
   *
   * @returns The signed data item.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/sign-data-item|signDataItem() docs}
   */
  async signDataItem(dataItem) {
    const { publicKey } = await this.requireUserDataOrThrow();
    const { data, tags, ...options } = dataItem;
    const signer = {
      publicKey: toBuffer(publicKey),
      signatureType: 1,
      signatureLength: 512,
      ownerLength: 512,
      sign: this.api.getSignerSignFn()
      // Note we don't provide `verify` as it's not used anyway:
      // verify: () => true,
    };
    const opts = {
      ...options,
      tags: this.addCommonTags(tags)
    };
    const dataItemInstance = (0, import_warp_arbundles.createData)(data, signer, opts);
    await dataItemInstance.sign(signer);
    return dataItemInstance.getRaw().buffer;
  }
  /**
   * Sign the given message. This function assumes (and requires) a user is authenticated.
   *
   * @param message The message to sign.
   *
   * @returns The signed version of the message.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/sign-message|signMessage() docs}
   */
  async signMessage(data, options) {
    await this.requireUserDataOrThrow();
    const hashAlgorithm = (options == null ? void 0 : options.hashAlgorithm) || "SHA-256";
    const hashArrayBuffer = await this.crypto.subtle.digest(
      hashAlgorithm,
      binaryDataTypeOrStringToBinaryDataType(data)
    );
    const signatureBuffer = await this.api.sign(hashArrayBuffer);
    return signatureBuffer;
  }
  /**
   * Verify the given message. This function assumes (and requires) a user is authenticated.
   *
   * @param signature The signature to verify.
   *
   * @returns The signed version of the message.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/verify-message|verifyMessage() docs}
   */
  async verifyMessage(data, signature, publicKey, options = { hashAlgorithm: "SHA-256" }) {
    if (!publicKey) {
      const requiredUserData = await this.requireUserDataOrThrow();
      publicKey || (publicKey = requiredUserData.publicKey);
    }
    const hashAlgorithm = (options == null ? void 0 : options.hashAlgorithm) || "SHA-256";
    const hashArrayBuffer = await this.crypto.subtle.digest(
      hashAlgorithm,
      binaryDataTypeOrStringToBinaryDataType(data)
    );
    const publicJWK = {
      e: "AQAB",
      ext: true,
      kty: "RSA",
      n: publicKey
    };
    const cryptoKey = await this.crypto.subtle.importKey(
      "jwk",
      publicJWK,
      {
        name: "RSA-PSS",
        hash: options.hashAlgorithm
      },
      false,
      ["verify"]
    );
    const result = await this.crypto.subtle.verify(
      { name: "RSA-PSS", saltLength: 32 },
      cryptoKey,
      binaryDataTypeOrStringToBinaryDataType(signature),
      hashArrayBuffer
    );
    return result;
  }
  /**
   * Create a deterministic secret based on the input data.
   *
   * @param data Input data to generate the hash from.
   * @param options Hash algorithm (default = `SHA-256`).
   *
   * @returns Hash `Uint8Array`.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/private-hash|privateHash() docs}
   */
  async privateHash(data, options) {
    return hash(
      binaryDataTypeOrStringToBinaryDataType(data),
      options == null ? void 0 : options.hashAlgorithm
    );
  }
  // MISC.:
  /**
   * Get the Arweave config used by Othent.
   *
   * @returns Promise of Othent's `GatewayConfig`.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-arweave-config|getArweaveConfig() docs}
   */
  getArweaveConfig() {
    return Promise.resolve(this.gatewayConfig);
  }
  /**
   * Get the permissions Othent can use in the current site.
   *
   * @returns Promise of Othent's `PermissionType[]`.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-permissions|getPermissions() docs}
   */
  getPermissions() {
    return Promise.resolve(_Othent.ALL_PERMISSIONS);
  }
  /**
   * Mocked implementation to add tokens.
   * Othent doesn't currently support this feature and only tracks added tokens temporarily in memory.
   */
  addToken(id, type, gateway) {
    console.warn(
      "Othent doesn't currently support this feature and only tracks added tokens temporarily in memory."
    );
    this.tokens.add(id);
    return Promise.resolve();
  }
  /**
   * Mocked implementation to check if a token has been added.
   * Othent doesn't currently support this feature and only tracks added tokens temporarily in memory.
   */
  isTokenAdded(id) {
    console.warn(
      "Othent doesn't currently support this feature and only tracks added tokens temporarily in memory."
    );
    return Promise.resolve(this.tokens.has(id));
  }
  // DEVELOPMENT:
  __overridePublicKey(publicKeyPEM) {
    this.auth0.overridePublicKey(publicKeyPEM);
  }
  __getServerInfo(options) {
    return this.api.serverInfo(options);
  }
};
_Othent.walletName = CLIENT_NAME;
_Othent.walletVersion = CLIENT_VERSION;
_Othent.ALL_PERMISSIONS = [
  "ACCESS_ADDRESS",
  "ACCESS_ALL_ADDRESSES",
  "ACCESS_ARWEAVE_CONFIG",
  "ACCESS_PUBLIC_KEY",
  "DECRYPT",
  "DISPATCH",
  "ENCRYPT",
  "SIGN_TRANSACTION",
  "SIGNATURE"
];
var Othent = _Othent;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_APP_INFO,
  DEFAULT_COOKIE_KEY,
  DEFAULT_DISPATCH_NODE,
  DEFAULT_GATEWAY_CONFIG,
  DEFAULT_LOCAL_STORAGE_KEY,
  DEFAULT_OTHENT_CONFIG,
  DEFAULT_OTHENT_OPTIONS,
  Othent,
  OthentError,
  OthentErrorID,
  PROVIDER_LABELS,
  b64ToUint8Array,
  b64UrlDecode,
  b64UrlEncode,
  binaryDataTypeOrStringToBinaryDataType,
  binaryDataTypeOrStringTob64String,
  binaryDataTypeToString,
  binaryDataTypeTob64Url,
  hash,
  isBufferObject,
  isLegacyBufferObject,
  stringOrUint8ArrayToUint8Array,
  stringToUint8Array,
  stringTob64Url,
  uint8ArrayTob64,
  uint8ArrayTob64Url
});
