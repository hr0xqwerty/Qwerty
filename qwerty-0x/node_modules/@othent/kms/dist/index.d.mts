import { SignatureOptions } from 'arweave/node/lib/crypto/crypto-interface';
import Transaction from 'arweave/node/lib/transaction';
import Transaction$1 from 'arweave/web/lib/transaction';
import Arweave from 'arweave/web';
import { Tag } from 'warp-arbundles';
import { ICache } from '@auth0/auth0-spa-js';

type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array;
type BinaryDataType = ArrayBuffer | ArrayBufferView | TypedArray | DataView | Buffer;
declare function binaryDataTypeToString(buffer: BinaryDataType): string;
declare function binaryDataTypeTob64Url(buffer: BinaryDataType): B64UrlString;
declare function binaryDataTypeOrStringTob64String(source: string | BinaryDataType): B64UrlString;
declare function binaryDataTypeOrStringToBinaryDataType(source: string | BinaryDataType): BinaryDataType;
declare function stringTob64Url(str: string): B64UrlString;
declare function stringToUint8Array(str: string): Uint8Array;
declare function stringOrUint8ArrayToUint8Array(str: string | Uint8Array): Uint8Array;
type B64String = string & {
    __brand: "B64String";
};
type B64UrlString = string & {
    __brand: "B64UrlString";
};
type VerifiedUTF16String = string & {
    __brand: "VerifiedUTF16String";
};
declare function uint8ArrayTob64(buffer: Uint8Array): B64String;
declare function uint8ArrayTob64Url(buffer: Uint8Array): B64UrlString;
declare function b64ToUint8Array(str: B64String | B64UrlString): Uint8Array;
declare function b64UrlEncode(str: B64String | B64UrlString): B64UrlString;
declare function b64UrlDecode(str: B64String | B64UrlString): B64String;
declare function hash(data: BinaryDataType, algorithm?: string): Promise<Uint8Array>;

type UrlString = `http://${string}` | `https://${string}`;

declare enum OthentErrorID {
    Unexpected = "Unexpected",
    Validation = "Validation",
    UserCreation = "UserCreation",
    Encryption = "Encryption",
    Decryption = "Decryption",
    Signing = "Signing",
    PublicKey = "PublicKey"
}
declare class OthentError extends Error {
    id: OthentErrorID;
    developerMessage: string;
    cause?: Error;
    constructor(id: OthentErrorID, developerMessage: string, error?: unknown, fromServer?: boolean);
}

type OthentEventType = "auth" | "error";
type AuthListener = (userDetails: UserDetails | null, isAuthenticated: boolean) => void;
type ErrorListener = (err: Error | OthentError) => void;
type EventListenersByType = {
    auth: AuthListener;
    error: ErrorListener;
};
interface DispatchOptions {
    arweave?: Arweave;
    node?: UrlString;
}
interface ArDriveBundledTransactionResponseData {
    id: string;
    timestamp: number;
    winc: string;
    version: string;
    deadlineHeight: number;
    dataCaches: string[];
    fastFinalityIndexes: string[];
    public: string;
    signature: string;
    owner: string;
}
interface ArDriveBundledTransactionData extends ArDriveBundledTransactionResponseData {
    type: "BUNDLED";
}
interface UploadedTransactionData {
    type: "BASE";
    id: string;
    signature: string;
    owner: string;
}
type TagData = Tag;
interface DataItem$1 {
    data: string | Uint8Array;
    target?: string;
    anchor?: string;
    tags?: TagData[];
}

declare abstract class ArConnect {
    /**
     * Name of the wallet the API was provided by.
     */
    abstract walletName: string;
    /**
     * Semver type version of the wallet
     */
    abstract walletVersion: string;
    /**
     * Connect to ArConnect and request permissions. This function can always be
     * called again if you want to request more permissions for your site.
     *
     * @param permissions
     * @param appInfo
     */
    abstract connect(permissions: PermissionType[], appInfo?: AppInfo$1, gateway?: GatewayConfig): Promise<void>;
    /**
     * Disconnect from ArConnect. Removes all permissions from your site.
     */
    abstract disconnect(): Promise<void>;
    /**
     * Get the currently used wallet's address in the extension.
     *
     * @returns Promise of wallet address string
     */
    abstract getActiveAddress(): Promise<string>;
    /**
     * Get all addresses added to the ArConnect extension
     *
     * @returns Promise of a list of the added wallets' addresses.
     */
    abstract getAllAddresses(): Promise<string[]>;
    /**
     * Get wallet names for addresses.
     *
     * @returns Promise of an object with addresses and wallet names
     */
    abstract getWalletNames(): Promise<{
        [addr: string]: string;
    }>;
    /**
     * Sign a transaction.
     *
     * @param transaction A valid Arweave transaction without a wallet keyfile added to it
     * @param options Arweave signing options
     *
     * @returns Promise of a signed transaction instance
     */
    abstract sign(transaction: Transaction, options?: SignatureOptions): Promise<Transaction>;
    /**
     * Get the permissions allowed for you site by the user.
     *
     * @returns Promise of a list of permissions allowed for your dApp.
     */
    abstract getPermissions(): Promise<PermissionType[]>;
    /**
     * Encrypt a string, using the user's wallet.
     *
     * @param data String to encrypt
     * @param options Encrypt options
     *
     * @returns Promise of the encrypted string
     */
    abstract encrypt(data: BinaryDataType, options?: RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams): Promise<Uint8Array>;
    /**
     * Decrypt a string encrypted with the user's wallet.
     *
     * @param data `Uint8Array` data to decrypt to a string
     * @param options Decrypt options
     *
     * @returns Promise of the decrypted string
     */
    abstract decrypt(data: BinaryDataType, options?: RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams): Promise<Uint8Array>;
    /**
     * Get the user's custom Arweave config set in the extension
     *
     * @returns Promise of the user's Arweave config
     */
    abstract getArweaveConfig(): Promise<GatewayConfig>;
    /**
     * @deprecated Find alternatives at https://docs.arconnect.io/api/signature
     */
    abstract signature(data: Uint8Array, algorithm?: RsaPssParams | EcdsaParams | {
        name: "RSASSA-PKCS1-v1_5";
    } | {
        name: "HMAC";
    }): Promise<Uint8Array>;
    /**
     * Get the user's active public key, from their wallet
     *
     * @returns Promise of the active public key
     */
    abstract getActivePublicKey(): Promise<string>;
    /**
     * Add a token to ArConnect (if it is not already present)
     *
     * @param id Token contract ID
     * @param type Type of the token (asset or collectible)
     * @param gateway Gateway config for the token
     */
    abstract addToken(id: string, type?: string, gateway?: GatewayConfig): Promise<void>;
    /**
     * Checks if a token has been added to ArConnect
     *
     * @param id Token to check for
     *
     * @returns Token added or not
     */
    abstract isTokenAdded(id: string): Promise<boolean>;
    /**
     * Dispatch an Arweave transaction (preferably bundled)
     *
     * @param transaction Transaction to dispatch
     *
     * @returns Dispatched transaction ID and type
     */
    abstract dispatch(transaction: Transaction): Promise<DispatchResult>;
    /**
     * Create a deterministic secret based on the input data.
     *
     * @param data Input data to generate the hash from
     * @param options Hash configuration
     *
     * @returns Hash array
     */
    abstract privateHash(data: ArrayBuffer, options: SignMessageOptions): Promise<Uint8Array>;
    /**
     * Create and sign a DataItem (bundled transaction item),
     * that can be loaded into "arbundles".
     *
     * @param dataItem Data item params
     *
     * @returns Buffer of the signed data item
     */
    abstract signDataItem(dataItem: DataItem): Promise<ArrayBufferLike>;
    /**
     * Create a cryptographic signature for any piece of data for later validation.
     * This function cannot be used to sign transactions or interactions, because the data
     * gets hashed before the signature generation.
     *
     * @param data Message to be hashed and signed
     * @param options Signature options
     *
     * @returns Signature
     */
    abstract signMessage(data: ArrayBuffer, options?: SignMessageOptions): Promise<Uint8Array>;
    /**
     * Verify a cryptographic signature created with the arweaveWallet.signMessage() function.
     *
     * @param data Data to verify with the signature
     * @param signature Signature to validate
     * @param publicKey Optionally match the signature with a different public key than the currently active
     * @param options Signature options
     *
     * @returns Validity
     */
    abstract verifyMessage(data: ArrayBuffer, signature: ArrayBuffer | string, publicKey?: string, options?: SignMessageOptions): Promise<boolean>;
}
/**
 * Arweave wallet permission types
 */
type PermissionType = "ACCESS_ADDRESS" | "ACCESS_PUBLIC_KEY" | "ACCESS_ALL_ADDRESSES" | "SIGN_TRANSACTION" | "ENCRYPT" | "DECRYPT" | "SIGNATURE" | "ACCESS_ARWEAVE_CONFIG" | "DISPATCH";
interface DispatchResult {
    id: string;
    type?: "BASE" | "BUNDLED";
}
interface AppInfo$1 {
    name?: string;
    logo?: string;
}
interface GatewayConfig {
    host: string;
    port: number;
    protocol: "http" | "https";
}
interface SignMessageOptions {
    hashAlgorithm?: "SHA-256" | "SHA-384" | "SHA-512";
}
interface DataItem {
    data: string | Uint8Array;
    target?: string;
    anchor?: string;
    tags?: {
        name: string;
        value: string;
    }[];
}

type OthentStorageKey = `othent${string}`;
type Auth0Strategy = "cross-site-cookies" | "refresh-tokens";
type Auth0Cache = "memory" | "localstorage" | ICache;
type Auth0CacheType = "memory" | "localstorage" | "custom";
type Auth0RedirectUri = UrlString | `${string}.auth0://${string}/ios/${string}/callback` | `${string}.auth0://${string}/android/${string}/callback`;
type Auth0RedirectUriWithParams = `${Auth0RedirectUri}?${string}`;
type Auth0LogInMethod = "popup" | "redirect";
type AutoConnect = "eager" | "lazy" | "off";
interface AppInfo {
    /**
     * Name of your app. This will add a tag `App-Name: <appName>` to any transaction signed or sent using `Othent.sign`,
     * `Othent.dispatch` or `Othent.signDataItem`.
     */
    name: string;
    /**
     * Version of your app. This will add a tag `App-Version: <appVersion>` to any transaction signed or sent using
     * `Othent.sign`, `Othent.dispatch` or `Othent.signDataItem`.
     */
    version: string;
    /**
     * Environment your app is currently running on (e.g. "development", "staging", "production", ...). This will add a
     * tag `App-Env: <appEnv>` to any transaction signed or sent using `Othent.sign`, `Othent.dispatch` or
     * `Othent.signDataItem`.
     *
     * If no value (empty `string`) is provided, this will automatically be set to `"development"` if
     * `location.hostname = "localhost"` or `"production"` otherwise.
     */
    env: string;
    /**
     * Image with the logo of your app. Optional and not used for now.
     */
    logo?: UrlString;
}
interface OthentConfig {
    /**
     * Enable additional logs.
     *
     * @defaultValue `false`
     */
    debug: boolean;
    /**
     * Inject Othent's instance as `globalThis.arweaveWallet` so that `arweave-js` can use it on the background.
     *
     * @defaultValue `false`
     */
    inject: boolean;
    /**
     * API base URL. Needed if you are using a private/self-hosted API and Auth0 tenant.
     */
    serverBaseURL: string;
    /**
     * Auth0 domain. Needed if you are using a private/self-hosted API and Auth0 tenant.
     */
    auth0Domain: string;
    /**
     * Auth0 client ID. Needed if you are using a private/self-hosted API and Auth0 tenant, or if you have a dedicated
     * App inside Othent's Auth0 tenant to personalize the logic experience (premium subscription).
     */
    auth0ClientId: string;
    /**
     * Possible values are:
     *
     * - `refresh-tokens`: Use refresh tokens for authentication. This is the most secure and robust option.
     *
     * - `cross-site-cookies`: Use cross-site cookies for authentication. Not recommended, as this won't work in browsers
     *   that block cross-site cookies, such as Brave.
     *
     * @defaultValue `refresh-tokens`
     */
    auth0Strategy: Auth0Strategy;
    /**
     * Possible values are:
     *
     * - `memory`: This is the most secure and recommended option/location to store tokens, but new tabs won't be able to
     *   automatically log in using a popup without a previous user action.
     *
     *   However, by setting the `persistLocalStorage = true` option, the user details (but not the refresh / access
     *   tokens) will be persisted in `localStorage` until the most recent refresh token's expiration date, allowing you
     *   to read the user details (`.getUserDetails()` / `.getSyncUserDetails()`) and make it look in the UI as if the
     *   user were already logged in.
     *
     * - `localstorage`: Store tokens `localStorage`. This makes it possible for new tabs to automatically log in using a
     *   popup, even after up to 2 weeks of inactivity (i.e. "keep me logged in"), but offers a larger attack surface to
     *   attackers trying to get a hold of the refresh / access tokens.
     *
     * - `custom`: Provide a custom storage implementation that implements Auth0's
     *   [`ICache`](https://auth0.github.io/auth0-spa-js/interfaces/ICache.html). Useful for mobile apps (e.g. React
     *   Native).
     *
     * @defaultValue `memory`
     */
    auth0Cache: Auth0CacheType;
    /**
     * Possible values are:
     *
     * - `popup`: Open Auth0's authentication page on a popup window while the original page just waits for authentication
     *   to take place or to timeout. This option is faster and less intrusive.
     *
     * - `redirect`: Navigate to Auth0's authentication page, which will redirect users back to your site or
     *   `auth0RedirectURI` upon authentication. Once they are redirected back, the URL will show a `code` and `state`
     *   query parameters for a second or two, until the authentication flow is completed.
     *
     * @see https://auth0.github.io/auth0-spa-js/classes/Auth0Client.html#loginWithRedirect
     * @see https://auth0.github.io/auth0-spa-js/classes/Auth0Client.html#handleRedirectCallback
     * @see https://auth0.github.io/auth0-spa-js/classes/Auth0Client.html#loginWithPopup
     *
     * @defaultValue `popup`
     */
    auth0LogInMethod: Auth0LogInMethod;
    /**
     * Auth0's callback URL (`redirect_uri`) used during the authentication flow.
     *
     * @see https://auth0.com/docs/authenticate/login/redirect-users-after-login
     *
     * @defaultValue `location.origin` (when available in the platform)
     */
    auth0RedirectURI: Auth0RedirectUri | null;
    /**
     * Auth0's logout URL (`returnTo`) used during the logout flow.
     *
     * @see https://auth0.com/docs/authenticate/login/logout/redirect-users-after-logout
     *
     * @defaultValue `location.origin` (when available in the platform)
     */
    auth0ReturnToURI: Auth0RedirectUri | null;
    /**
     * Refresh token expiration in milliseconds. This should/must match the value set in Auth0. On the client, this value
     * is only used to set a timer to automatically log out users when their refresh token expires. Incorrectly setting
     * this value will make users think they are still logged in, even after their refresh token expires (until they try
     * to perform any kind of action through Othent and get an error).
     *
     * @defaultValue `1296000000` (2 weeks)
     */
    auth0RefreshTokenExpirationMs: number;
    /**
     * Possible values are:
     *
     * - `eager`: Try to log in as soon as the page loads. This won't work when using `auth0Strategy = "refresh-memory"`.
     *
     * - `lazy` Try to log in as soon as there's an attempt to perform any action through Othent. This will only work with
     *   `auth0Strategy = "refresh-memory"` if the first action is preceded by a user action (e.g. click on a button).
     *
     * - `off`: Do not log in automatically. Trying to perform any action through Othent before calling `connect()` or
     *   `requireAuth()` will result in an error.
     *
     * @defaultValue `lazy`
     */
    autoConnect: AutoConnect;
    /**
     * All `Othent` methods could throw an error, so you should wrap them in `try-catch` blocks. Alternatively, you can
     * set this option to `false` and the library will do this automatically, so no method will ever throw an error. In
     * this case, however, you must add at least one error event listener with `othent.addEventListener("error", () => { ... })`.
     *
     * @defaultValue `true`
     */
    throwErrors: boolean;
    /**
     * Additional tags to include in transactions signed or sent using `Othent.sign`, `Othent.dispatch` or
     * `Othent.signDataItem`.
     *
     * @defaultValue `[]`
     */
    tags: TagData[];
    /**
     * Name of the cookie where the user details JSON will be stored.
     *
     * @defaultValue `null`
     */
    cookieKey: OthentStorageKey | null;
    /**
     * Name of the `localStorage` item where the user details JSON will be stored.
     *
     * @defaultValue `null`
     */
    localStorageKey: OthentStorageKey | null;
}
interface OthentOptions extends Partial<Omit<OthentConfig, "cookieKey" | "localStorageKey" | "auth0Cache">> {
    appInfo: AppInfo;
    /**
     * Gateway config to connect to Arweave.
     */
    gatewayConfig?: GatewayConfig;
    /**
     * Set this to `true` or the name of the cookie where you'd like the user details JSON to be stored. Useful when you use
     * SSR and need to user details to be available on the server.
     *
     * The cookie will expire after `refreshTokenExpirationMs`.
     * Note setting this option to `true` will set the cookie on client / frontend, but you'll have to manually recover it on
     * the server / backend, and pass it to `Othent`'s `constructor` as `initialUserDetails`.
     *
     * @defaultValue `false`
     */
    persistCookie?: boolean | OthentStorageKey;
    /**
     * Set this to `true` or the name of the `localStorage` item where you'd like the user details JSON to be stored. Useful
     * to immediately sync user details and authentication status across tabs, and to make it look to users as if they were
     * already authenticated when coming back to your app before `refreshTokenExpirationMs`, even if the session still needs
     * to be refreshed by calling `connect()` or `requireAuth()`.
     *
     * The stored values will be removed / discarded if more than `refreshTokenExpirationMs` have passed, but will remain
     * in `localStorage` until the user logs out or until that time has passed and `Othent` is instantiated again.
     *
     * @defaultValue `false`
     */
    persistLocalStorage?: boolean | OthentStorageKey;
    /**
     * Initial user details. Useful for server-side rendered sites or native apps that might store the most recent user
     * details externally (e.g. cookie or `SharedPreferences`).
     */
    initialUserDetails?: UserDetails | null;
    /**
     * Possible values are:
     *
     * - `memory`: This is the most secure and recommended option/location to store tokens, but new tabs won't be able to
     *   automatically log in using a popup without a previous user action. However, you can set
     *   `persistLocalStorage = true`, which stores the user details, but not the refresh / access tokens, in
     *   `localStorage`.
     *
     * - `localstorage`: Store tokens `localStorage`. This makes it possible for new tabs to automatically log in using a
     *   popup, even after up to 2 weeks of inactivity (i.e. "keep me logged in"), but offers a larger attack surface to
     *   attackers trying to get a hold of the refresh / access tokens.
     *
     * - `custom`: Provide a custom storage implementation that implements Auth0's
     *   [`ICache`](https://auth0.github.io/auth0-spa-js/interfaces/ICache.html). Useful for mobile apps (e.g. React
     *   Native).
     *
     * @defaultValue `memory`
     */
    auth0Cache?: Auth0Cache;
}

type Auth0Provider = `apple` | `auth0` | `google-oauth2` | `<LinkedIn>` | `twitter` | `<Meta>` | `<Twitch>` | `github`;
type Auth0Sub = `${Auth0Provider}|${string}`;
type Auth0ProviderLabel = `Apple` | `E-Mail` | `Google` | `LinkedIn` | `X` | `Meta` | `Twitch` | `GitHub` | `Unknown Provider`;
type Auth0WalletAddressLabel = `${Auth0ProviderLabel} (${string})`;
type ANSDomain = `${string}.ar`;
type OthentWalletAddressLabel = Auth0WalletAddressLabel | ANSDomain;
interface UserDetails {
    /**
     * ID of the user's Auth0 account.
     */
    sub: Auth0Sub;
    /**
     * The full name of the connected user created by the concatenation of the `givenName` and `familyName`.
     */
    name: string;
    /**
     * The first name associated with the connected user.
     */
    givenName: string;
    /**
     * The middle name or surname associated with the connected user.
     */
    middleName: string;
    /**
     * The last name or surname associated with the connected user.
     */
    familyName: string;
    /**
     * A less formal nickname for the connected user.
     */
    nickname: string;
    /**
     * The preferred username for the connected user.
     */
    preferredUsername: string;
    /**
     * ???
     */
    profile: string;
    /**
     * The image URL of the profile picture of the connected user account.
     */
    picture: string;
    /**
     * Website associated to the connected user, if any.
     */
    website: string;
    /**
     * Locale of the connected user.
     */
    locale: string;
    /**
     * Date when the connected user was last updated.
     */
    updatedAt: string;
    /**
     * The connected user’s email address.
     */
    email: string;
    /**
     * This field is set to `true` when the user successfully verifies their email address by clicking a verification
     * link sent to their email.
     */
    emailVerified: boolean;
    /**
     * Every user account has an associated Arweave wallet. This is the public key of the associated Arweave wallet,
     * derived from `sub`.
     */
    owner: B64UrlString;
    /**
     * Every user account has an associated Arweave wallet. This is the wallet address of the associated Arweave wallet,
     * derived from `owner`,
     */
    walletAddress: B64UrlString;
    /**
     * The wallet address label. This is either coming from ANS or `"{Auth0Provider} ({email})"`.
     */
    walletAddressLabel: OthentWalletAddressLabel;
    /**
     * The authentication protocol used (this will always be "KMS").
     */
    authSystem: "KMS";
    /**
     * The authentication provider (social network, platform...) that was used to sign in.
     */
    authProvider: Auth0Provider;
}

interface ServerInfoOptions {
    includeToken?: boolean;
}
interface ServerInfo {
    version: string;
    buildDate: string;
    hasToken: boolean;
    hasTokenData: boolean;
    isTokenValid: boolean;
    isTokenUnused: boolean;
}

declare class Othent implements Omit<ArConnect, "connect"> {
    static walletName: "Othent KMS";
    static walletVersion: "2.1.1";
    static ALL_PERMISSIONS: ["ACCESS_ADDRESS", "ACCESS_ALL_ADDRESSES", "ACCESS_ARWEAVE_CONFIG", "ACCESS_PUBLIC_KEY", "DECRYPT", "DISPATCH", "ENCRYPT", "SIGN_TRANSACTION", "SIGNATURE"];
    private crypto;
    private api;
    private auth0;
    private errorEventListenerHandler;
    private tokens;
    walletName: "Othent KMS";
    walletVersion: "2.1.1";
    config: OthentConfig;
    appInfo: AppInfo;
    gatewayConfig: GatewayConfig;
    /**
     * Instantiate `Othent`.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/constructor|constructor() docs}
     */
    constructor(options?: OthentOptions);
    /**
     * @param appInfo Setter and validator for `appInfo`.
     *
     * @returns `Othent.appInfo`
     */
    private setAppInfo;
    /**
     * @param appInfo Setter and validator for `gatewayConfig`.
     *
     * @returns `Othent.gatewayConfig`
     */
    private setGatewayConfig;
    /**
     * Start listening for `storage` events to sync user details across tabs. Only needed if `persistLocalStorage = true`.
     *
     * @returns A cleanup function that must be called whenever Othent needs to stop listening for `storage` events (e.g.
     * to be used in React's `useEffects`'s cleanup function).
     *
     * @see {@link https://docs.othent.io/js-sdk-api/start-tab-synching|startTabSynching() docs}
     */
    startTabSynching(): () => void;
    private onError;
    /**
     * Add an event listener for the specific error type.
     *
     * @param type `"auth"` or `error`.
     * @param listener Function of type `AuthListener` or `ErrorListener`.
     *
     * @returns A cleanup function that will remove the error listener when called.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/events|Events docs}
     */
    addEventListener<E extends OthentEventType>(type: E, listener: EventListenersByType[E]): () => void;
    /**
     * Remove an error listener of the specified error type.
     *
     * @param type `"auth"` or `error`.
     * @param listener Function of type `AuthListener` or `ErrorListener`.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/events|Events docs}
     */
    removeEventListener<E extends OthentEventType>(type: E, listener: EventListenersByType[E]): void;
    /**
     * @returns `true` if the user is authenticated; `false` otherwise.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/is-authenticated|isAuthenticated docs}
     */
    get isAuthenticated(): boolean;
    /**
     * Automatically checks if the user is authenticated. If they are not, and...
     *
     * - `autoConnect === "eager"`: Prompts them to sign in/up again. It throws an error if authentication fails.
     * - `autoConnect === "lazy"`: Authenticates them automatically, either from an existing session or by prompting them
     *   to sign in/up again. It throws an error if authentication fails.
     * - `autoConnect === "off"`: It throws an error.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/require-auth|requireAuth() docs}
     */
    requireAuth(): Promise<void>;
    /**
     * Automatically checks if the user is authenticated. If they are not, and...
     *
     * - `autoConnect === "eager"`: Prompts them to sign in/up again. It throws an error if authentication fails.
     * - `autoConnect === "lazy"`: Authenticates them automatically, either from an existing session or by prompting them
     *   to sign in/up again. It throws an error if authentication fails.
     * - `autoConnect === "off"`: It throws an error.
     *
     * @returns `Promise<{ sub, publicKey }>` to get these 2 properties required in most Othent functions.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/require-auth|requireAuth() docs}
     */
    private requireUserDataOrThrow;
    private completeConnectionOrCreateAuth0User;
    /**
     * If and only if you set the [`auth0LogInMethod = "redirect"`](./constructor.md#auth0loginmethod-auth0loginmethod) option,
     * users will be redirected to Auth0 to authenticate and then back to your application. When they land back in your
     * application, you must call `completeConnectionAfterRedirect()` to complete the authentication process.
     *
     * By default, `callbackUriWithParams = location.href`, if you environment supports it. Otherwise, you'll have to manually
     * pass an URI with the `code` and `state` params provided by Auth0, which handles the redirect callback.
     *
     * See [Auth0's `handleRedirectCallback`](https://auth0.github.io/auth0-spa-js/classes/Auth0Client.html#handleRedirectCallback).
     *
     * @param callbackUriWithParams
     *
     * @returns A Promise with the `UserDetails` or `null` if the log in modal was closed, could not even be opened or
     * authentication failed.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/complete-connection-after-redirect|completeConnectionAfterRedirect() docs}
     */
    completeConnectionAfterRedirect(callbackUriWithParams?: Auth0RedirectUriWithParams): Promise<UserDetails | null>;
    /**
     * Prompts the user to sign in/up using Auth0's modal. This function cannot be called programmatically before the user
     * interacts with the page (e.g. by clicking on a button), as that will result in a `Unable to open a popup` error.
     *
     * @returns A Promise with the `UserDetails` or `null` if the log in modal was closed, could not even be opened or
     * authentication failed.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/connect|connect() docs}
     */
    connect(permissions?: PermissionType[], appInfo?: AppInfo, gateway?: GatewayConfig): Promise<UserDetails | null>;
    /**
     * Logs out the user (disconnect the user's wallet). This will require the user to log back in after called.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/disconnect|disconnect() docs}
     */
    disconnect(): Promise<void>;
    /**
     * Returns the Arweave wallet address associated with the active (authenticated) user account.
     *
     * The wallet address is derived from the corresponding public key (see [`getActivePublicKey()`](get-active-public-key.md)).
     *
     * This function assumes (and requires) a user is authenticated.
     *
     * @returns A Promise with the active wallet address of the users wallet.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/get-active-address|getActiveAddress() docs}
     */
    getActiveAddress(): Promise<"" | B64UrlString>;
    /**
     * Returns the public key (`jwk.n` field) associated with the active (authenticated) user account.
     *
     * This function assumes (and requires) a user is authenticated.
     *
     * @returns A Promise with the owner (jwk.n field) of the users wallet.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/get-active-public-key|getActivePublicKey() docs}
     */
    getActivePublicKey(): Promise<"" | B64UrlString>;
    /**
     * Returns an array of Arweave wallet addresses associated with the active (authenticated) user account.
     *
     * However, note that Othent does not currently support creating/storing more than one wallet associated to the same
     * account, so this function will always return exactly one wallet address.
     *
     * This function assumes (and requires) a user is authenticated.
     *
     * @returns A Promise with an array of all wallet addresses of the users wallet.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/get-all-addresses|getAllAddresses() docs}
     */
    getAllAddresses(): Promise<B64UrlString[]>;
    /**
     * Similarly to ArConnect, each wallet in Othent has a nickname. This is either:
     *
     * - The user's [ANS](https://ans.gg) name.
     * - A platform + email identifying label (e.g. `Google (email@gmail.com)`, `Twitter (email@outlook.com)`...).
     *
     * To provide better UX, you can retrieve these names and display them to the user, so that they can easily recognize
     * which wallet they're using.
     *
     * However, note that Othent does not currently support creating/storing more than one wallet associated to the same
     * account, so this function will always return exactly one wallet address.
     *
     * This function assumes (and requires) a user is authenticated.
     *
     * @returns A Promise containing an object that maps each wallet addresses to their nickname.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/get-wallet-names|getWalletNames() docs}
     */
    getWalletNames(): Promise<Record<B64UrlString, string>>;
    /**
     * Returns an object with all the user details of the active (authenticated) user account.
     *
     * @returns A Promise containing all the user details of the active user, or `null` if the user is not authenticated.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/get-user-details|getUserDetails() docs}
     */
    getUserDetails(): Promise<UserDetails | null>;
    /**
     * Get the active wallet address of the users wallet. This function assumes (and requires) a user is authenticated.
     *
     * @returns The active wallet address of the users wallet.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/get-sync-active-address|getSyncActiveAddress() docs}
     */
    getSyncActiveAddress(): "" | B64UrlString;
    /**
     * Get the owner (jwk.n) field of the users wallet. This function assumes (and requires) a user is authenticated.
     *
     * @returns The owner (jwk.n) field of the users wallet.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/get-sync-active-public-key|getSyncActivePublicKey() docs}
     */
    getSyncActivePublicKey(): "" | B64UrlString;
    /**
     * Get all addresses of the users wallet. This function assumes (and requires) a user is authenticated.
     *
     * @returns All wallet addresses of the users wallet.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/get-sync-all-addresses|getSyncAllAddresses() docs}
     */
    getSyncAllAddresses(): B64UrlString[];
    /**
     * Get the wallets (users) email. This function assumes (and requires) a user is authenticated.
     *
     * @returns The wallets (users) email.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/get-sync-wallet-names|getSyncWalletNames() docs}
     */
    getSyncWalletNames(): Promise<Record<B64UrlString, string>>;
    /**
     * Get user details. This function assumes (and requires) a user is authenticated.
     *
     * @returns The user's details.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/get-sync-user-details|getSyncUserDetails() docs}
     */
    getSyncUserDetails(): UserDetails | null;
    private addCommonTags;
    /**
     * To submit a transaction to the Arweave Network, it first has to be signed using a private key. Othent creates a private
     * key / Arweave wallet for every account and stores it in Google KMS. The wallet associated with the active user account
     * is used to sign transactions using the `sign()` function.
     *
     * The `sign()` function is meant to replicate the behavior of the `transactions.sign()` function of
     * [`arweave-js`](https://github.com/arweaveTeam/arweave-js#sign-a-transaction), but instead of mutating the transaction
     * object, it returns a new and signed transaction instance.
     *
     * This function assumes (and requires) a user is authenticated and a valid arweave transaction.
     *
     * @param transaction The transaction to sign.
     *
     * @returns A Promise containing a new signed transaction.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/sign|sign() docs}
     * @see {@link https://docs.arweave.org/developers/arweave-node-server/http-api#transaction-format|Transaction Format docs}
     */
    sign(transaction: Transaction$1): Promise<Transaction$1>;
    /**
     * The `dispatch()` function allows you to quickly sign and send a transaction to the network in a bundled format. It is
     * best for smaller datas and contract interactions. If the bundled transaction cannot be submitted, it will fall back to a
     * base layer transaction. The function returns the [result](dispatch.md#dispatch-result) of the API call.
     *
     * This function assumes (and requires) a user is authenticated and a valid arweave transaction.
     *
     * @param transaction The transaction to sign and dispatch.
     *
     * @returns The signed version of the transaction.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/dispatch|dispatch() docs}
     */
    dispatch(transaction: Transaction$1, options?: DispatchOptions): Promise<ArDriveBundledTransactionData | UploadedTransactionData>;
    /**
     * Encrypt data with the users JWK.
     *
     * This function assumes (and requires) a user is authenticate.
     *
     * @param plaintext The data in string format to sign.
     *
     * @returns The encrypted data.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/encrypt|encrypt() docs}
     */
    encrypt(plaintext: string | BinaryDataType): Promise<Uint8Array>;
    /**
     * Decrypt data with the users JWK.
     *
     * This function assumes (and requires) a user is authenticated.
     *
     * @param ciphertext The data to decrypt.
     *
     * @returns The decrypted data.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/decrypt|decrypt() docs}
     */
    decrypt(ciphertext: BinaryDataType): Promise<Uint8Array>;
    /**
     * Generate a signature. This function assumes (and requires) a user is authenticated.
     *
     * @deprecated Use `sign`, `signDataItems` or `signMessage` instead.
     *
     * @param data The data to sign.
     *
     * @returns The {@linkcode Buffer} format of the signature.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/signature|signature() docs}
     */
    signature(data: string | BinaryDataType): Promise<Uint8Array>;
    /**
     * The signDataItem() function allows you to create and sign a data item object, compatible with arbundles. These data
     * items can then be submitted to an ANS-104 compatible bundler.
     *
     * @param dataItem The data to sign.
     *
     * @returns The signed data item.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/sign-data-item|signDataItem() docs}
     */
    signDataItem(dataItem: DataItem$1): Promise<ArrayBufferLike>;
    /**
     * Sign the given message. This function assumes (and requires) a user is authenticated.
     *
     * @param message The message to sign.
     *
     * @returns The signed version of the message.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/sign-message|signMessage() docs}
     */
    signMessage(data: string | BinaryDataType, options?: SignMessageOptions): Promise<Uint8Array>;
    /**
     * Verify the given message. This function assumes (and requires) a user is authenticated.
     *
     * @param signature The signature to verify.
     *
     * @returns The signed version of the message.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/verify-message|verifyMessage() docs}
     */
    verifyMessage(data: string | BinaryDataType, signature: string | BinaryDataType, publicKey?: B64UrlString, options?: SignMessageOptions): Promise<boolean>;
    /**
     * Create a deterministic secret based on the input data.
     *
     * @param data Input data to generate the hash from.
     * @param options Hash algorithm (default = `SHA-256`).
     *
     * @returns Hash `Uint8Array`.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/private-hash|privateHash() docs}
     */
    privateHash(data: string | BinaryDataType, options?: SignMessageOptions): Promise<Uint8Array>;
    /**
     * Get the Arweave config used by Othent.
     *
     * @returns Promise of Othent's `GatewayConfig`.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/get-arweave-config|getArweaveConfig() docs}
     */
    getArweaveConfig(): Promise<GatewayConfig>;
    /**
     * Get the permissions Othent can use in the current site.
     *
     * @returns Promise of Othent's `PermissionType[]`.
     *
     * @see {@link https://docs.othent.io/js-sdk-api/get-permissions|getPermissions() docs}
     */
    getPermissions(): Promise<PermissionType[]>;
    /**
     * Mocked implementation to add tokens.
     * Othent doesn't currently support this feature and only tracks added tokens temporarily in memory.
     */
    addToken(id: string, type?: string, gateway?: GatewayConfig): Promise<void>;
    /**
     * Mocked implementation to check if a token has been added.
     * Othent doesn't currently support this feature and only tracks added tokens temporarily in memory.
     */
    isTokenAdded(id: string): Promise<boolean>;
    __overridePublicKey(publicKeyPEM: string): void;
    __getServerInfo(options?: ServerInfoOptions): Promise<ServerInfo>;
}

declare const DEFAULT_OTHENT_CONFIG: {
    readonly debug: false;
    readonly inject: false;
    readonly auth0Domain: "auth.othent.io";
    readonly auth0ClientId: "uXkRmJoIa0NfzYgYEDAgj6Rss4wR1tIc";
    readonly auth0Strategy: "refresh-tokens";
    readonly auth0Cache: "memory";
    readonly auth0RefreshTokenExpirationMs: 1296000000;
    readonly auth0LogInMethod: "popup";
    readonly auth0RedirectURI: null;
    readonly auth0ReturnToURI: null;
    readonly serverBaseURL: "https://kms-server.othent.io";
    readonly autoConnect: "lazy";
    readonly cookieKey: null;
    readonly localStorageKey: null;
    readonly throwErrors: true;
    readonly tags: [];
};
declare const DEFAULT_APP_INFO: {
    readonly name: "";
    readonly version: "";
    readonly env: "production" | "development";
};
declare const DEFAULT_GATEWAY_CONFIG: {
    readonly host: "arweave.net";
    readonly protocol: "https";
    readonly port: 443;
};
declare const DEFAULT_OTHENT_OPTIONS: {
    readonly appInfo: {
        readonly name: "";
        readonly version: "";
        readonly env: "production" | "development";
    };
    readonly gatewayConfig: {
        readonly host: "arweave.net";
        readonly protocol: "https";
        readonly port: 443;
    };
    readonly persistCookie: false;
    readonly persistLocalStorage: false;
    readonly auth0Cache: "memory";
    readonly debug: false;
    readonly inject: false;
    readonly auth0Domain: "auth.othent.io";
    readonly auth0ClientId: "uXkRmJoIa0NfzYgYEDAgj6Rss4wR1tIc";
    readonly auth0Strategy: "refresh-tokens";
    readonly auth0RefreshTokenExpirationMs: 1296000000;
    readonly auth0LogInMethod: "popup";
    readonly auth0RedirectURI: null;
    readonly auth0ReturnToURI: null;
    readonly serverBaseURL: "https://kms-server.othent.io";
    readonly autoConnect: "lazy";
    readonly cookieKey: null;
    readonly localStorageKey: null;
    readonly throwErrors: true;
    readonly tags: [];
};
declare const DEFAULT_DISPATCH_NODE: "https://turbo.ardrive.io";
declare const DEFAULT_COOKIE_KEY: "othentUserDetails";
declare const DEFAULT_LOCAL_STORAGE_KEY: "othentUserDetails";

declare const PROVIDER_LABELS: Record<Auth0Provider, Auth0ProviderLabel>;

/**
 * @deprecated
 */
type LegacyBufferRecord = Record<number, number>;
/**
 * @deprecated
 */
interface LegacyBufferObject {
    type: "Buffer";
    data: number[];
}
/**
 * Alias of `LegacyBufferObject`.
 *
 * @deprecated
 */
type BufferObject = LegacyBufferObject;
/**
 * JSON-compatible representation of a Buffer.
 * @deprecated This type will soon be removed and the code will be updated to work exclusively with native binary data types (e.g. `Uint8Array`).
 */
type LegacyBufferData = LegacyBufferRecord | LegacyBufferObject;
declare function isLegacyBufferObject(legacyBufferData: LegacyBufferData): legacyBufferData is LegacyBufferObject;
/**
 * Alias of `isLegacyBufferObject`.
 */
declare function isBufferObject(obj: any): obj is BufferObject;

export { type ANSDomain, type AppInfo, type ArDriveBundledTransactionData, type ArDriveBundledTransactionResponseData, type Auth0Cache, type Auth0CacheType, type Auth0LogInMethod, type Auth0Provider, type Auth0ProviderLabel, type Auth0RedirectUri, type Auth0RedirectUriWithParams, type Auth0Strategy, type Auth0Sub, type Auth0WalletAddressLabel, type AuthListener, type AutoConnect, type B64String, type B64UrlString, type BinaryDataType, type BufferObject, DEFAULT_APP_INFO, DEFAULT_COOKIE_KEY, DEFAULT_DISPATCH_NODE, DEFAULT_GATEWAY_CONFIG, DEFAULT_LOCAL_STORAGE_KEY, DEFAULT_OTHENT_CONFIG, DEFAULT_OTHENT_OPTIONS, type DataItem$1 as DataItem, type DispatchOptions, type ErrorListener, type EventListenersByType, type GatewayConfig, type LegacyBufferData, type LegacyBufferObject, type LegacyBufferRecord, Othent, type OthentConfig, OthentError, OthentErrorID, type OthentEventType, type OthentOptions, type OthentStorageKey, type OthentWalletAddressLabel, PROVIDER_LABELS, type PermissionType, type SignMessageOptions, type TagData, type TypedArray, type UploadedTransactionData, type UrlString, type UserDetails, type VerifiedUTF16String, b64ToUint8Array, b64UrlDecode, b64UrlEncode, binaryDataTypeOrStringToBinaryDataType, binaryDataTypeOrStringTob64String, binaryDataTypeToString, binaryDataTypeTob64Url, hash, isBufferObject, isLegacyBufferObject, stringOrUint8ArrayToUint8Array, stringToUint8Array, stringTob64Url, uint8ArrayTob64, uint8ArrayTob64Url };
