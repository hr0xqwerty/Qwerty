(function(){"use strict";try{if(typeof document<"u"){var e=document.createElement("style");e.appendChild(document.createTextNode(".b1cb9caz{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;font-family:var(--b1cb9caz-0),sans-serif;font-size:.9rem;font-weight:600;color:#fff;background-color:rgb(var(--b1cb9caz-1));border-radius:var(--b1cb9caz-2);padding:.3rem .8rem;text-align:center;border:none;outline:none;text-transform:uppercase;cursor:pointer;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;gap:.4rem;white-space:nowrap;-webkit-tap-highlight-color:transparent;-webkit-transition:all .18s ease-in-out;transition:all .18s ease-in-out}.b1cb9caz:hover:not(:active):not(:disabled){-webkit-transform:translate3d(0px,-1.4px,0px);-ms-transform:translate3d(0px,-1.4px,0px);transform:translate3d(0,-1.4px,0);box-shadow:var(--b1cb9caz-3)}.b1cb9caz:disabled{opacity:.7;cursor:not-allowed}.b1cb9caz svg{font-size:1em;width:1em;height:1em}.w14emrir{border-radius:var(--w14emrir-0);text-transform:none;padding:.3rem;background-color:var(--w14emrir-1)}.czh4f0e{line-height:2.6rem;padding:0 .9rem}.pwkn5es{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:rgb(var(--pwkn5es-0),.2);height:2.6rem;border-radius:var(--pwkn5es-1);padding:0 .3rem 0 .6rem;gap:.25rem}.bdt02oh{padding:0 .5rem}.e3hlv71{font-size:1.5rem!important}.a1jsmwxp{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:var(--a1jsmwxp-0);object-fit:cover;width:1.7rem;height:1.7rem;margin-right:.4rem}.as6ir6f{font-size:1rem!important;color:#fff}.av7js2i{position:relative;border-radius:var(--av7js2i-0);width:1.7rem;height:1.7rem;margin-right:.4rem;background:linear-gradient(to right,#4776e6,#8e54e9);background-size:cover}.av7js2i .as6ir6f{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.bbvkbel{position:fixed;top:0;left:0;right:0;bottom:0;width:100vw;height:100vh;z-index:90000;background-color:#0006}.m1767o4q{height:100vh;left:0;position:fixed;top:0;width:100vw;z-index:100000}.mzdiz37{height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width:720px){.mzdiz37{-webkit-align-items:flex-end;-webkit-box-align:flex-end;-ms-flex-align:flex-end;align-items:flex-end}}.m69h97z{position:relative;left:0;top:100%;z-index:100000;font-family:var(--m69h97z-0),sans-serif;overflow:hidden;-webkit-transition-property:width;transition-property:width}.m69h97z *::selection{background-color:#000000bf;color:#fff}.m69h97z *::-moz-selection{background-color:#000000bf;color:#fff}@media screen and (min-width:1081px){.m69h97z{max-width:28vw}}@media screen and (min-width:721px) and (max-width:1080px){.m69h97z{max-width:50vw}}@media screen and (max-width:720px){.m69h97z{max-width:100vw}}.mh21eb7{-webkit-transition:background-color .23s ease-in-out;transition:background-color .23s ease-in-out;background-color:rgb(var(--mh21eb7-0));border-radius:var(--mh21eb7-1);width:100%}@media screen and (max-width:720px){.mh21eb7{border-bottom-left-radius:0;border-bottom-right-radius:0}}.k17wyawm{position:fixed;font-family:var(--k17wyawm-0),sans-serif;font-size:.8rem;font-weight:500;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default;text-align:center;margin:0;color:#ffffff80;left:50%;bottom:10px;-webkit-transform:translateX(-50%);-ms-transform:translateX(-50%);transform:translate(-50%)}@media screen and (max-width:720px){.k17wyawm{bottom:unset;top:10px}}.b7jc8fb{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:1.24rem;padding:.75rem 1rem;border-radius:var(--b7jc8fb-0);border-radius:15px;bottom:0;right:1.5rem;left:unset;top:unset;width:auto}@media screen and (max-width:720px){.b7jc8fb{left:1.5rem;gap:1rem}}.typmncv{font-size:1.05rem;font-weight:500;color:rgb(var(--typmncv-0));margin:0}.b14qolsb{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:.6rem}@media screen and (max-width:720px){.b14qolsb{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.b14qolsb .b1cb9caz{width:100%}}.c1jq17m8{background-color:transparent;color:rgb(var(--c1jq17m8-0))}.c1jq17m8:hover{background-color:rgba(var(--c1jq17m8-1),.05);color:rgb(var(--c1jq17m8-1));box-shadow:none!important}.p1jty3xq{font-size:var(--p1jty3xq-0);color:rgb(var(--p1jty3xq-1));margin:0;font-weight:600;-webkit-transition:color .23s ease-in-out;transition:color .23s ease-in-out}.t1sgzzc0{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;font-family:var(--t1sgzzc0-0),sans-serif;font-size:var(--t1sgzzc0-1);font-weight:600;color:rgb(var(--t1sgzzc0-2));cursor:var(--t1sgzzc0-3);-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:.34rem;margin:0;-webkit-transition:color .23s ease-in-out;transition:color .23s ease-in-out}.tb205ol{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;gap:.1rem}.wzg6vks{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;padding:0 20px}.a1vzc1qt{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:.8rem}.l1rbotc6{width:60%;height:60%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;object-fit:contain}.acuhj7u{position:relative;width:3.8rem;height:3.8rem;border-radius:var(--acuhj7u-0);background-color:rgb(var(--acuhj7u-1));-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-tap-highlight-color:transparent;cursor:var(--acuhj7u-2);-webkit-transition:-webkit-transform .125s ease;-webkit-transition:transform .125s ease;transition:transform .125s ease}.acuhj7u .l1rbotc6{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.acuhj7u:active{-webkit-transform:scale(var(--acuhj7u-3));-ms-transform:scale(var(--acuhj7u-3));transform:scale(var(--acuhj7u-3))}.a143ijem{-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1}.wv1c1ab{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;padding:10px 20px;border-top:1px solid rgb(var(--wv1c1ab-0));-webkit-transition:border-color .23s ease-in-out;transition:border-color .23s ease-in-out}.s9sva{color:currentColor;font-size:1em;width:1em;height:1em;-webkit-animation:rotate-s9sva .9s linear infinite;animation:rotate-s9sva .9s linear infinite}@-webkit-keyframes rotate-s9sva{0%{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes rotate-s9sva{0%{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg)}}.h1mmuqym{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;padding:20px}.c86k5gq{position:relative;width:1.4rem;height:1.4rem;border-radius:100%;background-color:rgb(var(--c86k5gq-0));cursor:pointer;-webkit-tap-highlight-color:transparent;-webkit-transition:opacity .23s ease-in-out,-webkit-transform .125s ease,background-color .23s ease-in-out;-webkit-transition:opacity .23s ease-in-out,transform .125s ease,background-color .23s ease-in-out;transition:opacity .23s ease-in-out,transform .125s ease,background-color .23s ease-in-out}.c86k5gq:hover{-webkit-transform:scale(1.14);-ms-transform:scale(1.14);transform:scale(1.14)}.c86k5gq:active{-webkit-transform:scale(.92);-ms-transform:scale(.92);transform:scale(.92)}.c86k5gq svg{font-size:1.1rem;width:1em;height:1em;position:absolute;top:50%;left:50%;color:rgb(var(--c86k5gq-1));-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.a1osnke6{position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;gap:1.1rem;padding-bottom:1.2rem;max-height:280px;overflow-y:auto}.c15u83h7{position:relative;height:280px}.w5r445t{position:absolute;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;top:45%;left:50%;width:70%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.w5r445t .acuhj7u{margin-bottom:.65rem}.w5r445t .t1sgzzc0{text-align:center;font-weight:700;margin-bottom:.1rem;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}.w5r445t .p1jty3xq{text-align:center}.w5r445t .b1cb9caz{margin-top:1rem}.bukrfi8{background-color:#fb552b33;color:#fb542b;padding:.44rem;border-radius:var(--bukrfi8-0);margin-top:.6rem}.c13sms3{display:block;margin:0 auto;margin-top:1rem;color:rgb(var(--c13sms3-0));width:1.25rem;height:1.25rem}.b1r2gdr0{font-size:1em;width:1em;height:1em;cursor:pointer;color:#007aff;-webkit-transform:scale(1.75);-ms-transform:scale(1.75);transform:scale(1.75);-webkit-tap-highlight-color:transparent;-webkit-transition:-webkit-transform .125s ease;-webkit-transition:transform .125s ease;transition:transform .125s ease}.b1r2gdr0:hover{-webkit-transform:scale(1.9);-ms-transform:scale(1.9);transform:scale(1.9)}.b1r2gdr0:active{-webkit-transform:scale(1.5);-ms-transform:scale(1.5);transform:scale(1.5)}.p1hjgol5{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:0 20px 20px}.p1hjgol5 .t1sgzzc0,.p1hjgol5 .p1jty3xq{text-align:center}.p1hjgol5 .t1sgzzc0 svg,.p1hjgol5 .p1jty3xq svg{font-size:.85em;width:1em;height:1em;cursor:pointer;-webkit-tap-highlight-color:transparent;-webkit-transition:all .125s ease-in-out;transition:all .125s ease-in-out}.p1hjgol5 .t1sgzzc0 svg:hover,.p1hjgol5 .p1jty3xq svg:hover{opacity:.85}.p1hjgol5 .t1sgzzc0 svg:active,.p1hjgol5 .p1jty3xq svg:active{-webkit-transform:scale(.9);-ms-transform:scale(.9);transform:scale(.9)}.p1hjgol5 .b1cb9caz{margin-top:1.5rem;width:100%;padding:.9rem 0;border-radius:var(--p1hjgol5-0);text-transform:none}.publs4f{position:relative;width:80px;height:80px;border-radius:var(--publs4f-0);margin-bottom:.475rem;background-color:rgb(var(--publs4f-1));background-size:cover;z-index:1;-webkit-var(--publs4f-2);-moz-var(--publs4f-2);-ms-var(--publs4f-2);var(--publs4f-2)}.alzinag{position:absolute;bottom:0;right:0;width:1.45rem;height:1.45rem;border-radius:100%;background-color:rgb(var(--alzinag-0));border:2px solid rgb(var(--alzinag-1))}.alzinag img{position:absolute;top:50%;left:50%;object-fit:contain;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:74%;height:74%;border-radius:100%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.p1qewrlg{position:absolute;font-size:45px;width:1em;height:1em;top:50%;left:50%;color:#fff;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}")),document.head.appendChild(e)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
var Sf = Object.defineProperty;
var Pf = (t, e, r) => e in t ? Sf(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var pe = (t, e, r) => (Pf(t, typeof e != "symbol" ? e + "" : e, r), r), Li = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
};
var pt = (t, e, r) => (Li(t, e, "read from private field"), r ? r.call(t) : e.get(t)), Sr = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, Un = (t, e, r, n) => (Li(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r);
var mt = (t, e, r) => (Li(t, e, "access private method"), r);
import * as ke from "react";
import ht, { createContext as Tr, useContext as dt, useMemo as bt, useState as wt, useEffect as Le, useRef as Ot, useLayoutEffect as Cf, useCallback as qr, forwardRef as Of, createElement as Xu, useId as jo, useInsertionEffect as Rf, cloneElement as If, Children as Bf, isValidElement as kf, useReducer as Df } from "react";
import { Othent as Lf } from "@othent/kms";
function Nf(t, e) {
  var r = {};
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
}
function Mt(t, e, r, n) {
  function i(o) {
    return o instanceof r ? o : new r(function(s) {
      s(o);
    });
  }
  return new (r || (r = Promise))(function(o, s) {
    function a(d) {
      try {
        p(n.next(d));
      } catch (y) {
        s(y);
      }
    }
    function f(d) {
      try {
        p(n.throw(d));
      } catch (y) {
        s(y);
      }
    }
    function p(d) {
      d.done ? o(d.value) : i(d.value).then(a, f);
    }
    p((n = n.apply(t, e || [])).next());
  });
}
const Zu = () => {
  for (var t = [], e = [], r = typeof Uint8Array < "u" ? Uint8Array : Array, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, o = n.length; i < o; ++i)
    t[i] = n[i], e[n.charCodeAt(i)] = i;
  e["-".charCodeAt(0)] = 62, e["_".charCodeAt(0)] = 63;
  function s(v) {
    var w = v.length;
    if (w % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var I = v.indexOf("=");
    I === -1 && (I = w);
    var N = I === w ? 0 : 4 - I % 4;
    return [I, N];
  }
  function a(v, w, I) {
    return (w + I) * 3 / 4 - I;
  }
  function f(v) {
    var w, I = s(v), N = I[0], k = I[1], M = new r(a(v, N, k)), S = 0, Y = k > 0 ? N - 4 : N, W;
    for (W = 0; W < Y; W += 4)
      w = e[v.charCodeAt(W)] << 18 | e[v.charCodeAt(W + 1)] << 12 | e[v.charCodeAt(W + 2)] << 6 | e[v.charCodeAt(W + 3)], M[S++] = w >> 16 & 255, M[S++] = w >> 8 & 255, M[S++] = w & 255;
    return k === 2 && (w = e[v.charCodeAt(W)] << 2 | e[v.charCodeAt(W + 1)] >> 4, M[S++] = w & 255), k === 1 && (w = e[v.charCodeAt(W)] << 10 | e[v.charCodeAt(W + 1)] << 4 | e[v.charCodeAt(W + 2)] >> 2, M[S++] = w >> 8 & 255, M[S++] = w & 255), M;
  }
  function p(v) {
    return t[v >> 18 & 63] + t[v >> 12 & 63] + t[v >> 6 & 63] + t[v & 63];
  }
  function d(v, w, I) {
    for (var N, k = [], M = w; M < I; M += 3)
      N = (v[M] << 16 & 16711680) + (v[M + 1] << 8 & 65280) + (v[M + 2] & 255), k.push(p(N));
    return k.join("");
  }
  function y(v) {
    for (var w, I = v.length, N = I % 3, k = [], M = 16383, S = 0, Y = I - N; S < Y; S += M)
      k.push(d(v, S, S + M > Y ? Y : S + M));
    return N === 1 ? (w = v[I - 1], k.push(t[w >> 2] + t[w << 4 & 63] + "==")) : N === 2 && (w = (v[I - 2] << 8) + v[I - 1], k.push(t[w >> 10] + t[w >> 4 & 63] + t[w << 2 & 63] + "=")), k.join("");
  }
  return { toByteArray: f, fromByteArray: y };
};
function Uf(t) {
  let e = Qu(t);
  return new TextDecoder("utf-8", { fatal: !0 }).decode(e);
}
function Ff(t) {
  return new TextDecoder("utf-8", { fatal: !0 }).decode(t);
}
function Ju(t) {
  return new TextEncoder().encode(t);
}
function jf(t) {
  return tc(Ju(t));
}
function Qu(t) {
  return new Uint8Array(Zu().toByteArray(nc(t)));
}
function ec(t) {
  return Zu().fromByteArray(new Uint8Array(t));
}
function tc(t) {
  return rc(ec(t));
}
function rc(t) {
  return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function nc(t) {
  t = t.replace(/\-/g, "+").replace(/\_/g, "/");
  let e;
  return t.length % 4 == 0 ? e = 0 : e = 4 - t.length % 4, t.concat("=".repeat(e));
}
const ln = {
  b64UrlToString: Uf,
  bufferToString: Ff,
  stringToBuffer: Ju,
  stringToB64Url: jf,
  b64UrlToBuffer: Qu,
  bufferTob64: ec,
  bufferTob64Url: tc,
  b64UrlEncode: rc,
  b64UrlDecode: nc
};
class $f {
  get(e, r) {
    if (!Object.getOwnPropertyNames(this).includes(e))
      throw new Error(`Field "${e}" is not a property of the Arweave Transaction class.`);
    return this[e] instanceof Uint8Array ? r && r.decode && r.string ? ln.bufferToString(this[e]) : r && r.decode && !r.string ? this[e] : ln.bufferTob64Url(this[e]) : r && r.decode == !0 ? r && r.string ? ln.b64UrlToString(this[e]) : ln.b64UrlToBuffer(this[e]) : this[e];
  }
}
class Vf extends $f {
  constructor(e, r, n = !1) {
    super(), this.name = e, this.value = r;
  }
}
var Qs = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, ea = {};
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var ta;
function ic() {
  if (ta)
    return ea;
  ta = 1;
  var t;
  return function(e) {
    (function(r) {
      var n = typeof Qs == "object" ? Qs : typeof self == "object" ? self : typeof this == "object" ? this : Function("return this;")(), i = o(e);
      typeof n.Reflect > "u" ? n.Reflect = e : i = o(n.Reflect, i), r(i);
      function o(s, a) {
        return function(f, p) {
          typeof s[f] != "function" && Object.defineProperty(s, f, { configurable: !0, writable: !0, value: p }), a && a(f, p);
        };
      }
    })(function(r) {
      var n = Object.prototype.hasOwnProperty, i = typeof Symbol == "function", o = i && typeof Symbol.toPrimitive < "u" ? Symbol.toPrimitive : "@@toPrimitive", s = i && typeof Symbol.iterator < "u" ? Symbol.iterator : "@@iterator", a = typeof Object.create == "function", f = { __proto__: [] } instanceof Array, p = !a && !f, d = {
        // create an object in dictionary mode (a.k.a. "slow" mode in v8)
        create: a ? function() {
          return Ae(/* @__PURE__ */ Object.create(null));
        } : f ? function() {
          return Ae({ __proto__: null });
        } : function() {
          return Ae({});
        },
        has: p ? function(U, te) {
          return n.call(U, te);
        } : function(U, te) {
          return te in U;
        },
        get: p ? function(U, te) {
          return n.call(U, te) ? U[te] : void 0;
        } : function(U, te) {
          return U[te];
        }
      }, y = Object.getPrototypeOf(Function), v = typeof process == "object" && process.env && process.env.REFLECT_METADATA_USE_MAP_POLYFILL === "true", w = !v && typeof Map == "function" && typeof Map.prototype.entries == "function" ? Map : oe(), I = !v && typeof Set == "function" && typeof Set.prototype.entries == "function" ? Set : de(), N = !v && typeof WeakMap == "function" ? WeakMap : Ee(), k = new N();
      function M(U, te, g, u) {
        if (re(g)) {
          if (!R(U))
            throw new TypeError();
          if (!V(te))
            throw new TypeError();
          return O(U, te);
        } else {
          if (!R(U))
            throw new TypeError();
          if (!ce(te))
            throw new TypeError();
          if (!ce(u) && !re(u) && !ae(u))
            throw new TypeError();
          return ae(u) && (u = void 0), g = b(g), c(U, te, g, u);
        }
      }
      r("decorate", M);
      function S(U, te) {
        function g(u, h) {
          if (!ce(u))
            throw new TypeError();
          if (!re(h) && !K(h))
            throw new TypeError();
          H(U, te, u, h);
        }
        return g;
      }
      r("metadata", S);
      function Y(U, te, g, u) {
        if (!ce(g))
          throw new TypeError();
        return re(u) || (u = b(u)), H(U, te, g, u);
      }
      r("defineMetadata", Y);
      function W(U, te, g) {
        if (!ce(te))
          throw new TypeError();
        return re(g) || (g = b(g)), _(U, te, g);
      }
      r("hasMetadata", W);
      function Q(U, te, g) {
        if (!ce(te))
          throw new TypeError();
        return re(g) || (g = b(g)), T(U, te, g);
      }
      r("hasOwnMetadata", Q);
      function X(U, te, g) {
        if (!ce(te))
          throw new TypeError();
        return re(g) || (g = b(g)), C(U, te, g);
      }
      r("getMetadata", X);
      function ne(U, te, g) {
        if (!ce(te))
          throw new TypeError();
        return re(g) || (g = b(g)), L(U, te, g);
      }
      r("getOwnMetadata", ne);
      function ue(U, te) {
        if (!ce(U))
          throw new TypeError();
        return re(te) || (te = b(te)), P(U, te);
      }
      r("getMetadataKeys", ue);
      function se(U, te) {
        if (!ce(U))
          throw new TypeError();
        return re(te) || (te = b(te)), l(U, te);
      }
      r("getOwnMetadataKeys", se);
      function ie(U, te, g) {
        if (!ce(te))
          throw new TypeError();
        re(g) || (g = b(g));
        var u = m(
          te,
          g,
          /*Create*/
          !1
        );
        if (re(u) || !u.delete(U))
          return !1;
        if (u.size > 0)
          return !0;
        var h = k.get(te);
        return h.delete(g), h.size > 0 || k.delete(te), !0;
      }
      r("deleteMetadata", ie);
      function O(U, te) {
        for (var g = U.length - 1; g >= 0; --g) {
          var u = U[g], h = u(te);
          if (!re(h) && !ae(h)) {
            if (!V(h))
              throw new TypeError();
            te = h;
          }
        }
        return te;
      }
      function c(U, te, g, u) {
        for (var h = U.length - 1; h >= 0; --h) {
          var A = U[h], B = A(te, g, u);
          if (!re(B) && !ae(B)) {
            if (!ce(B))
              throw new TypeError();
            u = B;
          }
        }
        return u;
      }
      function m(U, te, g) {
        var u = k.get(U);
        if (re(u)) {
          if (!g)
            return;
          u = new w(), k.set(U, u);
        }
        var h = u.get(te);
        if (re(h)) {
          if (!g)
            return;
          h = new w(), u.set(te, h);
        }
        return h;
      }
      function _(U, te, g) {
        var u = T(U, te, g);
        if (u)
          return !0;
        var h = ee(te);
        return ae(h) ? !1 : _(U, h, g);
      }
      function T(U, te, g) {
        var u = m(
          te,
          g,
          /*Create*/
          !1
        );
        return re(u) ? !1 : xe(u.has(U));
      }
      function C(U, te, g) {
        var u = T(U, te, g);
        if (u)
          return L(U, te, g);
        var h = ee(te);
        if (!ae(h))
          return C(U, h, g);
      }
      function L(U, te, g) {
        var u = m(
          te,
          g,
          /*Create*/
          !1
        );
        if (!re(u))
          return u.get(U);
      }
      function H(U, te, g, u) {
        var h = m(
          g,
          u,
          /*Create*/
          !0
        );
        h.set(U, te);
      }
      function P(U, te) {
        var g = l(U, te), u = ee(U);
        if (u === null)
          return g;
        var h = P(u, te);
        if (h.length <= 0)
          return g;
        if (g.length <= 0)
          return h;
        for (var A = new I(), B = [], z = 0, F = g; z < F.length; z++) {
          var fe = F[z], we = A.has(fe);
          we || (A.add(fe), B.push(fe));
        }
        for (var _e = 0, be = h; _e < be.length; _e++) {
          var fe = be[_e], we = A.has(fe);
          we || (A.add(fe), B.push(fe));
        }
        return B;
      }
      function l(U, te) {
        var g = [], u = m(
          U,
          te,
          /*Create*/
          !1
        );
        if (re(u))
          return g;
        for (var h = u.keys(), A = J(h), B = 0; ; ) {
          var z = q(A);
          if (!z)
            return g.length = B, g;
          var F = j(z);
          try {
            g[B] = F;
          } catch (fe) {
            try {
              Z(A);
            } finally {
              throw fe;
            }
          }
          B++;
        }
      }
      function x(U) {
        if (U === null)
          return 1;
        switch (typeof U) {
          case "undefined":
            return 0;
          case "boolean":
            return 2;
          case "string":
            return 3;
          case "symbol":
            return 4;
          case "number":
            return 5;
          case "object":
            return U === null ? 1 : 6;
          default:
            return 6;
        }
      }
      function re(U) {
        return U === void 0;
      }
      function ae(U) {
        return U === null;
      }
      function G(U) {
        return typeof U == "symbol";
      }
      function ce(U) {
        return typeof U == "object" ? U !== null : typeof U == "function";
      }
      function me(U, te) {
        switch (x(U)) {
          case 0:
            return U;
          case 1:
            return U;
          case 2:
            return U;
          case 3:
            return U;
          case 4:
            return U;
          case 5:
            return U;
        }
        var g = te === 3 ? "string" : te === 5 ? "number" : "default", u = $(U, o);
        if (u !== void 0) {
          var h = u.call(U, g);
          if (ce(h))
            throw new TypeError();
          return h;
        }
        return ye(U, g === "default" ? "number" : g);
      }
      function ye(U, te) {
        if (te === "string") {
          var g = U.toString;
          if (E(g)) {
            var u = g.call(U);
            if (!ce(u))
              return u;
          }
          var h = U.valueOf;
          if (E(h)) {
            var u = h.call(U);
            if (!ce(u))
              return u;
          }
        } else {
          var h = U.valueOf;
          if (E(h)) {
            var u = h.call(U);
            if (!ce(u))
              return u;
          }
          var A = U.toString;
          if (E(A)) {
            var u = A.call(U);
            if (!ce(u))
              return u;
          }
        }
        throw new TypeError();
      }
      function xe(U) {
        return !!U;
      }
      function ve(U) {
        return "" + U;
      }
      function b(U) {
        var te = me(
          U,
          3
          /* String */
        );
        return G(te) ? te : ve(te);
      }
      function R(U) {
        return Array.isArray ? Array.isArray(U) : U instanceof Object ? U instanceof Array : Object.prototype.toString.call(U) === "[object Array]";
      }
      function E(U) {
        return typeof U == "function";
      }
      function V(U) {
        return typeof U == "function";
      }
      function K(U) {
        switch (x(U)) {
          case 3:
            return !0;
          case 4:
            return !0;
          default:
            return !1;
        }
      }
      function $(U, te) {
        var g = U[te];
        if (g != null) {
          if (!E(g))
            throw new TypeError();
          return g;
        }
      }
      function J(U) {
        var te = $(U, s);
        if (!E(te))
          throw new TypeError();
        var g = te.call(U);
        if (!ce(g))
          throw new TypeError();
        return g;
      }
      function j(U) {
        return U.value;
      }
      function q(U) {
        var te = U.next();
        return te.done ? !1 : te;
      }
      function Z(U) {
        var te = U.return;
        te && te.call(U);
      }
      function ee(U) {
        var te = Object.getPrototypeOf(U);
        if (typeof U != "function" || U === y || te !== y)
          return te;
        var g = U.prototype, u = g && Object.getPrototypeOf(g);
        if (u == null || u === Object.prototype)
          return te;
        var h = u.constructor;
        return typeof h != "function" || h === U ? te : h;
      }
      function oe() {
        var U = {}, te = [], g = (
          /** @class */
          function() {
            function B(z, F, fe) {
              this._index = 0, this._keys = z, this._values = F, this._selector = fe;
            }
            return B.prototype["@@iterator"] = function() {
              return this;
            }, B.prototype[s] = function() {
              return this;
            }, B.prototype.next = function() {
              var z = this._index;
              if (z >= 0 && z < this._keys.length) {
                var F = this._selector(this._keys[z], this._values[z]);
                return z + 1 >= this._keys.length ? (this._index = -1, this._keys = te, this._values = te) : this._index++, { value: F, done: !1 };
              }
              return { value: void 0, done: !0 };
            }, B.prototype.throw = function(z) {
              throw this._index >= 0 && (this._index = -1, this._keys = te, this._values = te), z;
            }, B.prototype.return = function(z) {
              return this._index >= 0 && (this._index = -1, this._keys = te, this._values = te), { value: z, done: !0 };
            }, B;
          }()
        );
        return (
          /** @class */
          function() {
            function B() {
              this._keys = [], this._values = [], this._cacheKey = U, this._cacheIndex = -2;
            }
            return Object.defineProperty(B.prototype, "size", {
              get: function() {
                return this._keys.length;
              },
              enumerable: !0,
              configurable: !0
            }), B.prototype.has = function(z) {
              return this._find(
                z,
                /*insert*/
                !1
              ) >= 0;
            }, B.prototype.get = function(z) {
              var F = this._find(
                z,
                /*insert*/
                !1
              );
              return F >= 0 ? this._values[F] : void 0;
            }, B.prototype.set = function(z, F) {
              var fe = this._find(
                z,
                /*insert*/
                !0
              );
              return this._values[fe] = F, this;
            }, B.prototype.delete = function(z) {
              var F = this._find(
                z,
                /*insert*/
                !1
              );
              if (F >= 0) {
                for (var fe = this._keys.length, we = F + 1; we < fe; we++)
                  this._keys[we - 1] = this._keys[we], this._values[we - 1] = this._values[we];
                return this._keys.length--, this._values.length--, z === this._cacheKey && (this._cacheKey = U, this._cacheIndex = -2), !0;
              }
              return !1;
            }, B.prototype.clear = function() {
              this._keys.length = 0, this._values.length = 0, this._cacheKey = U, this._cacheIndex = -2;
            }, B.prototype.keys = function() {
              return new g(this._keys, this._values, u);
            }, B.prototype.values = function() {
              return new g(this._keys, this._values, h);
            }, B.prototype.entries = function() {
              return new g(this._keys, this._values, A);
            }, B.prototype["@@iterator"] = function() {
              return this.entries();
            }, B.prototype[s] = function() {
              return this.entries();
            }, B.prototype._find = function(z, F) {
              return this._cacheKey !== z && (this._cacheIndex = this._keys.indexOf(this._cacheKey = z)), this._cacheIndex < 0 && F && (this._cacheIndex = this._keys.length, this._keys.push(z), this._values.push(void 0)), this._cacheIndex;
            }, B;
          }()
        );
        function u(B, z) {
          return B;
        }
        function h(B, z) {
          return z;
        }
        function A(B, z) {
          return [B, z];
        }
      }
      function de() {
        return (
          /** @class */
          function() {
            function U() {
              this._map = new w();
            }
            return Object.defineProperty(U.prototype, "size", {
              get: function() {
                return this._map.size;
              },
              enumerable: !0,
              configurable: !0
            }), U.prototype.has = function(te) {
              return this._map.has(te);
            }, U.prototype.add = function(te) {
              return this._map.set(te, te), this;
            }, U.prototype.delete = function(te) {
              return this._map.delete(te);
            }, U.prototype.clear = function() {
              this._map.clear();
            }, U.prototype.keys = function() {
              return this._map.keys();
            }, U.prototype.values = function() {
              return this._map.values();
            }, U.prototype.entries = function() {
              return this._map.entries();
            }, U.prototype["@@iterator"] = function() {
              return this.keys();
            }, U.prototype[s] = function() {
              return this.keys();
            }, U;
          }()
        );
      }
      function Ee() {
        var U = 16, te = d.create(), g = u();
        return (
          /** @class */
          function() {
            function F() {
              this._key = u();
            }
            return F.prototype.has = function(fe) {
              var we = h(
                fe,
                /*create*/
                !1
              );
              return we !== void 0 ? d.has(we, this._key) : !1;
            }, F.prototype.get = function(fe) {
              var we = h(
                fe,
                /*create*/
                !1
              );
              return we !== void 0 ? d.get(we, this._key) : void 0;
            }, F.prototype.set = function(fe, we) {
              var _e = h(
                fe,
                /*create*/
                !0
              );
              return _e[this._key] = we, this;
            }, F.prototype.delete = function(fe) {
              var we = h(
                fe,
                /*create*/
                !1
              );
              return we !== void 0 ? delete we[this._key] : !1;
            }, F.prototype.clear = function() {
              this._key = u();
            }, F;
          }()
        );
        function u() {
          var F;
          do
            F = "@@WeakMap@@" + z();
          while (d.has(te, F));
          return te[F] = !0, F;
        }
        function h(F, fe) {
          if (!n.call(F, g)) {
            if (!fe)
              return;
            Object.defineProperty(F, g, { value: d.create() });
          }
          return F[g];
        }
        function A(F, fe) {
          for (var we = 0; we < fe; ++we)
            F[we] = Math.random() * 255 | 0;
          return F;
        }
        function B(F) {
          return typeof Uint8Array == "function" ? typeof crypto < "u" ? crypto.getRandomValues(new Uint8Array(F)) : typeof msCrypto < "u" ? msCrypto.getRandomValues(new Uint8Array(F)) : A(new Uint8Array(F), F) : A(new Array(F), F);
        }
        function z() {
          var F = B(U);
          F[6] = F[6] & 79 | 64, F[8] = F[8] & 191 | 128;
          for (var fe = "", we = 0; we < U; ++we) {
            var _e = F[we];
            (we === 4 || we === 6 || we === 8) && (fe += "-"), _e < 16 && (fe += "0"), fe += _e.toString(16).toLowerCase();
          }
          return fe;
        }
      }
      function Ae(U) {
        return U.__ = void 0, delete U.__, U;
      }
    });
  }(t || (t = {})), ea;
}
let Mn;
function hi(t) {
  if (typeof t != "function")
    throw new Error("This module should not be used in runtime. Instead, use a transformer during compilation.");
}
const ao = Symbol("assertions");
function qf(t, e) {
  let r = e;
  for (const n of t.slice(1))
    r = r[n.startsWith("[") ? parseInt(n.replace("[", "").replace("]", "")) : n];
  return r;
}
function Wf(t, e, r) {
  if (t === void 0)
    return "validation error";
  const n = qf(e, r);
  try {
    return t + ", found: " + require("util").inspect(n);
  } catch {
  }
  try {
    return t + ", found: " + JSON.stringify(n);
  } catch {
  }
  return t;
}
class $o extends Error {
  constructor(e, r) {
    super(Wf(e.message, e.path, r)), this.name = "TypeGuardError", this.path = e.path, this.reason = e.reason, this.input = r;
  }
}
function Hf(t, e = {}) {
  return ic(), function(r, n, i) {
    const o = Reflect.getOwnMetadata(ao, r, n) || [];
    Reflect.getOwnMetadata("design:returntype", r, n) === Promise ? o[i] = { assertion: t, options: Object.assign({ async: !0 }, e) } : o[i] = { assertion: t, options: e }, Reflect.defineMetadata(ao, o, r, n);
  };
}
function Kf(t = $o) {
  return ic(), function(e) {
    for (const r of Object.getOwnPropertyNames(e.prototype)) {
      const n = Reflect.getOwnMetadata(ao, e.prototype, r);
      if (n) {
        const i = e.prototype[r];
        e.prototype[r] = function(...o) {
          for (let s = 0; s < n.length; s++) {
            if (!n[s])
              continue;
            const a = n[s].assertion(o[s]);
            if (a !== null) {
              const f = new t(a, o[s]);
              if (n[s].options.async)
                return Promise.reject(f);
              throw f;
            }
          }
          return i.apply(this, o);
        };
      }
    }
  };
}
function uo(t, e = Mn) {
  return hi(e), e(t) === null;
}
function co(t, e = Mn) {
  hi(e);
  const r = e(t);
  if (r === null)
    return t;
  throw new $o(r, t);
}
function ra(t = Mn) {
  return hi(t), (e) => uo(e, t);
}
function na(t = Mn) {
  return hi(t), (e) => co(e, t);
}
function zf(t) {
  Mn = t;
}
var mr = {
  is: uo,
  assertType: co,
  createIs: ra,
  createAssertType: na,
  equals: uo,
  createEquals: ra,
  assertEquals: co,
  createAssertEquals: na,
  AssertType: Hf,
  ValidateClass: Kf,
  TypeGuardError: $o,
  setDefaultGetErrorObject: zf
};
function Gf(t) {
  return class extends t {
    constructor(...r) {
      super(...r), this.namespaces = {
        arweaveWallet: {
          walletName: "ArConnect",
          connect: () => this.address || this.connect(),
          disconnect: () => this.disconnect(),
          getActiveAddress: () => this.address,
          getActivePublicKey: () => this.getPublicKey(),
          getAllAddresses: () => {
            throw "not implemented";
          },
          getWalletNames: () => {
            throw "not implemented";
          },
          signature: () => {
            throw "deprecated, do not use";
          },
          sign: (n, i) => this.signTransaction(n, i),
          dispatch: (n, i) => this.dispatch(n, i),
          encrypt: (n, i) => Mt(this, void 0, void 0, function* () {
            const o = yield this.getPublicKey();
            return this.encrypt(n, o, i);
          }),
          decrypt: (n, i) => this.decrypt(n, i),
          getPermissions: () => ["ACCESS_ADDRESS", "ACCESS_PUBLIC_KEY", "ACCESS_ALL_ADDRESSES", "SIGN_TRANSACTION", "ENCRYPT", "DECRYPT", "SIGNATURE", "ACCESS_ARWEAVE_CONFIG", "DISPATCH"],
          getArweaveConfig: () => this.getArweaveConfig()
        }
      };
    }
    postMessage(r, n, i) {
      return super.postMessage(r, n, Object.assign(Object.assign({}, i), { protocol: "arweave", version: "1.0.0" }));
    }
    getPublicKey() {
      return Mt(this, void 0, void 0, function* () {
        const r = yield this.postMessage("getPublicKey");
        if (!mr.is(r, (n) => {
          function i(o) {
            return typeof o != "string" ? {} : null;
          }
          return i(n);
        }))
          throw "TypeError";
        return r;
      });
    }
    getArweaveConfig() {
      return Mt(this, void 0, void 0, function* () {
        const r = yield this.postMessage("getArweaveConfig");
        if (!mr.is(r, (n) => {
          function i(M) {
            return M !== void 0 ? {} : null;
          }
          function o(M) {
            return typeof M != "string" ? {} : null;
          }
          function s(M) {
            var S = [i, o];
            for (const W of S) {
              var Y = W(M);
              if (!Y)
                return null;
            }
            return {};
          }
          function a(M) {
            return typeof M != "number" ? {} : null;
          }
          function f(M) {
            var S = [i, o, a];
            for (const W of S) {
              var Y = W(M);
              if (!Y)
                return null;
            }
            return {};
          }
          function p(M) {
            var S = [i, a];
            for (const W of S) {
              var Y = W(M);
              if (!Y)
                return null;
            }
            return {};
          }
          function d(M) {
            return M !== !1 ? {} : null;
          }
          function y(M) {
            return M !== !0 ? {} : null;
          }
          function v(M) {
            var S = [i, d, y];
            for (const W of S) {
              var Y = W(M);
              if (!Y)
                return null;
            }
            return {};
          }
          function w(M) {
            if (typeof M != "object" || M === null || Array.isArray(M))
              return {};
            if ("host" in M) {
              var S = s(M.host);
              if (S)
                return S;
            }
            if ("protocol" in M) {
              var S = s(M.protocol);
              if (S)
                return S;
            }
            if ("port" in M) {
              var S = f(M.port);
              if (S)
                return S;
            }
            if ("timeout" in M) {
              var S = p(M.timeout);
              if (S)
                return S;
            }
            if ("logging" in M) {
              var S = v(M.logging);
              if (S)
                return S;
            }
            if ("network" in M) {
              var S = s(M.network);
              if (S)
                return S;
            }
            return null;
          }
          function I() {
            return null;
          }
          function N(M) {
            if (typeof M != "object" || M === null || Array.isArray(M))
              return {};
            if ("logger" in M) {
              var S = I(M.logger);
              if (S)
                return S;
            }
            return null;
          }
          function k(M) {
            var S = [w, N];
            for (const W of S) {
              var Y = W(M);
              if (Y)
                return Y;
            }
            return null;
          }
          return k(n);
        }))
          throw "TypeError";
        return delete r.logger, r;
      });
    }
    signTransaction(r, n) {
      var i;
      return Mt(this, void 0, void 0, function* () {
        const o = Nf(r, ["data", "chunks"]), s = yield this.postMessage("signTransaction", [o, n]);
        if (!mr.is(s, (a) => {
          function f(k) {
            return typeof k != "string" ? {} : null;
          }
          function p(k) {
            return k !== void 0 ? {} : null;
          }
          function d(k) {
            return k !== null ? {} : null;
          }
          function y(k) {
            var M = [p, d, f];
            for (const Y of M) {
              var S = Y(k);
              if (!S)
                return null;
            }
            return {};
          }
          function v(k) {
            if (typeof k != "object" || k === null || Array.isArray(k))
              return {};
            if ("name" in k) {
              var M = f(k.name);
              if (M)
                return M;
            } else
              return {};
            if ("value" in k) {
              var M = f(k.value);
              if (M)
                return M;
            } else
              return {};
            return null;
          }
          function w(k) {
            if (!Array.isArray(k))
              return {};
            for (let S = 0; S < k.length; S++) {
              var M = v(k[S]);
              if (M)
                return M;
            }
            return null;
          }
          function I(k) {
            var M = [p, d, w];
            for (const Y of M) {
              var S = Y(k);
              if (!S)
                return null;
            }
            return {};
          }
          function N(k) {
            if (typeof k != "object" || k === null || Array.isArray(k))
              return {};
            if ("id" in k) {
              var M = f(k.id);
              if (M)
                return M;
            } else
              return {};
            if ("owner" in k) {
              var M = y(k.owner);
              if (M)
                return M;
            }
            if ("tags" in k) {
              var M = I(k.tags);
              if (M)
                return M;
            }
            if ("signature" in k) {
              var M = f(k.signature);
              if (M)
                return M;
            } else
              return {};
            if ("reward" in k) {
              var M = y(k.reward);
              if (M)
                return M;
            }
            return null;
          }
          return N(a);
        }))
          throw "TypeError";
        return r.setSignature({
          id: s.id,
          owner: s.owner || r.owner,
          tags: (i = s.tags) === null || i === void 0 ? void 0 : i.map((a) => new Vf(a.name, a.value, !0)),
          signature: s.signature,
          reward: s.reward || void 0
        }), r;
      });
    }
    signDataItem(r) {
      return Mt(this, void 0, void 0, function* () {
        const n = yield this.postMessage("signDataItem", [r]);
        if (!ArrayBuffer.isView(n))
          throw "TypeError";
        return n.buffer;
      });
    }
    dispatch(r, n) {
      return Mt(this, void 0, void 0, function* () {
        const i = yield this.postMessage("dispatch", [r, n], { transfer: !0 });
        if (!mr.is(i, (o) => {
          function s(y) {
            return typeof y != "string" ? {} : null;
          }
          function a(y) {
            return y !== "BASE" ? {} : null;
          }
          function f(y) {
            return y !== "BUNDLED" ? {} : null;
          }
          function p(y) {
            var v = [a, f];
            for (const I of v) {
              var w = I(y);
              if (!w)
                return null;
            }
            return {};
          }
          function d(y) {
            if (typeof y != "object" || y === null || Array.isArray(y))
              return {};
            if ("id" in y) {
              var v = s(y.id);
              if (v)
                return v;
            }
            if ("type" in y) {
              var v = p(y.type);
              if (v)
                return v;
            }
            return null;
          }
          return d(o);
        }))
          throw "TypeError";
        return i;
      });
    }
    signMessage(r, n) {
      return Mt(this, void 0, void 0, function* () {
        const i = yield this.postMessage("signMessage", [r, n]);
        if (!ArrayBuffer.isView(i))
          throw "TypeError";
        const o = r.constructor;
        return new o(i.buffer);
      });
    }
    verifyMessage(r, n, i, o) {
      return Mt(this, void 0, void 0, function* () {
        n = typeof n == "string" ? ln.b64UrlToBuffer(n) : n;
        const s = yield this.postMessage("verifyMessage", [r, n, i, o]);
        if (!mr.is(s, (a) => {
          function f(p) {
            return typeof p != "boolean" ? {} : null;
          }
          return f(a);
        }))
          throw "TypeError";
        return s;
      });
    }
    encrypt(r, n, i) {
      return Mt(this, void 0, void 0, function* () {
        const o = yield this.postMessage("encrypt", [r, n, i]);
        if (!ArrayBuffer.isView(o))
          throw "TypeError";
        const s = r.constructor;
        return new s(o.buffer);
      });
    }
    decrypt(r, n) {
      return Mt(this, void 0, void 0, function* () {
        const i = yield this.postMessage("decrypt", [r, n]);
        if (!ArrayBuffer.isView(i))
          throw "TypeError";
        const o = r.constructor;
        return new o(i.buffer);
      });
    }
    privateHash(r, n) {
      return Mt(this, void 0, void 0, function* () {
        const i = yield this.postMessage("privateHash", [r, n]);
        if (!ArrayBuffer.isView(i))
          throw "TypeError";
        const o = r.constructor;
        return new o(i.buffer);
      });
    }
  };
}
function Yf(t) {
  return { all: t = t || /* @__PURE__ */ new Map(), on: function(e, r) {
    var n = t.get(e);
    n ? n.push(r) : t.set(e, [r]);
  }, off: function(e, r) {
    var n = t.get(e);
    n && (r ? n.splice(n.indexOf(r) >>> 0, 1) : t.set(e, []));
  }, emit: function(e, r) {
    var n = t.get(e);
    n && n.slice().map(function(i) {
      i(r);
    }), (n = t.get("*")) && n.slice().map(function(i) {
      i(e, r);
    });
  } };
}
class oc {
  constructor() {
    this.mittInstance = Yf();
  }
  emit(e, r) {
    this.mittInstance.emit(e, r);
  }
  on(e, r) {
    this.mittInstance.on(e, r);
  }
  off(e, r) {
    this.mittInstance.off(e, r);
  }
  once(e, r) {
    return new Promise((n) => {
      const i = (o) => {
        this.off(e, i), n(o), r && r(o);
      };
      this.on(e, i);
    });
  }
}
class Xf {
  constructor() {
    this._promiseController = [];
  }
  newMessagePromise(e, r) {
    e.id = this._promiseController.length;
    const n = new Promise((i, o) => this._promiseController.push({ resolve: i, reject: o }));
    return r != null && r.timeout && setTimeout(() => this._promiseController[e.id].reject("timeout"), r.timeout), n;
  }
  processResponse(e) {
    const { id: r, result: n, error: i } = e;
    if (r != null) {
      if (typeof r != "number" && typeof r != "string" || typeof r == "string" && isNaN(parseInt(r)))
        throw "error";
      if (!this._promiseController[+r])
        throw "received result to nonexistent request";
      return i != null ? this._promiseController[+r].reject(i) : this._promiseController[+r].resolve(n), !0;
    }
  }
}
const ia = "400", oa = "600";
class Zf extends oc {
  constructor(e, r, n) {
    if (super(), this._iframe = {}, this._showIframe = !1, this._popup = {}, this._usePopup = !0, this._requirePopup = !1, this._keepPopup = !1, this._promiseController = new Xf(), this._pending = [], this.listener = (i) => {
      var o, s, a, f, p, d;
      if (i.source !== this._popup.window && i.source !== ((o = this._iframe) === null || o === void 0 ? void 0 : o.window) || i.origin !== ((s = this._url) === null || s === void 0 ? void 0 : s.origin) || typeof i.data != "object")
        return;
      const { method: y, params: v, id: w, result: I, error: N, session: k } = i.data;
      if (console.info(`WalletConnector:${i.source === this._popup.window ? "popup" : "iframe"}`, i.data), w != null && (this._pending = this._pending.filter((S) => S != w)), this._promiseController.processResponse(i.data) || typeof y != "string")
        return;
      if (y === "ready") {
        i.source === this._popup.window && ((f = (a = this._popup).resolve) === null || f === void 0 || f.call(a)), i.source === this._iframe.window && ((d = (p = this._iframe).resolve) === null || d === void 0 || d.call(p));
        return;
      }
      if (y === "change")
        return;
      if (y === "showIframe") {
        if (typeof v != "boolean")
          return;
        this.showIframe = v;
      }
      if (y === "usePopup") {
        if (typeof v != "boolean")
          return;
        this.setUsePopup(v);
      }
      if (y === "keepPopup") {
        if (typeof v != "boolean")
          return;
        this.setRequirePopup(v);
      }
      const M = { method: y, params: v, session: k };
      if (!mr.is(M, (S) => {
        function Y(se) {
          return typeof se != "string" ? {} : null;
        }
        function W() {
          return null;
        }
        function Q(se) {
          return se !== void 0 ? {} : null;
        }
        function X(se) {
          return typeof se != "number" ? {} : null;
        }
        function ne(se) {
          var ie = [Q, Y, X];
          for (const c of ie) {
            var O = c(se);
            if (!O)
              return null;
          }
          return {};
        }
        function ue(se) {
          if (typeof se != "object" || se === null || Array.isArray(se))
            return {};
          if ("method" in se) {
            var ie = Y(se.method);
            if (ie)
              return ie;
          } else
            return {};
          if ("params" in se) {
            var ie = W(se.params);
            if (ie)
              return ie;
          } else
            return {};
          if ("session" in se) {
            var ie = ne(se.session);
            if (ie)
              return ie;
          }
          return null;
        }
        return ue(S);
      }))
        return console.warn("dropped");
      this.emit("message", M);
    }, this._iframeParentNode = r == null ? void 0 : r.iframeParentNode, this._url = e, typeof window < "u") {
      const i = {
        origin: window.location.origin,
        session: Math.random().toString().slice(2)
      };
      r != null && r.name && (i.name = r.name), r != null && r.logo && (i.logo = r.logo), this._url.hash = new URLSearchParams(i).toString(), window.addEventListener("message", this.listener), n && this.openIframe();
    }
  }
  get url() {
    var e;
    return (e = this._url) === null || e === void 0 ? void 0 : e.origin;
  }
  get showIframe() {
    return this._showIframe;
  }
  set showIframe(e) {
    e !== this._showIframe && (this._showIframe = e, this.deliverMessage({ method: "showIframe", params: e }), this.emit("builtin", { showIframe: e }), this._iframeNode && (this._iframeParentNode || (this._iframeNode.style.opacity = e ? "1" : "0", this._iframeNode.style.pointerEvents = e ? "" : "none", this._iframeNode.style.touchAction = e ? "" : "none", this._iframeNode.style.zIndex = e ? "1000000" : "-1000000", this._iframeNode.style.transform = e ? "" : "translate(0, 24px)", this._iframeNode.style.transition = e ? "opacity 0.36s cubic-bezier(0.22, 1, 0.36, 1), transform 0.36s cubic-bezier(0.22, 1, 0.36, 1)" : "opacity 0.1s ease, transform 0.1s ease, z-index 0s linear 0.1s")));
  }
  get usePopup() {
    return this._usePopup;
  }
  setUsePopup(e) {
    e !== this._usePopup && (this._usePopup = e, this.emit("builtin", { usePopup: e }));
  }
  get requirePopup() {
    return this._requirePopup;
  }
  setRequirePopup(e) {
    e !== this._requirePopup && (this._requirePopup = e, this.emit("builtin", { requirePopup: e }));
  }
  get keepPopup() {
    return this._keepPopup;
  }
  set keepPopup(e) {
    this._keepPopup = e, this.emit("builtin", { keepPopup: e }), e || this.closePopup(), e && this.openPopup(!0);
  }
  destructor(e) {
    this.closeIframe(), this.closePopup(!0), window.removeEventListener("message", this.listener);
  }
  postMessage(e, r) {
    const n = this._promiseController.newMessagePromise(e, r).finally(() => this.completeRequest());
    return this.deliverMessage(e), n;
  }
  openIframe() {
    var e;
    if (this._iframeEl)
      return;
    const r = new Promise((i, o) => this._iframe = { resolve: i, reject: o });
    this._iframe.promise = r;
    const n = Array.from(document.querySelectorAll("iframe")).find((i) => {
      try {
        return new URL(i.src).origin === this.url;
      } catch {
      }
    });
    if (n)
      this._iframeEl = n, this._iframe.window = this._iframeEl.contentWindow, this.postMessage({ method: "ready" });
    else {
      this._iframeNode = (e = this._iframeParentNode) !== null && e !== void 0 ? e : document.createElement("div"), this._iframeEl = document.createElement("iframe"), this._iframeEl.src = this._url.toString(), this._iframeEl.allow = "usb; hid; bluetooth; serial; camera; payment; web-share", this._iframeEl.setAttribute("allowTransparency", "true"), this._iframeEl.style.border = "none", this._iframeParentNode ? (this._iframeEl.style.backgroundColor = "transparent", this._iframeEl.style.width = "100%", this._iframeEl.style.height = "100%") : (this._iframeEl.width = ia, this._iframeEl.height = oa, this._iframeEl.style.borderRadius = "8px", this._iframeEl.style.maxWidth = "100%", this._iframeEl.style.maxHeight = "100%", this._iframeNode.style.position = "fixed", this._iframeNode.style.inset = "0", this._iframeNode.style.display = "flex", this._iframeNode.style.alignItems = "center", this._iframeNode.style.justifyContent = "center", this._iframeNode.style.background = "#00000088", this._iframeNode.style.opacity = "0", this._iframeNode.style.pointerEvents = "none", this._iframeNode.style.touchAction = "none", this._iframeNode.style.zIndex = "-1000000", this._iframeNode.style.transform = "translate(0, 24px)", this._iframeNode.style.transition = "opacity 0.1s ease, transform 0.1s ease, z-index 0s linear 0.1s"), this._iframeNode.appendChild(this._iframeEl);
      const i = () => {
        var o;
        this._iframeParentNode || document.body.appendChild(this._iframeNode), this._iframe.window = (o = this._iframeEl) === null || o === void 0 ? void 0 : o.contentWindow;
      };
      document.readyState === "complete" || document.readyState === "interactive" ? i() : document.addEventListener("DOMContentLoaded", i);
    }
  }
  closeIframe() {
    var e, r, n, i, o;
    (e = this._iframeEl) === null || e === void 0 || e.setAttribute("src", "about:blank"), (r = this._iframeEl) === null || r === void 0 || r.remove(), (n = this._iframeNode) === null || n === void 0 || n.remove(), this._iframeNode = void 0, this._iframeEl = void 0, (o = (i = this._iframe).reject) === null || o === void 0 || o.call(i), this._iframe = {};
  }
  openPopup(e) {
    if (this._popup.window && !this._popup.window.closed) {
      this._popup.window.focus();
      return;
    }
    if (!this.usePopup && !e)
      return;
    window.name = "parent";
    const r = window.open(this._url.toString(), "_blank", `location,resizable,scrollbars,width=${ia},height=${oa}`), n = new Promise((o, s) => this._popup = { window: r, resolve: o, reject: s });
    this._popup.promise = n;
    const i = setInterval(() => {
      this._popup.window && !this._popup.window.closed || (this.keepPopup && (this.keepPopup = !1), clearInterval(i));
    }, 200);
  }
  closePopup(e) {
    var r, n, i;
    if (!this._popup.window || !((r = this._popup.window) === null || r === void 0) && r.closed || (this.keepPopup || this.requirePopup) && !e)
      return;
    const o = this._popup.window;
    o.close(), o.location.href = "about:blank";
    let s = 0;
    const a = setInterval(() => {
      s > 50 || !o || o.closed ? clearInterval(a) : s++, o.close();
    }, 100);
    (i = (n = this._popup).reject) === null || i === void 0 || i.call(n), this._popup = {};
  }
  completeRequest() {
    setTimeout(() => {
      this._pending.length || (this.closePopup(), this.showIframe = !1);
    }, 100);
  }
  deliverMessage(e, r) {
    var n, i;
    if (!this._url)
      throw "Missing URL";
    console.info("WalletConnector:post", e);
    const o = Object.assign(Object.assign({}, e), { jsonrpc: "2.0" });
    o.id != null && this._pending.push(o.id), this.openIframe(), this._iframe.promise = (n = this._iframe.promise) === null || n === void 0 ? void 0 : n.then(() => {
      var s;
      return (s = this._iframe.window) === null || s === void 0 ? void 0 : s.postMessage(o, this._url.origin, r != null && r.transfer ? [o] : void 0);
    }).catch(() => {
    }), this.openPopup(), this._popup.promise = (i = this._popup.promise) === null || i === void 0 ? void 0 : i.then(() => {
      var s;
      return (s = this._popup.window) === null || s === void 0 ? void 0 : s.postMessage(o, this._url.origin, r != null && r.transfer ? [o] : void 0);
    }).catch(() => {
    });
  }
}
function sa(t) {
  return typeof t == "object" ? t : (t.includes("://") || (t = "https://" + t), new URL(t));
}
let aa;
const _r = [], hn = {}, lo = {};
function Jf(t) {
  t.namespaces && (_r.find((e) => e === t) || _r.push(t), Jn());
}
function Qf(t) {
  if (!_r.find((e) => e === t))
    return Jn();
  _r.splice(_r.indexOf(t), 1);
  for (const e in t.namespaces)
    hn[e] === t && (window[e] = lo[e], delete lo[e], delete hn[e]);
  Jn();
}
function Jn() {
  for (const t of _r)
    for (const e in t.namespaces)
      hn[e] && hn[e] !== t || window[e] !== t.namespaces[e] && (lo[e] = window[e], window[e] = t.namespaces[e], hn[e] = t);
  window.clearInterval(aa), _r.length && (aa = setInterval(() => Jn(), 1e4));
}
const eh = "Window context missing. If you are using a server side rendering framework, make sure that the connector is excluded. If you want to use the connector outside the browser, use the node version of the module instead";
class Ct extends oc {
  constructor(e, r) {
    super(), this._session = 0, this._listener = (n) => {
      const { method: i, params: o, session: s } = n;
      if (!(s != null && this._session != s) && !(!s && this._session)) {
        if (i === "connect") {
          if (!mr.is(o, (a) => {
            function f(p) {
              return typeof p != "string" ? {} : null;
            }
            return f(a);
          }))
            return;
          this.setAddress(o);
        }
        i === "disconnect" && this.disconnectEvent(!1);
      }
    }, this._appInfo = e, this._emitterPassthrough = (n) => {
      const i = Object.entries(n)[0];
      this.emit(i[0], i[1]);
    }, this.on("connect", () => Jf(this)), this.on("disconnect", () => Qf(this)), r && (this._url = sa(r));
  }
  get address() {
    return this._address;
  }
  setAddress(e) {
    e && e === this.address || (this._address = e, e != null ? this.emit("connect", e) : this.emit("disconnect", e), this.emit("change", e));
  }
  get connected() {
    return this._address != null;
  }
  get url() {
    var e;
    return (e = this._bridge) === null || e === void 0 ? void 0 : e.url;
  }
  get showIframe() {
    var e;
    return ((e = this._bridge) === null || e === void 0 ? void 0 : e.showIframe) || !1;
  }
  get usePopup() {
    var e;
    return ((e = this._bridge) === null || e === void 0 ? void 0 : e.usePopup) || !1;
  }
  get requirePopup() {
    var e;
    return ((e = this._bridge) === null || e === void 0 ? void 0 : e.requirePopup) || !1;
  }
  get keepPopup() {
    var e;
    return ((e = this._bridge) === null || e === void 0 ? void 0 : e.keepPopup) || !1;
  }
  set keepPopup(e) {
    this._bridge && (this._bridge.keepPopup = e);
  }
  setUrl(e, r) {
    var n;
    if (typeof window > "u") {
      console.error(eh);
      return;
    }
    const i = this._bridge, o = sa(e);
    if (this._url = o, ((n = this._bridge) === null || n === void 0 ? void 0 : n.url) !== o.origin) {
      if (this.disconnect(), !Ct._bridges[o.origin])
        this._bridge = new Zf(o, this._appInfo, r), Ct._bridges[o.origin] = { bridge: this._bridge, sessions: [] };
      else {
        this._bridge = Ct._bridges[o.origin].bridge;
        const s = Ct._bridges[o.origin].sessions;
        for (let a = 0; a <= s.length; a++)
          if (s.indexOf(a) < 0) {
            this._session = a;
            break;
          }
      }
      Ct._bridges[o.origin].sessions.push(this._session), this._bridge.on("message", this._listener), this._bridge.on("builtin", this._emitterPassthrough), this._bridge.showIframe !== (i == null ? void 0 : i.showIframe) && this.emit("showIframe", this._bridge.showIframe), this._bridge.usePopup !== (i == null ? void 0 : i.usePopup) && this.emit("usePopup", this._bridge.usePopup), this._bridge.requirePopup !== (i == null ? void 0 : i.requirePopup) && this.emit("requirePopup", this._bridge.requirePopup), this._bridge.keepPopup !== (i == null ? void 0 : i.keepPopup) && this.emit("keepPopup", this._bridge.keepPopup);
    }
  }
  connect(e) {
    return Mt(this, void 0, void 0, function* () {
      if (!this._url)
        throw "Connect failed: URL missing";
      this._bridge || this.setUrl(this._url);
      const r = new Promise((n, i) => {
        this.once("change", (o) => o ? n(o) : i());
      }).finally(() => {
        var n;
        return (n = this._bridge) === null || n === void 0 ? void 0 : n.completeRequest();
      });
      return this._bridge.deliverMessage({ method: "connect", params: e }), r;
    });
  }
  disconnect(e) {
    return Mt(this, void 0, void 0, function* () {
      return this.disconnectEvent(!0, e);
    });
  }
  disconnectEvent(e, r) {
    return Mt(this, void 0, void 0, function* () {
      if (!this._bridge)
        return;
      const n = this._bridge, i = this._session, o = n.url;
      if (this.setAddress(void 0), this._bridge = void 0, this._session = 0, e)
        try {
          yield n.postMessage({ method: "disconnect", params: [r], session: i }, { timeout: 5e3 });
        } catch {
          console.warn("disconnect request failed");
        }
      n.off("message", this._listener), n.off("builtin", this._emitterPassthrough), Ct._bridges[o].sessions = Ct._bridges[o].sessions.filter((s) => s != i), setTimeout(() => {
        Ct._bridges[o].sessions.length || (Ct._bridges[o].bridge.destructor(), delete Ct._bridges[o]);
      }, 100);
    });
  }
  postMessage(e, r, n) {
    return new Promise((i, o) => {
      if (!this._url)
        throw "Post message failed: URL missing";
      if (!this._bridge)
        throw "Post message failed: URL not loaded, call setUrl or connect first";
      this.once("disconnect", o), this._bridge.postMessage({ method: e, params: r, session: this._session, protocol: n == null ? void 0 : n.protocol, version: n == null ? void 0 : n.version }, n).then(i).catch(o);
    });
  }
}
Ct._bridges = {};
class gr extends Ct {
  constructor(e, r) {
    var n;
    if (super(e, (n = sc(r == null ? void 0 : r.state)) === null || n === void 0 ? void 0 : n.url), this._subs = [], this._localStorageKey = "arweave-wallet-connector:URL", this.setUrl = (s, a) => {
      super.setUrl(s, a), this.updateState({ url: super.url });
    }, this.subscribe = (s) => (this._subs.push(s), s(this._state.value), () => this._subs.filter((a) => a !== s)), this.setState = (s) => {
      var a;
      const f = (a = gr._instance) !== null && a !== void 0 ? a : this;
      s && Array.isArray(s) && (f._setState = s[1]), s && "set" in s && (f._setState = s.set);
      const p = th(s);
      return f._state = p.state, Object.keys(p.newProps).length && f.updateState(p.newProps), s;
    }, this.updateState = (s) => {
      s && (Object.assign(this._state.value, s), this._setState && this._setState(Object.assign({}, this._state.value)), this._subs.forEach((a) => a(this._state.value)));
    }, this.setState(r == null ? void 0 : r.state), gr._instance)
      return gr._instance;
    gr._instance = new Proxy(this, {
      get: (s, a, f) => a in s._state.value ? s._state.value[a] : s[a],
      set: (s, a, f, p) => (a === "keepPopup" ? super.keepPopup = f : s[a] = f, !0)
    });
    let i = !1;
    if (this.on("connect", (s) => {
      const a = super.url;
      this.updateState({ address: s, url: a, connected: !0 }), this._localStorageKey && localStorage.setItem(this._localStorageKey, a ?? "");
    }), this.on("disconnect", () => {
      this.updateState({ address: void 0, connected: !1 }), this._localStorageKey && !i && localStorage.removeItem(this._localStorageKey);
    }), ["showIframe", "usePopup", "requirePopup", "keepPopup"].forEach((s) => this.on(s, (a) => this.updateState({ [s]: a }))), typeof window < "u" && (window.addEventListener("beforeunload", () => i = !0), window.addEventListener("unload", () => i = !0), (r == null ? void 0 : r.localStorageKey) != null && (this._localStorageKey = r.localStorageKey), this._localStorageKey)) {
      const s = localStorage.getItem(this._localStorageKey);
      s && this.setUrl(s, !0), localStorage.removeItem(this._localStorageKey);
    }
    return gr._instance;
  }
}
function sc(t) {
  if (t) {
    if ("subscribe" in t) {
      let e;
      const r = t.subscribe((n) => e = n);
      return r == null || r(), e;
    }
    return Array.isArray(t) ? t[0] : "value" in t ? t.value : t;
  }
}
function th(t) {
  let e;
  return t ? Array.isArray(t) ? e = en({ value: t[0] }) : "value" in t ? e = en(t) : "subscribe" in t ? e = en({ value: sc(t) }) : e = en({ value: t }) : e = en({ value: {} }), e;
}
function en(t) {
  var e;
  (e = t.value) !== null && e !== void 0 || (t.value = {});
  const r = rh(t.value);
  return { state: t, newProps: r.newProps };
}
function rh(t = {}) {
  const e = {
    url: void 0,
    address: void 0,
    connected: !1,
    showIframe: !1,
    usePopup: !1,
    requirePopup: !1,
    keepPopup: !1
  }, r = {};
  for (const n in e)
    t[n] == null && (r[n] = e[n], t[n] = e[n]);
  return { state: t, newProps: r };
}
const ua = Gf(gr);
function Vo(t, e) {
  for (const r of t)
    if (!e.includes(r))
      return !1;
  return !0;
}
function ac(t, e = 13) {
  return t.substring(0, e) + "..." + t.substring(t.length - e, t.length);
}
const uc = (t) => `${t.r}, ${t.g}, ${t.b}`;
async function vt(t, e = []) {
  return window != null && window.arweaveWallet ? await window.arweaveWallet[t](...e) : new Promise(
    (r, n) => window.addEventListener("arweaveWalletLoaded", async () => {
      try {
        r(await window.arweaveWallet[t](...e));
      } catch (i) {
        n(i);
      }
    })
  );
}
class qo {
  constructor() {
    pe(this, "id", "browserwallet");
    pe(this, "name", "Browser Wallet");
    pe(this, "description", "Any browser wallet with an injected API");
    pe(this, "theme", "121,212,131");
    pe(this, "logo", "KKiSlNKc5K59MXzUPz5qjtCLsl6_ckjAOg9MyAzaUs0");
  }
  async isAvailable() {
    return typeof window > "u" || !window ? (console.error(
      `[Arweave Wallet Kit] "${this.id}" strategy is unavailable. Window is undefined`
    ), !1) : window.arweaveWallet ? !0 : new Promise((e) => {
      const r = () => e(!0);
      window.addEventListener("arweaveWalletLoaded", r), setTimeout(() => {
        window.removeEventListener("arweaveWalletLoaded", r), window.arweaveWallet || console.error(
          `[Arweave Wallet Kit] "${this.id}" strategy is unavailable. window.arweaveWallet is undefined`
        ), e(!!window.arweaveWallet);
      }, 7e3);
    });
  }
  async sync() {
  }
  async connect(e, r, n) {
    return await vt("connect", [e, r, n]);
  }
  async disconnect() {
    return await vt("disconnect");
  }
  async getActiveAddress() {
    return await vt("getActiveAddress");
  }
  async getAllAddresses() {
    return await vt("getAllAddresses");
  }
  async getPermissions() {
    return await vt("getPermissions");
  }
  async getWalletNames() {
    return await vt("getWalletNames");
  }
  async sign(e, r) {
    const n = await vt("sign", [
      e,
      r
    ]);
    return e.setSignature({
      id: n.id,
      owner: n.owner,
      reward: n.reward,
      tags: n.tags,
      signature: n.signature
    }), e;
  }
  async signDataItem(e) {
    return await vt("signDataItem", [e]);
  }
  async encrypt(e, r) {
    return await vt("encrypt", [e, r]);
  }
  async decrypt(e, r) {
    return await vt("decrypt", [e, r]);
  }
  async getArweaveConfig() {
    return await vt("getArweaveConfig");
  }
  async signature(e, r) {
    return await vt("signature", [e, r]);
  }
  async getActivePublicKey() {
    return await vt("getActivePublicKey");
  }
  async addToken(e) {
    throw new Error("Not implemented");
  }
  async dispatch(e) {
    return await vt("dispatch", [e]);
  }
  addAddressEvent(e) {
    const r = (n) => e(n.detail.address);
    return addEventListener("walletSwitch", r), r;
  }
  removeAddressEvent(e) {
    removeEventListener("walletSwitch", e);
  }
}
var Jt;
class nh extends qo {
  constructor() {
    super();
    // @ts-expect-error
    pe(this, "id", "webwallet");
    pe(this, "name", "Arweave.app");
    pe(this, "description", "Web based wallet software");
    pe(this, "theme", "24, 24, 24");
    pe(this, "logo", "qVms-k8Ox-eKFJN5QFvrPQvT9ryqQXaFcYbr-fJbgLY");
    pe(this, "url", "https://arweave.app");
    Sr(this, Jt, new ua());
  }
  async isAvailable() {
    return !0;
  }
  async resumeSession() {
    pt(this, Jt).setUrl("arweave.app"), await pt(this, Jt).connect();
  }
  async connect(r, n, i) {
    i && console.warn(
      "[Arweave Wallet Kit] Arweave.app does not support custom gateway connection yet."
    ), Un(this, Jt, new ua(n)), await this.resumeSession();
  }
  addAddressEvent(r) {
    return pt(this, Jt).on("connect", r), r;
  }
  removeAddressEvent(r) {
    pt(this, Jt).off("connect", r);
  }
  async signDataItem(r) {
    return await pt(this, Jt).signDataItem(
      r
    );
  }
}
Jt = new WeakMap();
class ih extends qo {
  constructor() {
    super();
    // @ts-expect-error
    pe(this, "id", "arconnect");
    pe(this, "name", "ArConnect");
    pe(this, "description", "Non-custodial Arweave wallet for your favorite browser");
    pe(this, "theme", "171, 154, 255");
    pe(this, "logo", "tQUcL4wlNj_NED2VjUGUhfCTJ6pDN9P0e3CbnHo3vUE");
    pe(this, "url", "https://arconnect.io");
  }
  async isAvailable() {
    return await super.isAvailable() ? window.arweaveWallet.walletName === "ArConnect" : !1;
  }
  async addToken(r) {
    return await vt("addToken", [r]);
  }
  async batchSignDataItem(r) {
    return await vt("batchSignDataItem", [r]);
  }
}
var Qt, Vr, wr, ut, gt;
class oh {
  constructor() {
    Sr(this, ut);
    pe(this, "id", "othent");
    pe(this, "name", "Othent");
    pe(this, "description", "Othent JS SDK to manage Arweave wallets backed by Auth0 and Google Key Management Service.");
    pe(this, "theme", "35, 117, 239");
    pe(this, "logo", "33nBIUNlGK4MnWtJZQy9EzkVJaAd7WoydIKfkJoMvDs");
    pe(this, "url", "https://othent.io");
    Sr(this, Qt, null);
    Sr(this, Vr, null);
    Sr(this, wr, []);
  }
  __overrideOthentOptions(e) {
    Un(this, Vr, e);
  }
  async isAvailable() {
    try {
      return !!mt(this, ut, gt).call(this);
    } catch {
      return !1;
    }
  }
  async connect(e, r, n) {
    const i = mt(this, ut, gt).call(this);
    return e && console.warn(
      "[Arweave Wallet Kit] Othent implicitly requires all permissions. Your `permissions` parameter will be ignored."
    ), i.connect(
      void 0,
      r ? { ...i.appInfo, ...r } : void 0,
      n
    ).then(() => {
    });
  }
  async disconnect() {
    return mt(this, ut, gt).call(this).disconnect();
  }
  async getActiveAddress() {
    return mt(this, ut, gt).call(this).getActiveAddress();
  }
  async getActivePublicKey() {
    return mt(this, ut, gt).call(this).getActivePublicKey();
  }
  async getAllAddresses() {
    return mt(this, ut, gt).call(this).getAllAddresses();
  }
  async getWalletNames() {
    return mt(this, ut, gt).call(this).getWalletNames();
  }
  async userDetails() {
    return mt(this, ut, gt).call(this).getUserDetails();
  }
  async sign(e, r) {
    return r && console.warn(
      "[Arweave Wallet Kit] Othent does not support `sign()` options"
    ), mt(this, ut, gt).call(this).sign(e);
  }
  async dispatch(e) {
    return mt(this, ut, gt).call(this).dispatch(e);
  }
  signDataItem(e) {
    return mt(this, ut, gt).call(this).signDataItem(e);
  }
  encrypt(e, r) {
    return r && console.warn(
      "[Arweave Wallet Kit] Othent does not support `encrypt()` options"
    ), mt(this, ut, gt).call(this).encrypt(e);
  }
  decrypt(e, r) {
    return r && console.warn(
      "[Arweave Wallet Kit] Othent does not support `decrypt()` options"
    ), mt(this, ut, gt).call(this).decrypt(e);
  }
  signature(e, r) {
    return r && console.warn(
      "[Arweave Wallet Kit] Othent does not support `signature()` options"
    ), mt(this, ut, gt).call(this).signature(e);
  }
  getArweaveConfig() {
    return mt(this, ut, gt).call(this).getArweaveConfig();
  }
  async getPermissions() {
    const e = mt(this, ut, gt).call(this);
    return e.getSyncUserDetails() ? e.getPermissions() : Promise.resolve([]);
  }
  async addToken(e) {
    throw new Error("Not implemented");
  }
  addAddressEvent(e) {
    return pt(this, wr).push(e), e;
  }
  removeAddressEvent(e) {
    pt(this, wr).splice(
      pt(this, wr).indexOf(e),
      1
    );
  }
}
Qt = new WeakMap(), Vr = new WeakMap(), wr = new WeakMap(), ut = new WeakSet(), gt = function() {
  var e;
  if (pt(this, Qt))
    return pt(this, Qt);
  try {
    const r = {
      name: typeof location > "u" ? "UNKNOWN" : location.hostname,
      version: "ArweaveWalletKit",
      env: ""
    };
    Un(this, Qt, new Lf({
      appInfo: r,
      persistLocalStorage: !0,
      ...pt(this, Vr)
    })), pt(this, Qt).addEventListener("auth", (n) => {
      for (const i of pt(this, wr))
        i((n == null ? void 0 : n.walletAddress) || void 0);
    }), (e = pt(this, Vr)) != null && e.persistLocalStorage && pt(this, Qt).startTabSynching();
  } catch (r) {
    throw new Error(`[Arweave Wallet Kit] ${r instanceof Error && r.message || r}`);
  }
  return pt(this, Qt);
};
const dn = [
  new ih(),
  new nh(),
  new oh(),
  new qo()
], Sn = "wallet_kit_strategy_id";
async function sh(t, e) {
  let r = (localStorage == null ? void 0 : localStorage.getItem(Sn)) || !1;
  if (r && Ir(r))
    return Ir(r);
  for (const n of dn) {
    const i = await n.getPermissions();
    if (!e && i.length > 0)
      return fo(n.id), Ir(n.id);
    if (e && Vo(t, i))
      return fo(n.id), Ir(n.id);
  }
  return !1;
}
function fo(t) {
  localStorage && localStorage.setItem(Sn, t);
}
function Ir(t) {
  return dn.find((e) => e.id === t);
}
const Wo = {
  activeModal: !1,
  activeStrategy: !1,
  givenPermissions: [],
  config: {
    permissions: []
  }
}, cc = Tr(void 0);
function xt() {
  const t = dt(cc);
  return bt(
    () => t || { state: Wo, dispatch: () => {
    } },
    [t]
  );
}
function ah() {
  const { state: t } = xt();
  return bt(() => t.activeStrategy, [t]);
}
function Gt() {
  const t = ah();
  return bt(() => Ir(t), [t]);
}
function D1() {
  const t = Gt();
  return bt(() => {
    if (!t)
      return;
    const r = t, n = [
      "name",
      "description",
      "theme",
      "logo",
      "url",
      "resumeSession",
      "isAvailable",
      "addAddressEvent",
      "removeAddressEvent",
      "connect"
    ];
    for (const i in t)
      n.includes(i) && delete r[i];
    return r;
  }, [t]);
}
function di() {
  const { state: t } = xt();
  return t == null ? void 0 : t.activeAddress;
}
async function uh() {
  const t = Gt(), { dispatch: e } = xt();
  Le(() => {
    (async () => {
      var i;
      if (!t)
        return;
      const r = async () => {
        try {
          const o = await t.getActiveAddress();
          e({
            type: "UPDATE_ADDRESS",
            payload: o
          });
        } catch (o) {
          console.error(
            `[Arweave Wallet Kit] Failed to sync address
${(o == null ? void 0 : o.message) || o}`
          );
        }
      };
      await r();
      const n = (i = t.addAddressEvent) == null ? void 0 : i.call(
        t,
        (o) => e({
          type: "UPDATE_ADDRESS",
          payload: o
        })
      );
      return addEventListener("focus", r), () => {
        n && t.removeAddressEvent && t.removeAddressEvent(n), removeEventListener("focus", r);
      };
    })();
  }, [t, e]);
}
function L1() {
  const [t, e] = wt(), r = Gt(), n = di();
  return Le(() => {
    (async () => !r || !r.getActivePublicKey || e(await r.getActivePublicKey()))();
  }, [n, r]), t;
}
function ch() {
  const [t, e] = wt([]), r = di(), { state: n } = xt(), i = Gt();
  return Le(() => {
    (async () => {
      if (!i)
        return e([]);
      const o = async () => {
        try {
          e(await i.getAllAddresses());
        } catch (s) {
          console.error(
            `[Arweave Wallet Kit] Failed to sync addresses
${(s == null ? void 0 : s.message) || s}`
          );
        }
      };
      return await o(), addEventListener("focus", o), () => removeEventListener("focus", o);
    })();
  }, [r, n, i]), t;
}
function N1() {
  const [t, e] = wt({}), r = ch(), { state: n } = xt(), i = Gt();
  return Le(() => {
    (async () => {
      if (!i || !i.getWalletNames)
        return e({});
      try {
        const o = await i.getWalletNames();
        e(o);
      } catch (o) {
        console.error(
          `[Arweave Wallet Kit] Failed to sync wallet names
${(o == null ? void 0 : o.message) || o}`
        );
      }
    })();
  }, [r, n == null ? void 0 : n.activeStrategy]), t;
}
var ge = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Pn(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function lh(t) {
  if (t.__esModule)
    return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var ho = { exports: {} }, tn = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ca;
function fh() {
  if (ca)
    return tn;
  ca = 1;
  var t = ht, e = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, f, p) {
    var d, y = {}, v = null, w = null;
    p !== void 0 && (v = "" + p), f.key !== void 0 && (v = "" + f.key), f.ref !== void 0 && (w = f.ref);
    for (d in f)
      n.call(f, d) && !o.hasOwnProperty(d) && (y[d] = f[d]);
    if (a && a.defaultProps)
      for (d in f = a.defaultProps, f)
        y[d] === void 0 && (y[d] = f[d]);
    return { $$typeof: e, type: a, key: v, ref: w, props: y, _owner: i.current };
  }
  return tn.Fragment = r, tn.jsx = s, tn.jsxs = s, tn;
}
var rn = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var la;
function hh() {
  return la || (la = 1, process.env.NODE_ENV !== "production" && function() {
    var t = ht, e = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), y = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), w = Symbol.for("react.offscreen"), I = Symbol.iterator, N = "@@iterator";
    function k(D) {
      if (D === null || typeof D != "object")
        return null;
      var le = I && D[I] || D[N];
      return typeof le == "function" ? le : null;
    }
    var M = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function S(D) {
      {
        for (var le = arguments.length, he = new Array(le > 1 ? le - 1 : 0), Te = 1; Te < le; Te++)
          he[Te - 1] = arguments[Te];
        Y("error", D, he);
      }
    }
    function Y(D, le, he) {
      {
        var Te = M.ReactDebugCurrentFrame, Ie = Te.getStackAddendum();
        Ie !== "" && (le += "%s", he = he.concat([Ie]));
        var De = he.map(function(Re) {
          return String(Re);
        });
        De.unshift("Warning: " + le), Function.prototype.apply.call(console[D], console, De);
      }
    }
    var W = !1, Q = !1, X = !1, ne = !1, ue = !1, se;
    se = Symbol.for("react.module.reference");
    function ie(D) {
      return !!(typeof D == "string" || typeof D == "function" || D === n || D === o || ue || D === i || D === p || D === d || ne || D === w || W || Q || X || typeof D == "object" && D !== null && (D.$$typeof === v || D.$$typeof === y || D.$$typeof === s || D.$$typeof === a || D.$$typeof === f || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      D.$$typeof === se || D.getModuleId !== void 0));
    }
    function O(D, le, he) {
      var Te = D.displayName;
      if (Te)
        return Te;
      var Ie = le.displayName || le.name || "";
      return Ie !== "" ? he + "(" + Ie + ")" : he;
    }
    function c(D) {
      return D.displayName || "Context";
    }
    function m(D) {
      if (D == null)
        return null;
      if (typeof D.tag == "number" && S("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof D == "function")
        return D.displayName || D.name || null;
      if (typeof D == "string")
        return D;
      switch (D) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case p:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof D == "object")
        switch (D.$$typeof) {
          case a:
            var le = D;
            return c(le) + ".Consumer";
          case s:
            var he = D;
            return c(he._context) + ".Provider";
          case f:
            return O(D, D.render, "ForwardRef");
          case y:
            var Te = D.displayName || null;
            return Te !== null ? Te : m(D.type) || "Memo";
          case v: {
            var Ie = D, De = Ie._payload, Re = Ie._init;
            try {
              return m(Re(De));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var _ = Object.assign, T = 0, C, L, H, P, l, x, re;
    function ae() {
    }
    ae.__reactDisabledLog = !0;
    function G() {
      {
        if (T === 0) {
          C = console.log, L = console.info, H = console.warn, P = console.error, l = console.group, x = console.groupCollapsed, re = console.groupEnd;
          var D = {
            configurable: !0,
            enumerable: !0,
            value: ae,
            writable: !0
          };
          Object.defineProperties(console, {
            info: D,
            log: D,
            warn: D,
            error: D,
            group: D,
            groupCollapsed: D,
            groupEnd: D
          });
        }
        T++;
      }
    }
    function ce() {
      {
        if (T--, T === 0) {
          var D = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: _({}, D, {
              value: C
            }),
            info: _({}, D, {
              value: L
            }),
            warn: _({}, D, {
              value: H
            }),
            error: _({}, D, {
              value: P
            }),
            group: _({}, D, {
              value: l
            }),
            groupCollapsed: _({}, D, {
              value: x
            }),
            groupEnd: _({}, D, {
              value: re
            })
          });
        }
        T < 0 && S("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var me = M.ReactCurrentDispatcher, ye;
    function xe(D, le, he) {
      {
        if (ye === void 0)
          try {
            throw Error();
          } catch (Ie) {
            var Te = Ie.stack.trim().match(/\n( *(at )?)/);
            ye = Te && Te[1] || "";
          }
        return `
` + ye + D;
      }
    }
    var ve = !1, b;
    {
      var R = typeof WeakMap == "function" ? WeakMap : Map;
      b = new R();
    }
    function E(D, le) {
      if (!D || ve)
        return "";
      {
        var he = b.get(D);
        if (he !== void 0)
          return he;
      }
      var Te;
      ve = !0;
      var Ie = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var De;
      De = me.current, me.current = null, G();
      try {
        if (le) {
          var Re = function() {
            throw Error();
          };
          if (Object.defineProperty(Re.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Re, []);
            } catch (ft) {
              Te = ft;
            }
            Reflect.construct(D, [], Re);
          } else {
            try {
              Re.call();
            } catch (ft) {
              Te = ft;
            }
            D.call(Re.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ft) {
            Te = ft;
          }
          D();
        }
      } catch (ft) {
        if (ft && Te && typeof ft.stack == "string") {
          for (var Oe = ft.stack.split(`
`), at = Te.stack.split(`
`), Ve = Oe.length - 1, Ke = at.length - 1; Ve >= 1 && Ke >= 0 && Oe[Ve] !== at[Ke]; )
            Ke--;
          for (; Ve >= 1 && Ke >= 0; Ve--, Ke--)
            if (Oe[Ve] !== at[Ke]) {
              if (Ve !== 1 || Ke !== 1)
                do
                  if (Ve--, Ke--, Ke < 0 || Oe[Ve] !== at[Ke]) {
                    var yt = `
` + Oe[Ve].replace(" at new ", " at ");
                    return D.displayName && yt.includes("<anonymous>") && (yt = yt.replace("<anonymous>", D.displayName)), typeof D == "function" && b.set(D, yt), yt;
                  }
                while (Ve >= 1 && Ke >= 0);
              break;
            }
        }
      } finally {
        ve = !1, me.current = De, ce(), Error.prepareStackTrace = Ie;
      }
      var Wt = D ? D.displayName || D.name : "", Ft = Wt ? xe(Wt) : "";
      return typeof D == "function" && b.set(D, Ft), Ft;
    }
    function V(D, le, he) {
      return E(D, !1);
    }
    function K(D) {
      var le = D.prototype;
      return !!(le && le.isReactComponent);
    }
    function $(D, le, he) {
      if (D == null)
        return "";
      if (typeof D == "function")
        return E(D, K(D));
      if (typeof D == "string")
        return xe(D);
      switch (D) {
        case p:
          return xe("Suspense");
        case d:
          return xe("SuspenseList");
      }
      if (typeof D == "object")
        switch (D.$$typeof) {
          case f:
            return V(D.render);
          case y:
            return $(D.type, le, he);
          case v: {
            var Te = D, Ie = Te._payload, De = Te._init;
            try {
              return $(De(Ie), le, he);
            } catch {
            }
          }
        }
      return "";
    }
    var J = Object.prototype.hasOwnProperty, j = {}, q = M.ReactDebugCurrentFrame;
    function Z(D) {
      if (D) {
        var le = D._owner, he = $(D.type, D._source, le ? le.type : null);
        q.setExtraStackFrame(he);
      } else
        q.setExtraStackFrame(null);
    }
    function ee(D, le, he, Te, Ie) {
      {
        var De = Function.call.bind(J);
        for (var Re in D)
          if (De(D, Re)) {
            var Oe = void 0;
            try {
              if (typeof D[Re] != "function") {
                var at = Error((Te || "React class") + ": " + he + " type `" + Re + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof D[Re] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw at.name = "Invariant Violation", at;
              }
              Oe = D[Re](le, Re, Te, he, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ve) {
              Oe = Ve;
            }
            Oe && !(Oe instanceof Error) && (Z(Ie), S("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Te || "React class", he, Re, typeof Oe), Z(null)), Oe instanceof Error && !(Oe.message in j) && (j[Oe.message] = !0, Z(Ie), S("Failed %s type: %s", he, Oe.message), Z(null));
          }
      }
    }
    var oe = Array.isArray;
    function de(D) {
      return oe(D);
    }
    function Ee(D) {
      {
        var le = typeof Symbol == "function" && Symbol.toStringTag, he = le && D[Symbol.toStringTag] || D.constructor.name || "Object";
        return he;
      }
    }
    function Ae(D) {
      try {
        return U(D), !1;
      } catch {
        return !0;
      }
    }
    function U(D) {
      return "" + D;
    }
    function te(D) {
      if (Ae(D))
        return S("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ee(D)), U(D);
    }
    var g = M.ReactCurrentOwner, u = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, h, A, B;
    B = {};
    function z(D) {
      if (J.call(D, "ref")) {
        var le = Object.getOwnPropertyDescriptor(D, "ref").get;
        if (le && le.isReactWarning)
          return !1;
      }
      return D.ref !== void 0;
    }
    function F(D) {
      if (J.call(D, "key")) {
        var le = Object.getOwnPropertyDescriptor(D, "key").get;
        if (le && le.isReactWarning)
          return !1;
      }
      return D.key !== void 0;
    }
    function fe(D, le) {
      if (typeof D.ref == "string" && g.current && le && g.current.stateNode !== le) {
        var he = m(g.current.type);
        B[he] || (S('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', m(g.current.type), D.ref), B[he] = !0);
      }
    }
    function we(D, le) {
      {
        var he = function() {
          h || (h = !0, S("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", le));
        };
        he.isReactWarning = !0, Object.defineProperty(D, "key", {
          get: he,
          configurable: !0
        });
      }
    }
    function _e(D, le) {
      {
        var he = function() {
          A || (A = !0, S("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", le));
        };
        he.isReactWarning = !0, Object.defineProperty(D, "ref", {
          get: he,
          configurable: !0
        });
      }
    }
    var be = function(D, le, he, Te, Ie, De, Re) {
      var Oe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: D,
        key: le,
        ref: he,
        props: Re,
        // Record the component responsible for creating this element.
        _owner: De
      };
      return Oe._store = {}, Object.defineProperty(Oe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Oe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Te
      }), Object.defineProperty(Oe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ie
      }), Object.freeze && (Object.freeze(Oe.props), Object.freeze(Oe)), Oe;
    };
    function Be(D, le, he, Te, Ie) {
      {
        var De, Re = {}, Oe = null, at = null;
        he !== void 0 && (te(he), Oe = "" + he), F(le) && (te(le.key), Oe = "" + le.key), z(le) && (at = le.ref, fe(le, Ie));
        for (De in le)
          J.call(le, De) && !u.hasOwnProperty(De) && (Re[De] = le[De]);
        if (D && D.defaultProps) {
          var Ve = D.defaultProps;
          for (De in Ve)
            Re[De] === void 0 && (Re[De] = Ve[De]);
        }
        if (Oe || at) {
          var Ke = typeof D == "function" ? D.displayName || D.name || "Unknown" : D;
          Oe && we(Re, Ke), at && _e(Re, Ke);
        }
        return be(D, Oe, at, Ie, Te, g.current, Re);
      }
    }
    var qe = M.ReactCurrentOwner, Ye = M.ReactDebugCurrentFrame;
    function Yt(D) {
      if (D) {
        var le = D._owner, he = $(D.type, D._source, le ? le.type : null);
        Ye.setExtraStackFrame(he);
      } else
        Ye.setExtraStackFrame(null);
    }
    var We;
    We = !1;
    function He(D) {
      return typeof D == "object" && D !== null && D.$$typeof === e;
    }
    function Xr() {
      {
        if (qe.current) {
          var D = m(qe.current.type);
          if (D)
            return `

Check the render method of \`` + D + "`.";
        }
        return "";
      }
    }
    function et(D) {
      {
        if (D !== void 0) {
          var le = D.fileName.replace(/^.*[\\\/]/, ""), he = D.lineNumber;
          return `

Check your code at ` + le + ":" + he + ".";
        }
        return "";
      }
    }
    var Xe = {};
    function Dn(D) {
      {
        var le = Xr();
        if (!le) {
          var he = typeof D == "string" ? D : D.displayName || D.name;
          he && (le = `

Check the top-level render call using <` + he + ">.");
        }
        return le;
      }
    }
    function Ze(D, le) {
      {
        if (!D._store || D._store.validated || D.key != null)
          return;
        D._store.validated = !0;
        var he = Dn(le);
        if (Xe[he])
          return;
        Xe[he] = !0;
        var Te = "";
        D && D._owner && D._owner !== qe.current && (Te = " It was passed a child from " + m(D._owner.type) + "."), Yt(D), S('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', he, Te), Yt(null);
      }
    }
    function Je(D, le) {
      {
        if (typeof D != "object")
          return;
        if (de(D))
          for (var he = 0; he < D.length; he++) {
            var Te = D[he];
            He(Te) && Ze(Te, le);
          }
        else if (He(D))
          D._store && (D._store.validated = !0);
        else if (D) {
          var Ie = k(D);
          if (typeof Ie == "function" && Ie !== D.entries)
            for (var De = Ie.call(D), Re; !(Re = De.next()).done; )
              He(Re.value) && Ze(Re.value, le);
        }
      }
    }
    function Ln(D) {
      {
        var le = D.type;
        if (le == null || typeof le == "string")
          return;
        var he;
        if (typeof le == "function")
          he = le.propTypes;
        else if (typeof le == "object" && (le.$$typeof === f || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        le.$$typeof === y))
          he = le.propTypes;
        else
          return;
        if (he) {
          var Te = m(le);
          ee(he, D.props, "prop", Te, D);
        } else if (le.PropTypes !== void 0 && !We) {
          We = !0;
          var Ie = m(le);
          S("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ie || "Unknown");
        }
        typeof le.getDefaultProps == "function" && !le.getDefaultProps.isReactClassApproved && S("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function tt(D) {
      {
        for (var le = Object.keys(D.props), he = 0; he < le.length; he++) {
          var Te = le[he];
          if (Te !== "children" && Te !== "key") {
            Yt(D), S("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Te), Yt(null);
            break;
          }
        }
        D.ref !== null && (Yt(D), S("Invalid attribute `ref` supplied to `React.Fragment`."), Yt(null));
      }
    }
    var Qe = {};
    function Zr(D, le, he, Te, Ie, De) {
      {
        var Re = ie(D);
        if (!Re) {
          var Oe = "";
          (D === void 0 || typeof D == "object" && D !== null && Object.keys(D).length === 0) && (Oe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var at = et(Ie);
          at ? Oe += at : Oe += Xr();
          var Ve;
          D === null ? Ve = "null" : de(D) ? Ve = "array" : D !== void 0 && D.$$typeof === e ? (Ve = "<" + (m(D.type) || "Unknown") + " />", Oe = " Did you accidentally export a JSX literal instead of a component?") : Ve = typeof D, S("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ve, Oe);
        }
        var Ke = Be(D, le, he, Ie, De);
        if (Ke == null)
          return Ke;
        if (Re) {
          var yt = le.children;
          if (yt !== void 0)
            if (Te)
              if (de(yt)) {
                for (var Wt = 0; Wt < yt.length; Wt++)
                  Je(yt[Wt], D);
                Object.freeze && Object.freeze(yt);
              } else
                S("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Je(yt, D);
        }
        if (J.call(le, "key")) {
          var Ft = m(D), ft = Object.keys(le).filter(function(Qr) {
            return Qr !== "key";
          }), fr = ft.length > 0 ? "{key: someKey, " + ft.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Qe[Ft + fr]) {
            var Jr = ft.length > 0 ? "{" + ft.join(": ..., ") + ": ...}" : "{}";
            S(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, fr, Ft, Jr, Ft), Qe[Ft + fr] = !0;
          }
        }
        return D === n ? tt(Ke) : Ln(Ke), Ke;
      }
    }
    function rt(D, le, he) {
      return Zr(D, le, he, !0);
    }
    function nt(D, le, he) {
      return Zr(D, le, he, !1);
    }
    var Nn = nt, it = rt;
    rn.Fragment = n, rn.jsx = Nn, rn.jsxs = it;
  }()), rn;
}
process.env.NODE_ENV === "production" ? ho.exports = fh() : ho.exports = hh();
var Ho = ho.exports;
const _n = Ho.Fragment, Me = Ho.jsx, Fe = Ho.jsxs;
function dh(t) {
  return /* @__PURE__ */ ke.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, t), /* @__PURE__ */ ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M15.25 10.75L12 14.25L8.75 10.75"
  }));
}
function ph(t) {
  return /* @__PURE__ */ ke.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, t), /* @__PURE__ */ ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M13.25 8.75L9.75 12L13.25 15.25"
  }));
}
function mh(t) {
  return /* @__PURE__ */ ke.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, t), /* @__PURE__ */ ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M17.25 6.75L6.75 17.25"
  }), /* @__PURE__ */ ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M6.75 6.75L17.25 17.25"
  }));
}
function gh(t) {
  return /* @__PURE__ */ ke.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, t), /* @__PURE__ */ ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M6.5 15.25V15.25C5.5335 15.25 4.75 14.4665 4.75 13.5V6.75C4.75 5.64543 5.64543 4.75 6.75 4.75H13.5C14.4665 4.75 15.25 5.5335 15.25 6.5V6.5"
  }), /* @__PURE__ */ ke.createElement("rect", {
    width: 10.5,
    height: 10.5,
    x: 8.75,
    y: 8.75,
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    rx: 2
  }));
}
function yh(t) {
  return /* @__PURE__ */ ke.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, t), /* @__PURE__ */ ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M15.75 8.75L19.25 12L15.75 15.25"
  }), /* @__PURE__ */ ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M19 12H10.75"
  }), /* @__PURE__ */ ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M15.25 4.75H6.75C5.64543 4.75 4.75 5.64543 4.75 6.75V17.25C4.75 18.3546 5.64543 19.25 6.75 19.25H15.25"
  }));
}
function lc(t) {
  return /* @__PURE__ */ ke.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, t), /* @__PURE__ */ ke.createElement("circle", {
    cx: 12,
    cy: 8,
    r: 3.25,
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5
  }), /* @__PURE__ */ ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M6.8475 19.25H17.1525C18.2944 19.25 19.174 18.2681 18.6408 17.2584C17.8563 15.7731 16.068 14 12 14C7.93201 14 6.14367 15.7731 5.35924 17.2584C4.82597 18.2681 5.70558 19.25 6.8475 19.25Z"
  }));
}
var Ko = {}, fc = { exports: {} };
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(ge, function() {
    var r = function(S) {
      return n(S) && !i(S);
    };
    function n(M) {
      return !!M && typeof M == "object";
    }
    function i(M) {
      var S = Object.prototype.toString.call(M);
      return S === "[object RegExp]" || S === "[object Date]" || a(M);
    }
    var o = typeof Symbol == "function" && Symbol.for, s = o ? Symbol.for("react.element") : 60103;
    function a(M) {
      return M.$$typeof === s;
    }
    function f(M) {
      return Array.isArray(M) ? [] : {};
    }
    function p(M, S) {
      return S.clone !== !1 && S.isMergeableObject(M) ? N(f(M), M, S) : M;
    }
    function d(M, S, Y) {
      return M.concat(S).map(function(W) {
        return p(W, Y);
      });
    }
    function y(M, S) {
      if (!S.customMerge)
        return N;
      var Y = S.customMerge(M);
      return typeof Y == "function" ? Y : N;
    }
    function v(M) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(M).filter(function(S) {
        return M.propertyIsEnumerable(S);
      }) : [];
    }
    function w(M) {
      return Object.keys(M).concat(v(M));
    }
    function I(M, S, Y) {
      var W = {};
      return Y.isMergeableObject(M) && w(M).forEach(function(Q) {
        W[Q] = p(M[Q], Y);
      }), w(S).forEach(function(Q) {
        !Y.isMergeableObject(S[Q]) || !M[Q] ? W[Q] = p(S[Q], Y) : W[Q] = y(Q, Y)(M[Q], S[Q], Y);
      }), W;
    }
    function N(M, S, Y) {
      Y = Y || {}, Y.arrayMerge = Y.arrayMerge || d, Y.isMergeableObject = Y.isMergeableObject || r;
      var W = Array.isArray(S), Q = Array.isArray(M), X = W === Q;
      return X ? W ? Y.arrayMerge(M, S, Y) : I(M, S, Y) : p(S, Y);
    }
    N.all = function(S, Y) {
      if (!Array.isArray(S))
        throw new Error("first argument should be an array");
      return S.reduce(function(W, Q) {
        return N(W, Q, Y);
      }, {});
    };
    var k = N;
    return k;
  });
})(fc);
var hc = fc.exports, pi = {};
pi.__esModule = !0;
pi.default = void 0;
var fa = vh(ht);
function vh(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null) {
    for (var r in t)
      if (Object.prototype.hasOwnProperty.call(t, r)) {
        var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(t, r) : {};
        n.get || n.set ? Object.defineProperty(e, r, n) : e[r] = t[r];
      }
  }
  return e.default = t, e;
}
function wh(t, e) {
  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
}
function _h(t, e, r) {
  return e in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;
}
function bh(t, e) {
  var r, n;
  return n = r = /* @__PURE__ */ function(i) {
    wh(o, i);
    function o() {
      return i.apply(this, arguments) || this;
    }
    var s = o.prototype;
    return s.render = function() {
      return fa.createElement(e.Provider, {
        value: this.props.theme
      }, this.props.children);
    }, o;
  }(fa.Component), _h(r, "defaultProps", {
    theme: t
  }), n;
}
var xh = bh;
pi.default = xh;
var mi = {}, Fn = { exports: {} }, Ne = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ha;
function Th() {
  if (ha)
    return Ne;
  ha = 1;
  var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, r = t ? Symbol.for("react.portal") : 60106, n = t ? Symbol.for("react.fragment") : 60107, i = t ? Symbol.for("react.strict_mode") : 60108, o = t ? Symbol.for("react.profiler") : 60114, s = t ? Symbol.for("react.provider") : 60109, a = t ? Symbol.for("react.context") : 60110, f = t ? Symbol.for("react.async_mode") : 60111, p = t ? Symbol.for("react.concurrent_mode") : 60111, d = t ? Symbol.for("react.forward_ref") : 60112, y = t ? Symbol.for("react.suspense") : 60113, v = t ? Symbol.for("react.suspense_list") : 60120, w = t ? Symbol.for("react.memo") : 60115, I = t ? Symbol.for("react.lazy") : 60116, N = t ? Symbol.for("react.block") : 60121, k = t ? Symbol.for("react.fundamental") : 60117, M = t ? Symbol.for("react.responder") : 60118, S = t ? Symbol.for("react.scope") : 60119;
  function Y(Q) {
    if (typeof Q == "object" && Q !== null) {
      var X = Q.$$typeof;
      switch (X) {
        case e:
          switch (Q = Q.type, Q) {
            case f:
            case p:
            case n:
            case o:
            case i:
            case y:
              return Q;
            default:
              switch (Q = Q && Q.$$typeof, Q) {
                case a:
                case d:
                case I:
                case w:
                case s:
                  return Q;
                default:
                  return X;
              }
          }
        case r:
          return X;
      }
    }
  }
  function W(Q) {
    return Y(Q) === p;
  }
  return Ne.AsyncMode = f, Ne.ConcurrentMode = p, Ne.ContextConsumer = a, Ne.ContextProvider = s, Ne.Element = e, Ne.ForwardRef = d, Ne.Fragment = n, Ne.Lazy = I, Ne.Memo = w, Ne.Portal = r, Ne.Profiler = o, Ne.StrictMode = i, Ne.Suspense = y, Ne.isAsyncMode = function(Q) {
    return W(Q) || Y(Q) === f;
  }, Ne.isConcurrentMode = W, Ne.isContextConsumer = function(Q) {
    return Y(Q) === a;
  }, Ne.isContextProvider = function(Q) {
    return Y(Q) === s;
  }, Ne.isElement = function(Q) {
    return typeof Q == "object" && Q !== null && Q.$$typeof === e;
  }, Ne.isForwardRef = function(Q) {
    return Y(Q) === d;
  }, Ne.isFragment = function(Q) {
    return Y(Q) === n;
  }, Ne.isLazy = function(Q) {
    return Y(Q) === I;
  }, Ne.isMemo = function(Q) {
    return Y(Q) === w;
  }, Ne.isPortal = function(Q) {
    return Y(Q) === r;
  }, Ne.isProfiler = function(Q) {
    return Y(Q) === o;
  }, Ne.isStrictMode = function(Q) {
    return Y(Q) === i;
  }, Ne.isSuspense = function(Q) {
    return Y(Q) === y;
  }, Ne.isValidElementType = function(Q) {
    return typeof Q == "string" || typeof Q == "function" || Q === n || Q === p || Q === o || Q === i || Q === y || Q === v || typeof Q == "object" && Q !== null && (Q.$$typeof === I || Q.$$typeof === w || Q.$$typeof === s || Q.$$typeof === a || Q.$$typeof === d || Q.$$typeof === k || Q.$$typeof === M || Q.$$typeof === S || Q.$$typeof === N);
  }, Ne.typeOf = Y, Ne;
}
var Ue = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var da;
function Eh() {
  return da || (da = 1, process.env.NODE_ENV !== "production" && function() {
    var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, r = t ? Symbol.for("react.portal") : 60106, n = t ? Symbol.for("react.fragment") : 60107, i = t ? Symbol.for("react.strict_mode") : 60108, o = t ? Symbol.for("react.profiler") : 60114, s = t ? Symbol.for("react.provider") : 60109, a = t ? Symbol.for("react.context") : 60110, f = t ? Symbol.for("react.async_mode") : 60111, p = t ? Symbol.for("react.concurrent_mode") : 60111, d = t ? Symbol.for("react.forward_ref") : 60112, y = t ? Symbol.for("react.suspense") : 60113, v = t ? Symbol.for("react.suspense_list") : 60120, w = t ? Symbol.for("react.memo") : 60115, I = t ? Symbol.for("react.lazy") : 60116, N = t ? Symbol.for("react.block") : 60121, k = t ? Symbol.for("react.fundamental") : 60117, M = t ? Symbol.for("react.responder") : 60118, S = t ? Symbol.for("react.scope") : 60119;
    function Y(E) {
      return typeof E == "string" || typeof E == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      E === n || E === p || E === o || E === i || E === y || E === v || typeof E == "object" && E !== null && (E.$$typeof === I || E.$$typeof === w || E.$$typeof === s || E.$$typeof === a || E.$$typeof === d || E.$$typeof === k || E.$$typeof === M || E.$$typeof === S || E.$$typeof === N);
    }
    function W(E) {
      if (typeof E == "object" && E !== null) {
        var V = E.$$typeof;
        switch (V) {
          case e:
            var K = E.type;
            switch (K) {
              case f:
              case p:
              case n:
              case o:
              case i:
              case y:
                return K;
              default:
                var $ = K && K.$$typeof;
                switch ($) {
                  case a:
                  case d:
                  case I:
                  case w:
                  case s:
                    return $;
                  default:
                    return V;
                }
            }
          case r:
            return V;
        }
      }
    }
    var Q = f, X = p, ne = a, ue = s, se = e, ie = d, O = n, c = I, m = w, _ = r, T = o, C = i, L = y, H = !1;
    function P(E) {
      return H || (H = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), l(E) || W(E) === f;
    }
    function l(E) {
      return W(E) === p;
    }
    function x(E) {
      return W(E) === a;
    }
    function re(E) {
      return W(E) === s;
    }
    function ae(E) {
      return typeof E == "object" && E !== null && E.$$typeof === e;
    }
    function G(E) {
      return W(E) === d;
    }
    function ce(E) {
      return W(E) === n;
    }
    function me(E) {
      return W(E) === I;
    }
    function ye(E) {
      return W(E) === w;
    }
    function xe(E) {
      return W(E) === r;
    }
    function ve(E) {
      return W(E) === o;
    }
    function b(E) {
      return W(E) === i;
    }
    function R(E) {
      return W(E) === y;
    }
    Ue.AsyncMode = Q, Ue.ConcurrentMode = X, Ue.ContextConsumer = ne, Ue.ContextProvider = ue, Ue.Element = se, Ue.ForwardRef = ie, Ue.Fragment = O, Ue.Lazy = c, Ue.Memo = m, Ue.Portal = _, Ue.Profiler = T, Ue.StrictMode = C, Ue.Suspense = L, Ue.isAsyncMode = P, Ue.isConcurrentMode = l, Ue.isContextConsumer = x, Ue.isContextProvider = re, Ue.isElement = ae, Ue.isForwardRef = G, Ue.isFragment = ce, Ue.isLazy = me, Ue.isMemo = ye, Ue.isPortal = xe, Ue.isProfiler = ve, Ue.isStrictMode = b, Ue.isSuspense = R, Ue.isValidElementType = Y, Ue.typeOf = W;
  }()), Ue;
}
var pa;
function zo() {
  return pa || (pa = 1, process.env.NODE_ENV === "production" ? Fn.exports = Th() : Fn.exports = Eh()), Fn.exports;
}
var Go = zo(), Ah = {
  childContextTypes: !0,
  contextType: !0,
  contextTypes: !0,
  defaultProps: !0,
  displayName: !0,
  getDefaultProps: !0,
  getDerivedStateFromError: !0,
  getDerivedStateFromProps: !0,
  mixins: !0,
  propTypes: !0,
  type: !0
}, Mh = {
  name: !0,
  length: !0,
  prototype: !0,
  caller: !0,
  callee: !0,
  arguments: !0,
  arity: !0
}, Sh = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, dc = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, Yo = {};
Yo[Go.ForwardRef] = Sh;
Yo[Go.Memo] = dc;
function ma(t) {
  return Go.isMemo(t) ? dc : Yo[t.$$typeof] || Ah;
}
var Ph = Object.defineProperty, Ch = Object.getOwnPropertyNames, ga = Object.getOwnPropertySymbols, Oh = Object.getOwnPropertyDescriptor, Rh = Object.getPrototypeOf, ya = Object.prototype;
function pc(t, e, r) {
  if (typeof e != "string") {
    if (ya) {
      var n = Rh(e);
      n && n !== ya && pc(t, n, r);
    }
    var i = Ch(e);
    ga && (i = i.concat(ga(e)));
    for (var o = ma(t), s = ma(e), a = 0; a < i.length; ++a) {
      var f = i[a];
      if (!Mh[f] && !(r && r[f]) && !(s && s[f]) && !(o && o[f])) {
        var p = Oh(e, f);
        try {
          Ph(t, f, p);
        } catch {
        }
      }
    }
  }
  return t;
}
var Ih = pc;
mi.__esModule = !0;
mi.default = void 0;
var nn = Dh(ht), Bh = mc(hc), kh = mc(Ih);
function mc(t) {
  return t && t.__esModule ? t : { default: t };
}
function Dh(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null) {
    for (var r in t)
      if (Object.prototype.hasOwnProperty.call(t, r)) {
        var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(t, r) : {};
        n.get || n.set ? Object.defineProperty(e, r, n) : e[r] = t[r];
      }
  }
  return e.default = t, e;
}
function Qn() {
  return Qn = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, Qn.apply(this, arguments);
}
function Lh(t, e) {
  if (t == null)
    return {};
  var r = {}, n = Object.keys(t), i, o;
  for (o = 0; o < n.length; o++)
    i = n[o], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
  return r;
}
function va(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function Nh(t, e) {
  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
}
function wa(t, e, r) {
  return e in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;
}
var Uh = function(e, r) {
  return function(i) {
    var o = /* @__PURE__ */ function(a) {
      Nh(f, a);
      function f() {
        for (var d, y = arguments.length, v = new Array(y), w = 0; w < y; w++)
          v[w] = arguments[w];
        return d = a.call.apply(a, [this].concat(v)) || this, wa(va(d), "_previous", void 0), wa(va(d), "_merge", function(I, N) {
          var k = d._previous;
          if (k && k.a === I && k.b === N)
            return k.result;
          var M = I && N && I !== N ? (0, Bh.default)(I, N) : I || N;
          return d._previous = {
            a: I,
            b: N,
            result: M
          }, M;
        }), d;
      }
      var p = f.prototype;
      return p.render = function() {
        var y = this, v = this.props, w = v._reactThemeProviderForwardedRef, I = Lh(v, ["_reactThemeProviderForwardedRef"]);
        return nn.createElement(r.Consumer, null, function(N) {
          return nn.createElement(i, Qn({}, I, {
            theme: y._merge(N, I.theme),
            ref: w
          }));
        });
      }, f;
    }(nn.Component), s = nn.forwardRef(function(a, f) {
      return nn.createElement(o, Qn({}, a, {
        _reactThemeProviderForwardedRef: f
      }));
    });
    return s.displayName = "withTheme(" + (i.displayName || i.name) + ")", (0, kh.default)(s, i), s;
  };
}, Fh = Uh;
mi.default = Fh;
Ko.__esModule = !0;
Ko.default = Wh;
var Ni = qh(ht), jh = Xo(hc), $h = Xo(pi), Vh = Xo(mi);
function Xo(t) {
  return t && t.__esModule ? t : { default: t };
}
function qh(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null) {
    for (var r in t)
      if (Object.prototype.hasOwnProperty.call(t, r)) {
        var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(t, r) : {};
        n.get || n.set ? Object.defineProperty(e, r, n) : e[r] = t[r];
      }
  }
  return e.default = t, e;
}
function Wh(t) {
  var e = Ni.createContext(t), r = (0, $h.default)(t, e), n = (0, Vh.default)(r, e), i = function(s) {
    var a = Ni.useContext(e), f = Ni.useMemo(function() {
      return a && s ? (0, jh.default)(a, s) : a || s;
    }, [a, s]);
    return f;
  };
  return {
    ThemeContext: e,
    ThemeProvider: r,
    withTheme: n,
    useTheme: i
  };
}
var Hh = zh(Ko), Kh = Hh.default;
function zh(t) {
  return t && t.__esModule ? t : { default: t };
}
const gc = {
  primaryText: "0, 0, 0",
  background: "255, 255, 255",
  secondaryText: "146, 146, 147",
  light: "242, 242, 247"
}, Gh = {
  primaryText: "240, 240, 240",
  background: "26, 27, 31",
  secondaryText: "161, 161, 161",
  light: "44, 45, 49"
}, Yh = {
  displayTheme: "light",
  accent: {
    r: 0,
    g: 0,
    b: 0
  },
  titleHighlight: {
    r: 0,
    g: 122,
    b: 255
  },
  radius: "default",
  font: {
    fontFamily: "Manrope"
  }
}, yc = Kh({
  displayTheme: "light",
  theme: "0, 0, 0",
  themeConfig: Yh,
  ...gc
}), { ThemeProvider: Xh, useTheme: U1 } = yc, st = yc.withTheme || ((t) => t);
function Zh() {
  const { state: t, dispatch: e } = xt(), r = Gt();
  return Le(() => {
    (async () => r && e({
      type: "UPDATE_PERMISSIONS",
      payload: await r.getPermissions()
    }))();
  }, [e]), t.givenPermissions;
}
function Jh() {
  const t = Ot(!1), { state: e, dispatch: r } = xt(), n = Gt(), { permissions: i, ensurePermissions: o } = e.config;
  Le(() => {
    async function s() {
      if (!n)
        return f(), r({
          type: "UPDATE_PERMISSIONS",
          payload: []
        });
      try {
        const d = await n.getPermissions(), y = Vo(
          i,
          d
        );
        if (r({
          type: "UPDATE_PERMISSIONS",
          payload: d
        }), i.length === 0 && o) {
          f();
          return;
        }
        !y && o && !t.current && (t.current = !0, await n.connect(
          i,
          e.config.appInfo,
          e.config.gatewayConfig
        )), d.length === 0 && f();
      } catch {
        f(), r({
          type: "UPDATE_PERMISSIONS",
          payload: []
        });
      }
    }
    async function a(d) {
      d.data.type === "connect_result" && await s();
    }
    function f() {
      !e.activeAddress && !e.activeStrategy || (r({ type: "DISCONNECT" }), localStorage.removeItem(Sn));
    }
    s(), addEventListener("arweaveWalletLoaded", s), addEventListener("focus", s), addEventListener("message", a);
    let p;
    return n && (p = n.addAddressEvent(s)), () => {
      removeEventListener("arweaveWalletLoaded", s), removeEventListener("focus", s), removeEventListener("message", a), n && p && n.removeAddressEvent(p);
    };
  }, [n, i, r]);
}
function Zo() {
  const [t, e] = wt(!1), r = Gt(), n = Zh(), { state: i } = xt(), { permissions: o, ensurePermissions: s } = i.config;
  return Le(() => {
    if (!r)
      return e(!1);
    e(s ? Vo(o, n) : n.length > 0);
  }, [r, n, o, s]), t;
}
function Qh() {
  const t = Gt(), { dispatch: e } = xt(), r = Zo();
  async function n() {
    if (!t || !r)
      throw new Error("[Arweave Wallet Kit] Not yet connected");
    try {
      await t.disconnect(), localStorage.removeItem(Sn), e({ type: "DISCONNECT" });
    } catch (i) {
      throw new Error(
        `[Arweave Wallet Kit] Could not disconnect
` + ((i == null ? void 0 : i.message) || i)
      );
    }
  }
  return n;
}
function ed() {
  const { dispatch: t } = xt(), e = Zo();
  return () => new Promise((n, i) => {
    if (e)
      return i("[Arweave Wallet Kit] Already connected");
    t({
      type: "OPEN_MODAL",
      payload: "connect"
    });
    async function o(s) {
      s.data.type === "connect_result" && (removeEventListener("message", o), s.data.res ? n() : i("[Arweave Wallet Kit] User cancelled the connection"));
    }
    addEventListener("message", o);
  });
}
function Jo() {
  const t = Zo(), e = ed(), r = Qh();
  return {
    connected: t,
    connect: e,
    disconnect: r
  };
}
function td() {
  const { state: t, dispatch: e } = xt();
  return Le(() => {
    t.activeStrategy || t.activeModal !== "profile" || e({ type: "CLOSE_MODAL" });
  }, [t, e]), {
    setOpen(r) {
      if (!t.activeStrategy)
        throw new Error("[Arweave Wallet Kit] App not connected");
      e(r ? {
        type: "OPEN_MODAL",
        payload: "profile"
      } : { type: "CLOSE_MODAL" });
    },
    open: t.activeModal === "profile"
  };
}
var jn = {}, Qo = {}, vc = { exports: {} };
(function(t) {
  (function(e) {
    var r, n = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, i = Math.ceil, o = Math.floor, s = "[BigNumber Error] ", a = s + "Number primitive has more than 15 significant digits: ", f = 1e14, p = 14, d = 9007199254740991, y = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], v = 1e7, w = 1e9;
    function I(X) {
      var ne, ue, se, ie = G.prototype = { constructor: G, toString: null, valueOf: null }, O = new G(1), c = 20, m = 4, _ = -7, T = 21, C = -1e7, L = 1e7, H = !1, P = 1, l = 0, x = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: " ",
        // non-breaking space
        suffix: ""
      }, re = "0123456789abcdefghijklmnopqrstuvwxyz", ae = !0;
      function G(b, R) {
        var E, V, K, $, J, j, q, Z, ee = this;
        if (!(ee instanceof G))
          return new G(b, R);
        if (R == null) {
          if (b && b._isBigNumber === !0) {
            ee.s = b.s, !b.c || b.e > L ? ee.c = ee.e = null : b.e < C ? ee.c = [ee.e = 0] : (ee.e = b.e, ee.c = b.c.slice());
            return;
          }
          if ((j = typeof b == "number") && b * 0 == 0) {
            if (ee.s = 1 / b < 0 ? (b = -b, -1) : 1, b === ~~b) {
              for ($ = 0, J = b; J >= 10; J /= 10, $++)
                ;
              $ > L ? ee.c = ee.e = null : (ee.e = $, ee.c = [b]);
              return;
            }
            Z = String(b);
          } else {
            if (!n.test(Z = String(b)))
              return se(ee, Z, j);
            ee.s = Z.charCodeAt(0) == 45 ? (Z = Z.slice(1), -1) : 1;
          }
          ($ = Z.indexOf(".")) > -1 && (Z = Z.replace(".", "")), (J = Z.search(/e/i)) > 0 ? ($ < 0 && ($ = J), $ += +Z.slice(J + 1), Z = Z.substring(0, J)) : $ < 0 && ($ = Z.length);
        } else {
          if (S(R, 2, re.length, "Base"), R == 10 && ae)
            return ee = new G(b), xe(ee, c + ee.e + 1, m);
          if (Z = String(b), j = typeof b == "number") {
            if (b * 0 != 0)
              return se(ee, Z, j, R);
            if (ee.s = 1 / b < 0 ? (Z = Z.slice(1), -1) : 1, G.DEBUG && Z.replace(/^0\.0*|\./, "").length > 15)
              throw Error(a + b);
          } else
            ee.s = Z.charCodeAt(0) === 45 ? (Z = Z.slice(1), -1) : 1;
          for (E = re.slice(0, R), $ = J = 0, q = Z.length; J < q; J++)
            if (E.indexOf(V = Z.charAt(J)) < 0) {
              if (V == ".") {
                if (J > $) {
                  $ = q;
                  continue;
                }
              } else if (!K && (Z == Z.toUpperCase() && (Z = Z.toLowerCase()) || Z == Z.toLowerCase() && (Z = Z.toUpperCase()))) {
                K = !0, J = -1, $ = 0;
                continue;
              }
              return se(ee, String(b), j, R);
            }
          j = !1, Z = ue(Z, R, 10, ee.s), ($ = Z.indexOf(".")) > -1 ? Z = Z.replace(".", "") : $ = Z.length;
        }
        for (J = 0; Z.charCodeAt(J) === 48; J++)
          ;
        for (q = Z.length; Z.charCodeAt(--q) === 48; )
          ;
        if (Z = Z.slice(J, ++q)) {
          if (q -= J, j && G.DEBUG && q > 15 && (b > d || b !== o(b)))
            throw Error(a + ee.s * b);
          if (($ = $ - J - 1) > L)
            ee.c = ee.e = null;
          else if ($ < C)
            ee.c = [ee.e = 0];
          else {
            if (ee.e = $, ee.c = [], J = ($ + 1) % p, $ < 0 && (J += p), J < q) {
              for (J && ee.c.push(+Z.slice(0, J)), q -= p; J < q; )
                ee.c.push(+Z.slice(J, J += p));
              J = p - (Z = Z.slice(J)).length;
            } else
              J -= q;
            for (; J--; Z += "0")
              ;
            ee.c.push(+Z);
          }
        } else
          ee.c = [ee.e = 0];
      }
      G.clone = I, G.ROUND_UP = 0, G.ROUND_DOWN = 1, G.ROUND_CEIL = 2, G.ROUND_FLOOR = 3, G.ROUND_HALF_UP = 4, G.ROUND_HALF_DOWN = 5, G.ROUND_HALF_EVEN = 6, G.ROUND_HALF_CEIL = 7, G.ROUND_HALF_FLOOR = 8, G.EUCLID = 9, G.config = G.set = function(b) {
        var R, E;
        if (b != null)
          if (typeof b == "object") {
            if (b.hasOwnProperty(R = "DECIMAL_PLACES") && (E = b[R], S(E, 0, w, R), c = E), b.hasOwnProperty(R = "ROUNDING_MODE") && (E = b[R], S(E, 0, 8, R), m = E), b.hasOwnProperty(R = "EXPONENTIAL_AT") && (E = b[R], E && E.pop ? (S(E[0], -w, 0, R), S(E[1], 0, w, R), _ = E[0], T = E[1]) : (S(E, -w, w, R), _ = -(T = E < 0 ? -E : E))), b.hasOwnProperty(R = "RANGE"))
              if (E = b[R], E && E.pop)
                S(E[0], -w, -1, R), S(E[1], 1, w, R), C = E[0], L = E[1];
              else if (S(E, -w, w, R), E)
                C = -(L = E < 0 ? -E : E);
              else
                throw Error(s + R + " cannot be zero: " + E);
            if (b.hasOwnProperty(R = "CRYPTO"))
              if (E = b[R], E === !!E)
                if (E)
                  if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                    H = E;
                  else
                    throw H = !E, Error(s + "crypto unavailable");
                else
                  H = E;
              else
                throw Error(s + R + " not true or false: " + E);
            if (b.hasOwnProperty(R = "MODULO_MODE") && (E = b[R], S(E, 0, 9, R), P = E), b.hasOwnProperty(R = "POW_PRECISION") && (E = b[R], S(E, 0, w, R), l = E), b.hasOwnProperty(R = "FORMAT"))
              if (E = b[R], typeof E == "object")
                x = E;
              else
                throw Error(s + R + " not an object: " + E);
            if (b.hasOwnProperty(R = "ALPHABET"))
              if (E = b[R], typeof E == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(E))
                ae = E.slice(0, 10) == "0123456789", re = E;
              else
                throw Error(s + R + " invalid: " + E);
          } else
            throw Error(s + "Object expected: " + b);
        return {
          DECIMAL_PLACES: c,
          ROUNDING_MODE: m,
          EXPONENTIAL_AT: [_, T],
          RANGE: [C, L],
          CRYPTO: H,
          MODULO_MODE: P,
          POW_PRECISION: l,
          FORMAT: x,
          ALPHABET: re
        };
      }, G.isBigNumber = function(b) {
        if (!b || b._isBigNumber !== !0)
          return !1;
        if (!G.DEBUG)
          return !0;
        var R, E, V = b.c, K = b.e, $ = b.s;
        e:
          if ({}.toString.call(V) == "[object Array]") {
            if (($ === 1 || $ === -1) && K >= -w && K <= w && K === o(K)) {
              if (V[0] === 0) {
                if (K === 0 && V.length === 1)
                  return !0;
                break e;
              }
              if (R = (K + 1) % p, R < 1 && (R += p), String(V[0]).length == R) {
                for (R = 0; R < V.length; R++)
                  if (E = V[R], E < 0 || E >= f || E !== o(E))
                    break e;
                if (E !== 0)
                  return !0;
              }
            }
          } else if (V === null && K === null && ($ === null || $ === 1 || $ === -1))
            return !0;
        throw Error(s + "Invalid BigNumber: " + b);
      }, G.maximum = G.max = function() {
        return me(arguments, -1);
      }, G.minimum = G.min = function() {
        return me(arguments, 1);
      }, G.random = function() {
        var b = 9007199254740992, R = Math.random() * b & 2097151 ? function() {
          return o(Math.random() * b);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(E) {
          var V, K, $, J, j, q = 0, Z = [], ee = new G(O);
          if (E == null ? E = c : S(E, 0, w), J = i(E / p), H)
            if (crypto.getRandomValues) {
              for (V = crypto.getRandomValues(new Uint32Array(J *= 2)); q < J; )
                j = V[q] * 131072 + (V[q + 1] >>> 11), j >= 9e15 ? (K = crypto.getRandomValues(new Uint32Array(2)), V[q] = K[0], V[q + 1] = K[1]) : (Z.push(j % 1e14), q += 2);
              q = J / 2;
            } else if (crypto.randomBytes) {
              for (V = crypto.randomBytes(J *= 7); q < J; )
                j = (V[q] & 31) * 281474976710656 + V[q + 1] * 1099511627776 + V[q + 2] * 4294967296 + V[q + 3] * 16777216 + (V[q + 4] << 16) + (V[q + 5] << 8) + V[q + 6], j >= 9e15 ? crypto.randomBytes(7).copy(V, q) : (Z.push(j % 1e14), q += 7);
              q = J / 7;
            } else
              throw H = !1, Error(s + "crypto unavailable");
          if (!H)
            for (; q < J; )
              j = R(), j < 9e15 && (Z[q++] = j % 1e14);
          for (J = Z[--q], E %= p, J && E && (j = y[p - E], Z[q] = o(J / j) * j); Z[q] === 0; Z.pop(), q--)
            ;
          if (q < 0)
            Z = [$ = 0];
          else {
            for ($ = -1; Z[0] === 0; Z.splice(0, 1), $ -= p)
              ;
            for (q = 1, j = Z[0]; j >= 10; j /= 10, q++)
              ;
            q < p && ($ -= p - q);
          }
          return ee.e = $, ee.c = Z, ee;
        };
      }(), G.sum = function() {
        for (var b = 1, R = arguments, E = new G(R[0]); b < R.length; )
          E = E.plus(R[b++]);
        return E;
      }, ue = function() {
        var b = "0123456789";
        function R(E, V, K, $) {
          for (var J, j = [0], q, Z = 0, ee = E.length; Z < ee; ) {
            for (q = j.length; q--; j[q] *= V)
              ;
            for (j[0] += $.indexOf(E.charAt(Z++)), J = 0; J < j.length; J++)
              j[J] > K - 1 && (j[J + 1] == null && (j[J + 1] = 0), j[J + 1] += j[J] / K | 0, j[J] %= K);
          }
          return j.reverse();
        }
        return function(E, V, K, $, J) {
          var j, q, Z, ee, oe, de, Ee, Ae, U = E.indexOf("."), te = c, g = m;
          for (U >= 0 && (ee = l, l = 0, E = E.replace(".", ""), Ae = new G(V), de = Ae.pow(E.length - U), l = ee, Ae.c = R(
            Q(k(de.c), de.e, "0"),
            10,
            K,
            b
          ), Ae.e = Ae.c.length), Ee = R(E, V, K, J ? (j = re, b) : (j = b, re)), Z = ee = Ee.length; Ee[--ee] == 0; Ee.pop())
            ;
          if (!Ee[0])
            return j.charAt(0);
          if (U < 0 ? --Z : (de.c = Ee, de.e = Z, de.s = $, de = ne(de, Ae, te, g, K), Ee = de.c, oe = de.r, Z = de.e), q = Z + te + 1, U = Ee[q], ee = K / 2, oe = oe || q < 0 || Ee[q + 1] != null, oe = g < 4 ? (U != null || oe) && (g == 0 || g == (de.s < 0 ? 3 : 2)) : U > ee || U == ee && (g == 4 || oe || g == 6 && Ee[q - 1] & 1 || g == (de.s < 0 ? 8 : 7)), q < 1 || !Ee[0])
            E = oe ? Q(j.charAt(1), -te, j.charAt(0)) : j.charAt(0);
          else {
            if (Ee.length = q, oe)
              for (--K; ++Ee[--q] > K; )
                Ee[q] = 0, q || (++Z, Ee = [1].concat(Ee));
            for (ee = Ee.length; !Ee[--ee]; )
              ;
            for (U = 0, E = ""; U <= ee; E += j.charAt(Ee[U++]))
              ;
            E = Q(E, Z, j.charAt(0));
          }
          return E;
        };
      }(), ne = function() {
        function b(V, K, $) {
          var J, j, q, Z, ee = 0, oe = V.length, de = K % v, Ee = K / v | 0;
          for (V = V.slice(); oe--; )
            q = V[oe] % v, Z = V[oe] / v | 0, J = Ee * q + Z * de, j = de * q + J % v * v + ee, ee = (j / $ | 0) + (J / v | 0) + Ee * Z, V[oe] = j % $;
          return ee && (V = [ee].concat(V)), V;
        }
        function R(V, K, $, J) {
          var j, q;
          if ($ != J)
            q = $ > J ? 1 : -1;
          else
            for (j = q = 0; j < $; j++)
              if (V[j] != K[j]) {
                q = V[j] > K[j] ? 1 : -1;
                break;
              }
          return q;
        }
        function E(V, K, $, J) {
          for (var j = 0; $--; )
            V[$] -= j, j = V[$] < K[$] ? 1 : 0, V[$] = j * J + V[$] - K[$];
          for (; !V[0] && V.length > 1; V.splice(0, 1))
            ;
        }
        return function(V, K, $, J, j) {
          var q, Z, ee, oe, de, Ee, Ae, U, te, g, u, h, A, B, z, F, fe, we = V.s == K.s ? 1 : -1, _e = V.c, be = K.c;
          if (!_e || !_e[0] || !be || !be[0])
            return new G(
              // Return NaN if either NaN, or both Infinity or 0.
              !V.s || !K.s || (_e ? be && _e[0] == be[0] : !be) ? NaN : (
                // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                _e && _e[0] == 0 || !be ? we * 0 : we / 0
              )
            );
          for (U = new G(we), te = U.c = [], Z = V.e - K.e, we = $ + Z + 1, j || (j = f, Z = N(V.e / p) - N(K.e / p), we = we / p | 0), ee = 0; be[ee] == (_e[ee] || 0); ee++)
            ;
          if (be[ee] > (_e[ee] || 0) && Z--, we < 0)
            te.push(1), oe = !0;
          else {
            for (B = _e.length, F = be.length, ee = 0, we += 2, de = o(j / (be[0] + 1)), de > 1 && (be = b(be, de, j), _e = b(_e, de, j), F = be.length, B = _e.length), A = F, g = _e.slice(0, F), u = g.length; u < F; g[u++] = 0)
              ;
            fe = be.slice(), fe = [0].concat(fe), z = be[0], be[1] >= j / 2 && z++;
            do {
              if (de = 0, q = R(be, g, F, u), q < 0) {
                if (h = g[0], F != u && (h = h * j + (g[1] || 0)), de = o(h / z), de > 1)
                  for (de >= j && (de = j - 1), Ee = b(be, de, j), Ae = Ee.length, u = g.length; R(Ee, g, Ae, u) == 1; )
                    de--, E(Ee, F < Ae ? fe : be, Ae, j), Ae = Ee.length, q = 1;
                else
                  de == 0 && (q = de = 1), Ee = be.slice(), Ae = Ee.length;
                if (Ae < u && (Ee = [0].concat(Ee)), E(g, Ee, u, j), u = g.length, q == -1)
                  for (; R(be, g, F, u) < 1; )
                    de++, E(g, F < u ? fe : be, u, j), u = g.length;
              } else
                q === 0 && (de++, g = [0]);
              te[ee++] = de, g[0] ? g[u++] = _e[A] || 0 : (g = [_e[A]], u = 1);
            } while ((A++ < B || g[0] != null) && we--);
            oe = g[0] != null, te[0] || te.splice(0, 1);
          }
          if (j == f) {
            for (ee = 1, we = te[0]; we >= 10; we /= 10, ee++)
              ;
            xe(U, $ + (U.e = ee + Z * p - 1) + 1, J, oe);
          } else
            U.e = Z, U.r = +oe;
          return U;
        };
      }();
      function ce(b, R, E, V) {
        var K, $, J, j, q;
        if (E == null ? E = m : S(E, 0, 8), !b.c)
          return b.toString();
        if (K = b.c[0], J = b.e, R == null)
          q = k(b.c), q = V == 1 || V == 2 && (J <= _ || J >= T) ? W(q, J) : Q(q, J, "0");
        else if (b = xe(new G(b), R, E), $ = b.e, q = k(b.c), j = q.length, V == 1 || V == 2 && (R <= $ || $ <= _)) {
          for (; j < R; q += "0", j++)
            ;
          q = W(q, $);
        } else if (R -= J, q = Q(q, $, "0"), $ + 1 > j) {
          if (--R > 0)
            for (q += "."; R--; q += "0")
              ;
        } else if (R += $ - j, R > 0)
          for ($ + 1 == j && (q += "."); R--; q += "0")
            ;
        return b.s < 0 && K ? "-" + q : q;
      }
      function me(b, R) {
        for (var E, V, K = 1, $ = new G(b[0]); K < b.length; K++)
          V = new G(b[K]), (!V.s || (E = M($, V)) === R || E === 0 && $.s === R) && ($ = V);
        return $;
      }
      function ye(b, R, E) {
        for (var V = 1, K = R.length; !R[--K]; R.pop())
          ;
        for (K = R[0]; K >= 10; K /= 10, V++)
          ;
        return (E = V + E * p - 1) > L ? b.c = b.e = null : E < C ? b.c = [b.e = 0] : (b.e = E, b.c = R), b;
      }
      se = function() {
        var b = /^(-?)0([xbo])(?=\w[\w.]*$)/i, R = /^([^.]+)\.$/, E = /^\.([^.]+)$/, V = /^-?(Infinity|NaN)$/, K = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function($, J, j, q) {
          var Z, ee = j ? J : J.replace(K, "");
          if (V.test(ee))
            $.s = isNaN(ee) ? null : ee < 0 ? -1 : 1;
          else {
            if (!j && (ee = ee.replace(b, function(oe, de, Ee) {
              return Z = (Ee = Ee.toLowerCase()) == "x" ? 16 : Ee == "b" ? 2 : 8, !q || q == Z ? de : oe;
            }), q && (Z = q, ee = ee.replace(R, "$1").replace(E, "0.$1")), J != ee))
              return new G(ee, Z);
            if (G.DEBUG)
              throw Error(s + "Not a" + (q ? " base " + q : "") + " number: " + J);
            $.s = null;
          }
          $.c = $.e = null;
        };
      }();
      function xe(b, R, E, V) {
        var K, $, J, j, q, Z, ee, oe = b.c, de = y;
        if (oe) {
          e: {
            for (K = 1, j = oe[0]; j >= 10; j /= 10, K++)
              ;
            if ($ = R - K, $ < 0)
              $ += p, J = R, q = oe[Z = 0], ee = o(q / de[K - J - 1] % 10);
            else if (Z = i(($ + 1) / p), Z >= oe.length)
              if (V) {
                for (; oe.length <= Z; oe.push(0))
                  ;
                q = ee = 0, K = 1, $ %= p, J = $ - p + 1;
              } else
                break e;
            else {
              for (q = j = oe[Z], K = 1; j >= 10; j /= 10, K++)
                ;
              $ %= p, J = $ - p + K, ee = J < 0 ? 0 : o(q / de[K - J - 1] % 10);
            }
            if (V = V || R < 0 || // Are there any non-zero digits after the rounding digit?
            // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
            // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
            oe[Z + 1] != null || (J < 0 ? q : q % de[K - J - 1]), V = E < 4 ? (ee || V) && (E == 0 || E == (b.s < 0 ? 3 : 2)) : ee > 5 || ee == 5 && (E == 4 || V || E == 6 && // Check whether the digit to the left of the rounding digit is odd.
            ($ > 0 ? J > 0 ? q / de[K - J] : 0 : oe[Z - 1]) % 10 & 1 || E == (b.s < 0 ? 8 : 7)), R < 1 || !oe[0])
              return oe.length = 0, V ? (R -= b.e + 1, oe[0] = de[(p - R % p) % p], b.e = -R || 0) : oe[0] = b.e = 0, b;
            if ($ == 0 ? (oe.length = Z, j = 1, Z--) : (oe.length = Z + 1, j = de[p - $], oe[Z] = J > 0 ? o(q / de[K - J] % de[J]) * j : 0), V)
              for (; ; )
                if (Z == 0) {
                  for ($ = 1, J = oe[0]; J >= 10; J /= 10, $++)
                    ;
                  for (J = oe[0] += j, j = 1; J >= 10; J /= 10, j++)
                    ;
                  $ != j && (b.e++, oe[0] == f && (oe[0] = 1));
                  break;
                } else {
                  if (oe[Z] += j, oe[Z] != f)
                    break;
                  oe[Z--] = 0, j = 1;
                }
            for ($ = oe.length; oe[--$] === 0; oe.pop())
              ;
          }
          b.e > L ? b.c = b.e = null : b.e < C && (b.c = [b.e = 0]);
        }
        return b;
      }
      function ve(b) {
        var R, E = b.e;
        return E === null ? b.toString() : (R = k(b.c), R = E <= _ || E >= T ? W(R, E) : Q(R, E, "0"), b.s < 0 ? "-" + R : R);
      }
      return ie.absoluteValue = ie.abs = function() {
        var b = new G(this);
        return b.s < 0 && (b.s = 1), b;
      }, ie.comparedTo = function(b, R) {
        return M(this, new G(b, R));
      }, ie.decimalPlaces = ie.dp = function(b, R) {
        var E, V, K, $ = this;
        if (b != null)
          return S(b, 0, w), R == null ? R = m : S(R, 0, 8), xe(new G($), b + $.e + 1, R);
        if (!(E = $.c))
          return null;
        if (V = ((K = E.length - 1) - N(this.e / p)) * p, K = E[K])
          for (; K % 10 == 0; K /= 10, V--)
            ;
        return V < 0 && (V = 0), V;
      }, ie.dividedBy = ie.div = function(b, R) {
        return ne(this, new G(b, R), c, m);
      }, ie.dividedToIntegerBy = ie.idiv = function(b, R) {
        return ne(this, new G(b, R), 0, 1);
      }, ie.exponentiatedBy = ie.pow = function(b, R) {
        var E, V, K, $, J, j, q, Z, ee, oe = this;
        if (b = new G(b), b.c && !b.isInteger())
          throw Error(s + "Exponent not an integer: " + ve(b));
        if (R != null && (R = new G(R)), j = b.e > 14, !oe.c || !oe.c[0] || oe.c[0] == 1 && !oe.e && oe.c.length == 1 || !b.c || !b.c[0])
          return ee = new G(Math.pow(+ve(oe), j ? b.s * (2 - Y(b)) : +ve(b))), R ? ee.mod(R) : ee;
        if (q = b.s < 0, R) {
          if (R.c ? !R.c[0] : !R.s)
            return new G(NaN);
          V = !q && oe.isInteger() && R.isInteger(), V && (oe = oe.mod(R));
        } else {
          if (b.e > 9 && (oe.e > 0 || oe.e < -1 || (oe.e == 0 ? oe.c[0] > 1 || j && oe.c[1] >= 24e7 : oe.c[0] < 8e13 || j && oe.c[0] <= 9999975e7)))
            return $ = oe.s < 0 && Y(b) ? -0 : 0, oe.e > -1 && ($ = 1 / $), new G(q ? 1 / $ : $);
          l && ($ = i(l / p + 2));
        }
        for (j ? (E = new G(0.5), q && (b.s = 1), Z = Y(b)) : (K = Math.abs(+ve(b)), Z = K % 2), ee = new G(O); ; ) {
          if (Z) {
            if (ee = ee.times(oe), !ee.c)
              break;
            $ ? ee.c.length > $ && (ee.c.length = $) : V && (ee = ee.mod(R));
          }
          if (K) {
            if (K = o(K / 2), K === 0)
              break;
            Z = K % 2;
          } else if (b = b.times(E), xe(b, b.e + 1, 1), b.e > 14)
            Z = Y(b);
          else {
            if (K = +ve(b), K === 0)
              break;
            Z = K % 2;
          }
          oe = oe.times(oe), $ ? oe.c && oe.c.length > $ && (oe.c.length = $) : V && (oe = oe.mod(R));
        }
        return V ? ee : (q && (ee = O.div(ee)), R ? ee.mod(R) : $ ? xe(ee, l, m, J) : ee);
      }, ie.integerValue = function(b) {
        var R = new G(this);
        return b == null ? b = m : S(b, 0, 8), xe(R, R.e + 1, b);
      }, ie.isEqualTo = ie.eq = function(b, R) {
        return M(this, new G(b, R)) === 0;
      }, ie.isFinite = function() {
        return !!this.c;
      }, ie.isGreaterThan = ie.gt = function(b, R) {
        return M(this, new G(b, R)) > 0;
      }, ie.isGreaterThanOrEqualTo = ie.gte = function(b, R) {
        return (R = M(this, new G(b, R))) === 1 || R === 0;
      }, ie.isInteger = function() {
        return !!this.c && N(this.e / p) > this.c.length - 2;
      }, ie.isLessThan = ie.lt = function(b, R) {
        return M(this, new G(b, R)) < 0;
      }, ie.isLessThanOrEqualTo = ie.lte = function(b, R) {
        return (R = M(this, new G(b, R))) === -1 || R === 0;
      }, ie.isNaN = function() {
        return !this.s;
      }, ie.isNegative = function() {
        return this.s < 0;
      }, ie.isPositive = function() {
        return this.s > 0;
      }, ie.isZero = function() {
        return !!this.c && this.c[0] == 0;
      }, ie.minus = function(b, R) {
        var E, V, K, $, J = this, j = J.s;
        if (b = new G(b, R), R = b.s, !j || !R)
          return new G(NaN);
        if (j != R)
          return b.s = -R, J.plus(b);
        var q = J.e / p, Z = b.e / p, ee = J.c, oe = b.c;
        if (!q || !Z) {
          if (!ee || !oe)
            return ee ? (b.s = -R, b) : new G(oe ? J : NaN);
          if (!ee[0] || !oe[0])
            return oe[0] ? (b.s = -R, b) : new G(ee[0] ? J : (
              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
              m == 3 ? -0 : 0
            ));
        }
        if (q = N(q), Z = N(Z), ee = ee.slice(), j = q - Z) {
          for (($ = j < 0) ? (j = -j, K = ee) : (Z = q, K = oe), K.reverse(), R = j; R--; K.push(0))
            ;
          K.reverse();
        } else
          for (V = ($ = (j = ee.length) < (R = oe.length)) ? j : R, j = R = 0; R < V; R++)
            if (ee[R] != oe[R]) {
              $ = ee[R] < oe[R];
              break;
            }
        if ($ && (K = ee, ee = oe, oe = K, b.s = -b.s), R = (V = oe.length) - (E = ee.length), R > 0)
          for (; R--; ee[E++] = 0)
            ;
        for (R = f - 1; V > j; ) {
          if (ee[--V] < oe[V]) {
            for (E = V; E && !ee[--E]; ee[E] = R)
              ;
            --ee[E], ee[V] += f;
          }
          ee[V] -= oe[V];
        }
        for (; ee[0] == 0; ee.splice(0, 1), --Z)
          ;
        return ee[0] ? ye(b, ee, Z) : (b.s = m == 3 ? -1 : 1, b.c = [b.e = 0], b);
      }, ie.modulo = ie.mod = function(b, R) {
        var E, V, K = this;
        return b = new G(b, R), !K.c || !b.s || b.c && !b.c[0] ? new G(NaN) : !b.c || K.c && !K.c[0] ? new G(K) : (P == 9 ? (V = b.s, b.s = 1, E = ne(K, b, 0, 3), b.s = V, E.s *= V) : E = ne(K, b, 0, P), b = K.minus(E.times(b)), !b.c[0] && P == 1 && (b.s = K.s), b);
      }, ie.multipliedBy = ie.times = function(b, R) {
        var E, V, K, $, J, j, q, Z, ee, oe, de, Ee, Ae, U, te, g = this, u = g.c, h = (b = new G(b, R)).c;
        if (!u || !h || !u[0] || !h[0])
          return !g.s || !b.s || u && !u[0] && !h || h && !h[0] && !u ? b.c = b.e = b.s = null : (b.s *= g.s, !u || !h ? b.c = b.e = null : (b.c = [0], b.e = 0)), b;
        for (V = N(g.e / p) + N(b.e / p), b.s *= g.s, q = u.length, oe = h.length, q < oe && (Ae = u, u = h, h = Ae, K = q, q = oe, oe = K), K = q + oe, Ae = []; K--; Ae.push(0))
          ;
        for (U = f, te = v, K = oe; --K >= 0; ) {
          for (E = 0, de = h[K] % te, Ee = h[K] / te | 0, J = q, $ = K + J; $ > K; )
            Z = u[--J] % te, ee = u[J] / te | 0, j = Ee * Z + ee * de, Z = de * Z + j % te * te + Ae[$] + E, E = (Z / U | 0) + (j / te | 0) + Ee * ee, Ae[$--] = Z % U;
          Ae[$] = E;
        }
        return E ? ++V : Ae.splice(0, 1), ye(b, Ae, V);
      }, ie.negated = function() {
        var b = new G(this);
        return b.s = -b.s || null, b;
      }, ie.plus = function(b, R) {
        var E, V = this, K = V.s;
        if (b = new G(b, R), R = b.s, !K || !R)
          return new G(NaN);
        if (K != R)
          return b.s = -R, V.minus(b);
        var $ = V.e / p, J = b.e / p, j = V.c, q = b.c;
        if (!$ || !J) {
          if (!j || !q)
            return new G(K / 0);
          if (!j[0] || !q[0])
            return q[0] ? b : new G(j[0] ? V : K * 0);
        }
        if ($ = N($), J = N(J), j = j.slice(), K = $ - J) {
          for (K > 0 ? (J = $, E = q) : (K = -K, E = j), E.reverse(); K--; E.push(0))
            ;
          E.reverse();
        }
        for (K = j.length, R = q.length, K - R < 0 && (E = q, q = j, j = E, R = K), K = 0; R; )
          K = (j[--R] = j[R] + q[R] + K) / f | 0, j[R] = f === j[R] ? 0 : j[R] % f;
        return K && (j = [K].concat(j), ++J), ye(b, j, J);
      }, ie.precision = ie.sd = function(b, R) {
        var E, V, K, $ = this;
        if (b != null && b !== !!b)
          return S(b, 1, w), R == null ? R = m : S(R, 0, 8), xe(new G($), b, R);
        if (!(E = $.c))
          return null;
        if (K = E.length - 1, V = K * p + 1, K = E[K]) {
          for (; K % 10 == 0; K /= 10, V--)
            ;
          for (K = E[0]; K >= 10; K /= 10, V++)
            ;
        }
        return b && $.e + 1 > V && (V = $.e + 1), V;
      }, ie.shiftedBy = function(b) {
        return S(b, -d, d), this.times("1e" + b);
      }, ie.squareRoot = ie.sqrt = function() {
        var b, R, E, V, K, $ = this, J = $.c, j = $.s, q = $.e, Z = c + 4, ee = new G("0.5");
        if (j !== 1 || !J || !J[0])
          return new G(!j || j < 0 && (!J || J[0]) ? NaN : J ? $ : 1 / 0);
        if (j = Math.sqrt(+ve($)), j == 0 || j == 1 / 0 ? (R = k(J), (R.length + q) % 2 == 0 && (R += "0"), j = Math.sqrt(+R), q = N((q + 1) / 2) - (q < 0 || q % 2), j == 1 / 0 ? R = "5e" + q : (R = j.toExponential(), R = R.slice(0, R.indexOf("e") + 1) + q), E = new G(R)) : E = new G(j + ""), E.c[0]) {
          for (q = E.e, j = q + Z, j < 3 && (j = 0); ; )
            if (K = E, E = ee.times(K.plus(ne($, K, Z, 1))), k(K.c).slice(0, j) === (R = k(E.c)).slice(0, j))
              if (E.e < q && --j, R = R.slice(j - 3, j + 1), R == "9999" || !V && R == "4999") {
                if (!V && (xe(K, K.e + c + 2, 0), K.times(K).eq($))) {
                  E = K;
                  break;
                }
                Z += 4, j += 4, V = 1;
              } else {
                (!+R || !+R.slice(1) && R.charAt(0) == "5") && (xe(E, E.e + c + 2, 1), b = !E.times(E).eq($));
                break;
              }
        }
        return xe(E, E.e + c + 1, m, b);
      }, ie.toExponential = function(b, R) {
        return b != null && (S(b, 0, w), b++), ce(this, b, R, 1);
      }, ie.toFixed = function(b, R) {
        return b != null && (S(b, 0, w), b = b + this.e + 1), ce(this, b, R);
      }, ie.toFormat = function(b, R, E) {
        var V, K = this;
        if (E == null)
          b != null && R && typeof R == "object" ? (E = R, R = null) : b && typeof b == "object" ? (E = b, b = R = null) : E = x;
        else if (typeof E != "object")
          throw Error(s + "Argument not an object: " + E);
        if (V = K.toFixed(b, R), K.c) {
          var $, J = V.split("."), j = +E.groupSize, q = +E.secondaryGroupSize, Z = E.groupSeparator || "", ee = J[0], oe = J[1], de = K.s < 0, Ee = de ? ee.slice(1) : ee, Ae = Ee.length;
          if (q && ($ = j, j = q, q = $, Ae -= $), j > 0 && Ae > 0) {
            for ($ = Ae % j || j, ee = Ee.substr(0, $); $ < Ae; $ += j)
              ee += Z + Ee.substr($, j);
            q > 0 && (ee += Z + Ee.slice($)), de && (ee = "-" + ee);
          }
          V = oe ? ee + (E.decimalSeparator || "") + ((q = +E.fractionGroupSize) ? oe.replace(
            new RegExp("\\d{" + q + "}\\B", "g"),
            "$&" + (E.fractionGroupSeparator || "")
          ) : oe) : ee;
        }
        return (E.prefix || "") + V + (E.suffix || "");
      }, ie.toFraction = function(b) {
        var R, E, V, K, $, J, j, q, Z, ee, oe, de, Ee = this, Ae = Ee.c;
        if (b != null && (j = new G(b), !j.isInteger() && (j.c || j.s !== 1) || j.lt(O)))
          throw Error(s + "Argument " + (j.isInteger() ? "out of range: " : "not an integer: ") + ve(j));
        if (!Ae)
          return new G(Ee);
        for (R = new G(O), Z = E = new G(O), V = q = new G(O), de = k(Ae), $ = R.e = de.length - Ee.e - 1, R.c[0] = y[(J = $ % p) < 0 ? p + J : J], b = !b || j.comparedTo(R) > 0 ? $ > 0 ? R : Z : j, J = L, L = 1 / 0, j = new G(de), q.c[0] = 0; ee = ne(j, R, 0, 1), K = E.plus(ee.times(V)), K.comparedTo(b) != 1; )
          E = V, V = K, Z = q.plus(ee.times(K = Z)), q = K, R = j.minus(ee.times(K = R)), j = K;
        return K = ne(b.minus(E), V, 0, 1), q = q.plus(K.times(Z)), E = E.plus(K.times(V)), q.s = Z.s = Ee.s, $ = $ * 2, oe = ne(Z, V, $, m).minus(Ee).abs().comparedTo(
          ne(q, E, $, m).minus(Ee).abs()
        ) < 1 ? [Z, V] : [q, E], L = J, oe;
      }, ie.toNumber = function() {
        return +ve(this);
      }, ie.toPrecision = function(b, R) {
        return b != null && S(b, 1, w), ce(this, b, R, 2);
      }, ie.toString = function(b) {
        var R, E = this, V = E.s, K = E.e;
        return K === null ? V ? (R = "Infinity", V < 0 && (R = "-" + R)) : R = "NaN" : (b == null ? R = K <= _ || K >= T ? W(k(E.c), K) : Q(k(E.c), K, "0") : b === 10 && ae ? (E = xe(new G(E), c + K + 1, m), R = Q(k(E.c), E.e, "0")) : (S(b, 2, re.length, "Base"), R = ue(Q(k(E.c), K, "0"), 10, b, V, !0)), V < 0 && E.c[0] && (R = "-" + R)), R;
      }, ie.valueOf = ie.toJSON = function() {
        return ve(this);
      }, ie._isBigNumber = !0, X != null && G.set(X), G;
    }
    function N(X) {
      var ne = X | 0;
      return X > 0 || X === ne ? ne : ne - 1;
    }
    function k(X) {
      for (var ne, ue, se = 1, ie = X.length, O = X[0] + ""; se < ie; ) {
        for (ne = X[se++] + "", ue = p - ne.length; ue--; ne = "0" + ne)
          ;
        O += ne;
      }
      for (ie = O.length; O.charCodeAt(--ie) === 48; )
        ;
      return O.slice(0, ie + 1 || 1);
    }
    function M(X, ne) {
      var ue, se, ie = X.c, O = ne.c, c = X.s, m = ne.s, _ = X.e, T = ne.e;
      if (!c || !m)
        return null;
      if (ue = ie && !ie[0], se = O && !O[0], ue || se)
        return ue ? se ? 0 : -m : c;
      if (c != m)
        return c;
      if (ue = c < 0, se = _ == T, !ie || !O)
        return se ? 0 : !ie ^ ue ? 1 : -1;
      if (!se)
        return _ > T ^ ue ? 1 : -1;
      for (m = (_ = ie.length) < (T = O.length) ? _ : T, c = 0; c < m; c++)
        if (ie[c] != O[c])
          return ie[c] > O[c] ^ ue ? 1 : -1;
      return _ == T ? 0 : _ > T ^ ue ? 1 : -1;
    }
    function S(X, ne, ue, se) {
      if (X < ne || X > ue || X !== o(X))
        throw Error(s + (se || "Argument") + (typeof X == "number" ? X < ne || X > ue ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(X));
    }
    function Y(X) {
      var ne = X.c.length - 1;
      return N(X.e / p) == ne && X.c[ne] % 2 != 0;
    }
    function W(X, ne) {
      return (X.length > 1 ? X.charAt(0) + "." + X.slice(1) : X) + (ne < 0 ? "e" : "e+") + ne;
    }
    function Q(X, ne, ue) {
      var se, ie;
      if (ne < 0) {
        for (ie = ue + "."; ++ne; ie += ue)
          ;
        X = ie + X;
      } else if (se = X.length, ++ne > se) {
        for (ie = ue, ne -= se; --ne; ie += ue)
          ;
        X += ie;
      } else
        ne < se && (X = X.slice(0, ne) + "." + X.slice(ne));
      return X;
    }
    r = I(), r.default = r.BigNumber = r, t.exports ? t.exports = r : (e || (e = typeof self < "u" && self ? self : window), e.BigNumber = r);
  })(ge);
})(vc);
var rd = vc.exports;
Object.defineProperty(Qo, "__esModule", { value: !0 });
const nd = rd;
class id {
  constructor() {
    /**
     * Method to take a string value and return a bignumber object.
     *
     * @protected
     * @type {Function}
     * @memberof Arweave
     */
    pe(this, "BigNum");
    this.BigNum = (e, r) => {
      let n = nd.BigNumber.clone({ DECIMAL_PLACES: r });
      return new n(e);
    };
  }
  winstonToAr(e, { formatted: r = !1, decimals: n = 12, trim: i = !0 } = {}) {
    let o = this.stringToBigNum(e, n).shiftedBy(-12);
    return r ? o.toFormat(n) : o.toFixed(n);
  }
  arToWinston(e, { formatted: r = !1 } = {}) {
    let n = this.stringToBigNum(e).shiftedBy(12);
    return r ? n.toFormat() : n.toFixed(0);
  }
  compare(e, r) {
    let n = this.stringToBigNum(e), i = this.stringToBigNum(r);
    return n.comparedTo(i);
  }
  isEqual(e, r) {
    return this.compare(e, r) === 0;
  }
  isLessThan(e, r) {
    let n = this.stringToBigNum(e), i = this.stringToBigNum(r);
    return n.isLessThan(i);
  }
  isGreaterThan(e, r) {
    let n = this.stringToBigNum(e), i = this.stringToBigNum(r);
    return n.isGreaterThan(i);
  }
  add(e, r) {
    let n = this.stringToBigNum(e);
    return this.stringToBigNum(r), n.plus(r).toFixed(0);
  }
  sub(e, r) {
    let n = this.stringToBigNum(e);
    return this.stringToBigNum(r), n.minus(r).toFixed(0);
  }
  stringToBigNum(e, r = 12) {
    return this.BigNum(e, r);
  }
}
Qo.default = id;
var es = {};
Object.defineProperty(es, "__esModule", { value: !0 });
class od {
  constructor(e) {
    pe(this, "METHOD_GET", "GET");
    pe(this, "METHOD_POST", "POST");
    pe(this, "config");
    this.applyConfig(e);
  }
  applyConfig(e) {
    this.config = this.mergeDefaults(e);
  }
  getConfig() {
    return this.config;
  }
  mergeDefaults(e) {
    const r = e.protocol || "http", n = e.port || (r === "https" ? 443 : 80);
    return {
      host: e.host || "127.0.0.1",
      protocol: r,
      port: n,
      timeout: e.timeout || 2e4,
      logging: e.logging || !1,
      logger: e.logger || console.log,
      network: e.network
    };
  }
  async get(e, r) {
    return await this.request(e, { ...r, method: this.METHOD_GET });
  }
  async post(e, r, n) {
    var o;
    const i = new Headers((n == null ? void 0 : n.headers) || {});
    return (o = i.get("content-type")) != null && o.includes("application/json") || i.append("content-type", "application/json"), i.append("accept", "application/json, text/plain, */*"), await this.request(e, {
      ...n,
      method: this.METHOD_POST,
      body: typeof r != "string" ? JSON.stringify(r) : r,
      headers: i
    });
  }
  async request(e, r) {
    var y;
    const n = new Headers((r == null ? void 0 : r.headers) || {}), i = `${this.config.protocol}://${this.config.host}:${this.config.port}`, o = r == null ? void 0 : r.responseType;
    r == null || delete r.responseType, e.startsWith("/") && (e = e.slice(1)), this.config.network && n.append("x-network", this.config.network), this.config.logging && this.config.logger(`Requesting: ${i}/${e}`);
    let s = await fetch(`${i}/${e}`, {
      ...r || {},
      headers: n
    });
    this.config.logging && this.config.logger(`Response:   ${s.url} - ${s.status}`);
    const a = s.headers.get("content-type"), f = (y = a == null ? void 0 : a.match(/charset=([^()<>@,;:\"/[\]?.=\s]*)/i)) == null ? void 0 : y[1], p = s, d = async () => {
      if (f)
        try {
          p.data = new TextDecoder(f).decode(await s.arrayBuffer());
        } catch {
          p.data = await s.text();
        }
      else
        p.data = await s.text();
    };
    if (o === "arraybuffer")
      p.data = await s.arrayBuffer();
    else if (o === "text")
      await d();
    else if (o === "webstream")
      p.data = sd(s.body);
    else
      try {
        let v = await s.clone().json();
        typeof v != "object" ? await d() : p.data = await s.json(), v = null;
      } catch {
        await d();
      }
    return p;
  }
}
es.default = od;
const sd = (t) => {
  const e = t;
  return typeof e[Symbol.asyncIterator] > "u" && (e[Symbol.asyncIterator] = ad(t)), e;
}, ad = function(t) {
  return async function* () {
    const r = t.getReader();
    try {
      for (; ; ) {
        const { done: n, value: i } = await r.read();
        if (n)
          return;
        yield i;
      }
    } finally {
      r.releaseLock();
    }
  };
};
var ts = {}, gi = {}, wc = {}, rs = { exports: {} };
const ud = {}, cd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ud
}, Symbol.toStringTag, { value: "Module" })), _c = /* @__PURE__ */ lh(cd);
rs.exports;
(function(t) {
  (function(e, r) {
    function n(O, c) {
      if (!O)
        throw new Error(c || "Assertion failed");
    }
    function i(O, c) {
      O.super_ = c;
      var m = function() {
      };
      m.prototype = c.prototype, O.prototype = new m(), O.prototype.constructor = O;
    }
    function o(O, c, m) {
      if (o.isBN(O))
        return O;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, O !== null && ((c === "le" || c === "be") && (m = c, c = 10), this._init(O || 0, c || 10, m || "be"));
    }
    typeof e == "object" ? e.exports = o : r.BN = o, o.BN = o, o.wordSize = 26;
    var s;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? s = window.Buffer : s = _c.Buffer;
    } catch {
    }
    o.isBN = function(c) {
      return c instanceof o ? !0 : c !== null && typeof c == "object" && c.constructor.wordSize === o.wordSize && Array.isArray(c.words);
    }, o.max = function(c, m) {
      return c.cmp(m) > 0 ? c : m;
    }, o.min = function(c, m) {
      return c.cmp(m) < 0 ? c : m;
    }, o.prototype._init = function(c, m, _) {
      if (typeof c == "number")
        return this._initNumber(c, m, _);
      if (typeof c == "object")
        return this._initArray(c, m, _);
      m === "hex" && (m = 16), n(m === (m | 0) && m >= 2 && m <= 36), c = c.toString().replace(/\s+/g, "");
      var T = 0;
      c[0] === "-" && (T++, this.negative = 1), T < c.length && (m === 16 ? this._parseHex(c, T, _) : (this._parseBase(c, m, T), _ === "le" && this._initArray(this.toArray(), m, _)));
    }, o.prototype._initNumber = function(c, m, _) {
      c < 0 && (this.negative = 1, c = -c), c < 67108864 ? (this.words = [c & 67108863], this.length = 1) : c < 4503599627370496 ? (this.words = [
        c & 67108863,
        c / 67108864 & 67108863
      ], this.length = 2) : (n(c < 9007199254740992), this.words = [
        c & 67108863,
        c / 67108864 & 67108863,
        1
      ], this.length = 3), _ === "le" && this._initArray(this.toArray(), m, _);
    }, o.prototype._initArray = function(c, m, _) {
      if (n(typeof c.length == "number"), c.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(c.length / 3), this.words = new Array(this.length);
      for (var T = 0; T < this.length; T++)
        this.words[T] = 0;
      var C, L, H = 0;
      if (_ === "be")
        for (T = c.length - 1, C = 0; T >= 0; T -= 3)
          L = c[T] | c[T - 1] << 8 | c[T - 2] << 16, this.words[C] |= L << H & 67108863, this.words[C + 1] = L >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, C++);
      else if (_ === "le")
        for (T = 0, C = 0; T < c.length; T += 3)
          L = c[T] | c[T + 1] << 8 | c[T + 2] << 16, this.words[C] |= L << H & 67108863, this.words[C + 1] = L >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, C++);
      return this.strip();
    };
    function a(O, c) {
      var m = O.charCodeAt(c);
      return m >= 65 && m <= 70 ? m - 55 : m >= 97 && m <= 102 ? m - 87 : m - 48 & 15;
    }
    function f(O, c, m) {
      var _ = a(O, m);
      return m - 1 >= c && (_ |= a(O, m - 1) << 4), _;
    }
    o.prototype._parseHex = function(c, m, _) {
      this.length = Math.ceil((c.length - m) / 6), this.words = new Array(this.length);
      for (var T = 0; T < this.length; T++)
        this.words[T] = 0;
      var C = 0, L = 0, H;
      if (_ === "be")
        for (T = c.length - 1; T >= m; T -= 2)
          H = f(c, m, T) << C, this.words[L] |= H & 67108863, C >= 18 ? (C -= 18, L += 1, this.words[L] |= H >>> 26) : C += 8;
      else {
        var P = c.length - m;
        for (T = P % 2 === 0 ? m + 1 : m; T < c.length; T += 2)
          H = f(c, m, T) << C, this.words[L] |= H & 67108863, C >= 18 ? (C -= 18, L += 1, this.words[L] |= H >>> 26) : C += 8;
      }
      this.strip();
    };
    function p(O, c, m, _) {
      for (var T = 0, C = Math.min(O.length, m), L = c; L < C; L++) {
        var H = O.charCodeAt(L) - 48;
        T *= _, H >= 49 ? T += H - 49 + 10 : H >= 17 ? T += H - 17 + 10 : T += H;
      }
      return T;
    }
    o.prototype._parseBase = function(c, m, _) {
      this.words = [0], this.length = 1;
      for (var T = 0, C = 1; C <= 67108863; C *= m)
        T++;
      T--, C = C / m | 0;
      for (var L = c.length - _, H = L % T, P = Math.min(L, L - H) + _, l = 0, x = _; x < P; x += T)
        l = p(c, x, x + T, m), this.imuln(C), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      if (H !== 0) {
        var re = 1;
        for (l = p(c, x, c.length, m), x = 0; x < H; x++)
          re *= m;
        this.imuln(re), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      }
      this.strip();
    }, o.prototype.copy = function(c) {
      c.words = new Array(this.length);
      for (var m = 0; m < this.length; m++)
        c.words[m] = this.words[m];
      c.length = this.length, c.negative = this.negative, c.red = this.red;
    }, o.prototype.clone = function() {
      var c = new o(null);
      return this.copy(c), c;
    }, o.prototype._expand = function(c) {
      for (; this.length < c; )
        this.words[this.length++] = 0;
      return this;
    }, o.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, o.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, o.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var d = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], y = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], v = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    o.prototype.toString = function(c, m) {
      c = c || 10, m = m | 0 || 1;
      var _;
      if (c === 16 || c === "hex") {
        _ = "";
        for (var T = 0, C = 0, L = 0; L < this.length; L++) {
          var H = this.words[L], P = ((H << T | C) & 16777215).toString(16);
          C = H >>> 24 - T & 16777215, C !== 0 || L !== this.length - 1 ? _ = d[6 - P.length] + P + _ : _ = P + _, T += 2, T >= 26 && (T -= 26, L--);
        }
        for (C !== 0 && (_ = C.toString(16) + _); _.length % m !== 0; )
          _ = "0" + _;
        return this.negative !== 0 && (_ = "-" + _), _;
      }
      if (c === (c | 0) && c >= 2 && c <= 36) {
        var l = y[c], x = v[c];
        _ = "";
        var re = this.clone();
        for (re.negative = 0; !re.isZero(); ) {
          var ae = re.modn(x).toString(c);
          re = re.idivn(x), re.isZero() ? _ = ae + _ : _ = d[l - ae.length] + ae + _;
        }
        for (this.isZero() && (_ = "0" + _); _.length % m !== 0; )
          _ = "0" + _;
        return this.negative !== 0 && (_ = "-" + _), _;
      }
      n(!1, "Base should be between 2 and 36");
    }, o.prototype.toNumber = function() {
      var c = this.words[0];
      return this.length === 2 ? c += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? c += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -c : c;
    }, o.prototype.toJSON = function() {
      return this.toString(16);
    }, o.prototype.toBuffer = function(c, m) {
      return n(typeof s < "u"), this.toArrayLike(s, c, m);
    }, o.prototype.toArray = function(c, m) {
      return this.toArrayLike(Array, c, m);
    }, o.prototype.toArrayLike = function(c, m, _) {
      var T = this.byteLength(), C = _ || Math.max(1, T);
      n(T <= C, "byte array longer than desired length"), n(C > 0, "Requested array length <= 0"), this.strip();
      var L = m === "le", H = new c(C), P, l, x = this.clone();
      if (L) {
        for (l = 0; !x.isZero(); l++)
          P = x.andln(255), x.iushrn(8), H[l] = P;
        for (; l < C; l++)
          H[l] = 0;
      } else {
        for (l = 0; l < C - T; l++)
          H[l] = 0;
        for (l = 0; !x.isZero(); l++)
          P = x.andln(255), x.iushrn(8), H[C - l - 1] = P;
      }
      return H;
    }, Math.clz32 ? o.prototype._countBits = function(c) {
      return 32 - Math.clz32(c);
    } : o.prototype._countBits = function(c) {
      var m = c, _ = 0;
      return m >= 4096 && (_ += 13, m >>>= 13), m >= 64 && (_ += 7, m >>>= 7), m >= 8 && (_ += 4, m >>>= 4), m >= 2 && (_ += 2, m >>>= 2), _ + m;
    }, o.prototype._zeroBits = function(c) {
      if (c === 0)
        return 26;
      var m = c, _ = 0;
      return m & 8191 || (_ += 13, m >>>= 13), m & 127 || (_ += 7, m >>>= 7), m & 15 || (_ += 4, m >>>= 4), m & 3 || (_ += 2, m >>>= 2), m & 1 || _++, _;
    }, o.prototype.bitLength = function() {
      var c = this.words[this.length - 1], m = this._countBits(c);
      return (this.length - 1) * 26 + m;
    };
    function w(O) {
      for (var c = new Array(O.bitLength()), m = 0; m < c.length; m++) {
        var _ = m / 26 | 0, T = m % 26;
        c[m] = (O.words[_] & 1 << T) >>> T;
      }
      return c;
    }
    o.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var c = 0, m = 0; m < this.length; m++) {
        var _ = this._zeroBits(this.words[m]);
        if (c += _, _ !== 26)
          break;
      }
      return c;
    }, o.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, o.prototype.toTwos = function(c) {
      return this.negative !== 0 ? this.abs().inotn(c).iaddn(1) : this.clone();
    }, o.prototype.fromTwos = function(c) {
      return this.testn(c - 1) ? this.notn(c).iaddn(1).ineg() : this.clone();
    }, o.prototype.isNeg = function() {
      return this.negative !== 0;
    }, o.prototype.neg = function() {
      return this.clone().ineg();
    }, o.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, o.prototype.iuor = function(c) {
      for (; this.length < c.length; )
        this.words[this.length++] = 0;
      for (var m = 0; m < c.length; m++)
        this.words[m] = this.words[m] | c.words[m];
      return this.strip();
    }, o.prototype.ior = function(c) {
      return n((this.negative | c.negative) === 0), this.iuor(c);
    }, o.prototype.or = function(c) {
      return this.length > c.length ? this.clone().ior(c) : c.clone().ior(this);
    }, o.prototype.uor = function(c) {
      return this.length > c.length ? this.clone().iuor(c) : c.clone().iuor(this);
    }, o.prototype.iuand = function(c) {
      var m;
      this.length > c.length ? m = c : m = this;
      for (var _ = 0; _ < m.length; _++)
        this.words[_] = this.words[_] & c.words[_];
      return this.length = m.length, this.strip();
    }, o.prototype.iand = function(c) {
      return n((this.negative | c.negative) === 0), this.iuand(c);
    }, o.prototype.and = function(c) {
      return this.length > c.length ? this.clone().iand(c) : c.clone().iand(this);
    }, o.prototype.uand = function(c) {
      return this.length > c.length ? this.clone().iuand(c) : c.clone().iuand(this);
    }, o.prototype.iuxor = function(c) {
      var m, _;
      this.length > c.length ? (m = this, _ = c) : (m = c, _ = this);
      for (var T = 0; T < _.length; T++)
        this.words[T] = m.words[T] ^ _.words[T];
      if (this !== m)
        for (; T < m.length; T++)
          this.words[T] = m.words[T];
      return this.length = m.length, this.strip();
    }, o.prototype.ixor = function(c) {
      return n((this.negative | c.negative) === 0), this.iuxor(c);
    }, o.prototype.xor = function(c) {
      return this.length > c.length ? this.clone().ixor(c) : c.clone().ixor(this);
    }, o.prototype.uxor = function(c) {
      return this.length > c.length ? this.clone().iuxor(c) : c.clone().iuxor(this);
    }, o.prototype.inotn = function(c) {
      n(typeof c == "number" && c >= 0);
      var m = Math.ceil(c / 26) | 0, _ = c % 26;
      this._expand(m), _ > 0 && m--;
      for (var T = 0; T < m; T++)
        this.words[T] = ~this.words[T] & 67108863;
      return _ > 0 && (this.words[T] = ~this.words[T] & 67108863 >> 26 - _), this.strip();
    }, o.prototype.notn = function(c) {
      return this.clone().inotn(c);
    }, o.prototype.setn = function(c, m) {
      n(typeof c == "number" && c >= 0);
      var _ = c / 26 | 0, T = c % 26;
      return this._expand(_ + 1), m ? this.words[_] = this.words[_] | 1 << T : this.words[_] = this.words[_] & ~(1 << T), this.strip();
    }, o.prototype.iadd = function(c) {
      var m;
      if (this.negative !== 0 && c.negative === 0)
        return this.negative = 0, m = this.isub(c), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && c.negative !== 0)
        return c.negative = 0, m = this.isub(c), c.negative = 1, m._normSign();
      var _, T;
      this.length > c.length ? (_ = this, T = c) : (_ = c, T = this);
      for (var C = 0, L = 0; L < T.length; L++)
        m = (_.words[L] | 0) + (T.words[L] | 0) + C, this.words[L] = m & 67108863, C = m >>> 26;
      for (; C !== 0 && L < _.length; L++)
        m = (_.words[L] | 0) + C, this.words[L] = m & 67108863, C = m >>> 26;
      if (this.length = _.length, C !== 0)
        this.words[this.length] = C, this.length++;
      else if (_ !== this)
        for (; L < _.length; L++)
          this.words[L] = _.words[L];
      return this;
    }, o.prototype.add = function(c) {
      var m;
      return c.negative !== 0 && this.negative === 0 ? (c.negative = 0, m = this.sub(c), c.negative ^= 1, m) : c.negative === 0 && this.negative !== 0 ? (this.negative = 0, m = c.sub(this), this.negative = 1, m) : this.length > c.length ? this.clone().iadd(c) : c.clone().iadd(this);
    }, o.prototype.isub = function(c) {
      if (c.negative !== 0) {
        c.negative = 0;
        var m = this.iadd(c);
        return c.negative = 1, m._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(c), this.negative = 1, this._normSign();
      var _ = this.cmp(c);
      if (_ === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var T, C;
      _ > 0 ? (T = this, C = c) : (T = c, C = this);
      for (var L = 0, H = 0; H < C.length; H++)
        m = (T.words[H] | 0) - (C.words[H] | 0) + L, L = m >> 26, this.words[H] = m & 67108863;
      for (; L !== 0 && H < T.length; H++)
        m = (T.words[H] | 0) + L, L = m >> 26, this.words[H] = m & 67108863;
      if (L === 0 && H < T.length && T !== this)
        for (; H < T.length; H++)
          this.words[H] = T.words[H];
      return this.length = Math.max(this.length, H), T !== this && (this.negative = 1), this.strip();
    }, o.prototype.sub = function(c) {
      return this.clone().isub(c);
    };
    function I(O, c, m) {
      m.negative = c.negative ^ O.negative;
      var _ = O.length + c.length | 0;
      m.length = _, _ = _ - 1 | 0;
      var T = O.words[0] | 0, C = c.words[0] | 0, L = T * C, H = L & 67108863, P = L / 67108864 | 0;
      m.words[0] = H;
      for (var l = 1; l < _; l++) {
        for (var x = P >>> 26, re = P & 67108863, ae = Math.min(l, c.length - 1), G = Math.max(0, l - O.length + 1); G <= ae; G++) {
          var ce = l - G | 0;
          T = O.words[ce] | 0, C = c.words[G] | 0, L = T * C + re, x += L / 67108864 | 0, re = L & 67108863;
        }
        m.words[l] = re | 0, P = x | 0;
      }
      return P !== 0 ? m.words[l] = P | 0 : m.length--, m.strip();
    }
    var N = function(c, m, _) {
      var T = c.words, C = m.words, L = _.words, H = 0, P, l, x, re = T[0] | 0, ae = re & 8191, G = re >>> 13, ce = T[1] | 0, me = ce & 8191, ye = ce >>> 13, xe = T[2] | 0, ve = xe & 8191, b = xe >>> 13, R = T[3] | 0, E = R & 8191, V = R >>> 13, K = T[4] | 0, $ = K & 8191, J = K >>> 13, j = T[5] | 0, q = j & 8191, Z = j >>> 13, ee = T[6] | 0, oe = ee & 8191, de = ee >>> 13, Ee = T[7] | 0, Ae = Ee & 8191, U = Ee >>> 13, te = T[8] | 0, g = te & 8191, u = te >>> 13, h = T[9] | 0, A = h & 8191, B = h >>> 13, z = C[0] | 0, F = z & 8191, fe = z >>> 13, we = C[1] | 0, _e = we & 8191, be = we >>> 13, Be = C[2] | 0, qe = Be & 8191, Ye = Be >>> 13, Yt = C[3] | 0, We = Yt & 8191, He = Yt >>> 13, Xr = C[4] | 0, et = Xr & 8191, Xe = Xr >>> 13, Dn = C[5] | 0, Ze = Dn & 8191, Je = Dn >>> 13, Ln = C[6] | 0, tt = Ln & 8191, Qe = Ln >>> 13, Zr = C[7] | 0, rt = Zr & 8191, nt = Zr >>> 13, Nn = C[8] | 0, it = Nn & 8191, D = Nn >>> 13, le = C[9] | 0, he = le & 8191, Te = le >>> 13;
      _.negative = c.negative ^ m.negative, _.length = 19, P = Math.imul(ae, F), l = Math.imul(ae, fe), l = l + Math.imul(G, F) | 0, x = Math.imul(G, fe);
      var Ie = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, P = Math.imul(me, F), l = Math.imul(me, fe), l = l + Math.imul(ye, F) | 0, x = Math.imul(ye, fe), P = P + Math.imul(ae, _e) | 0, l = l + Math.imul(ae, be) | 0, l = l + Math.imul(G, _e) | 0, x = x + Math.imul(G, be) | 0;
      var De = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (De >>> 26) | 0, De &= 67108863, P = Math.imul(ve, F), l = Math.imul(ve, fe), l = l + Math.imul(b, F) | 0, x = Math.imul(b, fe), P = P + Math.imul(me, _e) | 0, l = l + Math.imul(me, be) | 0, l = l + Math.imul(ye, _e) | 0, x = x + Math.imul(ye, be) | 0, P = P + Math.imul(ae, qe) | 0, l = l + Math.imul(ae, Ye) | 0, l = l + Math.imul(G, qe) | 0, x = x + Math.imul(G, Ye) | 0;
      var Re = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, P = Math.imul(E, F), l = Math.imul(E, fe), l = l + Math.imul(V, F) | 0, x = Math.imul(V, fe), P = P + Math.imul(ve, _e) | 0, l = l + Math.imul(ve, be) | 0, l = l + Math.imul(b, _e) | 0, x = x + Math.imul(b, be) | 0, P = P + Math.imul(me, qe) | 0, l = l + Math.imul(me, Ye) | 0, l = l + Math.imul(ye, qe) | 0, x = x + Math.imul(ye, Ye) | 0, P = P + Math.imul(ae, We) | 0, l = l + Math.imul(ae, He) | 0, l = l + Math.imul(G, We) | 0, x = x + Math.imul(G, He) | 0;
      var Oe = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, P = Math.imul($, F), l = Math.imul($, fe), l = l + Math.imul(J, F) | 0, x = Math.imul(J, fe), P = P + Math.imul(E, _e) | 0, l = l + Math.imul(E, be) | 0, l = l + Math.imul(V, _e) | 0, x = x + Math.imul(V, be) | 0, P = P + Math.imul(ve, qe) | 0, l = l + Math.imul(ve, Ye) | 0, l = l + Math.imul(b, qe) | 0, x = x + Math.imul(b, Ye) | 0, P = P + Math.imul(me, We) | 0, l = l + Math.imul(me, He) | 0, l = l + Math.imul(ye, We) | 0, x = x + Math.imul(ye, He) | 0, P = P + Math.imul(ae, et) | 0, l = l + Math.imul(ae, Xe) | 0, l = l + Math.imul(G, et) | 0, x = x + Math.imul(G, Xe) | 0;
      var at = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, P = Math.imul(q, F), l = Math.imul(q, fe), l = l + Math.imul(Z, F) | 0, x = Math.imul(Z, fe), P = P + Math.imul($, _e) | 0, l = l + Math.imul($, be) | 0, l = l + Math.imul(J, _e) | 0, x = x + Math.imul(J, be) | 0, P = P + Math.imul(E, qe) | 0, l = l + Math.imul(E, Ye) | 0, l = l + Math.imul(V, qe) | 0, x = x + Math.imul(V, Ye) | 0, P = P + Math.imul(ve, We) | 0, l = l + Math.imul(ve, He) | 0, l = l + Math.imul(b, We) | 0, x = x + Math.imul(b, He) | 0, P = P + Math.imul(me, et) | 0, l = l + Math.imul(me, Xe) | 0, l = l + Math.imul(ye, et) | 0, x = x + Math.imul(ye, Xe) | 0, P = P + Math.imul(ae, Ze) | 0, l = l + Math.imul(ae, Je) | 0, l = l + Math.imul(G, Ze) | 0, x = x + Math.imul(G, Je) | 0;
      var Ve = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, P = Math.imul(oe, F), l = Math.imul(oe, fe), l = l + Math.imul(de, F) | 0, x = Math.imul(de, fe), P = P + Math.imul(q, _e) | 0, l = l + Math.imul(q, be) | 0, l = l + Math.imul(Z, _e) | 0, x = x + Math.imul(Z, be) | 0, P = P + Math.imul($, qe) | 0, l = l + Math.imul($, Ye) | 0, l = l + Math.imul(J, qe) | 0, x = x + Math.imul(J, Ye) | 0, P = P + Math.imul(E, We) | 0, l = l + Math.imul(E, He) | 0, l = l + Math.imul(V, We) | 0, x = x + Math.imul(V, He) | 0, P = P + Math.imul(ve, et) | 0, l = l + Math.imul(ve, Xe) | 0, l = l + Math.imul(b, et) | 0, x = x + Math.imul(b, Xe) | 0, P = P + Math.imul(me, Ze) | 0, l = l + Math.imul(me, Je) | 0, l = l + Math.imul(ye, Ze) | 0, x = x + Math.imul(ye, Je) | 0, P = P + Math.imul(ae, tt) | 0, l = l + Math.imul(ae, Qe) | 0, l = l + Math.imul(G, tt) | 0, x = x + Math.imul(G, Qe) | 0;
      var Ke = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, P = Math.imul(Ae, F), l = Math.imul(Ae, fe), l = l + Math.imul(U, F) | 0, x = Math.imul(U, fe), P = P + Math.imul(oe, _e) | 0, l = l + Math.imul(oe, be) | 0, l = l + Math.imul(de, _e) | 0, x = x + Math.imul(de, be) | 0, P = P + Math.imul(q, qe) | 0, l = l + Math.imul(q, Ye) | 0, l = l + Math.imul(Z, qe) | 0, x = x + Math.imul(Z, Ye) | 0, P = P + Math.imul($, We) | 0, l = l + Math.imul($, He) | 0, l = l + Math.imul(J, We) | 0, x = x + Math.imul(J, He) | 0, P = P + Math.imul(E, et) | 0, l = l + Math.imul(E, Xe) | 0, l = l + Math.imul(V, et) | 0, x = x + Math.imul(V, Xe) | 0, P = P + Math.imul(ve, Ze) | 0, l = l + Math.imul(ve, Je) | 0, l = l + Math.imul(b, Ze) | 0, x = x + Math.imul(b, Je) | 0, P = P + Math.imul(me, tt) | 0, l = l + Math.imul(me, Qe) | 0, l = l + Math.imul(ye, tt) | 0, x = x + Math.imul(ye, Qe) | 0, P = P + Math.imul(ae, rt) | 0, l = l + Math.imul(ae, nt) | 0, l = l + Math.imul(G, rt) | 0, x = x + Math.imul(G, nt) | 0;
      var yt = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, P = Math.imul(g, F), l = Math.imul(g, fe), l = l + Math.imul(u, F) | 0, x = Math.imul(u, fe), P = P + Math.imul(Ae, _e) | 0, l = l + Math.imul(Ae, be) | 0, l = l + Math.imul(U, _e) | 0, x = x + Math.imul(U, be) | 0, P = P + Math.imul(oe, qe) | 0, l = l + Math.imul(oe, Ye) | 0, l = l + Math.imul(de, qe) | 0, x = x + Math.imul(de, Ye) | 0, P = P + Math.imul(q, We) | 0, l = l + Math.imul(q, He) | 0, l = l + Math.imul(Z, We) | 0, x = x + Math.imul(Z, He) | 0, P = P + Math.imul($, et) | 0, l = l + Math.imul($, Xe) | 0, l = l + Math.imul(J, et) | 0, x = x + Math.imul(J, Xe) | 0, P = P + Math.imul(E, Ze) | 0, l = l + Math.imul(E, Je) | 0, l = l + Math.imul(V, Ze) | 0, x = x + Math.imul(V, Je) | 0, P = P + Math.imul(ve, tt) | 0, l = l + Math.imul(ve, Qe) | 0, l = l + Math.imul(b, tt) | 0, x = x + Math.imul(b, Qe) | 0, P = P + Math.imul(me, rt) | 0, l = l + Math.imul(me, nt) | 0, l = l + Math.imul(ye, rt) | 0, x = x + Math.imul(ye, nt) | 0, P = P + Math.imul(ae, it) | 0, l = l + Math.imul(ae, D) | 0, l = l + Math.imul(G, it) | 0, x = x + Math.imul(G, D) | 0;
      var Wt = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, P = Math.imul(A, F), l = Math.imul(A, fe), l = l + Math.imul(B, F) | 0, x = Math.imul(B, fe), P = P + Math.imul(g, _e) | 0, l = l + Math.imul(g, be) | 0, l = l + Math.imul(u, _e) | 0, x = x + Math.imul(u, be) | 0, P = P + Math.imul(Ae, qe) | 0, l = l + Math.imul(Ae, Ye) | 0, l = l + Math.imul(U, qe) | 0, x = x + Math.imul(U, Ye) | 0, P = P + Math.imul(oe, We) | 0, l = l + Math.imul(oe, He) | 0, l = l + Math.imul(de, We) | 0, x = x + Math.imul(de, He) | 0, P = P + Math.imul(q, et) | 0, l = l + Math.imul(q, Xe) | 0, l = l + Math.imul(Z, et) | 0, x = x + Math.imul(Z, Xe) | 0, P = P + Math.imul($, Ze) | 0, l = l + Math.imul($, Je) | 0, l = l + Math.imul(J, Ze) | 0, x = x + Math.imul(J, Je) | 0, P = P + Math.imul(E, tt) | 0, l = l + Math.imul(E, Qe) | 0, l = l + Math.imul(V, tt) | 0, x = x + Math.imul(V, Qe) | 0, P = P + Math.imul(ve, rt) | 0, l = l + Math.imul(ve, nt) | 0, l = l + Math.imul(b, rt) | 0, x = x + Math.imul(b, nt) | 0, P = P + Math.imul(me, it) | 0, l = l + Math.imul(me, D) | 0, l = l + Math.imul(ye, it) | 0, x = x + Math.imul(ye, D) | 0, P = P + Math.imul(ae, he) | 0, l = l + Math.imul(ae, Te) | 0, l = l + Math.imul(G, he) | 0, x = x + Math.imul(G, Te) | 0;
      var Ft = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, P = Math.imul(A, _e), l = Math.imul(A, be), l = l + Math.imul(B, _e) | 0, x = Math.imul(B, be), P = P + Math.imul(g, qe) | 0, l = l + Math.imul(g, Ye) | 0, l = l + Math.imul(u, qe) | 0, x = x + Math.imul(u, Ye) | 0, P = P + Math.imul(Ae, We) | 0, l = l + Math.imul(Ae, He) | 0, l = l + Math.imul(U, We) | 0, x = x + Math.imul(U, He) | 0, P = P + Math.imul(oe, et) | 0, l = l + Math.imul(oe, Xe) | 0, l = l + Math.imul(de, et) | 0, x = x + Math.imul(de, Xe) | 0, P = P + Math.imul(q, Ze) | 0, l = l + Math.imul(q, Je) | 0, l = l + Math.imul(Z, Ze) | 0, x = x + Math.imul(Z, Je) | 0, P = P + Math.imul($, tt) | 0, l = l + Math.imul($, Qe) | 0, l = l + Math.imul(J, tt) | 0, x = x + Math.imul(J, Qe) | 0, P = P + Math.imul(E, rt) | 0, l = l + Math.imul(E, nt) | 0, l = l + Math.imul(V, rt) | 0, x = x + Math.imul(V, nt) | 0, P = P + Math.imul(ve, it) | 0, l = l + Math.imul(ve, D) | 0, l = l + Math.imul(b, it) | 0, x = x + Math.imul(b, D) | 0, P = P + Math.imul(me, he) | 0, l = l + Math.imul(me, Te) | 0, l = l + Math.imul(ye, he) | 0, x = x + Math.imul(ye, Te) | 0;
      var ft = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, P = Math.imul(A, qe), l = Math.imul(A, Ye), l = l + Math.imul(B, qe) | 0, x = Math.imul(B, Ye), P = P + Math.imul(g, We) | 0, l = l + Math.imul(g, He) | 0, l = l + Math.imul(u, We) | 0, x = x + Math.imul(u, He) | 0, P = P + Math.imul(Ae, et) | 0, l = l + Math.imul(Ae, Xe) | 0, l = l + Math.imul(U, et) | 0, x = x + Math.imul(U, Xe) | 0, P = P + Math.imul(oe, Ze) | 0, l = l + Math.imul(oe, Je) | 0, l = l + Math.imul(de, Ze) | 0, x = x + Math.imul(de, Je) | 0, P = P + Math.imul(q, tt) | 0, l = l + Math.imul(q, Qe) | 0, l = l + Math.imul(Z, tt) | 0, x = x + Math.imul(Z, Qe) | 0, P = P + Math.imul($, rt) | 0, l = l + Math.imul($, nt) | 0, l = l + Math.imul(J, rt) | 0, x = x + Math.imul(J, nt) | 0, P = P + Math.imul(E, it) | 0, l = l + Math.imul(E, D) | 0, l = l + Math.imul(V, it) | 0, x = x + Math.imul(V, D) | 0, P = P + Math.imul(ve, he) | 0, l = l + Math.imul(ve, Te) | 0, l = l + Math.imul(b, he) | 0, x = x + Math.imul(b, Te) | 0;
      var fr = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (fr >>> 26) | 0, fr &= 67108863, P = Math.imul(A, We), l = Math.imul(A, He), l = l + Math.imul(B, We) | 0, x = Math.imul(B, He), P = P + Math.imul(g, et) | 0, l = l + Math.imul(g, Xe) | 0, l = l + Math.imul(u, et) | 0, x = x + Math.imul(u, Xe) | 0, P = P + Math.imul(Ae, Ze) | 0, l = l + Math.imul(Ae, Je) | 0, l = l + Math.imul(U, Ze) | 0, x = x + Math.imul(U, Je) | 0, P = P + Math.imul(oe, tt) | 0, l = l + Math.imul(oe, Qe) | 0, l = l + Math.imul(de, tt) | 0, x = x + Math.imul(de, Qe) | 0, P = P + Math.imul(q, rt) | 0, l = l + Math.imul(q, nt) | 0, l = l + Math.imul(Z, rt) | 0, x = x + Math.imul(Z, nt) | 0, P = P + Math.imul($, it) | 0, l = l + Math.imul($, D) | 0, l = l + Math.imul(J, it) | 0, x = x + Math.imul(J, D) | 0, P = P + Math.imul(E, he) | 0, l = l + Math.imul(E, Te) | 0, l = l + Math.imul(V, he) | 0, x = x + Math.imul(V, Te) | 0;
      var Jr = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, P = Math.imul(A, et), l = Math.imul(A, Xe), l = l + Math.imul(B, et) | 0, x = Math.imul(B, Xe), P = P + Math.imul(g, Ze) | 0, l = l + Math.imul(g, Je) | 0, l = l + Math.imul(u, Ze) | 0, x = x + Math.imul(u, Je) | 0, P = P + Math.imul(Ae, tt) | 0, l = l + Math.imul(Ae, Qe) | 0, l = l + Math.imul(U, tt) | 0, x = x + Math.imul(U, Qe) | 0, P = P + Math.imul(oe, rt) | 0, l = l + Math.imul(oe, nt) | 0, l = l + Math.imul(de, rt) | 0, x = x + Math.imul(de, nt) | 0, P = P + Math.imul(q, it) | 0, l = l + Math.imul(q, D) | 0, l = l + Math.imul(Z, it) | 0, x = x + Math.imul(Z, D) | 0, P = P + Math.imul($, he) | 0, l = l + Math.imul($, Te) | 0, l = l + Math.imul(J, he) | 0, x = x + Math.imul(J, Te) | 0;
      var Qr = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, P = Math.imul(A, Ze), l = Math.imul(A, Je), l = l + Math.imul(B, Ze) | 0, x = Math.imul(B, Je), P = P + Math.imul(g, tt) | 0, l = l + Math.imul(g, Qe) | 0, l = l + Math.imul(u, tt) | 0, x = x + Math.imul(u, Qe) | 0, P = P + Math.imul(Ae, rt) | 0, l = l + Math.imul(Ae, nt) | 0, l = l + Math.imul(U, rt) | 0, x = x + Math.imul(U, nt) | 0, P = P + Math.imul(oe, it) | 0, l = l + Math.imul(oe, D) | 0, l = l + Math.imul(de, it) | 0, x = x + Math.imul(de, D) | 0, P = P + Math.imul(q, he) | 0, l = l + Math.imul(q, Te) | 0, l = l + Math.imul(Z, he) | 0, x = x + Math.imul(Z, Te) | 0;
      var Ri = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (Ri >>> 26) | 0, Ri &= 67108863, P = Math.imul(A, tt), l = Math.imul(A, Qe), l = l + Math.imul(B, tt) | 0, x = Math.imul(B, Qe), P = P + Math.imul(g, rt) | 0, l = l + Math.imul(g, nt) | 0, l = l + Math.imul(u, rt) | 0, x = x + Math.imul(u, nt) | 0, P = P + Math.imul(Ae, it) | 0, l = l + Math.imul(Ae, D) | 0, l = l + Math.imul(U, it) | 0, x = x + Math.imul(U, D) | 0, P = P + Math.imul(oe, he) | 0, l = l + Math.imul(oe, Te) | 0, l = l + Math.imul(de, he) | 0, x = x + Math.imul(de, Te) | 0;
      var Ii = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (Ii >>> 26) | 0, Ii &= 67108863, P = Math.imul(A, rt), l = Math.imul(A, nt), l = l + Math.imul(B, rt) | 0, x = Math.imul(B, nt), P = P + Math.imul(g, it) | 0, l = l + Math.imul(g, D) | 0, l = l + Math.imul(u, it) | 0, x = x + Math.imul(u, D) | 0, P = P + Math.imul(Ae, he) | 0, l = l + Math.imul(Ae, Te) | 0, l = l + Math.imul(U, he) | 0, x = x + Math.imul(U, Te) | 0;
      var Bi = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (Bi >>> 26) | 0, Bi &= 67108863, P = Math.imul(A, it), l = Math.imul(A, D), l = l + Math.imul(B, it) | 0, x = Math.imul(B, D), P = P + Math.imul(g, he) | 0, l = l + Math.imul(g, Te) | 0, l = l + Math.imul(u, he) | 0, x = x + Math.imul(u, Te) | 0;
      var ki = (H + P | 0) + ((l & 8191) << 13) | 0;
      H = (x + (l >>> 13) | 0) + (ki >>> 26) | 0, ki &= 67108863, P = Math.imul(A, he), l = Math.imul(A, Te), l = l + Math.imul(B, he) | 0, x = Math.imul(B, Te);
      var Di = (H + P | 0) + ((l & 8191) << 13) | 0;
      return H = (x + (l >>> 13) | 0) + (Di >>> 26) | 0, Di &= 67108863, L[0] = Ie, L[1] = De, L[2] = Re, L[3] = Oe, L[4] = at, L[5] = Ve, L[6] = Ke, L[7] = yt, L[8] = Wt, L[9] = Ft, L[10] = ft, L[11] = fr, L[12] = Jr, L[13] = Qr, L[14] = Ri, L[15] = Ii, L[16] = Bi, L[17] = ki, L[18] = Di, H !== 0 && (L[19] = H, _.length++), _;
    };
    Math.imul || (N = I);
    function k(O, c, m) {
      m.negative = c.negative ^ O.negative, m.length = O.length + c.length;
      for (var _ = 0, T = 0, C = 0; C < m.length - 1; C++) {
        var L = T;
        T = 0;
        for (var H = _ & 67108863, P = Math.min(C, c.length - 1), l = Math.max(0, C - O.length + 1); l <= P; l++) {
          var x = C - l, re = O.words[x] | 0, ae = c.words[l] | 0, G = re * ae, ce = G & 67108863;
          L = L + (G / 67108864 | 0) | 0, ce = ce + H | 0, H = ce & 67108863, L = L + (ce >>> 26) | 0, T += L >>> 26, L &= 67108863;
        }
        m.words[C] = H, _ = L, L = T;
      }
      return _ !== 0 ? m.words[C] = _ : m.length--, m.strip();
    }
    function M(O, c, m) {
      var _ = new S();
      return _.mulp(O, c, m);
    }
    o.prototype.mulTo = function(c, m) {
      var _, T = this.length + c.length;
      return this.length === 10 && c.length === 10 ? _ = N(this, c, m) : T < 63 ? _ = I(this, c, m) : T < 1024 ? _ = k(this, c, m) : _ = M(this, c, m), _;
    };
    function S(O, c) {
      this.x = O, this.y = c;
    }
    S.prototype.makeRBT = function(c) {
      for (var m = new Array(c), _ = o.prototype._countBits(c) - 1, T = 0; T < c; T++)
        m[T] = this.revBin(T, _, c);
      return m;
    }, S.prototype.revBin = function(c, m, _) {
      if (c === 0 || c === _ - 1)
        return c;
      for (var T = 0, C = 0; C < m; C++)
        T |= (c & 1) << m - C - 1, c >>= 1;
      return T;
    }, S.prototype.permute = function(c, m, _, T, C, L) {
      for (var H = 0; H < L; H++)
        T[H] = m[c[H]], C[H] = _[c[H]];
    }, S.prototype.transform = function(c, m, _, T, C, L) {
      this.permute(L, c, m, _, T, C);
      for (var H = 1; H < C; H <<= 1)
        for (var P = H << 1, l = Math.cos(2 * Math.PI / P), x = Math.sin(2 * Math.PI / P), re = 0; re < C; re += P)
          for (var ae = l, G = x, ce = 0; ce < H; ce++) {
            var me = _[re + ce], ye = T[re + ce], xe = _[re + ce + H], ve = T[re + ce + H], b = ae * xe - G * ve;
            ve = ae * ve + G * xe, xe = b, _[re + ce] = me + xe, T[re + ce] = ye + ve, _[re + ce + H] = me - xe, T[re + ce + H] = ye - ve, ce !== P && (b = l * ae - x * G, G = l * G + x * ae, ae = b);
          }
    }, S.prototype.guessLen13b = function(c, m) {
      var _ = Math.max(m, c) | 1, T = _ & 1, C = 0;
      for (_ = _ / 2 | 0; _; _ = _ >>> 1)
        C++;
      return 1 << C + 1 + T;
    }, S.prototype.conjugate = function(c, m, _) {
      if (!(_ <= 1))
        for (var T = 0; T < _ / 2; T++) {
          var C = c[T];
          c[T] = c[_ - T - 1], c[_ - T - 1] = C, C = m[T], m[T] = -m[_ - T - 1], m[_ - T - 1] = -C;
        }
    }, S.prototype.normalize13b = function(c, m) {
      for (var _ = 0, T = 0; T < m / 2; T++) {
        var C = Math.round(c[2 * T + 1] / m) * 8192 + Math.round(c[2 * T] / m) + _;
        c[T] = C & 67108863, C < 67108864 ? _ = 0 : _ = C / 67108864 | 0;
      }
      return c;
    }, S.prototype.convert13b = function(c, m, _, T) {
      for (var C = 0, L = 0; L < m; L++)
        C = C + (c[L] | 0), _[2 * L] = C & 8191, C = C >>> 13, _[2 * L + 1] = C & 8191, C = C >>> 13;
      for (L = 2 * m; L < T; ++L)
        _[L] = 0;
      n(C === 0), n((C & -8192) === 0);
    }, S.prototype.stub = function(c) {
      for (var m = new Array(c), _ = 0; _ < c; _++)
        m[_] = 0;
      return m;
    }, S.prototype.mulp = function(c, m, _) {
      var T = 2 * this.guessLen13b(c.length, m.length), C = this.makeRBT(T), L = this.stub(T), H = new Array(T), P = new Array(T), l = new Array(T), x = new Array(T), re = new Array(T), ae = new Array(T), G = _.words;
      G.length = T, this.convert13b(c.words, c.length, H, T), this.convert13b(m.words, m.length, x, T), this.transform(H, L, P, l, T, C), this.transform(x, L, re, ae, T, C);
      for (var ce = 0; ce < T; ce++) {
        var me = P[ce] * re[ce] - l[ce] * ae[ce];
        l[ce] = P[ce] * ae[ce] + l[ce] * re[ce], P[ce] = me;
      }
      return this.conjugate(P, l, T), this.transform(P, l, G, L, T, C), this.conjugate(G, L, T), this.normalize13b(G, T), _.negative = c.negative ^ m.negative, _.length = c.length + m.length, _.strip();
    }, o.prototype.mul = function(c) {
      var m = new o(null);
      return m.words = new Array(this.length + c.length), this.mulTo(c, m);
    }, o.prototype.mulf = function(c) {
      var m = new o(null);
      return m.words = new Array(this.length + c.length), M(this, c, m);
    }, o.prototype.imul = function(c) {
      return this.clone().mulTo(c, this);
    }, o.prototype.imuln = function(c) {
      n(typeof c == "number"), n(c < 67108864);
      for (var m = 0, _ = 0; _ < this.length; _++) {
        var T = (this.words[_] | 0) * c, C = (T & 67108863) + (m & 67108863);
        m >>= 26, m += T / 67108864 | 0, m += C >>> 26, this.words[_] = C & 67108863;
      }
      return m !== 0 && (this.words[_] = m, this.length++), this;
    }, o.prototype.muln = function(c) {
      return this.clone().imuln(c);
    }, o.prototype.sqr = function() {
      return this.mul(this);
    }, o.prototype.isqr = function() {
      return this.imul(this.clone());
    }, o.prototype.pow = function(c) {
      var m = w(c);
      if (m.length === 0)
        return new o(1);
      for (var _ = this, T = 0; T < m.length && m[T] === 0; T++, _ = _.sqr())
        ;
      if (++T < m.length)
        for (var C = _.sqr(); T < m.length; T++, C = C.sqr())
          m[T] !== 0 && (_ = _.mul(C));
      return _;
    }, o.prototype.iushln = function(c) {
      n(typeof c == "number" && c >= 0);
      var m = c % 26, _ = (c - m) / 26, T = 67108863 >>> 26 - m << 26 - m, C;
      if (m !== 0) {
        var L = 0;
        for (C = 0; C < this.length; C++) {
          var H = this.words[C] & T, P = (this.words[C] | 0) - H << m;
          this.words[C] = P | L, L = H >>> 26 - m;
        }
        L && (this.words[C] = L, this.length++);
      }
      if (_ !== 0) {
        for (C = this.length - 1; C >= 0; C--)
          this.words[C + _] = this.words[C];
        for (C = 0; C < _; C++)
          this.words[C] = 0;
        this.length += _;
      }
      return this.strip();
    }, o.prototype.ishln = function(c) {
      return n(this.negative === 0), this.iushln(c);
    }, o.prototype.iushrn = function(c, m, _) {
      n(typeof c == "number" && c >= 0);
      var T;
      m ? T = (m - m % 26) / 26 : T = 0;
      var C = c % 26, L = Math.min((c - C) / 26, this.length), H = 67108863 ^ 67108863 >>> C << C, P = _;
      if (T -= L, T = Math.max(0, T), P) {
        for (var l = 0; l < L; l++)
          P.words[l] = this.words[l];
        P.length = L;
      }
      if (L !== 0)
        if (this.length > L)
          for (this.length -= L, l = 0; l < this.length; l++)
            this.words[l] = this.words[l + L];
        else
          this.words[0] = 0, this.length = 1;
      var x = 0;
      for (l = this.length - 1; l >= 0 && (x !== 0 || l >= T); l--) {
        var re = this.words[l] | 0;
        this.words[l] = x << 26 - C | re >>> C, x = re & H;
      }
      return P && x !== 0 && (P.words[P.length++] = x), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, o.prototype.ishrn = function(c, m, _) {
      return n(this.negative === 0), this.iushrn(c, m, _);
    }, o.prototype.shln = function(c) {
      return this.clone().ishln(c);
    }, o.prototype.ushln = function(c) {
      return this.clone().iushln(c);
    }, o.prototype.shrn = function(c) {
      return this.clone().ishrn(c);
    }, o.prototype.ushrn = function(c) {
      return this.clone().iushrn(c);
    }, o.prototype.testn = function(c) {
      n(typeof c == "number" && c >= 0);
      var m = c % 26, _ = (c - m) / 26, T = 1 << m;
      if (this.length <= _)
        return !1;
      var C = this.words[_];
      return !!(C & T);
    }, o.prototype.imaskn = function(c) {
      n(typeof c == "number" && c >= 0);
      var m = c % 26, _ = (c - m) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= _)
        return this;
      if (m !== 0 && _++, this.length = Math.min(_, this.length), m !== 0) {
        var T = 67108863 ^ 67108863 >>> m << m;
        this.words[this.length - 1] &= T;
      }
      return this.strip();
    }, o.prototype.maskn = function(c) {
      return this.clone().imaskn(c);
    }, o.prototype.iaddn = function(c) {
      return n(typeof c == "number"), n(c < 67108864), c < 0 ? this.isubn(-c) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < c ? (this.words[0] = c - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(c), this.negative = 1, this) : this._iaddn(c);
    }, o.prototype._iaddn = function(c) {
      this.words[0] += c;
      for (var m = 0; m < this.length && this.words[m] >= 67108864; m++)
        this.words[m] -= 67108864, m === this.length - 1 ? this.words[m + 1] = 1 : this.words[m + 1]++;
      return this.length = Math.max(this.length, m + 1), this;
    }, o.prototype.isubn = function(c) {
      if (n(typeof c == "number"), n(c < 67108864), c < 0)
        return this.iaddn(-c);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(c), this.negative = 1, this;
      if (this.words[0] -= c, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var m = 0; m < this.length && this.words[m] < 0; m++)
          this.words[m] += 67108864, this.words[m + 1] -= 1;
      return this.strip();
    }, o.prototype.addn = function(c) {
      return this.clone().iaddn(c);
    }, o.prototype.subn = function(c) {
      return this.clone().isubn(c);
    }, o.prototype.iabs = function() {
      return this.negative = 0, this;
    }, o.prototype.abs = function() {
      return this.clone().iabs();
    }, o.prototype._ishlnsubmul = function(c, m, _) {
      var T = c.length + _, C;
      this._expand(T);
      var L, H = 0;
      for (C = 0; C < c.length; C++) {
        L = (this.words[C + _] | 0) + H;
        var P = (c.words[C] | 0) * m;
        L -= P & 67108863, H = (L >> 26) - (P / 67108864 | 0), this.words[C + _] = L & 67108863;
      }
      for (; C < this.length - _; C++)
        L = (this.words[C + _] | 0) + H, H = L >> 26, this.words[C + _] = L & 67108863;
      if (H === 0)
        return this.strip();
      for (n(H === -1), H = 0, C = 0; C < this.length; C++)
        L = -(this.words[C] | 0) + H, H = L >> 26, this.words[C] = L & 67108863;
      return this.negative = 1, this.strip();
    }, o.prototype._wordDiv = function(c, m) {
      var _ = this.length - c.length, T = this.clone(), C = c, L = C.words[C.length - 1] | 0, H = this._countBits(L);
      _ = 26 - H, _ !== 0 && (C = C.ushln(_), T.iushln(_), L = C.words[C.length - 1] | 0);
      var P = T.length - C.length, l;
      if (m !== "mod") {
        l = new o(null), l.length = P + 1, l.words = new Array(l.length);
        for (var x = 0; x < l.length; x++)
          l.words[x] = 0;
      }
      var re = T.clone()._ishlnsubmul(C, 1, P);
      re.negative === 0 && (T = re, l && (l.words[P] = 1));
      for (var ae = P - 1; ae >= 0; ae--) {
        var G = (T.words[C.length + ae] | 0) * 67108864 + (T.words[C.length + ae - 1] | 0);
        for (G = Math.min(G / L | 0, 67108863), T._ishlnsubmul(C, G, ae); T.negative !== 0; )
          G--, T.negative = 0, T._ishlnsubmul(C, 1, ae), T.isZero() || (T.negative ^= 1);
        l && (l.words[ae] = G);
      }
      return l && l.strip(), T.strip(), m !== "div" && _ !== 0 && T.iushrn(_), {
        div: l || null,
        mod: T
      };
    }, o.prototype.divmod = function(c, m, _) {
      if (n(!c.isZero()), this.isZero())
        return {
          div: new o(0),
          mod: new o(0)
        };
      var T, C, L;
      return this.negative !== 0 && c.negative === 0 ? (L = this.neg().divmod(c, m), m !== "mod" && (T = L.div.neg()), m !== "div" && (C = L.mod.neg(), _ && C.negative !== 0 && C.iadd(c)), {
        div: T,
        mod: C
      }) : this.negative === 0 && c.negative !== 0 ? (L = this.divmod(c.neg(), m), m !== "mod" && (T = L.div.neg()), {
        div: T,
        mod: L.mod
      }) : this.negative & c.negative ? (L = this.neg().divmod(c.neg(), m), m !== "div" && (C = L.mod.neg(), _ && C.negative !== 0 && C.isub(c)), {
        div: L.div,
        mod: C
      }) : c.length > this.length || this.cmp(c) < 0 ? {
        div: new o(0),
        mod: this
      } : c.length === 1 ? m === "div" ? {
        div: this.divn(c.words[0]),
        mod: null
      } : m === "mod" ? {
        div: null,
        mod: new o(this.modn(c.words[0]))
      } : {
        div: this.divn(c.words[0]),
        mod: new o(this.modn(c.words[0]))
      } : this._wordDiv(c, m);
    }, o.prototype.div = function(c) {
      return this.divmod(c, "div", !1).div;
    }, o.prototype.mod = function(c) {
      return this.divmod(c, "mod", !1).mod;
    }, o.prototype.umod = function(c) {
      return this.divmod(c, "mod", !0).mod;
    }, o.prototype.divRound = function(c) {
      var m = this.divmod(c);
      if (m.mod.isZero())
        return m.div;
      var _ = m.div.negative !== 0 ? m.mod.isub(c) : m.mod, T = c.ushrn(1), C = c.andln(1), L = _.cmp(T);
      return L < 0 || C === 1 && L === 0 ? m.div : m.div.negative !== 0 ? m.div.isubn(1) : m.div.iaddn(1);
    }, o.prototype.modn = function(c) {
      n(c <= 67108863);
      for (var m = (1 << 26) % c, _ = 0, T = this.length - 1; T >= 0; T--)
        _ = (m * _ + (this.words[T] | 0)) % c;
      return _;
    }, o.prototype.idivn = function(c) {
      n(c <= 67108863);
      for (var m = 0, _ = this.length - 1; _ >= 0; _--) {
        var T = (this.words[_] | 0) + m * 67108864;
        this.words[_] = T / c | 0, m = T % c;
      }
      return this.strip();
    }, o.prototype.divn = function(c) {
      return this.clone().idivn(c);
    }, o.prototype.egcd = function(c) {
      n(c.negative === 0), n(!c.isZero());
      var m = this, _ = c.clone();
      m.negative !== 0 ? m = m.umod(c) : m = m.clone();
      for (var T = new o(1), C = new o(0), L = new o(0), H = new o(1), P = 0; m.isEven() && _.isEven(); )
        m.iushrn(1), _.iushrn(1), ++P;
      for (var l = _.clone(), x = m.clone(); !m.isZero(); ) {
        for (var re = 0, ae = 1; !(m.words[0] & ae) && re < 26; ++re, ae <<= 1)
          ;
        if (re > 0)
          for (m.iushrn(re); re-- > 0; )
            (T.isOdd() || C.isOdd()) && (T.iadd(l), C.isub(x)), T.iushrn(1), C.iushrn(1);
        for (var G = 0, ce = 1; !(_.words[0] & ce) && G < 26; ++G, ce <<= 1)
          ;
        if (G > 0)
          for (_.iushrn(G); G-- > 0; )
            (L.isOdd() || H.isOdd()) && (L.iadd(l), H.isub(x)), L.iushrn(1), H.iushrn(1);
        m.cmp(_) >= 0 ? (m.isub(_), T.isub(L), C.isub(H)) : (_.isub(m), L.isub(T), H.isub(C));
      }
      return {
        a: L,
        b: H,
        gcd: _.iushln(P)
      };
    }, o.prototype._invmp = function(c) {
      n(c.negative === 0), n(!c.isZero());
      var m = this, _ = c.clone();
      m.negative !== 0 ? m = m.umod(c) : m = m.clone();
      for (var T = new o(1), C = new o(0), L = _.clone(); m.cmpn(1) > 0 && _.cmpn(1) > 0; ) {
        for (var H = 0, P = 1; !(m.words[0] & P) && H < 26; ++H, P <<= 1)
          ;
        if (H > 0)
          for (m.iushrn(H); H-- > 0; )
            T.isOdd() && T.iadd(L), T.iushrn(1);
        for (var l = 0, x = 1; !(_.words[0] & x) && l < 26; ++l, x <<= 1)
          ;
        if (l > 0)
          for (_.iushrn(l); l-- > 0; )
            C.isOdd() && C.iadd(L), C.iushrn(1);
        m.cmp(_) >= 0 ? (m.isub(_), T.isub(C)) : (_.isub(m), C.isub(T));
      }
      var re;
      return m.cmpn(1) === 0 ? re = T : re = C, re.cmpn(0) < 0 && re.iadd(c), re;
    }, o.prototype.gcd = function(c) {
      if (this.isZero())
        return c.abs();
      if (c.isZero())
        return this.abs();
      var m = this.clone(), _ = c.clone();
      m.negative = 0, _.negative = 0;
      for (var T = 0; m.isEven() && _.isEven(); T++)
        m.iushrn(1), _.iushrn(1);
      do {
        for (; m.isEven(); )
          m.iushrn(1);
        for (; _.isEven(); )
          _.iushrn(1);
        var C = m.cmp(_);
        if (C < 0) {
          var L = m;
          m = _, _ = L;
        } else if (C === 0 || _.cmpn(1) === 0)
          break;
        m.isub(_);
      } while (!0);
      return _.iushln(T);
    }, o.prototype.invm = function(c) {
      return this.egcd(c).a.umod(c);
    }, o.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, o.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, o.prototype.andln = function(c) {
      return this.words[0] & c;
    }, o.prototype.bincn = function(c) {
      n(typeof c == "number");
      var m = c % 26, _ = (c - m) / 26, T = 1 << m;
      if (this.length <= _)
        return this._expand(_ + 1), this.words[_] |= T, this;
      for (var C = T, L = _; C !== 0 && L < this.length; L++) {
        var H = this.words[L] | 0;
        H += C, C = H >>> 26, H &= 67108863, this.words[L] = H;
      }
      return C !== 0 && (this.words[L] = C, this.length++), this;
    }, o.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, o.prototype.cmpn = function(c) {
      var m = c < 0;
      if (this.negative !== 0 && !m)
        return -1;
      if (this.negative === 0 && m)
        return 1;
      this.strip();
      var _;
      if (this.length > 1)
        _ = 1;
      else {
        m && (c = -c), n(c <= 67108863, "Number is too big");
        var T = this.words[0] | 0;
        _ = T === c ? 0 : T < c ? -1 : 1;
      }
      return this.negative !== 0 ? -_ | 0 : _;
    }, o.prototype.cmp = function(c) {
      if (this.negative !== 0 && c.negative === 0)
        return -1;
      if (this.negative === 0 && c.negative !== 0)
        return 1;
      var m = this.ucmp(c);
      return this.negative !== 0 ? -m | 0 : m;
    }, o.prototype.ucmp = function(c) {
      if (this.length > c.length)
        return 1;
      if (this.length < c.length)
        return -1;
      for (var m = 0, _ = this.length - 1; _ >= 0; _--) {
        var T = this.words[_] | 0, C = c.words[_] | 0;
        if (T !== C) {
          T < C ? m = -1 : T > C && (m = 1);
          break;
        }
      }
      return m;
    }, o.prototype.gtn = function(c) {
      return this.cmpn(c) === 1;
    }, o.prototype.gt = function(c) {
      return this.cmp(c) === 1;
    }, o.prototype.gten = function(c) {
      return this.cmpn(c) >= 0;
    }, o.prototype.gte = function(c) {
      return this.cmp(c) >= 0;
    }, o.prototype.ltn = function(c) {
      return this.cmpn(c) === -1;
    }, o.prototype.lt = function(c) {
      return this.cmp(c) === -1;
    }, o.prototype.lten = function(c) {
      return this.cmpn(c) <= 0;
    }, o.prototype.lte = function(c) {
      return this.cmp(c) <= 0;
    }, o.prototype.eqn = function(c) {
      return this.cmpn(c) === 0;
    }, o.prototype.eq = function(c) {
      return this.cmp(c) === 0;
    }, o.red = function(c) {
      return new se(c);
    }, o.prototype.toRed = function(c) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), c.convertTo(this)._forceRed(c);
    }, o.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, o.prototype._forceRed = function(c) {
      return this.red = c, this;
    }, o.prototype.forceRed = function(c) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(c);
    }, o.prototype.redAdd = function(c) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, c);
    }, o.prototype.redIAdd = function(c) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, c);
    }, o.prototype.redSub = function(c) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, c);
    }, o.prototype.redISub = function(c) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, c);
    }, o.prototype.redShl = function(c) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, c);
    }, o.prototype.redMul = function(c) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.mul(this, c);
    }, o.prototype.redIMul = function(c) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.imul(this, c);
    }, o.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, o.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, o.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, o.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, o.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, o.prototype.redPow = function(c) {
      return n(this.red && !c.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, c);
    };
    var Y = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function W(O, c) {
      this.name = O, this.p = new o(c, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    W.prototype._tmp = function() {
      var c = new o(null);
      return c.words = new Array(Math.ceil(this.n / 13)), c;
    }, W.prototype.ireduce = function(c) {
      var m = c, _;
      do
        this.split(m, this.tmp), m = this.imulK(m), m = m.iadd(this.tmp), _ = m.bitLength();
      while (_ > this.n);
      var T = _ < this.n ? -1 : m.ucmp(this.p);
      return T === 0 ? (m.words[0] = 0, m.length = 1) : T > 0 ? m.isub(this.p) : m.strip !== void 0 ? m.strip() : m._strip(), m;
    }, W.prototype.split = function(c, m) {
      c.iushrn(this.n, 0, m);
    }, W.prototype.imulK = function(c) {
      return c.imul(this.k);
    };
    function Q() {
      W.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(Q, W), Q.prototype.split = function(c, m) {
      for (var _ = 4194303, T = Math.min(c.length, 9), C = 0; C < T; C++)
        m.words[C] = c.words[C];
      if (m.length = T, c.length <= 9) {
        c.words[0] = 0, c.length = 1;
        return;
      }
      var L = c.words[9];
      for (m.words[m.length++] = L & _, C = 10; C < c.length; C++) {
        var H = c.words[C] | 0;
        c.words[C - 10] = (H & _) << 4 | L >>> 22, L = H;
      }
      L >>>= 22, c.words[C - 10] = L, L === 0 && c.length > 10 ? c.length -= 10 : c.length -= 9;
    }, Q.prototype.imulK = function(c) {
      c.words[c.length] = 0, c.words[c.length + 1] = 0, c.length += 2;
      for (var m = 0, _ = 0; _ < c.length; _++) {
        var T = c.words[_] | 0;
        m += T * 977, c.words[_] = m & 67108863, m = T * 64 + (m / 67108864 | 0);
      }
      return c.words[c.length - 1] === 0 && (c.length--, c.words[c.length - 1] === 0 && c.length--), c;
    };
    function X() {
      W.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(X, W);
    function ne() {
      W.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(ne, W);
    function ue() {
      W.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(ue, W), ue.prototype.imulK = function(c) {
      for (var m = 0, _ = 0; _ < c.length; _++) {
        var T = (c.words[_] | 0) * 19 + m, C = T & 67108863;
        T >>>= 26, c.words[_] = C, m = T;
      }
      return m !== 0 && (c.words[c.length++] = m), c;
    }, o._prime = function(c) {
      if (Y[c])
        return Y[c];
      var m;
      if (c === "k256")
        m = new Q();
      else if (c === "p224")
        m = new X();
      else if (c === "p192")
        m = new ne();
      else if (c === "p25519")
        m = new ue();
      else
        throw new Error("Unknown prime " + c);
      return Y[c] = m, m;
    };
    function se(O) {
      if (typeof O == "string") {
        var c = o._prime(O);
        this.m = c.p, this.prime = c;
      } else
        n(O.gtn(1), "modulus must be greater than 1"), this.m = O, this.prime = null;
    }
    se.prototype._verify1 = function(c) {
      n(c.negative === 0, "red works only with positives"), n(c.red, "red works only with red numbers");
    }, se.prototype._verify2 = function(c, m) {
      n((c.negative | m.negative) === 0, "red works only with positives"), n(
        c.red && c.red === m.red,
        "red works only with red numbers"
      );
    }, se.prototype.imod = function(c) {
      return this.prime ? this.prime.ireduce(c)._forceRed(this) : c.umod(this.m)._forceRed(this);
    }, se.prototype.neg = function(c) {
      return c.isZero() ? c.clone() : this.m.sub(c)._forceRed(this);
    }, se.prototype.add = function(c, m) {
      this._verify2(c, m);
      var _ = c.add(m);
      return _.cmp(this.m) >= 0 && _.isub(this.m), _._forceRed(this);
    }, se.prototype.iadd = function(c, m) {
      this._verify2(c, m);
      var _ = c.iadd(m);
      return _.cmp(this.m) >= 0 && _.isub(this.m), _;
    }, se.prototype.sub = function(c, m) {
      this._verify2(c, m);
      var _ = c.sub(m);
      return _.cmpn(0) < 0 && _.iadd(this.m), _._forceRed(this);
    }, se.prototype.isub = function(c, m) {
      this._verify2(c, m);
      var _ = c.isub(m);
      return _.cmpn(0) < 0 && _.iadd(this.m), _;
    }, se.prototype.shl = function(c, m) {
      return this._verify1(c), this.imod(c.ushln(m));
    }, se.prototype.imul = function(c, m) {
      return this._verify2(c, m), this.imod(c.imul(m));
    }, se.prototype.mul = function(c, m) {
      return this._verify2(c, m), this.imod(c.mul(m));
    }, se.prototype.isqr = function(c) {
      return this.imul(c, c.clone());
    }, se.prototype.sqr = function(c) {
      return this.mul(c, c);
    }, se.prototype.sqrt = function(c) {
      if (c.isZero())
        return c.clone();
      var m = this.m.andln(3);
      if (n(m % 2 === 1), m === 3) {
        var _ = this.m.add(new o(1)).iushrn(2);
        return this.pow(c, _);
      }
      for (var T = this.m.subn(1), C = 0; !T.isZero() && T.andln(1) === 0; )
        C++, T.iushrn(1);
      n(!T.isZero());
      var L = new o(1).toRed(this), H = L.redNeg(), P = this.m.subn(1).iushrn(1), l = this.m.bitLength();
      for (l = new o(2 * l * l).toRed(this); this.pow(l, P).cmp(H) !== 0; )
        l.redIAdd(H);
      for (var x = this.pow(l, T), re = this.pow(c, T.addn(1).iushrn(1)), ae = this.pow(c, T), G = C; ae.cmp(L) !== 0; ) {
        for (var ce = ae, me = 0; ce.cmp(L) !== 0; me++)
          ce = ce.redSqr();
        n(me < G);
        var ye = this.pow(x, new o(1).iushln(G - me - 1));
        re = re.redMul(ye), x = ye.redSqr(), ae = ae.redMul(x), G = me;
      }
      return re;
    }, se.prototype.invm = function(c) {
      var m = c._invmp(this.m);
      return m.negative !== 0 ? (m.negative = 0, this.imod(m).redNeg()) : this.imod(m);
    }, se.prototype.pow = function(c, m) {
      if (m.isZero())
        return new o(1).toRed(this);
      if (m.cmpn(1) === 0)
        return c.clone();
      var _ = 4, T = new Array(1 << _);
      T[0] = new o(1).toRed(this), T[1] = c;
      for (var C = 2; C < T.length; C++)
        T[C] = this.mul(T[C - 1], c);
      var L = T[0], H = 0, P = 0, l = m.bitLength() % 26;
      for (l === 0 && (l = 26), C = m.length - 1; C >= 0; C--) {
        for (var x = m.words[C], re = l - 1; re >= 0; re--) {
          var ae = x >> re & 1;
          if (L !== T[0] && (L = this.sqr(L)), ae === 0 && H === 0) {
            P = 0;
            continue;
          }
          H <<= 1, H |= ae, P++, !(P !== _ && (C !== 0 || re !== 0)) && (L = this.mul(L, T[H]), P = 0, H = 0);
        }
        l = 26;
      }
      return L;
    }, se.prototype.convertTo = function(c) {
      var m = c.umod(this.m);
      return m === c ? m.clone() : m;
    }, se.prototype.convertFrom = function(c) {
      var m = c.clone();
      return m.red = null, m;
    }, o.mont = function(c) {
      return new ie(c);
    };
    function ie(O) {
      se.call(this, O), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(ie, se), ie.prototype.convertTo = function(c) {
      return this.imod(c.ushln(this.shift));
    }, ie.prototype.convertFrom = function(c) {
      var m = this.imod(c.mul(this.rinv));
      return m.red = null, m;
    }, ie.prototype.imul = function(c, m) {
      if (c.isZero() || m.isZero())
        return c.words[0] = 0, c.length = 1, c;
      var _ = c.imul(m), T = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), C = _.isub(T).iushrn(this.shift), L = C;
      return C.cmp(this.m) >= 0 ? L = C.isub(this.m) : C.cmpn(0) < 0 && (L = C.iadd(this.m)), L._forceRed(this);
    }, ie.prototype.mul = function(c, m) {
      if (c.isZero() || m.isZero())
        return new o(0)._forceRed(this);
      var _ = c.mul(m), T = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), C = _.isub(T).iushrn(this.shift), L = C;
      return C.cmp(this.m) >= 0 ? L = C.isub(this.m) : C.cmpn(0) < 0 && (L = C.iadd(this.m)), L._forceRed(this);
    }, ie.prototype.invm = function(c) {
      var m = this.imod(c._invmp(this.m).mul(this.r2));
      return m._forceRed(this);
    };
  })(t, ge);
})(rs);
var bc = rs.exports, xc = {}, ns = {}, po = { exports: {} };
typeof Object.create == "function" ? po.exports = function(e, r) {
  r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : po.exports = function(e, r) {
  if (r) {
    e.super_ = r;
    var n = function() {
    };
    n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
  }
};
var Er = po.exports, Tc = {}, Cn = {};
Cn.byteLength = hd;
Cn.toByteArray = pd;
Cn.fromByteArray = yd;
var Kt = [], kt = [], ld = typeof Uint8Array < "u" ? Uint8Array : Array, Ui = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Pr = 0, fd = Ui.length; Pr < fd; ++Pr)
  Kt[Pr] = Ui[Pr], kt[Ui.charCodeAt(Pr)] = Pr;
kt["-".charCodeAt(0)] = 62;
kt["_".charCodeAt(0)] = 63;
function Ec(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = t.indexOf("=");
  r === -1 && (r = e);
  var n = r === e ? 0 : 4 - r % 4;
  return [r, n];
}
function hd(t) {
  var e = Ec(t), r = e[0], n = e[1];
  return (r + n) * 3 / 4 - n;
}
function dd(t, e, r) {
  return (e + r) * 3 / 4 - r;
}
function pd(t) {
  var e, r = Ec(t), n = r[0], i = r[1], o = new ld(dd(t, n, i)), s = 0, a = i > 0 ? n - 4 : n, f;
  for (f = 0; f < a; f += 4)
    e = kt[t.charCodeAt(f)] << 18 | kt[t.charCodeAt(f + 1)] << 12 | kt[t.charCodeAt(f + 2)] << 6 | kt[t.charCodeAt(f + 3)], o[s++] = e >> 16 & 255, o[s++] = e >> 8 & 255, o[s++] = e & 255;
  return i === 2 && (e = kt[t.charCodeAt(f)] << 2 | kt[t.charCodeAt(f + 1)] >> 4, o[s++] = e & 255), i === 1 && (e = kt[t.charCodeAt(f)] << 10 | kt[t.charCodeAt(f + 1)] << 4 | kt[t.charCodeAt(f + 2)] >> 2, o[s++] = e >> 8 & 255, o[s++] = e & 255), o;
}
function md(t) {
  return Kt[t >> 18 & 63] + Kt[t >> 12 & 63] + Kt[t >> 6 & 63] + Kt[t & 63];
}
function gd(t, e, r) {
  for (var n, i = [], o = e; o < r; o += 3)
    n = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (t[o + 2] & 255), i.push(md(n));
  return i.join("");
}
function yd(t) {
  for (var e, r = t.length, n = r % 3, i = [], o = 16383, s = 0, a = r - n; s < a; s += o)
    i.push(gd(t, s, s + o > a ? a : s + o));
  return n === 1 ? (e = t[r - 1], i.push(
    Kt[e >> 2] + Kt[e << 4 & 63] + "=="
  )) : n === 2 && (e = (t[r - 2] << 8) + t[r - 1], i.push(
    Kt[e >> 10] + Kt[e >> 4 & 63] + Kt[e << 2 & 63] + "="
  )), i.join("");
}
var is = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
is.read = function(t, e, r, n, i) {
  var o, s, a = i * 8 - n - 1, f = (1 << a) - 1, p = f >> 1, d = -7, y = r ? i - 1 : 0, v = r ? -1 : 1, w = t[e + y];
  for (y += v, o = w & (1 << -d) - 1, w >>= -d, d += a; d > 0; o = o * 256 + t[e + y], y += v, d -= 8)
    ;
  for (s = o & (1 << -d) - 1, o >>= -d, d += n; d > 0; s = s * 256 + t[e + y], y += v, d -= 8)
    ;
  if (o === 0)
    o = 1 - p;
  else {
    if (o === f)
      return s ? NaN : (w ? -1 : 1) * (1 / 0);
    s = s + Math.pow(2, n), o = o - p;
  }
  return (w ? -1 : 1) * s * Math.pow(2, o - n);
};
is.write = function(t, e, r, n, i, o) {
  var s, a, f, p = o * 8 - i - 1, d = (1 << p) - 1, y = d >> 1, v = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, w = n ? 0 : o - 1, I = n ? 1 : -1, N = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = d) : (s = Math.floor(Math.log(e) / Math.LN2), e * (f = Math.pow(2, -s)) < 1 && (s--, f *= 2), s + y >= 1 ? e += v / f : e += v * Math.pow(2, 1 - y), e * f >= 2 && (s++, f /= 2), s + y >= d ? (a = 0, s = d) : s + y >= 1 ? (a = (e * f - 1) * Math.pow(2, i), s = s + y) : (a = e * Math.pow(2, y - 1) * Math.pow(2, i), s = 0)); i >= 8; t[r + w] = a & 255, w += I, a /= 256, i -= 8)
    ;
  for (s = s << i | a, p += i; p > 0; t[r + w] = s & 255, w += I, s /= 256, p -= 8)
    ;
  t[r + w - I] |= N * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
  const e = Cn, r = is, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t.Buffer = a, t.SlowBuffer = S, t.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  t.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = o(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function o() {
    try {
      const g = new Uint8Array(1), u = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(u, Uint8Array.prototype), Object.setPrototypeOf(g, u), g.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(a.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (a.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(a.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (a.isBuffer(this))
        return this.byteOffset;
    }
  });
  function s(g) {
    if (g > i)
      throw new RangeError('The value "' + g + '" is invalid for option "size"');
    const u = new Uint8Array(g);
    return Object.setPrototypeOf(u, a.prototype), u;
  }
  function a(g, u, h) {
    if (typeof g == "number") {
      if (typeof u == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return y(g);
    }
    return f(g, u, h);
  }
  a.poolSize = 8192;
  function f(g, u, h) {
    if (typeof g == "string")
      return v(g, u);
    if (ArrayBuffer.isView(g))
      return I(g);
    if (g == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof g
      );
    if (de(g, ArrayBuffer) || g && de(g.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (de(g, SharedArrayBuffer) || g && de(g.buffer, SharedArrayBuffer)))
      return N(g, u, h);
    if (typeof g == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const A = g.valueOf && g.valueOf();
    if (A != null && A !== g)
      return a.from(A, u, h);
    const B = k(g);
    if (B)
      return B;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof g[Symbol.toPrimitive] == "function")
      return a.from(g[Symbol.toPrimitive]("string"), u, h);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof g
    );
  }
  a.from = function(g, u, h) {
    return f(g, u, h);
  }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
  function p(g) {
    if (typeof g != "number")
      throw new TypeError('"size" argument must be of type number');
    if (g < 0)
      throw new RangeError('The value "' + g + '" is invalid for option "size"');
  }
  function d(g, u, h) {
    return p(g), g <= 0 ? s(g) : u !== void 0 ? typeof h == "string" ? s(g).fill(u, h) : s(g).fill(u) : s(g);
  }
  a.alloc = function(g, u, h) {
    return d(g, u, h);
  };
  function y(g) {
    return p(g), s(g < 0 ? 0 : M(g) | 0);
  }
  a.allocUnsafe = function(g) {
    return y(g);
  }, a.allocUnsafeSlow = function(g) {
    return y(g);
  };
  function v(g, u) {
    if ((typeof u != "string" || u === "") && (u = "utf8"), !a.isEncoding(u))
      throw new TypeError("Unknown encoding: " + u);
    const h = Y(g, u) | 0;
    let A = s(h);
    const B = A.write(g, u);
    return B !== h && (A = A.slice(0, B)), A;
  }
  function w(g) {
    const u = g.length < 0 ? 0 : M(g.length) | 0, h = s(u);
    for (let A = 0; A < u; A += 1)
      h[A] = g[A] & 255;
    return h;
  }
  function I(g) {
    if (de(g, Uint8Array)) {
      const u = new Uint8Array(g);
      return N(u.buffer, u.byteOffset, u.byteLength);
    }
    return w(g);
  }
  function N(g, u, h) {
    if (u < 0 || g.byteLength < u)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (g.byteLength < u + (h || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let A;
    return u === void 0 && h === void 0 ? A = new Uint8Array(g) : h === void 0 ? A = new Uint8Array(g, u) : A = new Uint8Array(g, u, h), Object.setPrototypeOf(A, a.prototype), A;
  }
  function k(g) {
    if (a.isBuffer(g)) {
      const u = M(g.length) | 0, h = s(u);
      return h.length === 0 || g.copy(h, 0, 0, u), h;
    }
    if (g.length !== void 0)
      return typeof g.length != "number" || Ee(g.length) ? s(0) : w(g);
    if (g.type === "Buffer" && Array.isArray(g.data))
      return w(g.data);
  }
  function M(g) {
    if (g >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return g | 0;
  }
  function S(g) {
    return +g != g && (g = 0), a.alloc(+g);
  }
  a.isBuffer = function(u) {
    return u != null && u._isBuffer === !0 && u !== a.prototype;
  }, a.compare = function(u, h) {
    if (de(u, Uint8Array) && (u = a.from(u, u.offset, u.byteLength)), de(h, Uint8Array) && (h = a.from(h, h.offset, h.byteLength)), !a.isBuffer(u) || !a.isBuffer(h))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (u === h)
      return 0;
    let A = u.length, B = h.length;
    for (let z = 0, F = Math.min(A, B); z < F; ++z)
      if (u[z] !== h[z]) {
        A = u[z], B = h[z];
        break;
      }
    return A < B ? -1 : B < A ? 1 : 0;
  }, a.isEncoding = function(u) {
    switch (String(u).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, a.concat = function(u, h) {
    if (!Array.isArray(u))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (u.length === 0)
      return a.alloc(0);
    let A;
    if (h === void 0)
      for (h = 0, A = 0; A < u.length; ++A)
        h += u[A].length;
    const B = a.allocUnsafe(h);
    let z = 0;
    for (A = 0; A < u.length; ++A) {
      let F = u[A];
      if (de(F, Uint8Array))
        z + F.length > B.length ? (a.isBuffer(F) || (F = a.from(F)), F.copy(B, z)) : Uint8Array.prototype.set.call(
          B,
          F,
          z
        );
      else if (a.isBuffer(F))
        F.copy(B, z);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      z += F.length;
    }
    return B;
  };
  function Y(g, u) {
    if (a.isBuffer(g))
      return g.length;
    if (ArrayBuffer.isView(g) || de(g, ArrayBuffer))
      return g.byteLength;
    if (typeof g != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof g
      );
    const h = g.length, A = arguments.length > 2 && arguments[2] === !0;
    if (!A && h === 0)
      return 0;
    let B = !1;
    for (; ; )
      switch (u) {
        case "ascii":
        case "latin1":
        case "binary":
          return h;
        case "utf8":
        case "utf-8":
          return j(g).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return h * 2;
        case "hex":
          return h >>> 1;
        case "base64":
          return ee(g).length;
        default:
          if (B)
            return A ? -1 : j(g).length;
          u = ("" + u).toLowerCase(), B = !0;
      }
  }
  a.byteLength = Y;
  function W(g, u, h) {
    let A = !1;
    if ((u === void 0 || u < 0) && (u = 0), u > this.length || ((h === void 0 || h > this.length) && (h = this.length), h <= 0) || (h >>>= 0, u >>>= 0, h <= u))
      return "";
    for (g || (g = "utf8"); ; )
      switch (g) {
        case "hex":
          return P(this, u, h);
        case "utf8":
        case "utf-8":
          return _(this, u, h);
        case "ascii":
          return L(this, u, h);
        case "latin1":
        case "binary":
          return H(this, u, h);
        case "base64":
          return m(this, u, h);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return l(this, u, h);
        default:
          if (A)
            throw new TypeError("Unknown encoding: " + g);
          g = (g + "").toLowerCase(), A = !0;
      }
  }
  a.prototype._isBuffer = !0;
  function Q(g, u, h) {
    const A = g[u];
    g[u] = g[h], g[h] = A;
  }
  a.prototype.swap16 = function() {
    const u = this.length;
    if (u % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let h = 0; h < u; h += 2)
      Q(this, h, h + 1);
    return this;
  }, a.prototype.swap32 = function() {
    const u = this.length;
    if (u % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let h = 0; h < u; h += 4)
      Q(this, h, h + 3), Q(this, h + 1, h + 2);
    return this;
  }, a.prototype.swap64 = function() {
    const u = this.length;
    if (u % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let h = 0; h < u; h += 8)
      Q(this, h, h + 7), Q(this, h + 1, h + 6), Q(this, h + 2, h + 5), Q(this, h + 3, h + 4);
    return this;
  }, a.prototype.toString = function() {
    const u = this.length;
    return u === 0 ? "" : arguments.length === 0 ? _(this, 0, u) : W.apply(this, arguments);
  }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(u) {
    if (!a.isBuffer(u))
      throw new TypeError("Argument must be a Buffer");
    return this === u ? !0 : a.compare(this, u) === 0;
  }, a.prototype.inspect = function() {
    let u = "";
    const h = t.INSPECT_MAX_BYTES;
    return u = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (u += " ... "), "<Buffer " + u + ">";
  }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(u, h, A, B, z) {
    if (de(u, Uint8Array) && (u = a.from(u, u.offset, u.byteLength)), !a.isBuffer(u))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof u
      );
    if (h === void 0 && (h = 0), A === void 0 && (A = u ? u.length : 0), B === void 0 && (B = 0), z === void 0 && (z = this.length), h < 0 || A > u.length || B < 0 || z > this.length)
      throw new RangeError("out of range index");
    if (B >= z && h >= A)
      return 0;
    if (B >= z)
      return -1;
    if (h >= A)
      return 1;
    if (h >>>= 0, A >>>= 0, B >>>= 0, z >>>= 0, this === u)
      return 0;
    let F = z - B, fe = A - h;
    const we = Math.min(F, fe), _e = this.slice(B, z), be = u.slice(h, A);
    for (let Be = 0; Be < we; ++Be)
      if (_e[Be] !== be[Be]) {
        F = _e[Be], fe = be[Be];
        break;
      }
    return F < fe ? -1 : fe < F ? 1 : 0;
  };
  function X(g, u, h, A, B) {
    if (g.length === 0)
      return -1;
    if (typeof h == "string" ? (A = h, h = 0) : h > 2147483647 ? h = 2147483647 : h < -2147483648 && (h = -2147483648), h = +h, Ee(h) && (h = B ? 0 : g.length - 1), h < 0 && (h = g.length + h), h >= g.length) {
      if (B)
        return -1;
      h = g.length - 1;
    } else if (h < 0)
      if (B)
        h = 0;
      else
        return -1;
    if (typeof u == "string" && (u = a.from(u, A)), a.isBuffer(u))
      return u.length === 0 ? -1 : ne(g, u, h, A, B);
    if (typeof u == "number")
      return u = u & 255, typeof Uint8Array.prototype.indexOf == "function" ? B ? Uint8Array.prototype.indexOf.call(g, u, h) : Uint8Array.prototype.lastIndexOf.call(g, u, h) : ne(g, [u], h, A, B);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ne(g, u, h, A, B) {
    let z = 1, F = g.length, fe = u.length;
    if (A !== void 0 && (A = String(A).toLowerCase(), A === "ucs2" || A === "ucs-2" || A === "utf16le" || A === "utf-16le")) {
      if (g.length < 2 || u.length < 2)
        return -1;
      z = 2, F /= 2, fe /= 2, h /= 2;
    }
    function we(be, Be) {
      return z === 1 ? be[Be] : be.readUInt16BE(Be * z);
    }
    let _e;
    if (B) {
      let be = -1;
      for (_e = h; _e < F; _e++)
        if (we(g, _e) === we(u, be === -1 ? 0 : _e - be)) {
          if (be === -1 && (be = _e), _e - be + 1 === fe)
            return be * z;
        } else
          be !== -1 && (_e -= _e - be), be = -1;
    } else
      for (h + fe > F && (h = F - fe), _e = h; _e >= 0; _e--) {
        let be = !0;
        for (let Be = 0; Be < fe; Be++)
          if (we(g, _e + Be) !== we(u, Be)) {
            be = !1;
            break;
          }
        if (be)
          return _e;
      }
    return -1;
  }
  a.prototype.includes = function(u, h, A) {
    return this.indexOf(u, h, A) !== -1;
  }, a.prototype.indexOf = function(u, h, A) {
    return X(this, u, h, A, !0);
  }, a.prototype.lastIndexOf = function(u, h, A) {
    return X(this, u, h, A, !1);
  };
  function ue(g, u, h, A) {
    h = Number(h) || 0;
    const B = g.length - h;
    A ? (A = Number(A), A > B && (A = B)) : A = B;
    const z = u.length;
    A > z / 2 && (A = z / 2);
    let F;
    for (F = 0; F < A; ++F) {
      const fe = parseInt(u.substr(F * 2, 2), 16);
      if (Ee(fe))
        return F;
      g[h + F] = fe;
    }
    return F;
  }
  function se(g, u, h, A) {
    return oe(j(u, g.length - h), g, h, A);
  }
  function ie(g, u, h, A) {
    return oe(q(u), g, h, A);
  }
  function O(g, u, h, A) {
    return oe(ee(u), g, h, A);
  }
  function c(g, u, h, A) {
    return oe(Z(u, g.length - h), g, h, A);
  }
  a.prototype.write = function(u, h, A, B) {
    if (h === void 0)
      B = "utf8", A = this.length, h = 0;
    else if (A === void 0 && typeof h == "string")
      B = h, A = this.length, h = 0;
    else if (isFinite(h))
      h = h >>> 0, isFinite(A) ? (A = A >>> 0, B === void 0 && (B = "utf8")) : (B = A, A = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const z = this.length - h;
    if ((A === void 0 || A > z) && (A = z), u.length > 0 && (A < 0 || h < 0) || h > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    B || (B = "utf8");
    let F = !1;
    for (; ; )
      switch (B) {
        case "hex":
          return ue(this, u, h, A);
        case "utf8":
        case "utf-8":
          return se(this, u, h, A);
        case "ascii":
        case "latin1":
        case "binary":
          return ie(this, u, h, A);
        case "base64":
          return O(this, u, h, A);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return c(this, u, h, A);
        default:
          if (F)
            throw new TypeError("Unknown encoding: " + B);
          B = ("" + B).toLowerCase(), F = !0;
      }
  }, a.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function m(g, u, h) {
    return u === 0 && h === g.length ? e.fromByteArray(g) : e.fromByteArray(g.slice(u, h));
  }
  function _(g, u, h) {
    h = Math.min(g.length, h);
    const A = [];
    let B = u;
    for (; B < h; ) {
      const z = g[B];
      let F = null, fe = z > 239 ? 4 : z > 223 ? 3 : z > 191 ? 2 : 1;
      if (B + fe <= h) {
        let we, _e, be, Be;
        switch (fe) {
          case 1:
            z < 128 && (F = z);
            break;
          case 2:
            we = g[B + 1], (we & 192) === 128 && (Be = (z & 31) << 6 | we & 63, Be > 127 && (F = Be));
            break;
          case 3:
            we = g[B + 1], _e = g[B + 2], (we & 192) === 128 && (_e & 192) === 128 && (Be = (z & 15) << 12 | (we & 63) << 6 | _e & 63, Be > 2047 && (Be < 55296 || Be > 57343) && (F = Be));
            break;
          case 4:
            we = g[B + 1], _e = g[B + 2], be = g[B + 3], (we & 192) === 128 && (_e & 192) === 128 && (be & 192) === 128 && (Be = (z & 15) << 18 | (we & 63) << 12 | (_e & 63) << 6 | be & 63, Be > 65535 && Be < 1114112 && (F = Be));
        }
      }
      F === null ? (F = 65533, fe = 1) : F > 65535 && (F -= 65536, A.push(F >>> 10 & 1023 | 55296), F = 56320 | F & 1023), A.push(F), B += fe;
    }
    return C(A);
  }
  const T = 4096;
  function C(g) {
    const u = g.length;
    if (u <= T)
      return String.fromCharCode.apply(String, g);
    let h = "", A = 0;
    for (; A < u; )
      h += String.fromCharCode.apply(
        String,
        g.slice(A, A += T)
      );
    return h;
  }
  function L(g, u, h) {
    let A = "";
    h = Math.min(g.length, h);
    for (let B = u; B < h; ++B)
      A += String.fromCharCode(g[B] & 127);
    return A;
  }
  function H(g, u, h) {
    let A = "";
    h = Math.min(g.length, h);
    for (let B = u; B < h; ++B)
      A += String.fromCharCode(g[B]);
    return A;
  }
  function P(g, u, h) {
    const A = g.length;
    (!u || u < 0) && (u = 0), (!h || h < 0 || h > A) && (h = A);
    let B = "";
    for (let z = u; z < h; ++z)
      B += Ae[g[z]];
    return B;
  }
  function l(g, u, h) {
    const A = g.slice(u, h);
    let B = "";
    for (let z = 0; z < A.length - 1; z += 2)
      B += String.fromCharCode(A[z] + A[z + 1] * 256);
    return B;
  }
  a.prototype.slice = function(u, h) {
    const A = this.length;
    u = ~~u, h = h === void 0 ? A : ~~h, u < 0 ? (u += A, u < 0 && (u = 0)) : u > A && (u = A), h < 0 ? (h += A, h < 0 && (h = 0)) : h > A && (h = A), h < u && (h = u);
    const B = this.subarray(u, h);
    return Object.setPrototypeOf(B, a.prototype), B;
  };
  function x(g, u, h) {
    if (g % 1 !== 0 || g < 0)
      throw new RangeError("offset is not uint");
    if (g + u > h)
      throw new RangeError("Trying to access beyond buffer length");
  }
  a.prototype.readUintLE = a.prototype.readUIntLE = function(u, h, A) {
    u = u >>> 0, h = h >>> 0, A || x(u, h, this.length);
    let B = this[u], z = 1, F = 0;
    for (; ++F < h && (z *= 256); )
      B += this[u + F] * z;
    return B;
  }, a.prototype.readUintBE = a.prototype.readUIntBE = function(u, h, A) {
    u = u >>> 0, h = h >>> 0, A || x(u, h, this.length);
    let B = this[u + --h], z = 1;
    for (; h > 0 && (z *= 256); )
      B += this[u + --h] * z;
    return B;
  }, a.prototype.readUint8 = a.prototype.readUInt8 = function(u, h) {
    return u = u >>> 0, h || x(u, 1, this.length), this[u];
  }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(u, h) {
    return u = u >>> 0, h || x(u, 2, this.length), this[u] | this[u + 1] << 8;
  }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(u, h) {
    return u = u >>> 0, h || x(u, 2, this.length), this[u] << 8 | this[u + 1];
  }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(u, h) {
    return u = u >>> 0, h || x(u, 4, this.length), (this[u] | this[u + 1] << 8 | this[u + 2] << 16) + this[u + 3] * 16777216;
  }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(u, h) {
    return u = u >>> 0, h || x(u, 4, this.length), this[u] * 16777216 + (this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3]);
  }, a.prototype.readBigUInt64LE = U(function(u) {
    u = u >>> 0, V(u, "offset");
    const h = this[u], A = this[u + 7];
    (h === void 0 || A === void 0) && K(u, this.length - 8);
    const B = h + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + this[++u] * 2 ** 24, z = this[++u] + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + A * 2 ** 24;
    return BigInt(B) + (BigInt(z) << BigInt(32));
  }), a.prototype.readBigUInt64BE = U(function(u) {
    u = u >>> 0, V(u, "offset");
    const h = this[u], A = this[u + 7];
    (h === void 0 || A === void 0) && K(u, this.length - 8);
    const B = h * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + this[++u], z = this[++u] * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + A;
    return (BigInt(B) << BigInt(32)) + BigInt(z);
  }), a.prototype.readIntLE = function(u, h, A) {
    u = u >>> 0, h = h >>> 0, A || x(u, h, this.length);
    let B = this[u], z = 1, F = 0;
    for (; ++F < h && (z *= 256); )
      B += this[u + F] * z;
    return z *= 128, B >= z && (B -= Math.pow(2, 8 * h)), B;
  }, a.prototype.readIntBE = function(u, h, A) {
    u = u >>> 0, h = h >>> 0, A || x(u, h, this.length);
    let B = h, z = 1, F = this[u + --B];
    for (; B > 0 && (z *= 256); )
      F += this[u + --B] * z;
    return z *= 128, F >= z && (F -= Math.pow(2, 8 * h)), F;
  }, a.prototype.readInt8 = function(u, h) {
    return u = u >>> 0, h || x(u, 1, this.length), this[u] & 128 ? (255 - this[u] + 1) * -1 : this[u];
  }, a.prototype.readInt16LE = function(u, h) {
    u = u >>> 0, h || x(u, 2, this.length);
    const A = this[u] | this[u + 1] << 8;
    return A & 32768 ? A | 4294901760 : A;
  }, a.prototype.readInt16BE = function(u, h) {
    u = u >>> 0, h || x(u, 2, this.length);
    const A = this[u + 1] | this[u] << 8;
    return A & 32768 ? A | 4294901760 : A;
  }, a.prototype.readInt32LE = function(u, h) {
    return u = u >>> 0, h || x(u, 4, this.length), this[u] | this[u + 1] << 8 | this[u + 2] << 16 | this[u + 3] << 24;
  }, a.prototype.readInt32BE = function(u, h) {
    return u = u >>> 0, h || x(u, 4, this.length), this[u] << 24 | this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3];
  }, a.prototype.readBigInt64LE = U(function(u) {
    u = u >>> 0, V(u, "offset");
    const h = this[u], A = this[u + 7];
    (h === void 0 || A === void 0) && K(u, this.length - 8);
    const B = this[u + 4] + this[u + 5] * 2 ** 8 + this[u + 6] * 2 ** 16 + (A << 24);
    return (BigInt(B) << BigInt(32)) + BigInt(h + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + this[++u] * 2 ** 24);
  }), a.prototype.readBigInt64BE = U(function(u) {
    u = u >>> 0, V(u, "offset");
    const h = this[u], A = this[u + 7];
    (h === void 0 || A === void 0) && K(u, this.length - 8);
    const B = (h << 24) + // Overflow
    this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + this[++u];
    return (BigInt(B) << BigInt(32)) + BigInt(this[++u] * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + A);
  }), a.prototype.readFloatLE = function(u, h) {
    return u = u >>> 0, h || x(u, 4, this.length), r.read(this, u, !0, 23, 4);
  }, a.prototype.readFloatBE = function(u, h) {
    return u = u >>> 0, h || x(u, 4, this.length), r.read(this, u, !1, 23, 4);
  }, a.prototype.readDoubleLE = function(u, h) {
    return u = u >>> 0, h || x(u, 8, this.length), r.read(this, u, !0, 52, 8);
  }, a.prototype.readDoubleBE = function(u, h) {
    return u = u >>> 0, h || x(u, 8, this.length), r.read(this, u, !1, 52, 8);
  };
  function re(g, u, h, A, B, z) {
    if (!a.isBuffer(g))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (u > B || u < z)
      throw new RangeError('"value" argument is out of bounds');
    if (h + A > g.length)
      throw new RangeError("Index out of range");
  }
  a.prototype.writeUintLE = a.prototype.writeUIntLE = function(u, h, A, B) {
    if (u = +u, h = h >>> 0, A = A >>> 0, !B) {
      const fe = Math.pow(2, 8 * A) - 1;
      re(this, u, h, A, fe, 0);
    }
    let z = 1, F = 0;
    for (this[h] = u & 255; ++F < A && (z *= 256); )
      this[h + F] = u / z & 255;
    return h + A;
  }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(u, h, A, B) {
    if (u = +u, h = h >>> 0, A = A >>> 0, !B) {
      const fe = Math.pow(2, 8 * A) - 1;
      re(this, u, h, A, fe, 0);
    }
    let z = A - 1, F = 1;
    for (this[h + z] = u & 255; --z >= 0 && (F *= 256); )
      this[h + z] = u / F & 255;
    return h + A;
  }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(u, h, A) {
    return u = +u, h = h >>> 0, A || re(this, u, h, 1, 255, 0), this[h] = u & 255, h + 1;
  }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(u, h, A) {
    return u = +u, h = h >>> 0, A || re(this, u, h, 2, 65535, 0), this[h] = u & 255, this[h + 1] = u >>> 8, h + 2;
  }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(u, h, A) {
    return u = +u, h = h >>> 0, A || re(this, u, h, 2, 65535, 0), this[h] = u >>> 8, this[h + 1] = u & 255, h + 2;
  }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(u, h, A) {
    return u = +u, h = h >>> 0, A || re(this, u, h, 4, 4294967295, 0), this[h + 3] = u >>> 24, this[h + 2] = u >>> 16, this[h + 1] = u >>> 8, this[h] = u & 255, h + 4;
  }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(u, h, A) {
    return u = +u, h = h >>> 0, A || re(this, u, h, 4, 4294967295, 0), this[h] = u >>> 24, this[h + 1] = u >>> 16, this[h + 2] = u >>> 8, this[h + 3] = u & 255, h + 4;
  };
  function ae(g, u, h, A, B) {
    E(u, A, B, g, h, 7);
    let z = Number(u & BigInt(4294967295));
    g[h++] = z, z = z >> 8, g[h++] = z, z = z >> 8, g[h++] = z, z = z >> 8, g[h++] = z;
    let F = Number(u >> BigInt(32) & BigInt(4294967295));
    return g[h++] = F, F = F >> 8, g[h++] = F, F = F >> 8, g[h++] = F, F = F >> 8, g[h++] = F, h;
  }
  function G(g, u, h, A, B) {
    E(u, A, B, g, h, 7);
    let z = Number(u & BigInt(4294967295));
    g[h + 7] = z, z = z >> 8, g[h + 6] = z, z = z >> 8, g[h + 5] = z, z = z >> 8, g[h + 4] = z;
    let F = Number(u >> BigInt(32) & BigInt(4294967295));
    return g[h + 3] = F, F = F >> 8, g[h + 2] = F, F = F >> 8, g[h + 1] = F, F = F >> 8, g[h] = F, h + 8;
  }
  a.prototype.writeBigUInt64LE = U(function(u, h = 0) {
    return ae(this, u, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeBigUInt64BE = U(function(u, h = 0) {
    return G(this, u, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeIntLE = function(u, h, A, B) {
    if (u = +u, h = h >>> 0, !B) {
      const we = Math.pow(2, 8 * A - 1);
      re(this, u, h, A, we - 1, -we);
    }
    let z = 0, F = 1, fe = 0;
    for (this[h] = u & 255; ++z < A && (F *= 256); )
      u < 0 && fe === 0 && this[h + z - 1] !== 0 && (fe = 1), this[h + z] = (u / F >> 0) - fe & 255;
    return h + A;
  }, a.prototype.writeIntBE = function(u, h, A, B) {
    if (u = +u, h = h >>> 0, !B) {
      const we = Math.pow(2, 8 * A - 1);
      re(this, u, h, A, we - 1, -we);
    }
    let z = A - 1, F = 1, fe = 0;
    for (this[h + z] = u & 255; --z >= 0 && (F *= 256); )
      u < 0 && fe === 0 && this[h + z + 1] !== 0 && (fe = 1), this[h + z] = (u / F >> 0) - fe & 255;
    return h + A;
  }, a.prototype.writeInt8 = function(u, h, A) {
    return u = +u, h = h >>> 0, A || re(this, u, h, 1, 127, -128), u < 0 && (u = 255 + u + 1), this[h] = u & 255, h + 1;
  }, a.prototype.writeInt16LE = function(u, h, A) {
    return u = +u, h = h >>> 0, A || re(this, u, h, 2, 32767, -32768), this[h] = u & 255, this[h + 1] = u >>> 8, h + 2;
  }, a.prototype.writeInt16BE = function(u, h, A) {
    return u = +u, h = h >>> 0, A || re(this, u, h, 2, 32767, -32768), this[h] = u >>> 8, this[h + 1] = u & 255, h + 2;
  }, a.prototype.writeInt32LE = function(u, h, A) {
    return u = +u, h = h >>> 0, A || re(this, u, h, 4, 2147483647, -2147483648), this[h] = u & 255, this[h + 1] = u >>> 8, this[h + 2] = u >>> 16, this[h + 3] = u >>> 24, h + 4;
  }, a.prototype.writeInt32BE = function(u, h, A) {
    return u = +u, h = h >>> 0, A || re(this, u, h, 4, 2147483647, -2147483648), u < 0 && (u = 4294967295 + u + 1), this[h] = u >>> 24, this[h + 1] = u >>> 16, this[h + 2] = u >>> 8, this[h + 3] = u & 255, h + 4;
  }, a.prototype.writeBigInt64LE = U(function(u, h = 0) {
    return ae(this, u, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), a.prototype.writeBigInt64BE = U(function(u, h = 0) {
    return G(this, u, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ce(g, u, h, A, B, z) {
    if (h + A > g.length)
      throw new RangeError("Index out of range");
    if (h < 0)
      throw new RangeError("Index out of range");
  }
  function me(g, u, h, A, B) {
    return u = +u, h = h >>> 0, B || ce(g, u, h, 4), r.write(g, u, h, A, 23, 4), h + 4;
  }
  a.prototype.writeFloatLE = function(u, h, A) {
    return me(this, u, h, !0, A);
  }, a.prototype.writeFloatBE = function(u, h, A) {
    return me(this, u, h, !1, A);
  };
  function ye(g, u, h, A, B) {
    return u = +u, h = h >>> 0, B || ce(g, u, h, 8), r.write(g, u, h, A, 52, 8), h + 8;
  }
  a.prototype.writeDoubleLE = function(u, h, A) {
    return ye(this, u, h, !0, A);
  }, a.prototype.writeDoubleBE = function(u, h, A) {
    return ye(this, u, h, !1, A);
  }, a.prototype.copy = function(u, h, A, B) {
    if (!a.isBuffer(u))
      throw new TypeError("argument should be a Buffer");
    if (A || (A = 0), !B && B !== 0 && (B = this.length), h >= u.length && (h = u.length), h || (h = 0), B > 0 && B < A && (B = A), B === A || u.length === 0 || this.length === 0)
      return 0;
    if (h < 0)
      throw new RangeError("targetStart out of bounds");
    if (A < 0 || A >= this.length)
      throw new RangeError("Index out of range");
    if (B < 0)
      throw new RangeError("sourceEnd out of bounds");
    B > this.length && (B = this.length), u.length - h < B - A && (B = u.length - h + A);
    const z = B - A;
    return this === u && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h, A, B) : Uint8Array.prototype.set.call(
      u,
      this.subarray(A, B),
      h
    ), z;
  }, a.prototype.fill = function(u, h, A, B) {
    if (typeof u == "string") {
      if (typeof h == "string" ? (B = h, h = 0, A = this.length) : typeof A == "string" && (B = A, A = this.length), B !== void 0 && typeof B != "string")
        throw new TypeError("encoding must be a string");
      if (typeof B == "string" && !a.isEncoding(B))
        throw new TypeError("Unknown encoding: " + B);
      if (u.length === 1) {
        const F = u.charCodeAt(0);
        (B === "utf8" && F < 128 || B === "latin1") && (u = F);
      }
    } else
      typeof u == "number" ? u = u & 255 : typeof u == "boolean" && (u = Number(u));
    if (h < 0 || this.length < h || this.length < A)
      throw new RangeError("Out of range index");
    if (A <= h)
      return this;
    h = h >>> 0, A = A === void 0 ? this.length : A >>> 0, u || (u = 0);
    let z;
    if (typeof u == "number")
      for (z = h; z < A; ++z)
        this[z] = u;
    else {
      const F = a.isBuffer(u) ? u : a.from(u, B), fe = F.length;
      if (fe === 0)
        throw new TypeError('The value "' + u + '" is invalid for argument "value"');
      for (z = 0; z < A - h; ++z)
        this[z + h] = F[z % fe];
    }
    return this;
  };
  const xe = {};
  function ve(g, u, h) {
    xe[g] = class extends h {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: u.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${g}]`, this.stack, delete this.name;
      }
      get code() {
        return g;
      }
      set code(B) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: B,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${g}]: ${this.message}`;
      }
    };
  }
  ve(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(g) {
      return g ? `${g} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), ve(
    "ERR_INVALID_ARG_TYPE",
    function(g, u) {
      return `The "${g}" argument must be of type number. Received type ${typeof u}`;
    },
    TypeError
  ), ve(
    "ERR_OUT_OF_RANGE",
    function(g, u, h) {
      let A = `The value of "${g}" is out of range.`, B = h;
      return Number.isInteger(h) && Math.abs(h) > 2 ** 32 ? B = b(String(h)) : typeof h == "bigint" && (B = String(h), (h > BigInt(2) ** BigInt(32) || h < -(BigInt(2) ** BigInt(32))) && (B = b(B)), B += "n"), A += ` It must be ${u}. Received ${B}`, A;
    },
    RangeError
  );
  function b(g) {
    let u = "", h = g.length;
    const A = g[0] === "-" ? 1 : 0;
    for (; h >= A + 4; h -= 3)
      u = `_${g.slice(h - 3, h)}${u}`;
    return `${g.slice(0, h)}${u}`;
  }
  function R(g, u, h) {
    V(u, "offset"), (g[u] === void 0 || g[u + h] === void 0) && K(u, g.length - (h + 1));
  }
  function E(g, u, h, A, B, z) {
    if (g > h || g < u) {
      const F = typeof u == "bigint" ? "n" : "";
      let fe;
      throw z > 3 ? u === 0 || u === BigInt(0) ? fe = `>= 0${F} and < 2${F} ** ${(z + 1) * 8}${F}` : fe = `>= -(2${F} ** ${(z + 1) * 8 - 1}${F}) and < 2 ** ${(z + 1) * 8 - 1}${F}` : fe = `>= ${u}${F} and <= ${h}${F}`, new xe.ERR_OUT_OF_RANGE("value", fe, g);
    }
    R(A, B, z);
  }
  function V(g, u) {
    if (typeof g != "number")
      throw new xe.ERR_INVALID_ARG_TYPE(u, "number", g);
  }
  function K(g, u, h) {
    throw Math.floor(g) !== g ? (V(g, h), new xe.ERR_OUT_OF_RANGE(h || "offset", "an integer", g)) : u < 0 ? new xe.ERR_BUFFER_OUT_OF_BOUNDS() : new xe.ERR_OUT_OF_RANGE(
      h || "offset",
      `>= ${h ? 1 : 0} and <= ${u}`,
      g
    );
  }
  const $ = /[^+/0-9A-Za-z-_]/g;
  function J(g) {
    if (g = g.split("=")[0], g = g.trim().replace($, ""), g.length < 2)
      return "";
    for (; g.length % 4 !== 0; )
      g = g + "=";
    return g;
  }
  function j(g, u) {
    u = u || 1 / 0;
    let h;
    const A = g.length;
    let B = null;
    const z = [];
    for (let F = 0; F < A; ++F) {
      if (h = g.charCodeAt(F), h > 55295 && h < 57344) {
        if (!B) {
          if (h > 56319) {
            (u -= 3) > -1 && z.push(239, 191, 189);
            continue;
          } else if (F + 1 === A) {
            (u -= 3) > -1 && z.push(239, 191, 189);
            continue;
          }
          B = h;
          continue;
        }
        if (h < 56320) {
          (u -= 3) > -1 && z.push(239, 191, 189), B = h;
          continue;
        }
        h = (B - 55296 << 10 | h - 56320) + 65536;
      } else
        B && (u -= 3) > -1 && z.push(239, 191, 189);
      if (B = null, h < 128) {
        if ((u -= 1) < 0)
          break;
        z.push(h);
      } else if (h < 2048) {
        if ((u -= 2) < 0)
          break;
        z.push(
          h >> 6 | 192,
          h & 63 | 128
        );
      } else if (h < 65536) {
        if ((u -= 3) < 0)
          break;
        z.push(
          h >> 12 | 224,
          h >> 6 & 63 | 128,
          h & 63 | 128
        );
      } else if (h < 1114112) {
        if ((u -= 4) < 0)
          break;
        z.push(
          h >> 18 | 240,
          h >> 12 & 63 | 128,
          h >> 6 & 63 | 128,
          h & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return z;
  }
  function q(g) {
    const u = [];
    for (let h = 0; h < g.length; ++h)
      u.push(g.charCodeAt(h) & 255);
    return u;
  }
  function Z(g, u) {
    let h, A, B;
    const z = [];
    for (let F = 0; F < g.length && !((u -= 2) < 0); ++F)
      h = g.charCodeAt(F), A = h >> 8, B = h % 256, z.push(B), z.push(A);
    return z;
  }
  function ee(g) {
    return e.toByteArray(J(g));
  }
  function oe(g, u, h, A) {
    let B;
    for (B = 0; B < A && !(B + h >= u.length || B >= g.length); ++B)
      u[B + h] = g[B];
    return B;
  }
  function de(g, u) {
    return g instanceof u || g != null && g.constructor != null && g.constructor.name != null && g.constructor.name === u.name;
  }
  function Ee(g) {
    return g !== g;
  }
  const Ae = function() {
    const g = "0123456789abcdef", u = new Array(256);
    for (let h = 0; h < 16; ++h) {
      const A = h * 16;
      for (let B = 0; B < 16; ++B)
        u[A + B] = g[h] + g[B];
    }
    return u;
  }();
  function U(g) {
    return typeof BigInt > "u" ? te : g;
  }
  function te() {
    throw new Error("BigInt not supported");
  }
})(Tc);
var Gn = Tc, Nr = Gn.Buffer, Dt = {}, Lt;
for (Lt in Gn)
  Gn.hasOwnProperty(Lt) && (Lt === "SlowBuffer" || Lt === "Buffer" || (Dt[Lt] = Gn[Lt]));
var Ur = Dt.Buffer = {};
for (Lt in Nr)
  Nr.hasOwnProperty(Lt) && (Lt === "allocUnsafe" || Lt === "allocUnsafeSlow" || (Ur[Lt] = Nr[Lt]));
Dt.Buffer.prototype = Nr.prototype;
(!Ur.from || Ur.from === Uint8Array.from) && (Ur.from = function(t, e, r) {
  if (typeof t == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
  if (t && typeof t.length > "u")
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
  return Nr(t, e, r);
});
Ur.alloc || (Ur.alloc = function(t, e, r) {
  if (typeof t != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
  if (t < 0 || t >= 2 * (1 << 30))
    throw new RangeError('The value "' + t + '" is invalid for option "size"');
  var n = Nr(t);
  return !e || e.length === 0 ? n.fill(0) : typeof r == "string" ? n.fill(e, r) : n.fill(e), n;
});
if (!Dt.kStringMaxLength)
  try {
    Dt.kStringMaxLength = process.binding("buffer").kStringMaxLength;
  } catch {
  }
Dt.constants || (Dt.constants = {
  MAX_LENGTH: Dt.kMaxLength
}, Dt.kStringMaxLength && (Dt.constants.MAX_STRING_LENGTH = Dt.kStringMaxLength));
var os = Dt, yi = {};
const vd = Er;
function Ut(t) {
  this._reporterState = {
    obj: null,
    path: [],
    options: t || {},
    errors: []
  };
}
yi.Reporter = Ut;
Ut.prototype.isError = function(e) {
  return e instanceof Wr;
};
Ut.prototype.save = function() {
  const e = this._reporterState;
  return { obj: e.obj, pathLen: e.path.length };
};
Ut.prototype.restore = function(e) {
  const r = this._reporterState;
  r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
};
Ut.prototype.enterKey = function(e) {
  return this._reporterState.path.push(e);
};
Ut.prototype.exitKey = function(e) {
  const r = this._reporterState;
  r.path = r.path.slice(0, e - 1);
};
Ut.prototype.leaveKey = function(e, r, n) {
  const i = this._reporterState;
  this.exitKey(e), i.obj !== null && (i.obj[r] = n);
};
Ut.prototype.path = function() {
  return this._reporterState.path.join("/");
};
Ut.prototype.enterObject = function() {
  const e = this._reporterState, r = e.obj;
  return e.obj = {}, r;
};
Ut.prototype.leaveObject = function(e) {
  const r = this._reporterState, n = r.obj;
  return r.obj = e, n;
};
Ut.prototype.error = function(e) {
  let r;
  const n = this._reporterState, i = e instanceof Wr;
  if (i ? r = e : r = new Wr(n.path.map(function(o) {
    return "[" + JSON.stringify(o) + "]";
  }).join(""), e.message || e, e.stack), !n.options.partial)
    throw r;
  return i || n.errors.push(r), r;
};
Ut.prototype.wrapResult = function(e) {
  const r = this._reporterState;
  return r.options.partial ? {
    result: this.isError(e) ? null : e,
    errors: r.errors
  } : e;
};
function Wr(t, e) {
  this.path = t, this.rethrow(e);
}
vd(Wr, Error);
Wr.prototype.rethrow = function(e) {
  if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Wr), !this.stack)
    try {
      throw new Error(this.message);
    } catch (r) {
      this.stack = r.stack;
    }
  return this;
};
var xr = {};
const wd = Er, vi = yi.Reporter, Hr = os.Buffer;
function Nt(t, e) {
  if (vi.call(this, e), !Hr.isBuffer(t)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = t, this.offset = 0, this.length = t.length;
}
wd(Nt, vi);
xr.DecoderBuffer = Nt;
Nt.isDecoderBuffer = function(e) {
  return e instanceof Nt ? !0 : typeof e == "object" && Hr.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
};
Nt.prototype.save = function() {
  return { offset: this.offset, reporter: vi.prototype.save.call(this) };
};
Nt.prototype.restore = function(e) {
  const r = new Nt(this.base);
  return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, vi.prototype.restore.call(this, e.reporter), r;
};
Nt.prototype.isEmpty = function() {
  return this.offset === this.length;
};
Nt.prototype.readUInt8 = function(e) {
  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(e || "DecoderBuffer overrun");
};
Nt.prototype.skip = function(e, r) {
  if (!(this.offset + e <= this.length))
    return this.error(r || "DecoderBuffer overrun");
  const n = new Nt(this.base);
  return n._reporterState = this._reporterState, n.offset = this.offset, n.length = this.offset + e, this.offset += e, n;
};
Nt.prototype.raw = function(e) {
  return this.base.slice(e ? e.offset : this.offset, this.length);
};
function Kr(t, e) {
  if (Array.isArray(t))
    this.length = 0, this.value = t.map(function(r) {
      return Kr.isEncoderBuffer(r) || (r = new Kr(r, e)), this.length += r.length, r;
    }, this);
  else if (typeof t == "number") {
    if (!(0 <= t && t <= 255))
      return e.error("non-byte EncoderBuffer value");
    this.value = t, this.length = 1;
  } else if (typeof t == "string")
    this.value = t, this.length = Hr.byteLength(t);
  else if (Hr.isBuffer(t))
    this.value = t, this.length = t.length;
  else
    return e.error("Unsupported type: " + typeof t);
}
xr.EncoderBuffer = Kr;
Kr.isEncoderBuffer = function(e) {
  return e instanceof Kr ? !0 : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
};
Kr.prototype.join = function(e, r) {
  return e || (e = Hr.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(n) {
    n.join(e, r), r += n.length;
  }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : Hr.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;
};
var _d = Ac;
function Ac(t, e) {
  if (!t)
    throw new Error(e || "Assertion failed");
}
Ac.equal = function(e, r, n) {
  if (e != r)
    throw new Error(n || "Assertion failed: " + e + " != " + r);
};
const bd = yi.Reporter, xd = xr.EncoderBuffer, Td = xr.DecoderBuffer, Et = _d, Mc = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
], Ed = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(Mc), Ad = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function je(t, e, r) {
  const n = {};
  this._baseState = n, n.name = r, n.enc = t, n.parent = e || null, n.children = null, n.tag = null, n.args = null, n.reverseArgs = null, n.choice = null, n.optional = !1, n.any = !1, n.obj = !1, n.use = null, n.useDecoder = null, n.key = null, n.default = null, n.explicit = null, n.implicit = null, n.contains = null, n.parent || (n.children = [], this._wrap());
}
var ss = je;
const Md = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
je.prototype.clone = function() {
  const e = this._baseState, r = {};
  Md.forEach(function(i) {
    r[i] = e[i];
  });
  const n = new this.constructor(r.parent);
  return n._baseState = r, n;
};
je.prototype._wrap = function() {
  const e = this._baseState;
  Ed.forEach(function(r) {
    this[r] = function() {
      const i = new this.constructor(this);
      return e.children.push(i), i[r].apply(i, arguments);
    };
  }, this);
};
je.prototype._init = function(e) {
  const r = this._baseState;
  Et(r.parent === null), e.call(this), r.children = r.children.filter(function(n) {
    return n._baseState.parent === this;
  }, this), Et.equal(r.children.length, 1, "Root node can have only one child");
};
je.prototype._useArgs = function(e) {
  const r = this._baseState, n = e.filter(function(i) {
    return i instanceof this.constructor;
  }, this);
  e = e.filter(function(i) {
    return !(i instanceof this.constructor);
  }, this), n.length !== 0 && (Et(r.children === null), r.children = n, n.forEach(function(i) {
    i._baseState.parent = this;
  }, this)), e.length !== 0 && (Et(r.args === null), r.args = e, r.reverseArgs = e.map(function(i) {
    if (typeof i != "object" || i.constructor !== Object)
      return i;
    const o = {};
    return Object.keys(i).forEach(function(s) {
      s == (s | 0) && (s |= 0);
      const a = i[s];
      o[a] = s;
    }), o;
  }));
};
Ad.forEach(function(t) {
  je.prototype[t] = function() {
    const r = this._baseState;
    throw new Error(t + " not implemented for encoding: " + r.enc);
  };
});
Mc.forEach(function(t) {
  je.prototype[t] = function() {
    const r = this._baseState, n = Array.prototype.slice.call(arguments);
    return Et(r.tag === null), r.tag = t, this._useArgs(n), this;
  };
});
je.prototype.use = function(e) {
  Et(e);
  const r = this._baseState;
  return Et(r.use === null), r.use = e, this;
};
je.prototype.optional = function() {
  const e = this._baseState;
  return e.optional = !0, this;
};
je.prototype.def = function(e) {
  const r = this._baseState;
  return Et(r.default === null), r.default = e, r.optional = !0, this;
};
je.prototype.explicit = function(e) {
  const r = this._baseState;
  return Et(r.explicit === null && r.implicit === null), r.explicit = e, this;
};
je.prototype.implicit = function(e) {
  const r = this._baseState;
  return Et(r.explicit === null && r.implicit === null), r.implicit = e, this;
};
je.prototype.obj = function() {
  const e = this._baseState, r = Array.prototype.slice.call(arguments);
  return e.obj = !0, r.length !== 0 && this._useArgs(r), this;
};
je.prototype.key = function(e) {
  const r = this._baseState;
  return Et(r.key === null), r.key = e, this;
};
je.prototype.any = function() {
  const e = this._baseState;
  return e.any = !0, this;
};
je.prototype.choice = function(e) {
  const r = this._baseState;
  return Et(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(n) {
    return e[n];
  })), this;
};
je.prototype.contains = function(e) {
  const r = this._baseState;
  return Et(r.use === null), r.contains = e, this;
};
je.prototype._decode = function(e, r) {
  const n = this._baseState;
  if (n.parent === null)
    return e.wrapResult(n.children[0]._decode(e, r));
  let i = n.default, o = !0, s = null;
  if (n.key !== null && (s = e.enterKey(n.key)), n.optional) {
    let f = null;
    if (n.explicit !== null ? f = n.explicit : n.implicit !== null ? f = n.implicit : n.tag !== null && (f = n.tag), f === null && !n.any) {
      const p = e.save();
      try {
        n.choice === null ? this._decodeGeneric(n.tag, e, r) : this._decodeChoice(e, r), o = !0;
      } catch {
        o = !1;
      }
      e.restore(p);
    } else if (o = this._peekTag(e, f, n.any), e.isError(o))
      return o;
  }
  let a;
  if (n.obj && o && (a = e.enterObject()), o) {
    if (n.explicit !== null) {
      const p = this._decodeTag(e, n.explicit);
      if (e.isError(p))
        return p;
      e = p;
    }
    const f = e.offset;
    if (n.use === null && n.choice === null) {
      let p;
      n.any && (p = e.save());
      const d = this._decodeTag(
        e,
        n.implicit !== null ? n.implicit : n.tag,
        n.any
      );
      if (e.isError(d))
        return d;
      n.any ? i = e.raw(p) : e = d;
    }
    if (r && r.track && n.tag !== null && r.track(e.path(), f, e.length, "tagged"), r && r.track && n.tag !== null && r.track(e.path(), e.offset, e.length, "content"), n.any || (n.choice === null ? i = this._decodeGeneric(n.tag, e, r) : i = this._decodeChoice(e, r)), e.isError(i))
      return i;
    if (!n.any && n.choice === null && n.children !== null && n.children.forEach(function(d) {
      d._decode(e, r);
    }), n.contains && (n.tag === "octstr" || n.tag === "bitstr")) {
      const p = new Td(i);
      i = this._getUse(n.contains, e._reporterState.obj)._decode(p, r);
    }
  }
  return n.obj && o && (i = e.leaveObject(a)), n.key !== null && (i !== null || o === !0) ? e.leaveKey(s, n.key, i) : s !== null && e.exitKey(s), i;
};
je.prototype._decodeGeneric = function(e, r, n) {
  const i = this._baseState;
  return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, i.args[0], n) : /str$/.test(e) ? this._decodeStr(r, e, n) : e === "objid" && i.args ? this._decodeObjid(r, i.args[0], i.args[1], n) : e === "objid" ? this._decodeObjid(r, null, null, n) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, n) : e === "null_" ? this._decodeNull(r, n) : e === "bool" ? this._decodeBool(r, n) : e === "objDesc" ? this._decodeStr(r, e, n) : e === "int" || e === "enum" ? this._decodeInt(r, i.args && i.args[0], n) : i.use !== null ? this._getUse(i.use, r._reporterState.obj)._decode(r, n) : r.error("unknown tag: " + e);
};
je.prototype._getUse = function(e, r) {
  const n = this._baseState;
  return n.useDecoder = this._use(e, r), Et(n.useDecoder._baseState.parent === null), n.useDecoder = n.useDecoder._baseState.children[0], n.implicit !== n.useDecoder._baseState.implicit && (n.useDecoder = n.useDecoder.clone(), n.useDecoder._baseState.implicit = n.implicit), n.useDecoder;
};
je.prototype._decodeChoice = function(e, r) {
  const n = this._baseState;
  let i = null, o = !1;
  return Object.keys(n.choice).some(function(s) {
    const a = e.save(), f = n.choice[s];
    try {
      const p = f._decode(e, r);
      if (e.isError(p))
        return !1;
      i = { type: s, value: p }, o = !0;
    } catch {
      return e.restore(a), !1;
    }
    return !0;
  }, this), o ? i : e.error("Choice not matched");
};
je.prototype._createEncoderBuffer = function(e) {
  return new xd(e, this.reporter);
};
je.prototype._encode = function(e, r, n) {
  const i = this._baseState;
  if (i.default !== null && i.default === e)
    return;
  const o = this._encodeValue(e, r, n);
  if (o !== void 0 && !this._skipDefault(o, r, n))
    return o;
};
je.prototype._encodeValue = function(e, r, n) {
  const i = this._baseState;
  if (i.parent === null)
    return i.children[0]._encode(e, r || new bd());
  let o = null;
  if (this.reporter = r, i.optional && e === void 0)
    if (i.default !== null)
      e = i.default;
    else
      return;
  let s = null, a = !1;
  if (i.any)
    o = this._createEncoderBuffer(e);
  else if (i.choice)
    o = this._encodeChoice(e, r);
  else if (i.contains)
    s = this._getUse(i.contains, n)._encode(e, r), a = !0;
  else if (i.children)
    s = i.children.map(function(f) {
      if (f._baseState.tag === "null_")
        return f._encode(null, r, e);
      if (f._baseState.key === null)
        return r.error("Child should have a key");
      const p = r.enterKey(f._baseState.key);
      if (typeof e != "object")
        return r.error("Child expected, but input is not object");
      const d = f._encode(e[f._baseState.key], r, e);
      return r.leaveKey(p), d;
    }, this).filter(function(f) {
      return f;
    }), s = this._createEncoderBuffer(s);
  else if (i.tag === "seqof" || i.tag === "setof") {
    if (!(i.args && i.args.length === 1))
      return r.error("Too many args for : " + i.tag);
    if (!Array.isArray(e))
      return r.error("seqof/setof, but data is not Array");
    const f = this.clone();
    f._baseState.implicit = null, s = this._createEncoderBuffer(e.map(function(p) {
      const d = this._baseState;
      return this._getUse(d.args[0], e)._encode(p, r);
    }, f));
  } else
    i.use !== null ? o = this._getUse(i.use, n)._encode(e, r) : (s = this._encodePrimitive(i.tag, e), a = !0);
  if (!i.any && i.choice === null) {
    const f = i.implicit !== null ? i.implicit : i.tag, p = i.implicit === null ? "universal" : "context";
    f === null ? i.use === null && r.error("Tag could be omitted only for .use()") : i.use === null && (o = this._encodeComposite(f, a, p, s));
  }
  return i.explicit !== null && (o = this._encodeComposite(i.explicit, !1, "context", o)), o;
};
je.prototype._encodeChoice = function(e, r) {
  const n = this._baseState, i = n.choice[e.type];
  return i || Et(
    !1,
    e.type + " not found in " + JSON.stringify(Object.keys(n.choice))
  ), i._encode(e.value, r);
};
je.prototype._encodePrimitive = function(e, r) {
  const n = this._baseState;
  if (/str$/.test(e))
    return this._encodeStr(r, e);
  if (e === "objid" && n.args)
    return this._encodeObjid(r, n.reverseArgs[0], n.args[1]);
  if (e === "objid")
    return this._encodeObjid(r, null, null);
  if (e === "gentime" || e === "utctime")
    return this._encodeTime(r, e);
  if (e === "null_")
    return this._encodeNull();
  if (e === "int" || e === "enum")
    return this._encodeInt(r, n.args && n.reverseArgs[0]);
  if (e === "bool")
    return this._encodeBool(r);
  if (e === "objDesc")
    return this._encodeStr(r, e);
  throw new Error("Unsupported tag: " + e);
};
je.prototype._isNumstr = function(e) {
  return /^[0-9 ]*$/.test(e);
};
je.prototype._isPrintstr = function(e) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
};
var wi = {};
(function(t) {
  function e(r) {
    const n = {};
    return Object.keys(r).forEach(function(i) {
      (i | 0) == i && (i = i | 0);
      const o = r[i];
      n[o] = i;
    }), n;
  }
  t.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  }, t.tagClassByName = e(t.tagClass), t.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  }, t.tagByName = e(t.tag);
})(wi);
const Sd = Er, er = os.Buffer, Sc = ss, Fi = wi;
function Pc(t) {
  this.enc = "der", this.name = t.name, this.entity = t, this.tree = new qt(), this.tree._init(t.body);
}
var Cc = Pc;
Pc.prototype.encode = function(e, r) {
  return this.tree._encode(e, r).join();
};
function qt(t) {
  Sc.call(this, "der", t);
}
Sd(qt, Sc);
qt.prototype._encodeComposite = function(e, r, n, i) {
  const o = Pd(e, r, n, this.reporter);
  if (i.length < 128) {
    const f = er.alloc(2);
    return f[0] = o, f[1] = i.length, this._createEncoderBuffer([f, i]);
  }
  let s = 1;
  for (let f = i.length; f >= 256; f >>= 8)
    s++;
  const a = er.alloc(1 + 1 + s);
  a[0] = o, a[1] = 128 | s;
  for (let f = 1 + s, p = i.length; p > 0; f--, p >>= 8)
    a[f] = p & 255;
  return this._createEncoderBuffer([a, i]);
};
qt.prototype._encodeStr = function(e, r) {
  if (r === "bitstr")
    return this._createEncoderBuffer([e.unused | 0, e.data]);
  if (r === "bmpstr") {
    const n = er.alloc(e.length * 2);
    for (let i = 0; i < e.length; i++)
      n.writeUInt16BE(e.charCodeAt(i), i * 2);
    return this._createEncoderBuffer(n);
  } else
    return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported");
};
qt.prototype._encodeObjid = function(e, r, n) {
  if (typeof e == "string") {
    if (!r)
      return this.reporter.error("string objid given, but no values map found");
    if (!r.hasOwnProperty(e))
      return this.reporter.error("objid not found in values map");
    e = r[e].split(/[\s.]+/g);
    for (let a = 0; a < e.length; a++)
      e[a] |= 0;
  } else if (Array.isArray(e)) {
    e = e.slice();
    for (let a = 0; a < e.length; a++)
      e[a] |= 0;
  }
  if (!Array.isArray(e))
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
  if (!n) {
    if (e[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    e.splice(0, 2, e[0] * 40 + e[1]);
  }
  let i = 0;
  for (let a = 0; a < e.length; a++) {
    let f = e[a];
    for (i++; f >= 128; f >>= 7)
      i++;
  }
  const o = er.alloc(i);
  let s = o.length - 1;
  for (let a = e.length - 1; a >= 0; a--) {
    let f = e[a];
    for (o[s--] = f & 127; (f >>= 7) > 0; )
      o[s--] = 128 | f & 127;
  }
  return this._createEncoderBuffer(o);
};
function Bt(t) {
  return t < 10 ? "0" + t : t;
}
qt.prototype._encodeTime = function(e, r) {
  let n;
  const i = new Date(e);
  return r === "gentime" ? n = [
    Bt(i.getUTCFullYear()),
    Bt(i.getUTCMonth() + 1),
    Bt(i.getUTCDate()),
    Bt(i.getUTCHours()),
    Bt(i.getUTCMinutes()),
    Bt(i.getUTCSeconds()),
    "Z"
  ].join("") : r === "utctime" ? n = [
    Bt(i.getUTCFullYear() % 100),
    Bt(i.getUTCMonth() + 1),
    Bt(i.getUTCDate()),
    Bt(i.getUTCHours()),
    Bt(i.getUTCMinutes()),
    Bt(i.getUTCSeconds()),
    "Z"
  ].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(n, "octstr");
};
qt.prototype._encodeNull = function() {
  return this._createEncoderBuffer("");
};
qt.prototype._encodeInt = function(e, r) {
  if (typeof e == "string") {
    if (!r)
      return this.reporter.error("String int or enum given, but no values map");
    if (!r.hasOwnProperty(e))
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
    e = r[e];
  }
  if (typeof e != "number" && !er.isBuffer(e)) {
    const o = e.toArray();
    !e.sign && o[0] & 128 && o.unshift(0), e = er.from(o);
  }
  if (er.isBuffer(e)) {
    let o = e.length;
    e.length === 0 && o++;
    const s = er.alloc(o);
    return e.copy(s), e.length === 0 && (s[0] = 0), this._createEncoderBuffer(s);
  }
  if (e < 128)
    return this._createEncoderBuffer(e);
  if (e < 256)
    return this._createEncoderBuffer([0, e]);
  let n = 1;
  for (let o = e; o >= 256; o >>= 8)
    n++;
  const i = new Array(n);
  for (let o = i.length - 1; o >= 0; o--)
    i[o] = e & 255, e >>= 8;
  return i[0] & 128 && i.unshift(0), this._createEncoderBuffer(er.from(i));
};
qt.prototype._encodeBool = function(e) {
  return this._createEncoderBuffer(e ? 255 : 0);
};
qt.prototype._use = function(e, r) {
  return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree;
};
qt.prototype._skipDefault = function(e, r, n) {
  const i = this._baseState;
  let o;
  if (i.default === null)
    return !1;
  const s = e.join();
  if (i.defaultBuffer === void 0 && (i.defaultBuffer = this._encodeValue(i.default, r, n).join()), s.length !== i.defaultBuffer.length)
    return !1;
  for (o = 0; o < s.length; o++)
    if (s[o] !== i.defaultBuffer[o])
      return !1;
  return !0;
};
function Pd(t, e, r, n) {
  let i;
  if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), Fi.tagByName.hasOwnProperty(t))
    i = Fi.tagByName[t];
  else if (typeof t == "number" && (t | 0) === t)
    i = t;
  else
    return n.error("Unknown tag: " + t);
  return i >= 31 ? n.error("Multi-octet tag encoding unsupported") : (e || (i |= 32), i |= Fi.tagClassByName[r || "universal"] << 6, i);
}
const Cd = Er, as = Cc;
function us(t) {
  as.call(this, t), this.enc = "pem";
}
Cd(us, as);
var Od = us;
us.prototype.encode = function(e, r) {
  const i = as.prototype.encode.call(this, e).toString("base64"), o = ["-----BEGIN " + r.label + "-----"];
  for (let s = 0; s < i.length; s += 64)
    o.push(i.slice(s, s + 64));
  return o.push("-----END " + r.label + "-----"), o.join(`
`);
};
(function(t) {
  const e = t;
  e.der = Cc, e.pem = Od;
})(ns);
var cs = {};
const Rd = Er, Id = bc, _a = xr.DecoderBuffer, Oc = ss, ba = wi;
function Rc(t) {
  this.enc = "der", this.name = t.name, this.entity = t, this.tree = new It(), this.tree._init(t.body);
}
var Ic = Rc;
Rc.prototype.decode = function(e, r) {
  return _a.isDecoderBuffer(e) || (e = new _a(e, r)), this.tree._decode(e, r);
};
function It(t) {
  Oc.call(this, "der", t);
}
Rd(It, Oc);
It.prototype._peekTag = function(e, r, n) {
  if (e.isEmpty())
    return !1;
  const i = e.save(), o = ls(e, 'Failed to peek tag: "' + r + '"');
  return e.isError(o) ? o : (e.restore(i), o.tag === r || o.tagStr === r || o.tagStr + "of" === r || n);
};
It.prototype._decodeTag = function(e, r, n) {
  const i = ls(
    e,
    'Failed to decode tag of "' + r + '"'
  );
  if (e.isError(i))
    return i;
  let o = Bc(
    e,
    i.primitive,
    'Failed to get length of "' + r + '"'
  );
  if (e.isError(o))
    return o;
  if (!n && i.tag !== r && i.tagStr !== r && i.tagStr + "of" !== r)
    return e.error('Failed to match tag: "' + r + '"');
  if (i.primitive || o !== null)
    return e.skip(o, 'Failed to match body of: "' + r + '"');
  const s = e.save(), a = this._skipUntilEnd(
    e,
    'Failed to skip indefinite length body: "' + this.tag + '"'
  );
  return e.isError(a) ? a : (o = e.offset - s.offset, e.restore(s), e.skip(o, 'Failed to match body of: "' + r + '"'));
};
It.prototype._skipUntilEnd = function(e, r) {
  for (; ; ) {
    const n = ls(e, r);
    if (e.isError(n))
      return n;
    const i = Bc(e, n.primitive, r);
    if (e.isError(i))
      return i;
    let o;
    if (n.primitive || i !== null ? o = e.skip(i) : o = this._skipUntilEnd(e, r), e.isError(o))
      return o;
    if (n.tagStr === "end")
      break;
  }
};
It.prototype._decodeList = function(e, r, n, i) {
  const o = [];
  for (; !e.isEmpty(); ) {
    const s = this._peekTag(e, "end");
    if (e.isError(s))
      return s;
    const a = n.decode(e, "der", i);
    if (e.isError(a) && s)
      break;
    o.push(a);
  }
  return o;
};
It.prototype._decodeStr = function(e, r) {
  if (r === "bitstr") {
    const n = e.readUInt8();
    return e.isError(n) ? n : { unused: n, data: e.raw() };
  } else if (r === "bmpstr") {
    const n = e.raw();
    if (n.length % 2 === 1)
      return e.error("Decoding of string type: bmpstr length mismatch");
    let i = "";
    for (let o = 0; o < n.length / 2; o++)
      i += String.fromCharCode(n.readUInt16BE(o * 2));
    return i;
  } else if (r === "numstr") {
    const n = e.raw().toString("ascii");
    return this._isNumstr(n) ? n : e.error("Decoding of string type: numstr unsupported characters");
  } else {
    if (r === "octstr")
      return e.raw();
    if (r === "objDesc")
      return e.raw();
    if (r === "printstr") {
      const n = e.raw().toString("ascii");
      return this._isPrintstr(n) ? n : e.error("Decoding of string type: printstr unsupported characters");
    } else
      return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported");
  }
};
It.prototype._decodeObjid = function(e, r, n) {
  let i;
  const o = [];
  let s = 0, a = 0;
  for (; !e.isEmpty(); )
    a = e.readUInt8(), s <<= 7, s |= a & 127, a & 128 || (o.push(s), s = 0);
  a & 128 && o.push(s);
  const f = o[0] / 40 | 0, p = o[0] % 40;
  if (n ? i = o : i = [f, p].concat(o.slice(1)), r) {
    let d = r[i.join(" ")];
    d === void 0 && (d = r[i.join(".")]), d !== void 0 && (i = d);
  }
  return i;
};
It.prototype._decodeTime = function(e, r) {
  const n = e.raw().toString();
  let i, o, s, a, f, p;
  if (r === "gentime")
    i = n.slice(0, 4) | 0, o = n.slice(4, 6) | 0, s = n.slice(6, 8) | 0, a = n.slice(8, 10) | 0, f = n.slice(10, 12) | 0, p = n.slice(12, 14) | 0;
  else if (r === "utctime")
    i = n.slice(0, 2) | 0, o = n.slice(2, 4) | 0, s = n.slice(4, 6) | 0, a = n.slice(6, 8) | 0, f = n.slice(8, 10) | 0, p = n.slice(10, 12) | 0, i < 70 ? i = 2e3 + i : i = 1900 + i;
  else
    return e.error("Decoding " + r + " time is not supported yet");
  return Date.UTC(i, o - 1, s, a, f, p, 0);
};
It.prototype._decodeNull = function() {
  return null;
};
It.prototype._decodeBool = function(e) {
  const r = e.readUInt8();
  return e.isError(r) ? r : r !== 0;
};
It.prototype._decodeInt = function(e, r) {
  const n = e.raw();
  let i = new Id(n);
  return r && (i = r[i.toString(10)] || i), i;
};
It.prototype._use = function(e, r) {
  return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree;
};
function ls(t, e) {
  let r = t.readUInt8(e);
  if (t.isError(r))
    return r;
  const n = ba.tagClass[r >> 6], i = (r & 32) === 0;
  if ((r & 31) === 31) {
    let s = r;
    for (r = 0; (s & 128) === 128; ) {
      if (s = t.readUInt8(e), t.isError(s))
        return s;
      r <<= 7, r |= s & 127;
    }
  } else
    r &= 31;
  const o = ba.tag[r];
  return {
    cls: n,
    primitive: i,
    tag: r,
    tagStr: o
  };
}
function Bc(t, e, r) {
  let n = t.readUInt8(r);
  if (t.isError(n))
    return n;
  if (!e && n === 128)
    return null;
  if (!(n & 128))
    return n;
  const i = n & 127;
  if (i > 4)
    return t.error("length octect is too long");
  n = 0;
  for (let o = 0; o < i; o++) {
    n <<= 8;
    const s = t.readUInt8(r);
    if (t.isError(s))
      return s;
    n |= s;
  }
  return n;
}
const Bd = Er, kd = os.Buffer, fs = Ic;
function hs(t) {
  fs.call(this, t), this.enc = "pem";
}
Bd(hs, fs);
var Dd = hs;
hs.prototype.decode = function(e, r) {
  const n = e.toString().split(/[\r\n]+/g), i = r.label.toUpperCase(), o = /^-----(BEGIN|END) ([^-]+)-----$/;
  let s = -1, a = -1;
  for (let d = 0; d < n.length; d++) {
    const y = n[d].match(o);
    if (y !== null && y[2] === i)
      if (s === -1) {
        if (y[1] !== "BEGIN")
          break;
        s = d;
      } else {
        if (y[1] !== "END")
          break;
        a = d;
        break;
      }
  }
  if (s === -1 || a === -1)
    throw new Error("PEM section not found for: " + i);
  const f = n.slice(s + 1, a).join("");
  f.replace(/[^a-z0-9+/=]+/gi, "");
  const p = kd.from(f, "base64");
  return fs.prototype.decode.call(this, p, r);
};
(function(t) {
  const e = t;
  e.der = Ic, e.pem = Dd;
})(cs);
(function(t) {
  const e = ns, r = cs, n = Er, i = t;
  i.define = function(a, f) {
    return new o(a, f);
  };
  function o(s, a) {
    this.name = s, this.body = a, this.decoders = {}, this.encoders = {};
  }
  o.prototype._createNamed = function(a) {
    const f = this.name;
    function p(d) {
      this._initNamed(d, f);
    }
    return n(p, a), p.prototype._initNamed = function(y, v) {
      a.call(this, y, v);
    }, new p(this);
  }, o.prototype._getDecoder = function(a) {
    return a = a || "der", this.decoders.hasOwnProperty(a) || (this.decoders[a] = this._createNamed(r[a])), this.decoders[a];
  }, o.prototype.decode = function(a, f, p) {
    return this._getDecoder(f).decode(a, p);
  }, o.prototype._getEncoder = function(a) {
    return a = a || "der", this.encoders.hasOwnProperty(a) || (this.encoders[a] = this._createNamed(e[a])), this.encoders[a];
  }, o.prototype.encode = function(a, f, p) {
    return this._getEncoder(f).encode(a, p);
  };
})(xc);
var kc = {};
(function(t) {
  const e = t;
  e.Reporter = yi.Reporter, e.DecoderBuffer = xr.DecoderBuffer, e.EncoderBuffer = xr.EncoderBuffer, e.Node = ss;
})(kc);
var Dc = {};
(function(t) {
  const e = t;
  e._reverse = function(n) {
    const i = {};
    return Object.keys(n).forEach(function(o) {
      (o | 0) == o && (o = o | 0);
      const s = n[o];
      i[s] = o;
    }), i;
  }, e.der = wi;
})(Dc);
(function(t) {
  const e = t;
  e.bignum = bc, e.define = xc.define, e.base = kc, e.constants = Dc, e.decoders = cs, e.encoders = ns;
})(wc);
var Ld = ge && ge.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var i = Object.getOwnPropertyDescriptor(e, r);
  (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, i);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), Nd = ge && ge.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), Ud = ge && ge.__importStar || function(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var r in t)
      r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && Ld(e, t, r);
  return Nd(e, t), e;
};
Object.defineProperty(gi, "__esModule", { value: !0 });
gi.pemTojwk = Gd;
gi.jwkTopem = Yd;
const rr = Ud(wc);
function Fd(t) {
  return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function ds(t) {
  return Fd(Buffer.from(t, "hex").toString("base64"));
}
var Lc = rr.define("RSAPublicKey", function() {
  this.seq().obj(this.key("n").int(), this.key("e").int());
}), Nc = rr.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional().any());
}), jd = rr.define("PublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(Nc), this.key("publicKey").bitstr());
}), Uc = rr.define("Version", function() {
  this.int({
    0: "two-prime",
    1: "multi"
  });
}), $d = rr.define("OtherPrimeInfos", function() {
  this.seq().obj(this.key("ri").int(), this.key("di").int(), this.key("ti").int());
}), Fc = rr.define("RSAPrivateKey", function() {
  this.seq().obj(this.key("version").use(Uc), this.key("n").int(), this.key("e").int(), this.key("d").int(), this.key("p").int(), this.key("q").int(), this.key("dp").int(), this.key("dq").int(), this.key("qi").int(), this.key("other").optional().use($d));
}), Vd = rr.define("PrivateKeyInfo", function() {
  this.seq().obj(this.key("version").use(Uc), this.key("algorithm").use(Nc), this.key("privateKey").bitstr());
});
function jc(t, e) {
  return e = e || {}, Object.keys(e).forEach(function(r) {
    t[r] = e[r];
  }), t;
}
function ps(t) {
  return t.length % 2 === 1 ? "0" + t : t;
}
function $c(t, e) {
  var r = Lc.decode(t, "der"), n = ps(r.e.toString(16)), i = {
    kty: "RSA",
    n: ir(r.n),
    e: ds(n)
  };
  return jc(i, e);
}
function Vc(t, e) {
  var r = Fc.decode(t, "der"), n = ps(r.e.toString(16)), i = {
    kty: "RSA",
    n: ir(r.n),
    e: ds(n),
    d: ir(r.d),
    p: ir(r.p),
    q: ir(r.q),
    dp: ir(r.dp),
    dq: ir(r.dq),
    qi: ir(r.qi)
  };
  return jc(i, e);
}
function qd(t, e) {
  var r = jd.decode(t, "der");
  return $c(r.publicKey.data, e);
}
function Wd(t, e) {
  var r = Vd.decode(t, "der");
  return Vc(r.privateKey.data, e);
}
function Hd(t) {
  var e = /^-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----$/.exec(t);
  if (!e)
    return null;
  var r = !!e[1], n = e[2] === "PRIVATE";
  return n ? r ? Vc : Wd : r ? $c : qd;
}
function Kd(t) {
  return {
    n: nr(t.n),
    e: nr(t.e),
    d: t.d && nr(t.d),
    p: t.p && nr(t.p),
    q: t.q && nr(t.q),
    dp: t.dp && nr(t.dp),
    dq: t.dq && nr(t.dq),
    qi: t.qi && nr(t.qi)
  };
}
function ir(t) {
  return ds(ps(t.toString(16)));
}
function zd(t) {
  return new rr.bignum(Buffer.from(t, "base64"));
}
function nr(t) {
  return /^[0-9]+$/.test(t) ? new rr.bignum(t, 10) : zd(t);
}
function Gd(t, e) {
  var r = t.toString().split(/(\r\n|\r|\n)+/g);
  r = r.filter(function(i) {
    return i.trim().length !== 0;
  });
  var n = Hd(r[0]);
  return r = r.slice(1, -1).join(""), n(Buffer.from(r.replace(/[^\w\d\+\/=]+/g, ""), "base64"), e);
}
function Yd(t) {
  var e = Kd(t), r = !!e.d, n = r ? "PRIVATE" : "PUBLIC", i = "-----BEGIN RSA " + n + ` KEY-----
`, o = `
-----END RSA ` + n + ` KEY-----
`, s = Buffer.alloc(0);
  r ? (e.version = "two-prime", s = Fc.encode(e, "der")) : s = Lc.encode(e, "der");
  var a = s.toString("base64").match(/.{1,64}/g).join(`
`);
  return i + a + o;
}
var Xd = ge && ge.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var i = Object.getOwnPropertyDescriptor(e, r);
  (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, i);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), Zd = ge && ge.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), Jd = ge && ge.__importStar || function(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var r in t)
      r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && Xd(e, t, r);
  return Zd(e, t), e;
};
Object.defineProperty(ts, "__esModule", { value: !0 });
const xa = gi, Pt = Jd(_c);
class Qd {
  constructor() {
    pe(this, "keyLength", 4096);
    pe(this, "publicExponent", 65537);
    pe(this, "hashAlgorithm", "sha256");
    pe(this, "encryptionAlgorithm", "aes-256-cbc");
  }
  generateJWK() {
    if (typeof Pt.generateKeyPair != "function")
      throw new Error("Keypair generation not supported in this version of Node, only supported in versions 10+");
    return new Promise((e, r) => {
      Pt.generateKeyPair("rsa", {
        modulusLength: this.keyLength,
        publicExponent: this.publicExponent,
        privateKeyEncoding: {
          type: "pkcs1",
          format: "pem"
        },
        publicKeyEncoding: { type: "pkcs1", format: "pem" }
      }, (n, i, o) => {
        n && r(n), e(this.pemToJWK(o));
      });
    });
  }
  sign(e, r, { saltLength: n } = {}) {
    return new Promise((i, o) => {
      i(Pt.createSign(this.hashAlgorithm).update(r).sign({
        key: this.jwkToPem(e),
        padding: Pt.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: n
      }));
    });
  }
  verify(e, r, n) {
    return new Promise((i, o) => {
      var y;
      const s = {
        kty: "RSA",
        e: "AQAB",
        n: e
      }, a = this.jwkToPem(s), f = Pt.createPublicKey({
        key: a,
        format: "pem"
      }), p = Pt.createVerify(this.hashAlgorithm);
      p.update(r);
      const d = p.verify({
        key: f,
        padding: Pt.constants.RSA_PKCS1_PSS_PADDING
      }, n);
      if (!d) {
        const v = {
          asymmetricKeyType: f.asymmetricKeyType,
          modulusLength: (y = f.asymmetricKeyDetails) == null ? void 0 : y.modulusLength
        };
        console.warn(`Transaction Verification Failed! 
Details: ${JSON.stringify(v, null, 2)} 
N.B. ArweaveJS is only guaranteed to verify txs created using ArweaveJS.`);
      }
      i(d);
    });
  }
  hash(e, r = "SHA-256") {
    if (typeof e == "string")
      throw new TypeError("Data must be a Uint8Array");
    return new Promise((n, i) => {
      n(Pt.createHash(this.parseHashAlgorithm(r)).update(e).digest());
    });
  }
  /**
   * If a key is passed as a buffer it *must* be exactly 32 bytes.
   * If a key is passed as a string then any length may be used.
   *
   * @param {Buffer} data
   * @param {(string | Buffer)} key
   * @returns {Promise<Uint8Array>}
   */
  async encrypt(e, r, n) {
    const i = Pt.pbkdf2Sync(r, n = n || "salt", 1e5, 32, this.hashAlgorithm), o = Pt.randomBytes(16), s = Pt.createCipheriv(this.encryptionAlgorithm, i, o);
    return Buffer.concat([o, s.update(e), s.final()]);
  }
  /**
   * If a key is passed as a buffer it *must* be exactly 32 bytes.
   * If a key is passed as a string then any length may be used.
   *
   * @param {Buffer} encrypted
   * @param {(string | Buffer)} key
   * @returns {Promise<Uint8Array>}
   */
  async decrypt(e, r, n) {
    try {
      const i = Pt.pbkdf2Sync(r, n = n || "salt", 1e5, 32, this.hashAlgorithm), o = e.slice(0, 16), s = e.slice(16), a = Pt.createDecipheriv(this.encryptionAlgorithm, i, o);
      return Buffer.concat([
        a.update(s),
        a.final()
      ]);
    } catch {
      throw new Error("Failed to decrypt");
    }
  }
  jwkToPem(e) {
    return (0, xa.jwkTopem)(e);
  }
  pemToJWK(e) {
    return (0, xa.pemTojwk)(e);
  }
  parseHashAlgorithm(e) {
    switch (e) {
      case "SHA-256":
        return "sha256";
      case "SHA-384":
        return "sha384";
      default:
        throw new Error(`Algorithm not supported: ${e}`);
    }
  }
}
ts.default = Qd;
var ms = {};
Object.defineProperty(ms, "__esModule", { value: !0 });
class ep {
  constructor(e) {
    pe(this, "api");
    this.api = e;
  }
  getInfo() {
    return this.api.get("info").then((e) => e.data);
  }
  getPeers() {
    return this.api.get("peers").then((e) => e.data);
  }
}
ms.default = ep;
var $n = {}, Ar = {};
Object.defineProperty(Ar, "__esModule", { value: !0 });
Ar.getError = rp;
class tp extends Error {
  constructor(r, n = {}) {
    var e = (...args) => {
      super(...args);
      pe(this, "type");
      pe(this, "response");
    };
    n.message ? e(n.message) : e(), this.type = r, this.response = n.response;
  }
  getType() {
    return this.type;
  }
}
Ar.default = tp;
function rp(t) {
  let e = t.data;
  if (typeof t.data == "string")
    try {
      e = JSON.parse(t.data);
    } catch {
    }
  if (t.data instanceof ArrayBuffer || t.data instanceof Uint8Array)
    try {
      e = JSON.parse(e.toString());
    } catch {
    }
  return e ? e.error || e : t.statusText || "unknown";
}
var Cr = {}, lt = {}, np = ge && ge.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var i = Object.getOwnPropertyDescriptor(e, r);
  (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, i);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), ip = ge && ge.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), op = ge && ge.__importStar || function(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var r in t)
      r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && np(e, t, r);
  return ip(e, t), e;
};
Object.defineProperty(lt, "__esModule", { value: !0 });
lt.concatBuffers = sp;
lt.b64UrlToString = ap;
lt.bufferToString = Wc;
lt.stringToBuffer = Hc;
lt.stringToB64Url = up;
lt.b64UrlToBuffer = Kc;
lt.bufferTob64 = zc;
lt.bufferTob64Url = Gc;
lt.b64UrlEncode = Yc;
lt.b64UrlDecode = Xc;
const qc = op(Cn);
function sp(t) {
  let e = 0;
  for (let i = 0; i < t.length; i++)
    e += t[i].byteLength;
  let r = new Uint8Array(e), n = 0;
  r.set(new Uint8Array(t[0]), n), n += t[0].byteLength;
  for (let i = 1; i < t.length; i++)
    r.set(new Uint8Array(t[i]), n), n += t[i].byteLength;
  return r;
}
function ap(t) {
  let e = Kc(t);
  return Wc(e);
}
function Wc(t) {
  return new TextDecoder("utf-8", { fatal: !0 }).decode(t);
}
function Hc(t) {
  return new TextEncoder().encode(t);
}
function up(t) {
  return Gc(Hc(t));
}
function Kc(t) {
  return new Uint8Array(qc.toByteArray(Xc(t)));
}
function zc(t) {
  return qc.fromByteArray(new Uint8Array(t));
}
function Gc(t) {
  return Yc(zc(t));
}
function Yc(t) {
  try {
    return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  } catch (e) {
    throw new Error("Failed to encode string", { cause: e });
  }
}
function Xc(t) {
  try {
    t = t.replace(/\-/g, "+").replace(/\_/g, "/");
    let e;
    return t.length % 4 == 0 ? e = 0 : e = 4 - t.length % 4, t.concat("=".repeat(e));
  } catch (e) {
    throw new Error("Failed to decode string", { cause: e });
  }
}
var Vn = {}, Ta;
function cp() {
  if (Ta)
    return Vn;
  Ta = 1;
  var t = ge && ge.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(Vn, "__esModule", { value: !0 }), Vn.default = r;
  const e = t(_s());
  async function r(i) {
    if (Array.isArray(i)) {
      const a = e.default.utils.concatBuffers([
        e.default.utils.stringToBuffer("list"),
        e.default.utils.stringToBuffer(i.length.toString())
      ]);
      return await n(i, await e.default.crypto.hash(a, "SHA-384"));
    }
    const o = e.default.utils.concatBuffers([
      e.default.utils.stringToBuffer("blob"),
      e.default.utils.stringToBuffer(i.byteLength.toString())
    ]), s = e.default.utils.concatBuffers([
      await e.default.crypto.hash(o, "SHA-384"),
      await e.default.crypto.hash(i, "SHA-384")
    ]);
    return await e.default.crypto.hash(s, "SHA-384");
  }
  async function n(i, o) {
    if (i.length < 1)
      return o;
    const s = e.default.utils.concatBuffers([
      o,
      await r(i[0])
    ]), a = await e.default.crypto.hash(s, "SHA-384");
    return await n(i.slice(1), a);
  }
  return Vn;
}
var ji = {}, Ea;
function Zc() {
  return Ea || (Ea = 1, function(t) {
    var e = ge && ge.__importDefault || function(X) {
      return X && X.__esModule ? X : { default: X };
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.arrayCompare = t.MIN_CHUNK_SIZE = t.MAX_CHUNK_SIZE = void 0, t.chunkData = s, t.generateLeaves = a, t.computeRootHash = f, t.generateTree = p, t.generateTransactionChunks = d, t.buildLayers = y, t.generateProofs = v, t.arrayFlatten = I, t.intToBuffer = M, t.bufferToInt = S, t.validatePath = W, t.debug = Q;
    const r = e(_s()), n = lt;
    t.MAX_CHUNK_SIZE = 256 * 1024, t.MIN_CHUNK_SIZE = 32 * 1024;
    const i = 32, o = 32;
    async function s(X) {
      let ne = [], ue = X, se = 0;
      for (; ue.byteLength >= t.MAX_CHUNK_SIZE; ) {
        let ie = t.MAX_CHUNK_SIZE, O = ue.byteLength - t.MAX_CHUNK_SIZE;
        O > 0 && O < t.MIN_CHUNK_SIZE && (ie = Math.ceil(ue.byteLength / 2));
        const c = ue.slice(0, ie), m = await r.default.crypto.hash(c);
        se += c.byteLength, ne.push({
          dataHash: m,
          minByteRange: se - c.byteLength,
          maxByteRange: se
        }), ue = ue.slice(ie);
      }
      return ne.push({
        dataHash: await r.default.crypto.hash(ue),
        minByteRange: se,
        maxByteRange: se + ue.byteLength
      }), ne;
    }
    async function a(X) {
      return Promise.all(X.map(async ({ dataHash: ne, minByteRange: ue, maxByteRange: se }) => ({
        type: "leaf",
        id: await k(await Promise.all([k(ne), k(M(se))])),
        dataHash: ne,
        minByteRange: ue,
        maxByteRange: se
      })));
    }
    async function f(X) {
      return (await p(X)).id;
    }
    async function p(X) {
      return await y(await a(await s(X)));
    }
    async function d(X) {
      const ne = await s(X), ue = await a(ne), se = await y(ue), ie = await v(se), O = ne.slice(-1)[0];
      return O.maxByteRange - O.minByteRange === 0 && (ne.splice(ne.length - 1, 1), ie.splice(ie.length - 1, 1)), {
        data_root: se.id,
        chunks: ne,
        proofs: ie
      };
    }
    async function y(X, ne = 0) {
      if (X.length < 2)
        return X[0];
      const ue = [];
      for (let se = 0; se < X.length; se += 2)
        ue.push(await N(X[se], X[se + 1]));
      return y(ue, ne + 1);
    }
    function v(X) {
      const ne = w(X);
      return Array.isArray(ne) ? I(ne) : [ne];
    }
    function w(X, ne = new Uint8Array(), ue = 0) {
      if (X.type == "leaf")
        return {
          offset: X.maxByteRange - 1,
          proof: (0, n.concatBuffers)([
            ne,
            X.dataHash,
            M(X.maxByteRange)
          ])
        };
      if (X.type == "branch") {
        const se = (0, n.concatBuffers)([
          ne,
          X.leftChild.id,
          X.rightChild.id,
          M(X.byteRange)
        ]);
        return [
          w(X.leftChild, se, ue + 1),
          w(X.rightChild, se, ue + 1)
        ];
      }
      throw new Error("Unexpected node type");
    }
    function I(X) {
      const ne = [];
      return X.forEach((ue) => {
        Array.isArray(ue) ? ne.push(...I(ue)) : ne.push(ue);
      }), ne;
    }
    async function N(X, ne) {
      return ne ? {
        type: "branch",
        id: await k([
          await k(X.id),
          await k(ne.id),
          await k(M(X.maxByteRange))
        ]),
        byteRange: X.maxByteRange,
        maxByteRange: ne.maxByteRange,
        leftChild: X,
        rightChild: ne
      } : X;
    }
    async function k(X) {
      return Array.isArray(X) && (X = r.default.utils.concatBuffers(X)), new Uint8Array(await r.default.crypto.hash(X));
    }
    function M(X) {
      const ne = new Uint8Array(i);
      for (var ue = ne.length - 1; ue >= 0; ue--) {
        var se = X % 256;
        ne[ue] = se, X = (X - se) / 256;
      }
      return ne;
    }
    function S(X) {
      let ne = 0;
      for (var ue = 0; ue < X.length; ue++)
        ne *= 256, ne += X[ue];
      return ne;
    }
    const Y = (X, ne) => X.every((ue, se) => ne[se] === ue);
    t.arrayCompare = Y;
    async function W(X, ne, ue, se, ie) {
      if (se <= 0)
        return !1;
      if (ne >= se)
        return W(X, 0, se - 1, se, ie);
      if (ne < 0)
        return W(X, 0, 0, se, ie);
      if (ie.length == o + i) {
        const L = ie.slice(0, o), H = ie.slice(L.length, L.length + i), P = await k([
          await k(L),
          await k(H)
        ]);
        return (0, t.arrayCompare)(X, P) ? {
          offset: se - 1,
          leftBound: ue,
          rightBound: se,
          chunkSize: se - ue
        } : !1;
      }
      const O = ie.slice(0, o), c = ie.slice(O.length, O.length + o), m = ie.slice(O.length + c.length, O.length + c.length + i), _ = S(m), T = ie.slice(O.length + c.length + m.length), C = await k([
        await k(O),
        await k(c),
        await k(m)
      ]);
      return (0, t.arrayCompare)(X, C) ? ne < _ ? await W(O, ne, ue, Math.min(se, _), T) : await W(c, ne, Math.max(ue, _), se, T) : !1;
    }
    async function Q(X, ne = "") {
      if (X.byteLength < 1)
        return ne;
      const ue = X.slice(0, o), se = X.slice(ue.length, ue.length + o), ie = X.slice(ue.length + se.length, ue.length + se.length + i), O = S(ie), c = X.slice(ue.length + se.length + ie.length), m = await k([
        await k(ue),
        await k(se),
        await k(ie)
      ]), _ = `${ne}
${JSON.stringify(Buffer.from(ue))},${JSON.stringify(Buffer.from(se))},${O} => ${JSON.stringify(m)}`;
      return Q(c, _);
    }
  }(ji)), ji;
}
var Aa;
function gs() {
  if (Aa)
    return Cr;
  Aa = 1;
  var t = ge && ge.__createBinding || (Object.create ? function(d, y, v, w) {
    w === void 0 && (w = v);
    var I = Object.getOwnPropertyDescriptor(y, v);
    (!I || ("get" in I ? !y.__esModule : I.writable || I.configurable)) && (I = { enumerable: !0, get: function() {
      return y[v];
    } }), Object.defineProperty(d, w, I);
  } : function(d, y, v, w) {
    w === void 0 && (w = v), d[w] = y[v];
  }), e = ge && ge.__setModuleDefault || (Object.create ? function(d, y) {
    Object.defineProperty(d, "default", { enumerable: !0, value: y });
  } : function(d, y) {
    d.default = y;
  }), r = ge && ge.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var y = {};
    if (d != null)
      for (var v in d)
        v !== "default" && Object.prototype.hasOwnProperty.call(d, v) && t(y, d, v);
    return e(y, d), y;
  }, n = ge && ge.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.Tag = void 0;
  const i = r(lt), o = n(cp()), s = Zc();
  class a {
    get(y, v) {
      if (!Object.getOwnPropertyNames(this).includes(y))
        throw new Error(`Field "${y}" is not a property of the Arweave Transaction class.`);
      if (this[y] instanceof Uint8Array)
        return v && v.decode && v.string ? i.bufferToString(this[y]) : v && v.decode && !v.string ? this[y] : i.bufferTob64Url(this[y]);
      if (this[y] instanceof Array) {
        if ((v == null ? void 0 : v.decode) !== void 0 || (v == null ? void 0 : v.string) !== void 0)
          throw y === "tags" && console.warn(`Did you mean to use 'transaction["tags"]' ?`), new Error("Cannot decode or stringify an array.");
        return this[y];
      }
      return v && v.decode == !0 ? v && v.string ? i.b64UrlToString(this[y]) : i.b64UrlToBuffer(this[y]) : this[y];
    }
  }
  class f extends a {
    constructor(v, w, I = !1) {
      super();
      pe(this, "name");
      pe(this, "value");
      this.name = v, this.value = w;
    }
  }
  Cr.Tag = f;
  class p extends a {
    constructor(v = {}) {
      super();
      pe(this, "format", 2);
      pe(this, "id", "");
      pe(this, "last_tx", "");
      pe(this, "owner", "");
      pe(this, "tags", []);
      pe(this, "target", "");
      pe(this, "quantity", "0");
      pe(this, "data_size", "0");
      pe(this, "data", new Uint8Array());
      pe(this, "data_root", "");
      pe(this, "reward", "0");
      pe(this, "signature", "");
      // Computed when needed.
      pe(this, "chunks");
      Object.assign(this, v), typeof this.data == "string" && (this.data = i.b64UrlToBuffer(this.data)), v.tags && (this.tags = v.tags.map((w) => new f(w.name, w.value)));
    }
    addTag(v, w) {
      this.tags.push(new f(i.stringToB64Url(v), i.stringToB64Url(w)));
    }
    toJSON() {
      return {
        format: this.format,
        id: this.id,
        last_tx: this.last_tx,
        owner: this.owner,
        tags: this.tags,
        target: this.target,
        quantity: this.quantity,
        data: i.bufferTob64Url(this.data),
        data_size: this.data_size,
        data_root: this.data_root,
        data_tree: this.data_tree,
        reward: this.reward,
        signature: this.signature
      };
    }
    setOwner(v) {
      this.owner = v;
    }
    setSignature({ id: v, owner: w, reward: I, tags: N, signature: k }) {
      this.id = v, this.owner = w, I && (this.reward = I), N && (this.tags = N), this.signature = k;
    }
    async prepareChunks(v) {
      !this.chunks && v.byteLength > 0 && (this.chunks = await (0, s.generateTransactionChunks)(v), this.data_root = i.bufferTob64Url(this.chunks.data_root)), !this.chunks && v.byteLength === 0 && (this.chunks = {
        chunks: [],
        data_root: new Uint8Array(),
        proofs: []
      }, this.data_root = "");
    }
    // Returns a chunk in a format suitable for posting to /chunk.
    // Similar to `prepareChunks()` this does not operate `this.data`,
    // instead using the data passed in.
    getChunk(v, w) {
      if (!this.chunks)
        throw new Error("Chunks have not been prepared");
      const I = this.chunks.proofs[v], N = this.chunks.chunks[v];
      return {
        data_root: this.data_root,
        data_size: this.data_size,
        data_path: i.bufferTob64Url(I.proof),
        offset: I.offset.toString(),
        chunk: i.bufferTob64Url(w.slice(N.minByteRange, N.maxByteRange))
      };
    }
    async getSignatureData() {
      switch (this.format) {
        case 1:
          let v = this.tags.reduce((I, N) => i.concatBuffers([
            I,
            N.get("name", { decode: !0, string: !1 }),
            N.get("value", { decode: !0, string: !1 })
          ]), new Uint8Array());
          return i.concatBuffers([
            this.get("owner", { decode: !0, string: !1 }),
            this.get("target", { decode: !0, string: !1 }),
            this.get("data", { decode: !0, string: !1 }),
            i.stringToBuffer(this.quantity),
            i.stringToBuffer(this.reward),
            this.get("last_tx", { decode: !0, string: !1 }),
            v
          ]);
        case 2:
          this.data_root || await this.prepareChunks(this.data);
          const w = this.tags.map((I) => [
            I.get("name", { decode: !0, string: !1 }),
            I.get("value", { decode: !0, string: !1 })
          ]);
          return await (0, o.default)([
            i.stringToBuffer(this.format.toString()),
            this.get("owner", { decode: !0, string: !1 }),
            this.get("target", { decode: !0, string: !1 }),
            i.stringToBuffer(this.quantity),
            i.stringToBuffer(this.reward),
            this.get("last_tx", { decode: !0, string: !1 }),
            w,
            i.stringToBuffer(this.data_size),
            this.get("data_root", { decode: !0, string: !1 })
          ]);
        default:
          throw new Error(`Unexpected transaction format: ${this.format}`);
      }
    }
  }
  return Cr.default = p, Cr;
}
var on = {}, Ma;
function lp() {
  if (Ma)
    return on;
  Ma = 1;
  var t = ge && ge.__createBinding || (Object.create ? function(v, w, I, N) {
    N === void 0 && (N = I);
    var k = Object.getOwnPropertyDescriptor(w, I);
    (!k || ("get" in k ? !w.__esModule : k.writable || k.configurable)) && (k = { enumerable: !0, get: function() {
      return w[I];
    } }), Object.defineProperty(v, N, k);
  } : function(v, w, I, N) {
    N === void 0 && (N = I), v[N] = w[I];
  }), e = ge && ge.__setModuleDefault || (Object.create ? function(v, w) {
    Object.defineProperty(v, "default", { enumerable: !0, value: w });
  } : function(v, w) {
    v.default = w;
  }), r = ge && ge.__importStar || function(v) {
    if (v && v.__esModule)
      return v;
    var w = {};
    if (v != null)
      for (var I in v)
        I !== "default" && Object.prototype.hasOwnProperty.call(v, I) && t(w, v, I);
    return e(w, v), w;
  }, n = ge && ge.__importDefault || function(v) {
    return v && v.__esModule ? v : { default: v };
  };
  Object.defineProperty(on, "__esModule", { value: !0 }), on.TransactionUploader = void 0;
  const i = n(gs()), o = r(lt), s = Ar, a = Zc(), f = 1, p = [
    "invalid_json",
    "chunk_too_big",
    "data_path_too_big",
    "offset_too_big",
    "data_size_too_big",
    "chunk_proof_ratio_not_attractive",
    "invalid_proof"
  ], d = 1e3 * 40;
  class y {
    constructor(w, I) {
      pe(this, "api");
      pe(this, "chunkIndex", 0);
      pe(this, "txPosted", !1);
      pe(this, "transaction");
      pe(this, "lastRequestTimeEnd", 0);
      pe(this, "totalErrors", 0);
      // Not serialized.
      pe(this, "data");
      pe(this, "lastResponseStatus", 0);
      pe(this, "lastResponseError", "");
      if (this.api = w, !I.id)
        throw new Error("Transaction is not signed");
      if (!I.chunks)
        throw new Error("Transaction chunks not prepared");
      this.data = I.data, this.transaction = new i.default(Object.assign({}, I, { data: new Uint8Array(0) }));
    }
    get isComplete() {
      return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
    }
    get totalChunks() {
      return this.transaction.chunks.chunks.length;
    }
    get uploadedChunks() {
      return this.chunkIndex;
    }
    get pctComplete() {
      return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
    }
    /**
     * Uploads the next part of the transaction.
     * On the first call this posts the transaction
     * itself and on any subsequent calls uploads the
     * next chunk until it completes.
     */
    async uploadChunk(w) {
      if (this.isComplete)
        throw new Error("Upload is already complete");
      if (this.lastResponseError !== "" ? this.totalErrors++ : this.totalErrors = 0, this.totalErrors === 100)
        throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
      let I = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + d - Date.now(), d);
      if (I > 0 && (I = I - I * Math.random() * 0.3, await new Promise((S) => setTimeout(S, I))), this.lastResponseError = "", !this.txPosted) {
        await this.postTransaction();
        return;
      }
      w && (this.chunkIndex = w);
      const N = this.transaction.getChunk(w || this.chunkIndex, this.data);
      if (!await (0, a.validatePath)(this.transaction.chunks.data_root, parseInt(N.offset), 0, parseInt(N.data_size), o.b64UrlToBuffer(N.data_path)))
        throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
      const M = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((S) => (console.error(S.message), { status: -1, data: { error: S.message } }));
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = M.status, this.lastResponseStatus == 200)
        this.chunkIndex++;
      else if (this.lastResponseError = (0, s.getError)(M), p.includes(this.lastResponseError))
        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
    }
    /**
     * Reconstructs an upload from its serialized state and data.
     * Checks if data matches the expected data_root.
     *
     * @param serialized
     * @param data
     */
    static async fromSerialized(w, I, N) {
      if (!I || typeof I.chunkIndex != "number" || typeof I.transaction != "object")
        throw new Error("Serialized object does not match expected format.");
      var k = new i.default(I.transaction);
      k.chunks || await k.prepareChunks(N);
      const M = new y(w, k);
      if (M.chunkIndex = I.chunkIndex, M.lastRequestTimeEnd = I.lastRequestTimeEnd, M.lastResponseError = I.lastResponseError, M.lastResponseStatus = I.lastResponseStatus, M.txPosted = I.txPosted, M.data = N, M.transaction.data_root !== I.transaction.data_root)
        throw new Error("Data mismatch: Uploader doesn't match provided data.");
      return M;
    }
    /**
     * Reconstruct an upload from the tx metadata, ie /tx/<id>.
     *
     * @param api
     * @param id
     * @param data
     */
    static async fromTransactionId(w, I) {
      const N = await w.get(`tx/${I}`);
      if (N.status !== 200)
        throw new Error(`Tx ${I} not found: ${N.status}`);
      const k = N.data;
      return k.data = new Uint8Array(0), {
        txPosted: !0,
        chunkIndex: 0,
        lastResponseError: "",
        lastRequestTimeEnd: 0,
        lastResponseStatus: 0,
        transaction: k
      };
    }
    toJSON() {
      return {
        chunkIndex: this.chunkIndex,
        transaction: this.transaction,
        lastRequestTimeEnd: this.lastRequestTimeEnd,
        lastResponseStatus: this.lastResponseStatus,
        lastResponseError: this.lastResponseError,
        txPosted: this.txPosted
      };
    }
    // POST to /tx
    async postTransaction() {
      if (this.totalChunks <= f) {
        this.transaction.data = this.data;
        const N = await this.api.post("tx", this.transaction).catch((k) => (console.error(k), { status: -1, data: { error: k.message } }));
        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = N.status, this.transaction.data = new Uint8Array(0), N.status >= 200 && N.status < 300) {
          this.txPosted = !0, this.chunkIndex = f;
          return;
        }
        throw this.lastResponseError = (0, s.getError)(N), new Error(`Unable to upload transaction: ${N.status}, ${this.lastResponseError}`);
      }
      const I = await this.api.post("tx", this.transaction);
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = I.status, !(I.status >= 200 && I.status < 300))
        throw this.lastResponseError = (0, s.getError)(I), new Error(`Unable to upload transaction: ${I.status}, ${this.lastResponseError}`);
      this.txPosted = !0;
    }
  }
  return on.TransactionUploader = y, on;
}
var Sa;
function fp() {
  if (Sa)
    return $n;
  Sa = 1;
  var t = ge && ge.__createBinding || (Object.create ? function(p, d, y, v) {
    v === void 0 && (v = y);
    var w = Object.getOwnPropertyDescriptor(d, y);
    (!w || ("get" in w ? !d.__esModule : w.writable || w.configurable)) && (w = { enumerable: !0, get: function() {
      return d[y];
    } }), Object.defineProperty(p, v, w);
  } : function(p, d, y, v) {
    v === void 0 && (v = y), p[v] = d[y];
  }), e = ge && ge.__setModuleDefault || (Object.create ? function(p, d) {
    Object.defineProperty(p, "default", { enumerable: !0, value: d });
  } : function(p, d) {
    p.default = d;
  }), r = ge && ge.__importStar || function(p) {
    if (p && p.__esModule)
      return p;
    var d = {};
    if (p != null)
      for (var y in p)
        y !== "default" && Object.prototype.hasOwnProperty.call(p, y) && t(d, p, y);
    return e(d, p), d;
  }, n = ge && ge.__importDefault || function(p) {
    return p && p.__esModule ? p : { default: p };
  };
  Object.defineProperty($n, "__esModule", { value: !0 });
  const i = n(Ar), o = n(gs()), s = r(lt), a = lp();
  class f {
    constructor(d, y, v) {
      pe(this, "api");
      pe(this, "crypto");
      pe(this, "chunks");
      this.api = d, this.crypto = y, this.chunks = v;
    }
    async getTransactionAnchor() {
      const d = await this.api.get("tx_anchor");
      if (!d.data.match(/^[a-z0-9_-]{43,}/i) || !d.ok)
        throw new Error(`Could not getTransactionAnchor. Received: ${d.data}. Status: ${d.status}, ${d.statusText}`);
      return d.data;
    }
    async getPrice(d, y) {
      let v = y ? `price/${d}/${y}` : `price/${d}`;
      const w = await this.api.get(v);
      if (!/^\d+$/.test(w.data) || !w.ok)
        throw new Error(`Could not getPrice. Received: ${w.data}. Status: ${w.status}, ${w.statusText}`);
      return w.data;
    }
    async get(d) {
      const y = await this.api.get(`tx/${d}`);
      if (y.status == 200) {
        const v = parseInt(y.data.data_size);
        if (y.data.format >= 2 && v > 0 && v <= 1024 * 1024 * 12) {
          const w = await this.getData(d);
          return new o.default({
            ...y.data,
            data: w
          });
        }
        return new o.default({
          ...y.data,
          format: y.data.format || 1
        });
      }
      throw y.status == 404 ? new i.default(
        "TX_NOT_FOUND"
        /* ArweaveErrorType.TX_NOT_FOUND */
      ) : y.status == 410 ? new i.default(
        "TX_FAILED"
        /* ArweaveErrorType.TX_FAILED */
      ) : new i.default(
        "TX_INVALID"
        /* ArweaveErrorType.TX_INVALID */
      );
    }
    fromRaw(d) {
      return new o.default(d);
    }
    /** @deprecated use GQL https://gql-guide.arweave.net */
    async search(d, y) {
      return this.api.post("arql", {
        op: "equals",
        expr1: d,
        expr2: y
      }).then((v) => v.data ? v.data : []);
    }
    getStatus(d) {
      return this.api.get(`tx/${d}/status`).then((y) => y.status == 200 ? {
        status: 200,
        confirmed: y.data
      } : {
        status: y.status,
        confirmed: null
      });
    }
    async getData(d, y) {
      let v;
      try {
        v = await this.chunks.downloadChunkedData(d);
      } catch (w) {
        console.error(`Error while trying to download chunked data for ${d}`), console.error(w);
      }
      if (!v) {
        console.warn(`Falling back to gateway cache for ${d}`);
        try {
          const { data: w, ok: I, status: N, statusText: k } = await this.api.get(`/${d}`, { responseType: "arraybuffer" });
          if (!I)
            throw new Error("Bad http status code", {
              cause: { status: N, statusText: k }
            });
          v = w;
        } catch (w) {
          console.error(`Error while trying to download contiguous data from gateway cache for ${d}`), console.error(w);
        }
      }
      if (!v)
        throw new Error(`${d} data was not found!`);
      return y && y.decode && !y.string ? v : y && y.decode && y.string ? s.bufferToString(v) : s.bufferTob64Url(v);
    }
    async sign(d, y, v) {
      const I = typeof y == "object" && ((k) => {
        let M = !0;
        return ["n", "e", "d", "p", "q", "dp", "dq", "qi"].map((S) => !(S in k) && (M = !1)), M;
      })(y), N = typeof arweaveWallet == "object";
      if (!I && !N)
        throw new Error("No valid JWK or external wallet found to sign transaction.");
      if (I) {
        d.setOwner(y.n);
        let k = await d.getSignatureData(), M = await this.crypto.sign(y, k, v), S = await this.crypto.hash(M);
        d.setSignature({
          id: s.bufferTob64Url(S),
          owner: y.n,
          signature: s.bufferTob64Url(M)
        });
      } else if (N) {
        try {
          (await arweaveWallet.getPermissions()).includes("SIGN_TRANSACTION") || await arweaveWallet.connect(["SIGN_TRANSACTION"]);
        } catch {
        }
        const k = await arweaveWallet.sign(d, v);
        d.setSignature({
          id: k.id,
          owner: k.owner,
          reward: k.reward,
          tags: k.tags,
          signature: k.signature
        });
      } else
        throw new Error("An error occurred while signing. Check wallet is valid");
    }
    async verify(d) {
      const y = await d.getSignatureData(), v = d.get("signature", {
        decode: !0,
        string: !1
      }), w = s.bufferTob64Url(await this.crypto.hash(v));
      if (d.id !== w)
        throw new Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
      return this.crypto.verify(d.owner, y, v);
    }
    async post(d) {
      if (typeof d == "string" ? d = new o.default(JSON.parse(d)) : typeof d.readInt32BE == "function" ? d = new o.default(JSON.parse(d.toString())) : typeof d == "object" && !(d instanceof o.default) && (d = new o.default(d)), !(d instanceof o.default))
        throw new Error("Must be Transaction object");
      d.chunks || await d.prepareChunks(d.data);
      const y = await this.getUploader(d, d.data);
      try {
        for (; !y.isComplete; )
          await y.uploadChunk();
      } catch (v) {
        if (y.lastResponseStatus > 0)
          return {
            status: y.lastResponseStatus,
            statusText: y.lastResponseError,
            data: {
              error: y.lastResponseError
            }
          };
        throw v;
      }
      return {
        status: 200,
        statusText: "OK",
        data: {}
      };
    }
    /**
     * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress
     * and the ability to resume.
     *
     * Usage example:
     *
     * ```
     * const uploader = arweave.transactions.getUploader(transaction);
     * while (!uploader.isComplete) {
     *   await uploader.uploadChunk();
     *   console.log(`${uploader.pctComplete}%`);
     * }
     * ```
     *
     * @param upload a Transaction object, a previously save progress object, or a transaction id.
     * @param data the data of the transaction. Required when resuming an upload.
     */
    async getUploader(d, y) {
      let v;
      if (y instanceof ArrayBuffer && (y = new Uint8Array(y)), d instanceof o.default) {
        if (y || (y = d.data), !(y instanceof Uint8Array))
          throw new Error("Data format is invalid");
        d.chunks || await d.prepareChunks(y), v = new a.TransactionUploader(this.api, d), (!v.data || v.data.length === 0) && (v.data = y);
      } else {
        if (typeof d == "string" && (d = await a.TransactionUploader.fromTransactionId(this.api, d)), !y || !(y instanceof Uint8Array))
          throw new Error("Must provide data when resuming upload");
        v = await a.TransactionUploader.fromSerialized(this.api, d, y);
      }
      return v;
    }
    /**
     * Async generator version of uploader
     *
     * Usage example:
     *
     * ```
     * for await (const uploader of arweave.transactions.upload(tx)) {
     *  console.log(`${uploader.pctComplete}%`);
     * }
     * ```
     *
     * @param upload a Transaction object, a previously save uploader, or a transaction id.
     * @param data the data of the transaction. Required when resuming an upload.
     */
    async *upload(d, y) {
      const v = await this.getUploader(d, y);
      for (; !v.isComplete; )
        await v.uploadChunk(), yield v;
      return v;
    }
  }
  return $n.default = f, $n;
}
var ys = {}, hp = ge && ge.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var i = Object.getOwnPropertyDescriptor(e, r);
  (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, i);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), dp = ge && ge.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), pp = ge && ge.__importStar || function(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var r in t)
      r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && hp(e, t, r);
  return dp(e, t), e;
};
Object.defineProperty(ys, "__esModule", { value: !0 });
const Pa = pp(lt);
class mp {
  constructor(e, r) {
    pe(this, "api");
    pe(this, "crypto");
    this.api = e, this.crypto = r;
  }
  /**
   * Get the wallet balance for the given address.
   *
   * @param {string} address - The arweave address to get the balance for.
   *
   * @returns {Promise<string>} - Promise which resolves with a winston string balance.
   */
  getBalance(e) {
    return this.api.get(`wallet/${e}/balance`).then((r) => r.data);
  }
  /**
   * Get the last transaction ID for the given wallet address.
   *
   * @param {string} address - The arweave address to get the transaction for.
   *
   * @returns {Promise<string>} - Promise which resolves with a transaction ID.
   */
  getLastTransactionID(e) {
    return this.api.get(`wallet/${e}/last_tx`).then((r) => r.data);
  }
  generate() {
    return this.crypto.generateJWK();
  }
  async jwkToAddress(e) {
    return !e || e === "use_wallet" ? this.getAddress() : this.getAddress(e);
  }
  async getAddress(e) {
    if (!e || e === "use_wallet") {
      try {
        await arweaveWallet.connect(["ACCESS_ADDRESS"]);
      } catch {
      }
      return arweaveWallet.getActiveAddress();
    } else
      return this.ownerToAddress(e.n);
  }
  async ownerToAddress(e) {
    return Pa.bufferTob64Url(await this.crypto.hash(Pa.b64UrlToBuffer(e)));
  }
}
ys.default = mp;
var On = {}, gp = ge && ge.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var i = Object.getOwnPropertyDescriptor(e, r);
  (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, i);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), yp = ge && ge.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), vp = ge && ge.__importStar || function(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var r in t)
      r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && gp(e, t, r);
  return yp(e, t), e;
};
Object.defineProperty(On, "__esModule", { value: !0 });
On.SiloResource = void 0;
const Ca = vp(lt);
class wp {
  constructor(e, r, n) {
    pe(this, "api");
    pe(this, "crypto");
    pe(this, "transactions");
    this.api = e, this.crypto = r, this.transactions = n;
  }
  async get(e) {
    if (!e)
      throw new Error("No Silo URI specified");
    const r = await this.parseUri(e), n = await this.transactions.search("Silo-Name", r.getAccessKey());
    if (n.length == 0)
      throw new Error(`No data could be found for the Silo URI: ${e}`);
    const i = await this.transactions.get(n[0]);
    if (!i)
      throw new Error(`No data could be found for the Silo URI: ${e}`);
    const o = i.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(o, r.getEncryptionKey());
  }
  async readTransactionData(e, r) {
    if (!r)
      throw new Error("No Silo URI specified");
    const n = await this.parseUri(r), i = e.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(i, n.getEncryptionKey());
  }
  async parseUri(e) {
    const r = e.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
    if (!r)
      throw new Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
    const n = r[1], i = Math.pow(2, parseInt(r[2])), o = await this.hash(Ca.stringToBuffer(n), i), s = Ca.bufferTob64(o.slice(0, 15)), a = await this.hash(o.slice(16, 31), 1);
    return new Jc(e, s, a);
  }
  async hash(e, r) {
    let n = await this.crypto.hash(e);
    for (let i = 0; i < r - 1; i++)
      n = await this.crypto.hash(n);
    return n;
  }
}
On.default = wp;
class Jc {
  constructor(e, r, n) {
    pe(this, "uri");
    pe(this, "accessKey");
    pe(this, "encryptionKey");
    this.uri = e, this.accessKey = r, this.encryptionKey = n;
  }
  getUri() {
    return this.uri;
  }
  getAccessKey() {
    return this.accessKey;
  }
  getEncryptionKey() {
    return this.encryptionKey;
  }
}
On.SiloResource = Jc;
var vs = {}, _p = ge && ge.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var i = Object.getOwnPropertyDescriptor(e, r);
  (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, i);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), bp = ge && ge.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), xp = ge && ge.__importStar || function(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var r in t)
      r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && _p(e, t, r);
  return bp(e, t), e;
};
Object.defineProperty(vs, "__esModule", { value: !0 });
const Oa = Ar, Tp = xp(lt);
class Ep {
  constructor(e) {
    pe(this, "api");
    this.api = e;
  }
  async getTransactionOffset(e) {
    const r = await this.api.get(`tx/${e}/offset`);
    if (r.status === 200)
      return r.data;
    throw new Error(`Unable to get transaction offset: ${(0, Oa.getError)(r)}`);
  }
  async getChunk(e) {
    const r = await this.api.get(`chunk/${e}`);
    if (r.status === 200)
      return r.data;
    throw new Error(`Unable to get chunk: ${(0, Oa.getError)(r)}`);
  }
  async getChunkData(e) {
    const r = await this.getChunk(e);
    return Tp.b64UrlToBuffer(r.chunk);
  }
  firstChunkOffset(e) {
    return parseInt(e.offset) - parseInt(e.size) + 1;
  }
  async downloadChunkedData(e) {
    const r = await this.getTransactionOffset(e), n = parseInt(r.size), o = parseInt(r.offset) - n + 1, s = new Uint8Array(n);
    let a = 0;
    for (; a < n; ) {
      this.api.config.logging && console.log(`[chunk] ${a}/${n}`);
      let f;
      try {
        f = await this.getChunkData(o + a);
      } catch {
        console.error(`[chunk] Failed to fetch chunk at offset ${o + a}`), console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
      }
      if (f)
        s.set(f, a), a += f.length;
      else
        throw new Error(`Couldn't complete data download at ${a}/${n}`);
    }
    return s;
  }
}
vs.default = Ep;
var ws = {}, Ap = ge && ge.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(ws, "__esModule", { value: !0 });
const Ra = Ap(Ar), Lr = class Lr {
  constructor(e, r) {
    pe(this, "api");
    pe(this, "network");
    this.api = e, this.network = r;
  }
  /**
   * Gets a block by its "indep_hash"
   */
  async get(e) {
    const r = await this.api.get(`${Lr.HASH_ENDPOINT}${e}`);
    if (r.status === 200)
      return r.data;
    throw r.status === 404 ? new Ra.default(
      "BLOCK_NOT_FOUND"
      /* ArweaveErrorType.BLOCK_NOT_FOUND */
    ) : new Error(`Error while loading block data: ${r}`);
  }
  /**
   * Gets a block by its "height"
   */
  async getByHeight(e) {
    const r = await this.api.get(`${Lr.HEIGHT_ENDPOINT}${e}`);
    if (r.status === 200)
      return r.data;
    throw r.status === 404 ? new Ra.default(
      "BLOCK_NOT_FOUND"
      /* ArweaveErrorType.BLOCK_NOT_FOUND */
    ) : new Error(`Error while loading block data: ${r}`);
  }
  /**
   * Gets current block data (ie. block with indep_hash = Network.getInfo().current)
   */
  async getCurrent() {
    const { current: e } = await this.network.getInfo();
    return await this.get(e);
  }
};
pe(Lr, "HASH_ENDPOINT", "block/hash/"), pe(Lr, "HEIGHT_ENDPOINT", "block/height/");
let mo = Lr;
ws.default = mo;
var Ia;
function _s() {
  if (Ia)
    return jn;
  Ia = 1;
  var t = ge && ge.__createBinding || (Object.create ? function(M, S, Y, W) {
    W === void 0 && (W = Y);
    var Q = Object.getOwnPropertyDescriptor(S, Y);
    (!Q || ("get" in Q ? !S.__esModule : Q.writable || Q.configurable)) && (Q = { enumerable: !0, get: function() {
      return S[Y];
    } }), Object.defineProperty(M, W, Q);
  } : function(M, S, Y, W) {
    W === void 0 && (W = Y), M[W] = S[Y];
  }), e = ge && ge.__setModuleDefault || (Object.create ? function(M, S) {
    Object.defineProperty(M, "default", { enumerable: !0, value: S });
  } : function(M, S) {
    M.default = S;
  }), r = ge && ge.__importStar || function(M) {
    if (M && M.__esModule)
      return M;
    var S = {};
    if (M != null)
      for (var Y in M)
        Y !== "default" && Object.prototype.hasOwnProperty.call(M, Y) && t(S, M, Y);
    return e(S, M), S;
  }, n = ge && ge.__importDefault || function(M) {
    return M && M.__esModule ? M : { default: M };
  };
  Object.defineProperty(jn, "__esModule", { value: !0 });
  const i = n(Qo), o = n(es), s = n(ts), a = n(ms), f = n(fp()), p = n(ys), d = n(gs()), y = r(lt), v = n(On), w = n(vs), I = n(ws), k = class k {
    constructor(S) {
      pe(this, "api");
      pe(this, "wallets");
      pe(this, "transactions");
      pe(this, "network");
      pe(this, "blocks");
      pe(this, "ar");
      pe(this, "silo");
      pe(this, "chunks");
      this.api = new o.default(S), this.wallets = new p.default(this.api, k.crypto), this.chunks = new w.default(this.api), this.transactions = new f.default(this.api, k.crypto, this.chunks), this.silo = new v.default(this.api, this.crypto, this.transactions), this.network = new a.default(this.api), this.blocks = new I.default(this.api, this.network), this.ar = new i.default();
    }
    /** @deprecated */
    get crypto() {
      return k.crypto;
    }
    /** @deprecated */
    get utils() {
      return k.utils;
    }
    getConfig() {
      return {
        api: this.api.getConfig(),
        crypto: null
      };
    }
    async createTransaction(S, Y) {
      const W = {};
      if (Object.assign(W, S), !S.data && !(S.target && S.quantity))
        throw new Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
      if (S.owner == null && Y && Y !== "use_wallet" && (W.owner = Y.n), S.last_tx == null && (W.last_tx = await this.transactions.getTransactionAnchor()), typeof S.data == "string" && (S.data = y.stringToBuffer(S.data)), S.data instanceof ArrayBuffer && (S.data = new Uint8Array(S.data)), S.data && !(S.data instanceof Uint8Array))
        throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
      if (S.reward == null) {
        const X = S.data ? S.data.byteLength : 0;
        W.reward = await this.transactions.getPrice(X, W.target);
      }
      W.data_root = "", W.data_size = S.data ? S.data.byteLength.toString() : "0", W.data = S.data || new Uint8Array(0);
      const Q = new d.default(W);
      return await Q.getSignatureData(), Q;
    }
    async createSiloTransaction(S, Y, W) {
      const Q = {};
      if (Object.assign(Q, S), !S.data)
        throw new Error("Silo transactions must have a 'data' value");
      if (!W)
        throw new Error("No Silo URI specified.");
      if (S.target || S.quantity)
        throw new Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
      if (S.owner == null) {
        if (!Y || !Y.n)
          throw new Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
        Q.owner = Y.n;
      }
      S.last_tx == null && (Q.last_tx = await this.transactions.getTransactionAnchor());
      const X = await this.silo.parseUri(W);
      if (typeof S.data == "string") {
        const ue = await this.crypto.encrypt(y.stringToBuffer(S.data), X.getEncryptionKey());
        Q.reward = await this.transactions.getPrice(ue.byteLength), Q.data = y.bufferTob64Url(ue);
      }
      if (S.data instanceof Uint8Array) {
        const ue = await this.crypto.encrypt(S.data, X.getEncryptionKey());
        Q.reward = await this.transactions.getPrice(ue.byteLength), Q.data = y.bufferTob64Url(ue);
      }
      const ne = new d.default(Q);
      return ne.addTag("Silo-Name", X.getAccessKey()), ne.addTag("Silo-Version", "0.1.0"), ne;
    }
    arql(S) {
      return this.api.post("/arql", S).then((Y) => Y.data || []);
    }
  };
  pe(k, "init"), pe(k, "crypto", new s.default()), pe(k, "utils", y);
  let N = k;
  return jn.default = N, jn;
}
var Mp = _s();
const Sp = /* @__PURE__ */ Pn(Mp);
function Qc() {
  const [t, e] = wt(0), { state: r } = xt();
  return Le(() => {
    (async () => {
      var o;
      if (!r.activeAddress)
        return;
      const n = new Sp(
        ((o = r == null ? void 0 : r.config) == null ? void 0 : o.gatewayConfig) || {
          host: "arweave.net",
          port: 443,
          protocol: "https"
        }
      ), i = n.ar.winstonToAr(
        await n.wallets.getBalance(r.activeAddress)
      );
      e(Number(i));
    })();
  }, [r == null ? void 0 : r.activeAddress]), t;
}
function Pp(t) {
  var e = /* @__PURE__ */ Object.create(null);
  return function(r) {
    return e[r] === void 0 && (e[r] = t(r)), e[r];
  };
}
var Cp = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, $i = /* @__PURE__ */ Pp(
  function(t) {
    return Cp.test(t) || t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) < 91;
  }
  /* Z+1 */
), Op = function() {
  const e = Array.prototype.slice.call(arguments).filter(Boolean), r = {}, n = [];
  e.forEach((o) => {
    (o ? o.split(" ") : []).forEach((a) => {
      if (a.startsWith("atm_")) {
        const [, f] = a.split("_");
        r[f] = a;
      } else
        n.push(a);
    });
  });
  const i = [];
  for (const o in r)
    Object.prototype.hasOwnProperty.call(r, o) && i.push(r[o]);
  return i.push(...n), i.join(" ");
}, Ba = Op, Rp = (t) => t.toUpperCase() === t, Ip = (t) => (e) => t.indexOf(e) === -1, el = (t, e) => {
  const r = {};
  return Object.keys(t).filter(Ip(e)).forEach((n) => {
    r[n] = t[n];
  }), r;
};
function Bp(t, e, r) {
  const n = el(e, r);
  if (!t) {
    const i = typeof $i == "function" ? { default: $i } : $i;
    Object.keys(n).forEach((o) => {
      i.default(o) || delete n[o];
    });
  }
  return n;
}
var kp = (t, e) => {
  if (process.env.NODE_ENV !== "production") {
    if (typeof t == "string" || typeof t == "number" && isFinite(t))
      return;
    const r = typeof t == "object" ? JSON.stringify(t) : String(t);
    console.warn(
      `An interpolation evaluated to '${r}' in the component '${e}', which is probably a mistake. You should explicitly cast or transform the value to a string.`
    );
  }
}, Dp = 0;
function ka(t) {
  var e;
  let r = "";
  return process.env.NODE_ENV === "test" && (r += `mocked-styled-${Dp++}`, (e = t == null ? void 0 : t.__linaria) != null && e.className && (r += ` ${t.__linaria.className}`)), (n) => {
    if (process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && Array.isArray(n))
      throw new Error(
        'Using the "styled" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly. See https://github.com/callstack/linaria#setup'
      );
    const i = (s, a) => {
      const { as: f = t, class: p = r } = s, d = n.propsAsIs === void 0 ? !(typeof f == "string" && f.indexOf("-") === -1 && !Rp(f[0])) : n.propsAsIs, y = Bp(d, s, [
        "as",
        "class"
      ]);
      y.ref = a, y.className = n.atomic ? Ba(n.class, y.className || p) : Ba(y.className || p, n.class);
      const { vars: v } = n;
      if (v) {
        const w = {};
        for (const k in v) {
          const M = v[k], S = M[0], Y = M[1] || "", W = typeof S == "function" ? S(s) : S;
          kp(W, n.name), w[`--${k}`] = `${W}${Y}`;
        }
        const I = y.style || {}, N = Object.keys(I);
        N.length > 0 && N.forEach((k) => {
          w[k] = I[k];
        }), y.style = w;
      }
      return t.__linaria && t !== f ? (y.as = f, ht.createElement(t, y)) : ht.createElement(f, y);
    }, o = ht.forwardRef ? ht.forwardRef(i) : (s) => {
      const a = el(s, ["innerRef"]);
      return i(a, s.innerRef);
    };
    return o.displayName = n.name, o.__linaria = {
      className: n.class || r,
      extends: t
    }, o;
  };
}
var Ce = process.env.NODE_ENV !== "production" ? new Proxy(ka, {
  get(t, e) {
    return t(e);
  }
}) : ka;
function bs() {
  var r;
  const { state: t } = xt();
  return bt(() => {
    var i;
    const n = (i = t == null ? void 0 : t.config) == null ? void 0 : i.gatewayConfig;
    return n ? `${n.protocol}://${n.host}:${n.port}` : "https://arweave.net";
  }, [(r = t == null ? void 0 : t.config) == null ? void 0 : r.gatewayConfig]);
}
function tl() {
  const [t, e] = wt(), r = di(), n = bs();
  return Le(() => {
    (async () => {
      if (!r)
        return e(void 0);
      try {
        const o = await (await fetch(
          `https://ans-stats.decent.land/profile/${r}`
        )).json();
        if (!(o != null && o.currentLabel))
          return e(void 0);
        e({
          ...o,
          currentLabel: o.currentLabel + ".ar",
          avatar: o.avatar ? `${n}/${o.avatar}` : void 0
        });
      } catch (i) {
        console.error(
          `[Arweave Wallet Kit] Failed to fetch ans profile
${(i == null ? void 0 : i.message) || i}`
        );
      }
    })();
  }, [r, n]), t;
}
const Lp = () => (t) => t.theme.themeConfig.font.fontFamily, Np = () => (t) => t.theme.theme, Up = () => (t) => ({
  default: 30,
  minimal: 6,
  none: 0
})[t.theme.themeConfig.radius] + "px", Fp = () => (t) => t.theme.displayTheme === "light" ? `0px 0px 2px rgba(${t.theme.displayTheme === "light" ? "0, 0, 0" : "255, 255, 255"}, .15), 0px 4px 7px rgba(${t.theme.displayTheme === "light" ? "0, 0, 0" : "255, 255, 255"}, .1)` : "none", ur = st(/* @__PURE__ */ Ce("button")({
  name: "Button",
  class: "b1cb9caz",
  propsAsIs: !1,
  vars: {
    "b1cb9caz-0": [Lp()],
    "b1cb9caz-1": [Np()],
    "b1cb9caz-2": [Up()],
    "b1cb9caz-3": [Fp()]
  }
}));
function j1({
  accent: t,
  showBalance: e = !0,
  showProfilePicture: r = !0,
  onClick: n,
  useAns: i = !0,
  profileModal: o = !0,
  ...s
}) {
  const {
    connected: a,
    connect: f,
    disconnect: p
  } = Jo(), d = di(), y = Qc(), v = tl(), w = td();
  return /* @__PURE__ */ Me(qp, {
    accent: t,
    onClick: async (I) => {
      if (a ? o ? w.setOpen(!0) : await p() : await f(), n)
        return n(I);
    },
    ...s,
    children: a && /* @__PURE__ */ Fe(_n, {
      children: [e && /* @__PURE__ */ Me(Gp, {
        children: y.toLocaleString(void 0, {
          maximumFractionDigits: 2
        }) + " AR"
      }), /* @__PURE__ */ Fe(zp, {
        showBalance: e,
        children: [r && /* @__PURE__ */ Me(_n, {
          children: (v == null ? void 0 : v.avatar) && i && /* @__PURE__ */ Me(Jp, {
            src: v == null ? void 0 : v.avatar,
            draggable: !1
          }) || /* @__PURE__ */ Me(r0, {
            children: /* @__PURE__ */ Me(e0, {})
          })
        }), i && (v == null ? void 0 : v.currentLabel) || ac(d || "", 5), /* @__PURE__ */ Me(Xp, {})]
      })]
    }) || /* @__PURE__ */ Me(Wp, {
      children: "Connect Wallet"
    })
  });
}
const jp = () => ur, $p = () => (t) => ({
  default: 18,
  minimal: 10,
  none: 0
})[t.theme.themeConfig.radius] + "px", Vp = () => (t) => t.accent || `rgb(${t.theme.theme})`, qp = st(/* @__PURE__ */ Ce(jp())({
  name: "Wrapper",
  class: "w14emrir",
  propsAsIs: !0,
  vars: {
    "w14emrir-0": [$p()],
    "w14emrir-1": [Vp()]
  }
})), Wp = /* @__PURE__ */ Ce("span")({
  name: "ConnectText",
  class: "czh4f0e",
  propsAsIs: !1
}), Hp = () => (t) => t.showBalance ? t.theme.background : "transparent", Kp = () => (t) => ({
  default: 18,
  minimal: 10,
  none: 0
})[t.theme.themeConfig.radius] - 3 + "px", zp = st(/* @__PURE__ */ Ce("div")({
  name: "ProfileSection",
  class: "pwkn5es",
  propsAsIs: !1,
  vars: {
    "pwkn5es-0": [Hp()],
    "pwkn5es-1": [Kp()]
  }
})), Gp = /* @__PURE__ */ Ce("span")({
  name: "Balance",
  class: "bdt02oh",
  propsAsIs: !1
}), Yp = () => dh, Xp = /* @__PURE__ */ Ce(Yp())({
  name: "ExpandIcon",
  class: "e3hlv71",
  propsAsIs: !0
}), Zp = () => (t) => ({
  default: "100%",
  minimal: "5px",
  none: "0px"
})[t.theme.themeConfig.radius], Jp = st(/* @__PURE__ */ Ce("img")({
  name: "Avatar",
  class: "a1jsmwxp",
  propsAsIs: !1,
  vars: {
    "a1jsmwxp-0": [Zp()]
  }
})), Qp = () => lc, e0 = /* @__PURE__ */ Ce(Qp())({
  name: "AvatarIcon",
  class: "as6ir6f",
  propsAsIs: !0
}), t0 = () => (t) => ({
  default: "100%",
  minimal: "5px",
  none: "0px"
})[t.theme.themeConfig.radius], r0 = st(/* @__PURE__ */ Ce("span")({
  name: "AvatarPlaceholder",
  class: "av7js2i",
  propsAsIs: !1,
  vars: {
    "av7js2i-0": [t0()]
  }
})), n0 = "1.0.8";
function i0(t = 720) {
  const [e, r] = wt(!1), n = bt(() => typeof window > "u" ? null : window.matchMedia(`(max-width: ${t}px)`), [t]);
  return Le(() => {
    if (!n)
      return;
    const i = (o) => r(o.matches);
    return n.addEventListener("change", i), r(n.matches), () => n.removeEventListener("change", i);
  }, [n]), e;
}
const xs = Tr({
  transformPagePoint: (t) => t,
  isStatic: !1,
  reducedMotion: "never"
}), _i = Tr({});
function o0() {
  return dt(_i).visualElement;
}
const Rn = Tr(null), bi = typeof document < "u", ei = bi ? Cf : Le, rl = Tr({ strict: !1 });
function s0(t, e, r, n) {
  const i = o0(), o = dt(rl), s = dt(Rn), a = dt(xs).reducedMotion, f = Ot();
  n = n || o.renderer, !f.current && n && (f.current = n(t, {
    visualState: e,
    parent: i,
    props: r,
    presenceId: s ? s.id : void 0,
    blockInitialAnimation: s ? s.initial === !1 : !1,
    reducedMotionConfig: a
  }));
  const p = f.current;
  return ei(() => {
    p && p.render();
  }), (window.HandoffAppearAnimations ? ei : Le)(() => {
    p && p.animationState && p.animationState.animateChanges();
  }), p;
}
function Br(t) {
  return typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
}
function a0(t, e, r) {
  return qr(
    (n) => {
      n && t.mount && t.mount(n), e && (n ? e.mount(n) : e.unmount()), r && (typeof r == "function" ? r(n) : Br(r) && (r.current = n));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [e]
  );
}
function bn(t) {
  return typeof t == "string" || Array.isArray(t);
}
function xi(t) {
  return typeof t == "object" && typeof t.start == "function";
}
const u0 = [
  "initial",
  "animate",
  "exit",
  "whileHover",
  "whileDrag",
  "whileTap",
  "whileFocus",
  "whileInView"
];
function Ti(t) {
  return xi(t.animate) || u0.some((e) => bn(t[e]));
}
function nl(t) {
  return !!(Ti(t) || t.variants);
}
function c0(t, e) {
  if (Ti(t)) {
    const { initial: r, animate: n } = t;
    return {
      initial: r === !1 || bn(r) ? r : void 0,
      animate: bn(n) ? n : void 0
    };
  }
  return t.inherit !== !1 ? e : {};
}
function l0(t) {
  const { initial: e, animate: r } = c0(t, dt(_i));
  return bt(() => ({ initial: e, animate: r }), [Da(e), Da(r)]);
}
function Da(t) {
  return Array.isArray(t) ? t.join(" ") : t;
}
const Xt = (t) => ({
  isEnabled: (e) => t.some((r) => !!e[r])
}), xn = {
  measureLayout: Xt(["layout", "layoutId", "drag"]),
  animation: Xt([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag",
    "whileInView"
  ]),
  exit: Xt(["exit"]),
  drag: Xt(["drag", "dragControls"]),
  focus: Xt(["whileFocus"]),
  hover: Xt(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: Xt(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: Xt([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  inView: Xt([
    "whileInView",
    "onViewportEnter",
    "onViewportLeave"
  ])
};
function f0(t) {
  for (const e in t)
    e === "projectionNodeConstructor" ? xn.projectionNodeConstructor = t[e] : xn[e].Component = t[e];
}
function Ei(t) {
  const e = Ot(null);
  return e.current === null && (e.current = t()), e.current;
}
const pn = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
let h0 = 1;
function d0() {
  return Ei(() => {
    if (pn.hasEverUpdated)
      return h0++;
  });
}
const Ts = Tr({});
class p0 extends ht.Component {
  /**
   * Update visual element props as soon as we know this update is going to be commited.
   */
  getSnapshotBeforeUpdate() {
    const { visualElement: e, props: r } = this.props;
    return e && e.setProps(r), null;
  }
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
const il = Tr({}), m0 = Symbol.for("motionComponentSymbol");
function g0({ preloadedFeatures: t, createVisualElement: e, projectionNodeConstructor: r, useRender: n, useVisualState: i, Component: o }) {
  t && f0(t);
  function s(f, p) {
    const d = {
      ...dt(xs),
      ...f,
      layoutId: y0(f)
    }, { isStatic: y } = d;
    let v = null;
    const w = l0(f), I = y ? void 0 : d0(), N = i(f, y);
    if (!y && bi) {
      w.visualElement = s0(o, N, d, e);
      const k = dt(rl).strict, M = dt(il);
      w.visualElement && (v = w.visualElement.loadFeatures(
        // Note: Pass the full new combined props to correctly re-render dynamic feature components.
        d,
        k,
        t,
        I,
        r || xn.projectionNodeConstructor,
        M
      ));
    }
    return ke.createElement(
      p0,
      { visualElement: w.visualElement, props: d },
      v,
      ke.createElement(_i.Provider, { value: w }, n(o, f, I, a0(N, w.visualElement, p), N, y, w.visualElement))
    );
  }
  const a = Of(s);
  return a[m0] = o, a;
}
function y0({ layoutId: t }) {
  const e = dt(Ts).id;
  return e && t !== void 0 ? e + "-" + t : t;
}
function v0(t) {
  function e(n, i = {}) {
    return g0(t(n, i));
  }
  if (typeof Proxy > "u")
    return e;
  const r = /* @__PURE__ */ new Map();
  return new Proxy(e, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (n, i) => (r.has(i) || r.set(i, e(i)), r.get(i))
  });
}
const w0 = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Es(t) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof t != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    t.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(w0.indexOf(t) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/.test(t))
    )
  );
}
const ti = {};
function _0(t) {
  Object.assign(ti, t);
}
const ri = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Yr = new Set(ri);
function ol(t, { layout: e, layoutId: r }) {
  return Yr.has(t) || t.startsWith("origin") || (e || r !== void 0) && (!!ti[t] || t === "opacity");
}
const St = (t) => !!(t != null && t.getVelocity), b0 = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, x0 = (t, e) => ri.indexOf(t) - ri.indexOf(e);
function T0({ transform: t, transformKeys: e }, { enableHardwareAcceleration: r = !0, allowTransformNone: n = !0 }, i, o) {
  let s = "";
  e.sort(x0);
  for (const a of e)
    s += `${b0[a] || a}(${t[a]}) `;
  return r && !t.z && (s += "translateZ(0)"), s = s.trim(), o ? s = o(t, i ? "" : s) : n && i && (s = "none"), s;
}
function sl(t) {
  return t.startsWith("--");
}
const E0 = (t, e) => e && typeof t == "number" ? e.transform(t) : t, zr = (t, e, r) => Math.min(Math.max(r, t), e), Mr = {
  test: (t) => typeof t == "number",
  parse: parseFloat,
  transform: (t) => t
}, mn = {
  ...Mr,
  transform: (t) => zr(0, 1, t)
}, qn = {
  ...Mr,
  default: 1
}, gn = (t) => Math.round(t * 1e5) / 1e5, Tn = /(-)?([\d]*\.?[\d])+/g, go = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, A0 = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function In(t) {
  return typeof t == "string";
}
const Bn = (t) => ({
  test: (e) => In(e) && e.endsWith(t) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${t}`
}), or = Bn("deg"), zt = Bn("%"), Se = Bn("px"), M0 = Bn("vh"), S0 = Bn("vw"), La = {
  ...zt,
  parse: (t) => zt.parse(t) / 100,
  transform: (t) => zt.transform(t * 100)
}, Na = {
  ...Mr,
  transform: Math.round
}, al = {
  // Border props
  borderWidth: Se,
  borderTopWidth: Se,
  borderRightWidth: Se,
  borderBottomWidth: Se,
  borderLeftWidth: Se,
  borderRadius: Se,
  radius: Se,
  borderTopLeftRadius: Se,
  borderTopRightRadius: Se,
  borderBottomRightRadius: Se,
  borderBottomLeftRadius: Se,
  // Positioning props
  width: Se,
  maxWidth: Se,
  height: Se,
  maxHeight: Se,
  size: Se,
  top: Se,
  right: Se,
  bottom: Se,
  left: Se,
  // Spacing props
  padding: Se,
  paddingTop: Se,
  paddingRight: Se,
  paddingBottom: Se,
  paddingLeft: Se,
  margin: Se,
  marginTop: Se,
  marginRight: Se,
  marginBottom: Se,
  marginLeft: Se,
  // Transform props
  rotate: or,
  rotateX: or,
  rotateY: or,
  rotateZ: or,
  scale: qn,
  scaleX: qn,
  scaleY: qn,
  scaleZ: qn,
  skew: or,
  skewX: or,
  skewY: or,
  distance: Se,
  translateX: Se,
  translateY: Se,
  translateZ: Se,
  x: Se,
  y: Se,
  z: Se,
  perspective: Se,
  transformPerspective: Se,
  opacity: mn,
  originX: La,
  originY: La,
  originZ: Se,
  // Misc
  zIndex: Na,
  // SVG
  fillOpacity: mn,
  strokeOpacity: mn,
  numOctaves: Na
};
function As(t, e, r, n) {
  const { style: i, vars: o, transform: s, transformKeys: a, transformOrigin: f } = t;
  a.length = 0;
  let p = !1, d = !1, y = !0;
  for (const v in e) {
    const w = e[v];
    if (sl(v)) {
      o[v] = w;
      continue;
    }
    const I = al[v], N = E0(w, I);
    if (Yr.has(v)) {
      if (p = !0, s[v] = N, a.push(v), !y)
        continue;
      w !== (I.default || 0) && (y = !1);
    } else
      v.startsWith("origin") ? (d = !0, f[v] = N) : i[v] = N;
  }
  if (e.transform || (p || n ? i.transform = T0(t, r, y, n) : i.transform && (i.transform = "none")), d) {
    const { originX: v = "50%", originY: w = "50%", originZ: I = 0 } = f;
    i.transformOrigin = `${v} ${w} ${I}`;
  }
}
const Ms = () => ({
  style: {},
  transform: {},
  transformKeys: [],
  transformOrigin: {},
  vars: {}
});
function ul(t, e, r) {
  for (const n in e)
    !St(e[n]) && !ol(n, r) && (t[n] = e[n]);
}
function P0({ transformTemplate: t }, e, r) {
  return bt(() => {
    const n = Ms();
    return As(n, e, { enableHardwareAcceleration: !r }, t), Object.assign({}, n.vars, n.style);
  }, [e]);
}
function C0(t, e, r) {
  const n = t.style || {}, i = {};
  return ul(i, n, t), Object.assign(i, P0(t, e, r)), t.transformValues ? t.transformValues(i) : i;
}
function O0(t, e, r) {
  const n = {}, i = C0(t, e, r);
  return t.drag && t.dragListener !== !1 && (n.draggable = !1, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none", i.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), n.style = i, n;
}
const R0 = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "viewport"
]);
function ni(t) {
  return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || R0.has(t);
}
let cl = (t) => !ni(t);
function I0(t) {
  t && (cl = (e) => e.startsWith("on") ? !ni(e) : t(e));
}
try {
  I0(require("@emotion/is-prop-valid").default);
} catch {
}
function B0(t, e, r) {
  const n = {};
  for (const i in t)
    i === "values" && typeof t.values == "object" || (cl(i) || r === !0 && ni(i) || !e && !ni(i) || // If trying to use native HTML drag events, forward drag listeners
    t.draggable && i.startsWith("onDrag")) && (n[i] = t[i]);
  return n;
}
function Ua(t, e, r) {
  return typeof t == "string" ? t : Se.transform(e + r * t);
}
function k0(t, e, r) {
  const n = Ua(e, t.x, t.width), i = Ua(r, t.y, t.height);
  return `${n} ${i}`;
}
const D0 = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, L0 = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function N0(t, e, r = 1, n = 0, i = !0) {
  t.pathLength = 1;
  const o = i ? D0 : L0;
  t[o.offset] = Se.transform(-n);
  const s = Se.transform(e), a = Se.transform(r);
  t[o.array] = `${s} ${a}`;
}
function Ss(t, {
  attrX: e,
  attrY: r,
  originX: n,
  originY: i,
  pathLength: o,
  pathSpacing: s = 1,
  pathOffset: a = 0,
  // This is object creation, which we try to avoid per-frame.
  ...f
}, p, d, y) {
  if (As(t, f, p, y), d) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
    return;
  }
  t.attrs = t.style, t.style = {};
  const { attrs: v, style: w, dimensions: I } = t;
  v.transform && (I && (w.transform = v.transform), delete v.transform), I && (n !== void 0 || i !== void 0 || w.transform) && (w.transformOrigin = k0(I, n !== void 0 ? n : 0.5, i !== void 0 ? i : 0.5)), e !== void 0 && (v.x = e), r !== void 0 && (v.y = r), o !== void 0 && N0(v, o, s, a, !1);
}
const ll = () => ({
  ...Ms(),
  attrs: {}
}), Ps = (t) => typeof t == "string" && t.toLowerCase() === "svg";
function U0(t, e, r, n) {
  const i = bt(() => {
    const o = ll();
    return Ss(o, e, { enableHardwareAcceleration: !1 }, Ps(n), t.transformTemplate), {
      ...o.attrs,
      style: { ...o.style }
    };
  }, [e]);
  if (t.style) {
    const o = {};
    ul(o, t.style, t), i.style = { ...o, ...i.style };
  }
  return i;
}
function F0(t = !1) {
  return (r, n, i, o, { latestValues: s }, a) => {
    const p = (Es(r) ? U0 : O0)(n, s, a, r), y = {
      ...B0(n, typeof r == "string", t),
      ...p,
      ref: o
    }, { children: v } = n, w = bt(() => St(v) ? v.get() : v, [v]);
    return i && (y["data-projection-id"] = i), Xu(r, {
      ...y,
      children: w
    });
  };
}
const Cs = (t) => t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function fl(t, { style: e, vars: r }, n, i) {
  Object.assign(t.style, e, i && i.getProjectionStyles(n));
  for (const o in r)
    t.style.setProperty(o, r[o]);
}
const hl = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function dl(t, e, r, n) {
  fl(t, e, void 0, n);
  for (const i in e.attrs)
    t.setAttribute(hl.has(i) ? i : Cs(i), e.attrs[i]);
}
function Os(t, e) {
  const { style: r } = t, n = {};
  for (const i in r)
    (St(r[i]) || e.style && St(e.style[i]) || ol(i, t)) && (n[i] = r[i]);
  return n;
}
function pl(t, e) {
  const r = Os(t, e);
  for (const n in t)
    if (St(t[n]) || St(e[n])) {
      const i = n === "x" || n === "y" ? "attr" + n.toUpperCase() : n;
      r[i] = t[n];
    }
  return r;
}
function Rs(t, e, r, n = {}, i = {}) {
  return typeof e == "function" && (e = e(r !== void 0 ? r : t.custom, n, i)), typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function" && (e = e(r !== void 0 ? r : t.custom, n, i)), e;
}
const ii = (t) => Array.isArray(t), j0 = (t) => !!(t && typeof t == "object" && t.mix && t.toValue), $0 = (t) => ii(t) ? t[t.length - 1] || 0 : t;
function Yn(t) {
  const e = St(t) ? t.get() : t;
  return j0(e) ? e.toValue() : e;
}
function V0({ scrapeMotionValuesFromProps: t, createRenderState: e, onMount: r }, n, i, o) {
  const s = {
    latestValues: q0(n, i, o, t),
    renderState: e()
  };
  return r && (s.mount = (a) => r(n, a, s)), s;
}
const ml = (t) => (e, r) => {
  const n = dt(_i), i = dt(Rn), o = () => V0(t, e, n, i);
  return r ? o() : Ei(o);
};
function q0(t, e, r, n) {
  const i = {}, o = n(t, {});
  for (const v in o)
    i[v] = Yn(o[v]);
  let { initial: s, animate: a } = t;
  const f = Ti(t), p = nl(t);
  e && p && !f && t.inherit !== !1 && (s === void 0 && (s = e.initial), a === void 0 && (a = e.animate));
  let d = r ? r.initial === !1 : !1;
  d = d || s === !1;
  const y = d ? a : s;
  return y && typeof y != "boolean" && !xi(y) && (Array.isArray(y) ? y : [y]).forEach((w) => {
    const I = Rs(t, w);
    if (!I)
      return;
    const { transitionEnd: N, transition: k, ...M } = I;
    for (const S in M) {
      let Y = M[S];
      if (Array.isArray(Y)) {
        const W = d ? Y.length - 1 : 0;
        Y = Y[W];
      }
      Y !== null && (i[S] = Y);
    }
    for (const S in N)
      i[S] = N[S];
  }), i;
}
const W0 = {
  useVisualState: ml({
    scrapeMotionValuesFromProps: pl,
    createRenderState: ll,
    onMount: (t, e, { renderState: r, latestValues: n }) => {
      try {
        r.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
      } catch {
        r.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      Ss(r, n, { enableHardwareAcceleration: !1 }, Ps(e.tagName), t.transformTemplate), dl(e, r);
    }
  })
}, H0 = {
  useVisualState: ml({
    scrapeMotionValuesFromProps: Os,
    createRenderState: Ms
  })
};
function K0(t, { forwardMotionProps: e = !1 }, r, n, i) {
  return {
    ...Es(t) ? W0 : H0,
    preloadedFeatures: r,
    useRender: F0(e),
    createVisualElement: n,
    projectionNodeConstructor: i,
    Component: t
  };
}
var $e;
(function(t) {
  t.Animate = "animate", t.Hover = "whileHover", t.Tap = "whileTap", t.Drag = "whileDrag", t.Focus = "whileFocus", t.InView = "whileInView", t.Exit = "exit";
})($e || ($e = {}));
function Ai(t, e, r, n = { passive: !0 }) {
  return t.addEventListener(e, r, n), () => t.removeEventListener(e, r);
}
function yo(t, e, r, n) {
  Le(() => {
    const i = t.current;
    if (r && i)
      return Ai(i, e, r, n);
  }, [t, e, r, n]);
}
function z0({ whileFocus: t, visualElement: e }) {
  const { animationState: r } = e, n = qr(() => {
    r && r.setActive($e.Focus, !0);
  }, [r]), i = qr(() => {
    r && r.setActive($e.Focus, !1);
  }, [r]);
  yo(e, "focus", t ? n : void 0), yo(e, "blur", t ? i : void 0);
}
const gl = (t) => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;
function Is(t, e = "page") {
  return {
    point: {
      x: t[e + "X"],
      y: t[e + "Y"]
    }
  };
}
const yl = (t) => (e) => gl(e) && t(e, Is(e));
function Fr(t, e, r, n) {
  return Ai(t, e, yl(r), n);
}
function oi(t, e, r, n) {
  return yo(t, e, r && yl(r), n);
}
function vl(t) {
  let e = null;
  return () => {
    const r = () => {
      e = null;
    };
    return e === null ? (e = t, r) : !1;
  };
}
const Fa = vl("dragHorizontal"), ja = vl("dragVertical");
function wl(t) {
  let e = !1;
  if (t === "y")
    e = ja();
  else if (t === "x")
    e = Fa();
  else {
    const r = Fa(), n = ja();
    r && n ? e = () => {
      r(), n();
    } : (r && r(), n && n());
  }
  return e;
}
function _l() {
  const t = wl(!0);
  return t ? (t(), !1) : !0;
}
function $a(t, e, r, n) {
  return (i, o) => {
    i.type === "touch" || _l() || (r && t.animationState && t.animationState.setActive($e.Hover, e), n && n(i, o));
  };
}
function G0({ onHoverStart: t, onHoverEnd: e, whileHover: r, visualElement: n }) {
  oi(n, "pointerenter", bt(() => t || r ? $a(n, !0, !!r, t) : void 0, [t, !!r, n]), { passive: !t }), oi(n, "pointerleave", bt(() => e || r ? $a(n, !1, !!r, e) : void 0, [t, !!r, n]), { passive: !e });
}
const bl = (t, e) => e ? t === e ? !0 : bl(t, e.parentElement) : !1;
function Bs(t) {
  return Le(() => () => t(), []);
}
const Y0 = (t, e) => (r) => e(t(r)), Mi = (...t) => t.reduce(Y0);
function X0({ onTap: t, onTapStart: e, onTapCancel: r, whileTap: n, visualElement: i, ...o }) {
  const s = t || e || r || n, a = Ot(!1), f = Ot(null), p = {
    passive: !(e || t || r || o.onPointerDown)
  };
  function d() {
    f.current && f.current(), f.current = null;
  }
  function y() {
    return d(), a.current = !1, i.getProps().whileTap && i.animationState && i.animationState.setActive($e.Tap, !1), !_l();
  }
  function v(N, k) {
    var M, S, Y, W;
    y() && (bl(i.current, N.target) ? (W = (Y = i.getProps()).onTap) === null || W === void 0 || W.call(Y, N, k) : (S = (M = i.getProps()).onTapCancel) === null || S === void 0 || S.call(M, N, k));
  }
  function w(N, k) {
    var M, S;
    y() && ((S = (M = i.getProps()).onTapCancel) === null || S === void 0 || S.call(M, N, k));
  }
  const I = qr((N, k) => {
    var M;
    if (d(), a.current)
      return;
    a.current = !0, f.current = Mi(Fr(window, "pointerup", v, p), Fr(window, "pointercancel", w, p));
    const S = i.getProps();
    S.whileTap && i.animationState && i.animationState.setActive($e.Tap, !0), (M = S.onTapStart) === null || M === void 0 || M.call(S, N, k);
  }, [!!e, i]);
  oi(i, "pointerdown", s ? I : void 0, p), Bs(d);
}
const Va = /* @__PURE__ */ new Set();
function Si(t, e, r) {
  t || Va.has(e) || (console.warn(e), r && console.warn(r), Va.add(e));
}
const vo = /* @__PURE__ */ new WeakMap(), Vi = /* @__PURE__ */ new WeakMap(), Z0 = (t) => {
  const e = vo.get(t.target);
  e && e(t);
}, J0 = (t) => {
  t.forEach(Z0);
};
function Q0({ root: t, ...e }) {
  const r = t || document;
  Vi.has(r) || Vi.set(r, {});
  const n = Vi.get(r), i = JSON.stringify(e);
  return n[i] || (n[i] = new IntersectionObserver(J0, { root: t, ...e })), n[i];
}
function em(t, e, r) {
  const n = Q0(e);
  return vo.set(t, r), n.observe(t), () => {
    vo.delete(t), n.unobserve(t);
  };
}
function tm({ visualElement: t, whileInView: e, onViewportEnter: r, onViewportLeave: n, viewport: i = {} }) {
  const o = Ot({
    hasEnteredView: !1,
    isInView: !1
  });
  let s = !!(e || r || n);
  i.once && o.current.hasEnteredView && (s = !1), (typeof IntersectionObserver > "u" ? im : nm)(s, o.current, t, i);
}
const rm = {
  some: 0,
  all: 1
};
function nm(t, e, r, { root: n, margin: i, amount: o = "some", once: s }) {
  Le(() => {
    if (!t || !r.current)
      return;
    const a = {
      root: n == null ? void 0 : n.current,
      rootMargin: i,
      threshold: typeof o == "number" ? o : rm[o]
    }, f = (p) => {
      const { isIntersecting: d } = p;
      if (e.isInView === d || (e.isInView = d, s && !d && e.hasEnteredView))
        return;
      d && (e.hasEnteredView = !0), r.animationState && r.animationState.setActive($e.InView, d);
      const y = r.getProps(), v = d ? y.onViewportEnter : y.onViewportLeave;
      v && v(p);
    };
    return em(r.current, a, f);
  }, [t, n, i, o]);
}
function im(t, e, r, { fallback: n = !0 }) {
  Le(() => {
    !t || !n || (process.env.NODE_ENV !== "production" && Si(!1, "IntersectionObserver not available on this device. whileInView animations will trigger on mount."), requestAnimationFrame(() => {
      e.hasEnteredView = !0;
      const { onViewportEnter: i } = r.getProps();
      i && i(null), r.animationState && r.animationState.setActive($e.InView, !0);
    }));
  }, [t]);
}
const ar = (t) => (e) => (t(e), null), om = {
  inView: ar(tm),
  tap: ar(X0),
  focus: ar(z0),
  hover: ar(G0)
};
function xl() {
  const t = dt(Rn);
  if (t === null)
    return [!0, null];
  const { isPresent: e, onExitComplete: r, register: n } = t, i = jo();
  return Le(() => n(i), []), !e && r ? [!1, () => r && r(i)] : [!0];
}
function Tl(t, e) {
  if (!Array.isArray(e))
    return !1;
  const r = e.length;
  if (r !== t.length)
    return !1;
  for (let n = 0; n < r; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
const sm = (t) => /^\-?\d*\.?\d+$/.test(t), am = (t) => /^0[^.\s]+$/.test(t), tr = {
  delta: 0,
  timestamp: 0
}, El = 1 / 60 * 1e3, um = typeof performance < "u" ? () => performance.now() : () => Date.now(), Al = typeof window < "u" ? (t) => window.requestAnimationFrame(t) : (t) => setTimeout(() => t(um()), El);
function cm(t) {
  let e = [], r = [], n = 0, i = !1, o = !1;
  const s = /* @__PURE__ */ new WeakSet(), a = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (f, p = !1, d = !1) => {
      const y = d && i, v = y ? e : r;
      return p && s.add(f), v.indexOf(f) === -1 && (v.push(f), y && i && (n = e.length)), f;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (f) => {
      const p = r.indexOf(f);
      p !== -1 && r.splice(p, 1), s.delete(f);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (f) => {
      if (i) {
        o = !0;
        return;
      }
      if (i = !0, [e, r] = [r, e], r.length = 0, n = e.length, n)
        for (let p = 0; p < n; p++) {
          const d = e[p];
          d(f), s.has(d) && (a.schedule(d), t());
        }
      i = !1, o && (o = !1, a.process(f));
    }
  };
  return a;
}
const lm = 40;
let wo = !0, En = !1, _o = !1;
const kn = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], Pi = kn.reduce((t, e) => (t[e] = cm(() => En = !0), t), {}), _t = kn.reduce((t, e) => {
  const r = Pi[e];
  return t[e] = (n, i = !1, o = !1) => (En || hm(), r.schedule(n, i, o)), t;
}, {}), cr = kn.reduce((t, e) => (t[e] = Pi[e].cancel, t), {}), qi = kn.reduce((t, e) => (t[e] = () => Pi[e].process(tr), t), {}), fm = (t) => Pi[t].process(tr), Ml = (t) => {
  En = !1, tr.delta = wo ? El : Math.max(Math.min(t - tr.timestamp, lm), 1), tr.timestamp = t, _o = !0, kn.forEach(fm), _o = !1, En && (wo = !1, Al(Ml));
}, hm = () => {
  En = !0, wo = !0, _o || Al(Ml);
};
function ks(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function Ds(t, e) {
  const r = t.indexOf(e);
  r > -1 && t.splice(r, 1);
}
class Ls {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return ks(this.subscriptions, e), () => Ds(this.subscriptions, e);
  }
  notify(e, r, n) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](e, r, n);
      else
        for (let o = 0; o < i; o++) {
          const s = this.subscriptions[o];
          s && s(e, r, n);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function Ns(t, e) {
  return e ? t * (1e3 / e) : 0;
}
const dm = (t) => !isNaN(parseFloat(t));
class pm {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(e, r = {}) {
    this.version = "8.5.5", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (n, i = !0) => {
      this.prev = this.current, this.current = n;
      const { delta: o, timestamp: s } = tr;
      this.lastUpdated !== s && (this.timeDelta = o, this.lastUpdated = s, _t.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), i && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.scheduleVelocityCheck = () => _t.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: n }) => {
      n !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()));
    }, this.hasAnimated = !1, this.prev = this.current = e, this.canTrackVelocity = dm(this.current), this.owner = r.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e) {
    return this.on("change", e);
  }
  on(e, r) {
    this.events[e] || (this.events[e] = new Ls());
    const n = this.events[e].add(r);
    return e === "change" ? () => {
      n(), _t.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : n;
  }
  clearListeners() {
    for (const e in this.events)
      this.events[e].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(e, r) {
    this.passiveEffect = e, this.stopPassiveEffect = r;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e, r = !0) {
    !r || !this.passiveEffect ? this.updateAndNotify(e, r) : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, r, n) {
    this.set(r), this.prev = e, this.timeDelta = n;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e) {
    this.updateAndNotify(e), this.prev = e, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      Ns(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(e) {
    return this.stop(), new Promise((r) => {
      this.hasAnimated = !0, this.animation = e(r) || null, this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    this.animation = null;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Gr(t, e) {
  return new pm(t, e);
}
const Us = (t, e) => (r) => !!(In(r) && A0.test(r) && r.startsWith(t) || e && Object.prototype.hasOwnProperty.call(r, e)), Sl = (t, e, r) => (n) => {
  if (!In(n))
    return n;
  const [i, o, s, a] = n.match(Tn);
  return {
    [t]: parseFloat(i),
    [e]: parseFloat(o),
    [r]: parseFloat(s),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, mm = (t) => zr(0, 255, t), Wi = {
  ...Mr,
  transform: (t) => Math.round(mm(t))
}, yr = {
  test: Us("rgb", "red"),
  parse: Sl("red", "green", "blue"),
  transform: ({ red: t, green: e, blue: r, alpha: n = 1 }) => "rgba(" + Wi.transform(t) + ", " + Wi.transform(e) + ", " + Wi.transform(r) + ", " + gn(mn.transform(n)) + ")"
};
function gm(t) {
  let e = "", r = "", n = "", i = "";
  return t.length > 5 ? (e = t.substring(1, 3), r = t.substring(3, 5), n = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), r = t.substring(2, 3), n = t.substring(3, 4), i = t.substring(4, 5), e += e, r += r, n += n, i += i), {
    red: parseInt(e, 16),
    green: parseInt(r, 16),
    blue: parseInt(n, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const bo = {
  test: Us("#"),
  parse: gm,
  transform: yr.transform
}, kr = {
  test: Us("hsl", "hue"),
  parse: Sl("hue", "saturation", "lightness"),
  transform: ({ hue: t, saturation: e, lightness: r, alpha: n = 1 }) => "hsla(" + Math.round(t) + ", " + zt.transform(gn(e)) + ", " + zt.transform(gn(r)) + ", " + gn(mn.transform(n)) + ")"
}, Tt = {
  test: (t) => yr.test(t) || bo.test(t) || kr.test(t),
  parse: (t) => yr.test(t) ? yr.parse(t) : kr.test(t) ? kr.parse(t) : bo.parse(t),
  transform: (t) => In(t) ? t : t.hasOwnProperty("red") ? yr.transform(t) : kr.transform(t)
}, Pl = "${c}", Cl = "${n}";
function ym(t) {
  var e, r;
  return isNaN(t) && In(t) && (((e = t.match(Tn)) === null || e === void 0 ? void 0 : e.length) || 0) + (((r = t.match(go)) === null || r === void 0 ? void 0 : r.length) || 0) > 0;
}
function si(t) {
  typeof t == "number" && (t = `${t}`);
  const e = [];
  let r = 0, n = 0;
  const i = t.match(go);
  i && (r = i.length, t = t.replace(go, Pl), e.push(...i.map(Tt.parse)));
  const o = t.match(Tn);
  return o && (n = o.length, t = t.replace(Tn, Cl), e.push(...o.map(Mr.parse))), { values: e, numColors: r, numNumbers: n, tokenised: t };
}
function Ol(t) {
  return si(t).values;
}
function Rl(t) {
  const { values: e, numColors: r, tokenised: n } = si(t), i = e.length;
  return (o) => {
    let s = n;
    for (let a = 0; a < i; a++)
      s = s.replace(a < r ? Pl : Cl, a < r ? Tt.transform(o[a]) : gn(o[a]));
    return s;
  };
}
const vm = (t) => typeof t == "number" ? 0 : t;
function wm(t) {
  const e = Ol(t);
  return Rl(t)(e.map(vm));
}
const lr = { test: ym, parse: Ol, createTransformer: Rl, getAnimatableNone: wm }, _m = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function bm(t) {
  const [e, r] = t.slice(0, -1).split("(");
  if (e === "drop-shadow")
    return t;
  const [n] = r.match(Tn) || [];
  if (!n)
    return t;
  const i = r.replace(n, "");
  let o = _m.has(e) ? 1 : 0;
  return n !== r && (o *= 100), e + "(" + o + i + ")";
}
const xm = /([a-z-]*)\(.*?\)/g, xo = {
  ...lr,
  getAnimatableNone: (t) => {
    const e = t.match(xm);
    return e ? e.map(bm).join(" ") : t;
  }
}, Tm = {
  ...al,
  // Color props
  color: Tt,
  backgroundColor: Tt,
  outlineColor: Tt,
  fill: Tt,
  stroke: Tt,
  // Border props
  borderColor: Tt,
  borderTopColor: Tt,
  borderRightColor: Tt,
  borderBottomColor: Tt,
  borderLeftColor: Tt,
  filter: xo,
  WebkitFilter: xo
}, Fs = (t) => Tm[t];
function js(t, e) {
  var r;
  let n = Fs(t);
  return n !== xo && (n = lr), (r = n.getAnimatableNone) === null || r === void 0 ? void 0 : r.call(n, e);
}
const Il = (t) => (e) => e.test(t), Em = {
  test: (t) => t === "auto",
  parse: (t) => t
}, Bl = [Mr, Se, zt, or, S0, M0, Em], sn = (t) => Bl.find(Il(t)), Am = [...Bl, Tt, lr], Mm = (t) => Am.find(Il(t));
function Sm(t) {
  const e = {};
  return t.values.forEach((r, n) => e[n] = r.get()), e;
}
function Pm(t) {
  const e = {};
  return t.values.forEach((r, n) => e[n] = r.getVelocity()), e;
}
function Ci(t, e, r) {
  const n = t.getProps();
  return Rs(n, e, r !== void 0 ? r : n.custom, Sm(t), Pm(t));
}
function Cm(t, e, r) {
  t.hasValue(e) ? t.getValue(e).set(r) : t.addValue(e, Gr(r));
}
function Om(t, e) {
  const r = Ci(t, e);
  let { transitionEnd: n = {}, transition: i = {}, ...o } = r ? t.makeTargetAnimatable(r, !1) : {};
  o = { ...o, ...n };
  for (const s in o) {
    const a = $0(o[s]);
    Cm(t, s, a);
  }
}
function Rm(t, e, r) {
  var n, i;
  const o = Object.keys(e).filter((a) => !t.hasValue(a)), s = o.length;
  if (s)
    for (let a = 0; a < s; a++) {
      const f = o[a], p = e[f];
      let d = null;
      Array.isArray(p) && (d = p[0]), d === null && (d = (i = (n = r[f]) !== null && n !== void 0 ? n : t.readValue(f)) !== null && i !== void 0 ? i : e[f]), d != null && (typeof d == "string" && (sm(d) || am(d)) ? d = parseFloat(d) : !Mm(d) && lr.test(p) && (d = js(f, p)), t.addValue(f, Gr(d, { owner: t })), r[f] === void 0 && (r[f] = d), d !== null && t.setBaseTarget(f, d));
    }
}
function Im(t, e) {
  return e ? (e[t] || e.default || e).from : void 0;
}
function Bm(t, e, r) {
  var n;
  const i = {};
  for (const o in t) {
    const s = Im(o, e);
    i[o] = s !== void 0 ? s : (n = r.getValue(o)) === null || n === void 0 ? void 0 : n.get();
  }
  return i;
}
function ai(t) {
  return !!(St(t) && t.add);
}
const km = "framerAppearId", Dm = "data-" + Cs(km);
var Oi = function() {
}, Vt = function() {
};
process.env.NODE_ENV !== "production" && (Oi = function(t, e) {
  !t && typeof console < "u" && console.warn(e);
}, Vt = function(t, e) {
  if (!t)
    throw new Error(e);
});
const Xn = (t) => t * 1e3, Lm = {
  current: !1
}, $s = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, Vs = (t) => (e) => 1 - t(1 - e), qs = (t) => t * t, Nm = Vs(qs), Ws = $s(qs), ot = (t, e, r) => -r * t + r * e + t;
function Hi(t, e, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + (e - t) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t;
}
function Um({ hue: t, saturation: e, lightness: r, alpha: n }) {
  t /= 360, e /= 100, r /= 100;
  let i = 0, o = 0, s = 0;
  if (!e)
    i = o = s = r;
  else {
    const a = r < 0.5 ? r * (1 + e) : r + e - r * e, f = 2 * r - a;
    i = Hi(f, a, t + 1 / 3), o = Hi(f, a, t), s = Hi(f, a, t - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(o * 255),
    blue: Math.round(s * 255),
    alpha: n
  };
}
const Ki = (t, e, r) => {
  const n = t * t;
  return Math.sqrt(Math.max(0, r * (e * e - n) + n));
}, Fm = [bo, yr, kr], jm = (t) => Fm.find((e) => e.test(t));
function qa(t) {
  const e = jm(t);
  Vt(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`);
  let r = e.parse(t);
  return e === kr && (r = Um(r)), r;
}
const kl = (t, e) => {
  const r = qa(t), n = qa(e), i = { ...r };
  return (o) => (i.red = Ki(r.red, n.red, o), i.green = Ki(r.green, n.green, o), i.blue = Ki(r.blue, n.blue, o), i.alpha = ot(r.alpha, n.alpha, o), yr.transform(i));
};
function Dl(t, e) {
  return typeof t == "number" ? (r) => ot(t, e, r) : Tt.test(t) ? kl(t, e) : Nl(t, e);
}
const Ll = (t, e) => {
  const r = [...t], n = r.length, i = t.map((o, s) => Dl(o, e[s]));
  return (o) => {
    for (let s = 0; s < n; s++)
      r[s] = i[s](o);
    return r;
  };
}, $m = (t, e) => {
  const r = { ...t, ...e }, n = {};
  for (const i in r)
    t[i] !== void 0 && e[i] !== void 0 && (n[i] = Dl(t[i], e[i]));
  return (i) => {
    for (const o in n)
      r[o] = n[o](i);
    return r;
  };
}, Nl = (t, e) => {
  const r = lr.createTransformer(e), n = si(t), i = si(e);
  return n.numColors === i.numColors && n.numNumbers >= i.numNumbers ? Mi(Ll(n.values, i.values), r) : (Oi(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), (s) => `${s > 0 ? e : t}`);
}, ui = (t, e, r) => {
  const n = e - t;
  return n === 0 ? 1 : (r - t) / n;
}, Wa = (t, e) => (r) => ot(t, e, r);
function Vm(t) {
  return typeof t == "number" ? Wa : typeof t == "string" ? Tt.test(t) ? kl : Nl : Array.isArray(t) ? Ll : typeof t == "object" ? $m : Wa;
}
function qm(t, e, r) {
  const n = [], i = r || Vm(t[0]), o = t.length - 1;
  for (let s = 0; s < o; s++) {
    let a = i(t[s], t[s + 1]);
    if (e) {
      const f = Array.isArray(e) ? e[s] : e;
      a = Mi(f, a);
    }
    n.push(a);
  }
  return n;
}
function Ul(t, e, { clamp: r = !0, ease: n, mixer: i } = {}) {
  const o = t.length;
  Vt(o === e.length, "Both input and output ranges must be the same length"), Vt(!n || !Array.isArray(n) || n.length === o - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values."), t[0] > t[o - 1] && (t = [...t].reverse(), e = [...e].reverse());
  const s = qm(e, n, i), a = s.length, f = (p) => {
    let d = 0;
    if (a > 1)
      for (; d < t.length - 2 && !(p < t[d + 1]); d++)
        ;
    const y = ui(t[d], t[d + 1], p);
    return s[d](y);
  };
  return r ? (p) => f(zr(t[0], t[o - 1], p)) : f;
}
const Hs = (t) => t, Fl = (t, e, r) => (((1 - 3 * r + 3 * e) * t + (3 * r - 6 * e)) * t + 3 * e) * t, Wm = 1e-7, Hm = 12;
function Km(t, e, r, n, i) {
  let o, s, a = 0;
  do
    s = e + (r - e) / 2, o = Fl(s, n, i) - t, o > 0 ? r = s : e = s;
  while (Math.abs(o) > Wm && ++a < Hm);
  return s;
}
function jl(t, e, r, n) {
  if (t === e && r === n)
    return Hs;
  const i = (o) => Km(o, 0, 1, t, r);
  return (o) => o === 0 || o === 1 ? o : Fl(i(o), e, n);
}
const $l = (t) => 1 - Math.sin(Math.acos(t)), Ks = Vs($l), zm = $s(Ks), Vl = jl(0.33, 1.53, 0.69, 0.99), zs = Vs(Vl), Gm = $s(zs), Ym = (t) => (t *= 2) < 1 ? 0.5 * zs(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), Ha = {
  linear: Hs,
  easeIn: qs,
  easeInOut: Ws,
  easeOut: Nm,
  circIn: $l,
  circInOut: zm,
  circOut: Ks,
  backIn: zs,
  backInOut: Gm,
  backOut: Vl,
  anticipate: Ym
}, Ka = (t) => {
  if (Array.isArray(t)) {
    Vt(t.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [e, r, n, i] = t;
    return jl(e, r, n, i);
  } else if (typeof t == "string")
    return Vt(Ha[t] !== void 0, `Invalid easing type '${t}'`), Ha[t];
  return t;
}, Xm = (t) => Array.isArray(t) && typeof t[0] != "number";
function Zm(t, e) {
  return t.map(() => e || Ws).splice(0, t.length - 1);
}
function Jm(t) {
  const e = t.length;
  return t.map((r, n) => n !== 0 ? n / (e - 1) : 0);
}
function Qm(t, e) {
  return t.map((r) => r * e);
}
function To({ keyframes: t, ease: e = Ws, times: r, duration: n = 300 }) {
  t = [...t];
  const i = Xm(e) ? e.map(Ka) : Ka(e), o = {
    done: !1,
    value: t[0]
  }, s = Qm(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    r && r.length === t.length ? r : Jm(t),
    n
  );
  function a() {
    return Ul(s, t, {
      ease: Array.isArray(i) ? i : Zm(t, i)
    });
  }
  let f = a();
  return {
    next: (p) => (o.value = f(p), o.done = p >= n, o),
    flipTarget: () => {
      t.reverse(), f = a();
    }
  };
}
const zi = 1e-3, eg = 0.01, za = 10, tg = 0.05, rg = 1;
function ng({ duration: t = 800, bounce: e = 0.25, velocity: r = 0, mass: n = 1 }) {
  let i, o;
  Oi(t <= za * 1e3, "Spring duration must be 10 seconds or less");
  let s = 1 - e;
  s = zr(tg, rg, s), t = zr(eg, za, t / 1e3), s < 1 ? (i = (p) => {
    const d = p * s, y = d * t, v = d - r, w = Eo(p, s), I = Math.exp(-y);
    return zi - v / w * I;
  }, o = (p) => {
    const y = p * s * t, v = y * r + r, w = Math.pow(s, 2) * Math.pow(p, 2) * t, I = Math.exp(-y), N = Eo(Math.pow(p, 2), s);
    return (-i(p) + zi > 0 ? -1 : 1) * ((v - w) * I) / N;
  }) : (i = (p) => {
    const d = Math.exp(-p * t), y = (p - r) * t + 1;
    return -zi + d * y;
  }, o = (p) => {
    const d = Math.exp(-p * t), y = (r - p) * (t * t);
    return d * y;
  });
  const a = 5 / t, f = og(i, o, a);
  if (t = t * 1e3, isNaN(f))
    return {
      stiffness: 100,
      damping: 10,
      duration: t
    };
  {
    const p = Math.pow(f, 2) * n;
    return {
      stiffness: p,
      damping: s * 2 * Math.sqrt(n * p),
      duration: t
    };
  }
}
const ig = 12;
function og(t, e, r) {
  let n = r;
  for (let i = 1; i < ig; i++)
    n = n - t(n) / e(n);
  return n;
}
function Eo(t, e) {
  return t * Math.sqrt(1 - e * e);
}
const sg = ["duration", "bounce"], ag = ["stiffness", "damping", "mass"];
function Ga(t, e) {
  return e.some((r) => t[r] !== void 0);
}
function ug(t) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!Ga(t, ag) && Ga(t, sg)) {
    const r = ng(t);
    e = {
      ...e,
      ...r,
      velocity: 0,
      mass: 1
    }, e.isResolvedFromDuration = !0;
  }
  return e;
}
const cg = 5;
function ql({ keyframes: t, restDelta: e, restSpeed: r, ...n }) {
  let i = t[0], o = t[t.length - 1];
  const s = { done: !1, value: i }, { stiffness: a, damping: f, mass: p, velocity: d, duration: y, isResolvedFromDuration: v } = ug(n);
  let w = lg, I = d ? -(d / 1e3) : 0;
  const N = f / (2 * Math.sqrt(a * p));
  function k() {
    const M = o - i, S = Math.sqrt(a / p) / 1e3, Y = Math.abs(M) < 5;
    if (r || (r = Y ? 0.01 : 2), e || (e = Y ? 5e-3 : 0.5), N < 1) {
      const W = Eo(S, N);
      w = (Q) => {
        const X = Math.exp(-N * S * Q);
        return o - X * ((I + N * S * M) / W * Math.sin(W * Q) + M * Math.cos(W * Q));
      };
    } else if (N === 1)
      w = (W) => o - Math.exp(-S * W) * (M + (I + S * M) * W);
    else {
      const W = S * Math.sqrt(N * N - 1);
      w = (Q) => {
        const X = Math.exp(-N * S * Q), ne = Math.min(W * Q, 300);
        return o - X * ((I + N * S * M) * Math.sinh(ne) + W * M * Math.cosh(ne)) / W;
      };
    }
  }
  return k(), {
    next: (M) => {
      const S = w(M);
      if (v)
        s.done = M >= y;
      else {
        let Y = I;
        if (M !== 0)
          if (N < 1) {
            const X = Math.max(0, M - cg);
            Y = Ns(S - w(X), M - X);
          } else
            Y = 0;
        const W = Math.abs(Y) <= r, Q = Math.abs(o - S) <= e;
        s.done = W && Q;
      }
      return s.value = s.done ? o : S, s;
    },
    flipTarget: () => {
      I = -I, [i, o] = [o, i], k();
    }
  };
}
ql.needsInterpolation = (t, e) => typeof t == "string" || typeof e == "string";
const lg = (t) => 0;
function fg({
  /**
   * The decay animation dynamically calculates an end of the animation
   * based on the initial keyframe, so we only need to define a single keyframe
   * as default.
   */
  keyframes: t = [0],
  velocity: e = 0,
  power: r = 0.8,
  timeConstant: n = 350,
  restDelta: i = 0.5,
  modifyTarget: o
}) {
  const s = t[0], a = { done: !1, value: s };
  let f = r * e;
  const p = s + f, d = o === void 0 ? p : o(p);
  return d !== p && (f = d - s), {
    next: (y) => {
      const v = -f * Math.exp(-y / n);
      return a.done = !(v > i || v < -i), a.value = a.done ? d : d + v, a;
    },
    flipTarget: () => {
    }
  };
}
const hg = {
  decay: fg,
  keyframes: To,
  tween: To,
  spring: ql
};
function Wl(t, e, r = 0) {
  return t - e - r;
}
function dg(t, e = 0, r = 0, n = !0) {
  return n ? Wl(e + -t, e, r) : e - (t - e) + r;
}
function pg(t, e, r, n) {
  return n ? t >= e + r : t <= -r;
}
const mg = (t) => {
  const e = ({ delta: r }) => t(r);
  return {
    start: () => _t.update(e, !0),
    stop: () => cr.update(e)
  };
};
function ci({ duration: t, driver: e = mg, elapsed: r = 0, repeat: n = 0, repeatType: i = "loop", repeatDelay: o = 0, keyframes: s, autoplay: a = !0, onPlay: f, onStop: p, onComplete: d, onRepeat: y, onUpdate: v, type: w = "keyframes", ...I }) {
  var N, k;
  const M = r;
  let S, Y = 0, W = t, Q = !1, X = !0, ne;
  const ue = hg[s.length > 2 ? "keyframes" : w] || To, se = s[0], ie = s[s.length - 1];
  let O = { done: !1, value: se };
  !((k = (N = ue).needsInterpolation) === null || k === void 0) && k.call(N, se, ie) && (ne = Ul([0, 100], [se, ie], {
    clamp: !1
  }), s = [0, 100]);
  const c = ue({
    ...I,
    duration: t,
    keyframes: s
  });
  function m() {
    Y++, i === "reverse" ? (X = Y % 2 === 0, r = dg(r, W, o, X)) : (r = Wl(r, W, o), i === "mirror" && c.flipTarget()), Q = !1, y && y();
  }
  function _() {
    S && S.stop(), d && d();
  }
  function T(L) {
    X || (L = -L), r += L, Q || (O = c.next(Math.max(0, r)), ne && (O.value = ne(O.value)), Q = X ? O.done : r <= 0), v && v(O.value), Q && (Y === 0 && (W = W !== void 0 ? W : r), Y < n ? pg(r, W, o, X) && m() : _());
  }
  function C() {
    f && f(), S = e(T), S.start();
  }
  return a && C(), {
    stop: () => {
      p && p(), S && S.stop();
    },
    /**
     * Set the current time of the animation. This is purposefully
     * mirroring the WAAPI animation API to make them interchanagable.
     * Going forward this file should be ported more towards
     * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts
     * Which behaviourally adheres to WAAPI as far as possible.
     *
     * WARNING: This is not safe to use for most animations. We currently
     * only use it for handoff from WAAPI within Framer.
     *
     * This animation function consumes time every frame rather than being sampled for time.
     * So the sample() method performs some headless frames to ensure
     * repeats are handled correctly. Ideally in the future we will replace
     * that method with this, once repeat calculations are pure.
     */
    set currentTime(L) {
      r = M, T(L);
    },
    /**
     * animate() can't yet be sampled for time, instead it
     * consumes time. So to sample it we have to run a low
     * temporal-resolution version.
     */
    sample: (L) => {
      r = M;
      const H = t && typeof t == "number" ? Math.max(t * 0.5, 50) : 50;
      let P = 0;
      for (T(0); P <= L; ) {
        const l = L - P;
        T(Math.min(l, H)), P += H;
      }
      return O;
    }
  };
}
function gg(t) {
  return !t || // Default easing
  Array.isArray(t) || // Bezier curve
  typeof t == "string" && Hl[t];
}
const fn = ([t, e, r, n]) => `cubic-bezier(${t}, ${e}, ${r}, ${n})`, Hl = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: fn([0, 0.65, 0.55, 1]),
  circOut: fn([0.55, 0, 1, 0.45]),
  backIn: fn([0.31, 0.01, 0.66, -0.59]),
  backOut: fn([0.33, 1.53, 0.69, 0.99])
};
function yg(t) {
  if (t)
    return Array.isArray(t) ? fn(t) : Hl[t];
}
function vg(t, e, r, { delay: n = 0, duration: i, repeat: o = 0, repeatType: s = "loop", ease: a, times: f } = {}) {
  return t.animate({ [e]: r, offset: f }, {
    delay: n,
    duration: i,
    easing: yg(a),
    fill: "both",
    iterations: o + 1,
    direction: s === "reverse" ? "alternate" : "normal"
  });
}
const Ya = {
  waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate")
}, Gi = {}, Kl = {};
for (const t in Ya)
  Kl[t] = () => (Gi[t] === void 0 && (Gi[t] = Ya[t]()), Gi[t]);
function wg(t, { repeat: e, repeatType: r = "loop" }) {
  const n = e && r !== "loop" && e % 2 === 1 ? 0 : t.length - 1;
  return t[n];
}
const _g = /* @__PURE__ */ new Set(["opacity"]), Wn = 10;
function bg(t, e, { onUpdate: r, onComplete: n, ...i }) {
  if (!(Kl.waapi() && _g.has(e) && !i.repeatDelay && i.repeatType !== "mirror" && i.damping !== 0))
    return !1;
  let { keyframes: s, duration: a = 300, elapsed: f = 0, ease: p } = i;
  if (i.type === "spring" || !gg(i.ease)) {
    if (i.repeat === 1 / 0)
      return;
    const y = ci({ ...i, elapsed: 0 });
    let v = { done: !1, value: s[0] };
    const w = [];
    let I = 0;
    for (; !v.done && I < 2e4; )
      v = y.sample(I), w.push(v.value), I += Wn;
    s = w, a = I - Wn, p = "linear";
  }
  const d = vg(t.owner.current, e, s, {
    ...i,
    delay: -f,
    duration: a,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: p
  });
  return d.onfinish = () => {
    t.set(wg(s, i)), _t.update(() => d.cancel()), n && n();
  }, {
    get currentTime() {
      return d.currentTime || 0;
    },
    set currentTime(y) {
      d.currentTime = y;
    },
    stop: () => {
      const { currentTime: y } = d;
      if (y) {
        const v = ci({ ...i, autoplay: !1 });
        t.setWithVelocity(v.sample(y - Wn).value, v.sample(y).value, Wn);
      }
      _t.update(() => d.cancel());
    }
  };
}
function zl(t, e) {
  const r = performance.now(), n = ({ timestamp: i }) => {
    const o = i - r;
    o >= e && (cr.read(n), t(o - e));
  };
  return _t.read(n, !0), () => cr.read(n);
}
function xg({ keyframes: t, elapsed: e, onUpdate: r, onComplete: n }) {
  const i = () => {
    r && r(t[t.length - 1]), n && n();
  };
  return e ? { stop: zl(i, -e) } : i();
}
function Tg({ keyframes: t, velocity: e = 0, min: r, max: n, power: i = 0.8, timeConstant: o = 750, bounceStiffness: s = 500, bounceDamping: a = 10, restDelta: f = 1, modifyTarget: p, driver: d, onUpdate: y, onComplete: v, onStop: w }) {
  const I = t[0];
  let N;
  function k(W) {
    return r !== void 0 && W < r || n !== void 0 && W > n;
  }
  function M(W) {
    return r === void 0 ? n : n === void 0 || Math.abs(r - W) < Math.abs(n - W) ? r : n;
  }
  function S(W) {
    N == null || N.stop(), N = ci({
      keyframes: [0, 1],
      velocity: 0,
      ...W,
      driver: d,
      onUpdate: (Q) => {
        var X;
        y == null || y(Q), (X = W.onUpdate) === null || X === void 0 || X.call(W, Q);
      },
      onComplete: v,
      onStop: w
    });
  }
  function Y(W) {
    S({
      type: "spring",
      stiffness: s,
      damping: a,
      restDelta: f,
      ...W
    });
  }
  if (k(I))
    Y({
      velocity: e,
      keyframes: [I, M(I)]
    });
  else {
    let W = i * e + I;
    typeof p < "u" && (W = p(W));
    const Q = M(W), X = Q === r ? -1 : 1;
    let ne, ue;
    const se = (ie) => {
      ne = ue, ue = ie, e = Ns(ie - ne, tr.delta), (X === 1 && ie > Q || X === -1 && ie < Q) && Y({ keyframes: [ie, Q], velocity: e });
    };
    S({
      type: "decay",
      keyframes: [I, 0],
      velocity: e,
      timeConstant: o,
      power: i,
      restDelta: f,
      modifyTarget: p,
      onUpdate: k(W) ? se : void 0
    });
  }
  return {
    stop: () => N == null ? void 0 : N.stop()
  };
}
const hr = () => ({
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}), Hn = (t) => ({
  type: "spring",
  stiffness: 550,
  damping: t === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), Yi = () => ({
  type: "keyframes",
  ease: "linear",
  duration: 0.3
}), Eg = {
  type: "keyframes",
  duration: 0.8
}, Xa = {
  x: hr,
  y: hr,
  z: hr,
  rotate: hr,
  rotateX: hr,
  rotateY: hr,
  rotateZ: hr,
  scaleX: Hn,
  scaleY: Hn,
  scale: Hn,
  opacity: Yi,
  backgroundColor: Yi,
  color: Yi,
  default: Hn
}, Ag = (t, { keyframes: e }) => e.length > 2 ? Eg : (Xa[t] || Xa.default)(e[1]), Ao = (t, e) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
lr.test(e) && // And it contains numbers and/or colors
!e.startsWith("url("));
function Mg({ when: t, delay: e, delayChildren: r, staggerChildren: n, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: a, from: f, elapsed: p, ...d }) {
  return !!Object.keys(d).length;
}
function Za(t) {
  return t === 0 || typeof t == "string" && parseFloat(t) === 0 && t.indexOf(" ") === -1;
}
function Ja(t) {
  return typeof t == "number" ? 0 : js("", t);
}
function Gl(t, e) {
  return t[e] || t.default || t;
}
function Sg(t, e, r, n) {
  const i = Ao(e, r);
  let o = n.from !== void 0 ? n.from : t.get();
  return o === "none" && i && typeof r == "string" ? o = js(e, r) : Za(o) && typeof r == "string" ? o = Ja(r) : !Array.isArray(r) && Za(r) && typeof o == "string" && (r = Ja(o)), Array.isArray(r) ? (r[0] === null && (r[0] = o), r) : [o, r];
}
const Gs = (t, e, r, n = {}) => (i) => {
  const o = Gl(n, t) || {}, s = o.delay || n.delay || 0;
  let { elapsed: a = 0 } = n;
  a = a - Xn(s);
  const f = Sg(e, t, r, o), p = f[0], d = f[f.length - 1], y = Ao(t, p), v = Ao(t, d);
  Oi(y === v, `You are trying to animate ${t} from "${p}" to "${d}". ${p} is not an animatable value - to enable this animation set ${p} to a value animatable to ${d} via the \`style\` property.`);
  let w = {
    keyframes: f,
    velocity: e.getVelocity(),
    ...o,
    elapsed: a,
    onUpdate: (k) => {
      e.set(k), o.onUpdate && o.onUpdate(k);
    },
    onComplete: () => {
      i(), o.onComplete && o.onComplete();
    }
  };
  if (!y || !v || Lm.current || o.type === !1)
    return xg(w);
  if (o.type === "inertia")
    return Tg(w);
  Mg(o) || (w = {
    ...w,
    ...Ag(t, w)
  }), w.duration && (w.duration = Xn(w.duration)), w.repeatDelay && (w.repeatDelay = Xn(w.repeatDelay));
  const I = e.owner, N = I && I.current;
  if (I && N instanceof HTMLElement && !(I != null && I.getProps().onUpdate)) {
    const k = bg(e, t, w);
    if (k)
      return k;
  }
  return ci(w);
};
function Pg(t, e, r = {}) {
  t.notify("AnimationStart", e);
  let n;
  if (Array.isArray(e)) {
    const i = e.map((o) => Mo(t, o, r));
    n = Promise.all(i);
  } else if (typeof e == "string")
    n = Mo(t, e, r);
  else {
    const i = typeof e == "function" ? Ci(t, e, r.custom) : e;
    n = Yl(t, i, r);
  }
  return n.then(() => t.notify("AnimationComplete", e));
}
function Mo(t, e, r = {}) {
  var n;
  const i = Ci(t, e, r.custom);
  let { transition: o = t.getDefaultTransition() || {} } = i || {};
  r.transitionOverride && (o = r.transitionOverride);
  const s = i ? () => Yl(t, i, r) : () => Promise.resolve(), a = !((n = t.variantChildren) === null || n === void 0) && n.size ? (p = 0) => {
    const { delayChildren: d = 0, staggerChildren: y, staggerDirection: v } = o;
    return Cg(t, e, d + p, y, v, r);
  } : () => Promise.resolve(), { when: f } = o;
  if (f) {
    const [p, d] = f === "beforeChildren" ? [s, a] : [a, s];
    return p().then(d);
  } else
    return Promise.all([s(), a(r.delay)]);
}
function Yl(t, e, { delay: r = 0, transitionOverride: n, type: i } = {}) {
  var o;
  let { transition: s = t.getDefaultTransition(), transitionEnd: a, ...f } = t.makeTargetAnimatable(e);
  const p = t.getValue("willChange");
  n && (s = n);
  const d = [], y = i && ((o = t.animationState) === null || o === void 0 ? void 0 : o.getState()[i]);
  for (const v in f) {
    const w = t.getValue(v), I = f[v];
    if (!w || I === void 0 || y && Rg(y, v))
      continue;
    const N = { delay: r, elapsed: 0, ...s };
    if (window.HandoffAppearAnimations && !w.hasAnimated) {
      const M = t.getProps()[Dm];
      M && (N.elapsed = window.HandoffAppearAnimations(M, v, w, _t));
    }
    let k = w.start(Gs(v, w, I, t.shouldReduceMotion && Yr.has(v) ? { type: !1 } : N));
    ai(p) && (p.add(v), k = k.then(() => p.remove(v))), d.push(k);
  }
  return Promise.all(d).then(() => {
    a && Om(t, a);
  });
}
function Cg(t, e, r = 0, n = 0, i = 1, o) {
  const s = [], a = (t.variantChildren.size - 1) * n, f = i === 1 ? (p = 0) => p * n : (p = 0) => a - p * n;
  return Array.from(t.variantChildren).sort(Og).forEach((p, d) => {
    p.notify("AnimationStart", e), s.push(Mo(p, e, {
      ...o,
      delay: r + f(d)
    }).then(() => p.notify("AnimationComplete", e)));
  }), Promise.all(s);
}
function Og(t, e) {
  return t.sortNodePosition(e);
}
function Rg({ protectedKeys: t, needsAnimating: e }, r) {
  const n = t.hasOwnProperty(r) && e[r] !== !0;
  return e[r] = !1, n;
}
const Ys = [
  $e.Animate,
  $e.InView,
  $e.Focus,
  $e.Hover,
  $e.Tap,
  $e.Drag,
  $e.Exit
], Ig = [...Ys].reverse(), Bg = Ys.length;
function kg(t) {
  return (e) => Promise.all(e.map(({ animation: r, options: n }) => Pg(t, r, n)));
}
function Dg(t) {
  let e = kg(t);
  const r = Ng();
  let n = !0;
  const i = (f, p) => {
    const d = Ci(t, p);
    if (d) {
      const { transition: y, transitionEnd: v, ...w } = d;
      f = { ...f, ...w, ...v };
    }
    return f;
  };
  function o(f) {
    e = f(t);
  }
  function s(f, p) {
    const d = t.getProps(), y = t.getVariantContext(!0) || {}, v = [], w = /* @__PURE__ */ new Set();
    let I = {}, N = 1 / 0;
    for (let M = 0; M < Bg; M++) {
      const S = Ig[M], Y = r[S], W = d[S] !== void 0 ? d[S] : y[S], Q = bn(W), X = S === p ? Y.isActive : null;
      X === !1 && (N = M);
      let ne = W === y[S] && W !== d[S] && Q;
      if (ne && n && t.manuallyAnimateOnMount && (ne = !1), Y.protectedKeys = { ...I }, // If it isn't active and hasn't *just* been set as inactive
      !Y.isActive && X === null || // If we didn't and don't have any defined prop for this animation type
      !W && !Y.prevProp || // Or if the prop doesn't define an animation
      xi(W) || typeof W == "boolean")
        continue;
      const ue = Lg(Y.prevProp, W);
      let se = ue || // If we're making this variant active, we want to always make it active
      S === p && Y.isActive && !ne && Q || // If we removed a higher-priority variant (i is in reverse order)
      M > N && Q;
      const ie = Array.isArray(W) ? W : [W];
      let O = ie.reduce(i, {});
      X === !1 && (O = {});
      const { prevResolvedValues: c = {} } = Y, m = {
        ...c,
        ...O
      }, _ = (T) => {
        se = !0, w.delete(T), Y.needsAnimating[T] = !0;
      };
      for (const T in m) {
        const C = O[T], L = c[T];
        I.hasOwnProperty(T) || (C !== L ? ii(C) && ii(L) ? !Tl(C, L) || ue ? _(T) : Y.protectedKeys[T] = !0 : C !== void 0 ? _(T) : w.add(T) : C !== void 0 && w.has(T) ? _(T) : Y.protectedKeys[T] = !0);
      }
      Y.prevProp = W, Y.prevResolvedValues = O, Y.isActive && (I = { ...I, ...O }), n && t.blockInitialAnimation && (se = !1), se && !ne && v.push(...ie.map((T) => ({
        animation: T,
        options: { type: S, ...f }
      })));
    }
    if (w.size) {
      const M = {};
      w.forEach((S) => {
        const Y = t.getBaseTarget(S);
        Y !== void 0 && (M[S] = Y);
      }), v.push({ animation: M });
    }
    let k = !!v.length;
    return n && d.initial === !1 && !t.manuallyAnimateOnMount && (k = !1), n = !1, k ? e(v) : Promise.resolve();
  }
  function a(f, p, d) {
    var y;
    if (r[f].isActive === p)
      return Promise.resolve();
    (y = t.variantChildren) === null || y === void 0 || y.forEach((w) => {
      var I;
      return (I = w.animationState) === null || I === void 0 ? void 0 : I.setActive(f, p);
    }), r[f].isActive = p;
    const v = s(d, f);
    for (const w in r)
      r[w].protectedKeys = {};
    return v;
  }
  return {
    animateChanges: s,
    setActive: a,
    setAnimateFunction: o,
    getState: () => r
  };
}
function Lg(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !Tl(e, t) : !1;
}
function dr(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function Ng() {
  return {
    [$e.Animate]: dr(!0),
    [$e.InView]: dr(),
    [$e.Hover]: dr(),
    [$e.Tap]: dr(),
    [$e.Drag]: dr(),
    [$e.Focus]: dr(),
    [$e.Exit]: dr()
  };
}
const Ug = {
  animation: ar(({ visualElement: t, animate: e }) => {
    t.animationState || (t.animationState = Dg(t)), xi(e) && Le(() => e.subscribe(t), [e]);
  }),
  exit: ar((t) => {
    const { custom: e, visualElement: r } = t, [n, i] = xl(), o = dt(Rn);
    Le(() => {
      r.isPresent = n;
      const s = r.animationState && r.animationState.setActive($e.Exit, !n, {
        custom: o && o.custom || e
      });
      s && !n && s.then(i);
    }, [n]);
  })
}, Qa = (t, e) => Math.abs(t - e);
function Fg(t, e) {
  const r = Qa(t.x, e.x), n = Qa(t.y, e.y);
  return Math.sqrt(r ** 2 + n ** 2);
}
class Xl {
  constructor(e, r, { transformPagePoint: n } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const p = Zi(this.lastMoveEventInfo, this.history), d = this.startEvent !== null, y = Fg(p.offset, { x: 0, y: 0 }) >= 3;
      if (!d && !y)
        return;
      const { point: v } = p, { timestamp: w } = tr;
      this.history.push({ ...v, timestamp: w });
      const { onStart: I, onMove: N } = this.handlers;
      d || (I && I(this.lastMoveEvent, p), this.startEvent = this.lastMoveEvent), N && N(this.lastMoveEvent, p);
    }, this.handlePointerMove = (p, d) => {
      this.lastMoveEvent = p, this.lastMoveEventInfo = Xi(d, this.transformPagePoint), _t.update(this.updatePoint, !0);
    }, this.handlePointerUp = (p, d) => {
      if (this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const { onEnd: y, onSessionEnd: v } = this.handlers, w = Zi(p.type === "pointercancel" ? this.lastMoveEventInfo : Xi(d, this.transformPagePoint), this.history);
      this.startEvent && y && y(p, w), v && v(p, w);
    }, !gl(e))
      return;
    this.handlers = r, this.transformPagePoint = n;
    const i = Is(e), o = Xi(i, this.transformPagePoint), { point: s } = o, { timestamp: a } = tr;
    this.history = [{ ...s, timestamp: a }];
    const { onSessionStart: f } = r;
    f && f(e, Zi(o, this.history)), this.removeListeners = Mi(Fr(window, "pointermove", this.handlePointerMove), Fr(window, "pointerup", this.handlePointerUp), Fr(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), cr.update(this.updatePoint);
  }
}
function Xi(t, e) {
  return e ? { point: e(t.point) } : t;
}
function eu(t, e) {
  return { x: t.x - e.x, y: t.y - e.y };
}
function Zi({ point: t }, e) {
  return {
    point: t,
    delta: eu(t, Zl(e)),
    offset: eu(t, jg(e)),
    velocity: $g(e, 0.1)
  };
}
function jg(t) {
  return t[0];
}
function Zl(t) {
  return t[t.length - 1];
}
function $g(t, e) {
  if (t.length < 2)
    return { x: 0, y: 0 };
  let r = t.length - 1, n = null;
  const i = Zl(t);
  for (; r >= 0 && (n = t[r], !(i.timestamp - n.timestamp > Xn(e))); )
    r--;
  if (!n)
    return { x: 0, y: 0 };
  const o = (i.timestamp - n.timestamp) / 1e3;
  if (o === 0)
    return { x: 0, y: 0 };
  const s = {
    x: (i.x - n.x) / o,
    y: (i.y - n.y) / o
  };
  return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s;
}
function Rt(t) {
  return t.max - t.min;
}
function So(t, e = 0, r = 0.01) {
  return Math.abs(t - e) <= r;
}
function tu(t, e, r, n = 0.5) {
  t.origin = n, t.originPoint = ot(e.min, e.max, t.origin), t.scale = Rt(r) / Rt(e), (So(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1), t.translate = ot(r.min, r.max, t.origin) - t.originPoint, (So(t.translate) || isNaN(t.translate)) && (t.translate = 0);
}
function yn(t, e, r, n) {
  tu(t.x, e.x, r.x, n == null ? void 0 : n.originX), tu(t.y, e.y, r.y, n == null ? void 0 : n.originY);
}
function ru(t, e, r) {
  t.min = r.min + e.min, t.max = t.min + Rt(e);
}
function Vg(t, e, r) {
  ru(t.x, e.x, r.x), ru(t.y, e.y, r.y);
}
function nu(t, e, r) {
  t.min = e.min - r.min, t.max = t.min + Rt(e);
}
function vn(t, e, r) {
  nu(t.x, e.x, r.x), nu(t.y, e.y, r.y);
}
function qg(t, { min: e, max: r }, n) {
  return e !== void 0 && t < e ? t = n ? ot(e, t, n.min) : Math.max(t, e) : r !== void 0 && t > r && (t = n ? ot(r, t, n.max) : Math.min(t, r)), t;
}
function iu(t, e, r) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: r !== void 0 ? t.max + r - (t.max - t.min) : void 0
  };
}
function Wg(t, { top: e, left: r, bottom: n, right: i }) {
  return {
    x: iu(t.x, r, i),
    y: iu(t.y, e, n)
  };
}
function ou(t, e) {
  let r = e.min - t.min, n = e.max - t.max;
  return e.max - e.min < t.max - t.min && ([r, n] = [n, r]), { min: r, max: n };
}
function Hg(t, e) {
  return {
    x: ou(t.x, e.x),
    y: ou(t.y, e.y)
  };
}
function Kg(t, e) {
  let r = 0.5;
  const n = Rt(t), i = Rt(e);
  return i > n ? r = ui(e.min, e.max - n, t.min) : n > i && (r = ui(t.min, t.max - i, e.min)), zr(0, 1, r);
}
function zg(t, e) {
  const r = {};
  return e.min !== void 0 && (r.min = e.min - t.min), e.max !== void 0 && (r.max = e.max - t.min), r;
}
const Po = 0.35;
function Gg(t = Po) {
  return t === !1 ? t = 0 : t === !0 && (t = Po), {
    x: su(t, "left", "right"),
    y: su(t, "top", "bottom")
  };
}
function su(t, e, r) {
  return {
    min: au(t, e),
    max: au(t, r)
  };
}
function au(t, e) {
  return typeof t == "number" ? t : t[e] || 0;
}
const uu = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), wn = () => ({
  x: uu(),
  y: uu()
}), cu = () => ({ min: 0, max: 0 }), ct = () => ({
  x: cu(),
  y: cu()
});
function Ht(t) {
  return [t("x"), t("y")];
}
function Jl({ top: t, left: e, right: r, bottom: n }) {
  return {
    x: { min: e, max: r },
    y: { min: t, max: n }
  };
}
function Yg({ x: t, y: e }) {
  return { top: e.min, right: t.max, bottom: e.max, left: t.min };
}
function Xg(t, e) {
  if (!e)
    return t;
  const r = e({ x: t.left, y: t.top }), n = e({ x: t.right, y: t.bottom });
  return {
    top: r.y,
    left: r.x,
    bottom: n.y,
    right: n.x
  };
}
function Ji(t) {
  return t === void 0 || t === 1;
}
function Co({ scale: t, scaleX: e, scaleY: r }) {
  return !Ji(t) || !Ji(e) || !Ji(r);
}
function pr(t) {
  return Co(t) || Ql(t) || t.z || t.rotate || t.rotateX || t.rotateY;
}
function Ql(t) {
  return lu(t.x) || lu(t.y);
}
function lu(t) {
  return t && t !== "0%";
}
function li(t, e, r) {
  const n = t - r, i = e * n;
  return r + i;
}
function fu(t, e, r, n, i) {
  return i !== void 0 && (t = li(t, i, n)), li(t, r, n) + e;
}
function Oo(t, e = 0, r = 1, n, i) {
  t.min = fu(t.min, e, r, n, i), t.max = fu(t.max, e, r, n, i);
}
function ef(t, { x: e, y: r }) {
  Oo(t.x, e.translate, e.scale, e.originPoint), Oo(t.y, r.translate, r.scale, r.originPoint);
}
function Zg(t, e, r, n = !1) {
  var i, o;
  const s = r.length;
  if (!s)
    return;
  e.x = e.y = 1;
  let a, f;
  for (let p = 0; p < s; p++)
    a = r[p], f = a.projectionDelta, ((o = (i = a.instance) === null || i === void 0 ? void 0 : i.style) === null || o === void 0 ? void 0 : o.display) !== "contents" && (n && a.options.layoutScroll && a.scroll && a !== a.root && Dr(t, {
      x: -a.scroll.offset.x,
      y: -a.scroll.offset.y
    }), f && (e.x *= f.x.scale, e.y *= f.y.scale, ef(t, f)), n && pr(a.latestValues) && Dr(t, a.latestValues));
  e.x = hu(e.x), e.y = hu(e.y);
}
function hu(t) {
  return Number.isInteger(t) || t > 1.0000000000001 || t < 0.999999999999 ? t : 1;
}
function sr(t, e) {
  t.min = t.min + e, t.max = t.max + e;
}
function du(t, e, [r, n, i]) {
  const o = e[i] !== void 0 ? e[i] : 0.5, s = ot(t.min, t.max, o);
  Oo(t, e[r], e[n], s, e.scale);
}
const Jg = ["x", "scaleX", "originX"], Qg = ["y", "scaleY", "originY"];
function Dr(t, e) {
  du(t.x, e, Jg), du(t.y, e, Qg);
}
function tf(t, e) {
  return Jl(Xg(t.getBoundingClientRect(), e));
}
function ey(t, e, r) {
  const n = tf(t, r), { scroll: i } = e;
  return i && (sr(n.x, i.offset.x), sr(n.y, i.offset.y)), n;
}
const ty = /* @__PURE__ */ new WeakMap();
class ry {
  constructor(e) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ct(), this.visualElement = e;
  }
  start(e, { snapToCursor: r = !1 } = {}) {
    if (this.visualElement.isPresent === !1)
      return;
    const n = (a) => {
      this.stopAnimation(), r && this.snapToCursor(Is(a, "page").point);
    }, i = (a, f) => {
      var p;
      const { drag: d, dragPropagation: y, onDragStart: v } = this.getProps();
      d && !y && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = wl(d), !this.openGlobalLock) || (this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Ht((w) => {
        var I, N;
        let k = this.getAxisMotionValue(w).get() || 0;
        if (zt.test(k)) {
          const M = (N = (I = this.visualElement.projection) === null || I === void 0 ? void 0 : I.layout) === null || N === void 0 ? void 0 : N.layoutBox[w];
          M && (k = Rt(M) * (parseFloat(k) / 100));
        }
        this.originPoint[w] = k;
      }), v == null || v(a, f), (p = this.visualElement.animationState) === null || p === void 0 || p.setActive($e.Drag, !0));
    }, o = (a, f) => {
      const { dragPropagation: p, dragDirectionLock: d, onDirectionLock: y, onDrag: v } = this.getProps();
      if (!p && !this.openGlobalLock)
        return;
      const { offset: w } = f;
      if (d && this.currentDirection === null) {
        this.currentDirection = ny(w), this.currentDirection !== null && (y == null || y(this.currentDirection));
        return;
      }
      this.updateAxis("x", f.point, w), this.updateAxis("y", f.point, w), this.visualElement.render(), v == null || v(a, f);
    }, s = (a, f) => this.stop(a, f);
    this.panSession = new Xl(e, {
      onSessionStart: n,
      onStart: i,
      onMove: o,
      onSessionEnd: s
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(e, r) {
    const n = this.isDragging;
    if (this.cancel(), !n)
      return;
    const { velocity: i } = r;
    this.startAnimation(i);
    const { onDragEnd: o } = this.getProps();
    o == null || o(e, r);
  }
  cancel() {
    var e, r;
    this.isDragging = !1, this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !1), (e = this.panSession) === null || e === void 0 || e.end(), this.panSession = void 0;
    const { dragPropagation: n } = this.getProps();
    !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), (r = this.visualElement.animationState) === null || r === void 0 || r.setActive($e.Drag, !1);
  }
  updateAxis(e, r, n) {
    const { drag: i } = this.getProps();
    if (!n || !Kn(e, i, this.currentDirection))
      return;
    const o = this.getAxisMotionValue(e);
    let s = this.originPoint[e] + n[e];
    this.constraints && this.constraints[e] && (s = qg(s, this.constraints[e], this.elastic[e])), o.set(s);
  }
  resolveConstraints() {
    const { dragConstraints: e, dragElastic: r } = this.getProps(), { layout: n } = this.visualElement.projection || {}, i = this.constraints;
    e && Br(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && n ? this.constraints = Wg(n.layoutBox, e) : this.constraints = !1, this.elastic = Gg(r), i !== this.constraints && n && this.constraints && !this.hasMutatedConstraints && Ht((o) => {
      this.getAxisMotionValue(o) && (this.constraints[o] = zg(n.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: r } = this.getProps();
    if (!e || !Br(e))
      return !1;
    const n = e.current;
    Vt(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const o = ey(n, i.root, this.visualElement.getTransformPagePoint());
    let s = Hg(i.layout.layoutBox, o);
    if (r) {
      const a = r(Yg(s));
      this.hasMutatedConstraints = !!a, a && (s = Jl(a));
    }
    return s;
  }
  startAnimation(e) {
    const { drag: r, dragMomentum: n, dragElastic: i, dragTransition: o, dragSnapToOrigin: s, onDragTransitionEnd: a } = this.getProps(), f = this.constraints || {}, p = Ht((d) => {
      if (!Kn(d, r, this.currentDirection))
        return;
      let y = (f == null ? void 0 : f[d]) || {};
      s && (y = { min: 0, max: 0 });
      const v = i ? 200 : 1e6, w = i ? 40 : 1e7, I = {
        type: "inertia",
        velocity: n ? e[d] : 0,
        bounceStiffness: v,
        bounceDamping: w,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...o,
        ...y
      };
      return this.startAxisValueAnimation(d, I);
    });
    return Promise.all(p).then(a);
  }
  startAxisValueAnimation(e, r) {
    const n = this.getAxisMotionValue(e);
    return n.start(Gs(e, n, 0, r));
  }
  stopAnimation() {
    Ht((e) => this.getAxisMotionValue(e).stop());
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e) {
    var r;
    const n = "_drag" + e.toUpperCase(), i = this.visualElement.getProps()[n];
    return i || this.visualElement.getValue(e, ((r = this.visualElement.getProps().initial) === null || r === void 0 ? void 0 : r[e]) || 0);
  }
  snapToCursor(e) {
    Ht((r) => {
      const { drag: n } = this.getProps();
      if (!Kn(r, n, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, o = this.getAxisMotionValue(r);
      if (i && i.layout) {
        const { min: s, max: a } = i.layout.layoutBox[r];
        o.set(e[r] - ot(s, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    var e;
    if (!this.visualElement.current)
      return;
    const { drag: r, dragConstraints: n } = this.getProps(), { projection: i } = this.visualElement;
    if (!Br(n) || !i || !this.constraints)
      return;
    this.stopAnimation();
    const o = { x: 0, y: 0 };
    Ht((a) => {
      const f = this.getAxisMotionValue(a);
      if (f) {
        const p = f.get();
        o[a] = Kg({ min: p, max: p }, this.constraints[a]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    this.visualElement.current.style.transform = s ? s({}, "") : "none", (e = i.root) === null || e === void 0 || e.updateScroll(), i.updateLayout(), this.resolveConstraints(), Ht((a) => {
      if (!Kn(a, r, null))
        return;
      const f = this.getAxisMotionValue(a), { min: p, max: d } = this.constraints[a];
      f.set(ot(p, d, o[a]));
    });
  }
  addListeners() {
    var e;
    if (!this.visualElement.current)
      return;
    ty.set(this.visualElement, this);
    const r = this.visualElement.current, n = Fr(r, "pointerdown", (p) => {
      const { drag: d, dragListener: y = !0 } = this.getProps();
      d && y && this.start(p);
    }), i = () => {
      const { dragConstraints: p } = this.getProps();
      Br(p) && (this.constraints = this.resolveRefConstraints());
    }, { projection: o } = this.visualElement, s = o.addEventListener("measure", i);
    o && !o.layout && ((e = o.root) === null || e === void 0 || e.updateScroll(), o.updateLayout()), i();
    const a = Ai(window, "resize", () => this.scalePositionWithinConstraints()), f = o.addEventListener("didUpdate", ({ delta: p, hasLayoutChanged: d }) => {
      this.isDragging && d && (Ht((y) => {
        const v = this.getAxisMotionValue(y);
        v && (this.originPoint[y] += p[y].translate, v.set(v.get() + p[y].translate));
      }), this.visualElement.render());
    });
    return () => {
      a(), n(), s(), f == null || f();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(), { drag: r = !1, dragDirectionLock: n = !1, dragPropagation: i = !1, dragConstraints: o = !1, dragElastic: s = Po, dragMomentum: a = !0 } = e;
    return {
      ...e,
      drag: r,
      dragDirectionLock: n,
      dragPropagation: i,
      dragConstraints: o,
      dragElastic: s,
      dragMomentum: a
    };
  }
}
function Kn(t, e, r) {
  return (e === !0 || e === t) && (r === null || r === t);
}
function ny(t, e = 10) {
  let r = null;
  return Math.abs(t.y) > e ? r = "y" : Math.abs(t.x) > e && (r = "x"), r;
}
function iy(t) {
  const { dragControls: e, visualElement: r } = t, n = Ei(() => new ry(r));
  Le(() => e && e.subscribe(n), [n, e]), Le(() => n.addListeners(), [n]);
}
function oy({ onPan: t, onPanStart: e, onPanEnd: r, onPanSessionStart: n, visualElement: i }) {
  const o = t || e || r || n, s = Ot(null), { transformPagePoint: a } = dt(xs), f = {
    onSessionStart: n,
    onStart: e,
    onMove: t,
    onEnd: (d, y) => {
      s.current = null, r && r(d, y);
    }
  };
  Le(() => {
    s.current !== null && s.current.updateHandlers(f);
  });
  function p(d) {
    s.current = new Xl(d, f, {
      transformPagePoint: a
    });
  }
  oi(i, "pointerdown", o && p), Bs(() => s.current && s.current.end());
}
const sy = {
  pan: ar(oy),
  drag: ar(iy)
};
function Ro(t) {
  return typeof t == "string" && t.startsWith("var(--");
}
const rf = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function ay(t) {
  const e = rf.exec(t);
  if (!e)
    return [,];
  const [, r, n] = e;
  return [r, n];
}
const uy = 4;
function Io(t, e, r = 1) {
  Vt(r <= uy, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`);
  const [n, i] = ay(t);
  if (!n)
    return;
  const o = window.getComputedStyle(e).getPropertyValue(n);
  return o ? o.trim() : Ro(i) ? Io(i, e, r + 1) : i;
}
function cy(t, { ...e }, r) {
  const n = t.current;
  if (!(n instanceof Element))
    return { target: e, transitionEnd: r };
  r && (r = { ...r }), t.values.forEach((i) => {
    const o = i.get();
    if (!Ro(o))
      return;
    const s = Io(o, n);
    s && i.set(s);
  });
  for (const i in e) {
    const o = e[i];
    if (!Ro(o))
      continue;
    const s = Io(o, n);
    s && (e[i] = s, r && r[i] === void 0 && (r[i] = o));
  }
  return { target: e, transitionEnd: r };
}
const ly = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]), nf = (t) => ly.has(t), fy = (t) => Object.keys(t).some(nf), zn = (t) => t === Mr || t === Se;
var pu;
(function(t) {
  t.width = "width", t.height = "height", t.left = "left", t.right = "right", t.top = "top", t.bottom = "bottom";
})(pu || (pu = {}));
const mu = (t, e) => parseFloat(t.split(", ")[e]), gu = (t, e) => (r, { transform: n }) => {
  if (n === "none" || !n)
    return 0;
  const i = n.match(/^matrix3d\((.+)\)$/);
  if (i)
    return mu(i[1], e);
  {
    const o = n.match(/^matrix\((.+)\)$/);
    return o ? mu(o[1], t) : 0;
  }
}, hy = /* @__PURE__ */ new Set(["x", "y", "z"]), dy = ri.filter((t) => !hy.has(t));
function py(t) {
  const e = [];
  return dy.forEach((r) => {
    const n = t.getValue(r);
    n !== void 0 && (e.push([r, n.get()]), n.set(r.startsWith("scale") ? 1 : 0));
  }), e.length && t.render(), e;
}
const yu = {
  // Dimensions
  width: ({ x: t }, { paddingLeft: e = "0", paddingRight: r = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(r),
  height: ({ y: t }, { paddingTop: e = "0", paddingBottom: r = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(r),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  // Transform
  x: gu(4, 13),
  y: gu(5, 14)
}, my = (t, e, r) => {
  const n = e.measureViewportBox(), i = e.current, o = getComputedStyle(i), { display: s } = o, a = {};
  s === "none" && e.setStaticValue("display", t.display || "block"), r.forEach((p) => {
    a[p] = yu[p](n, o);
  }), e.render();
  const f = e.measureViewportBox();
  return r.forEach((p) => {
    const d = e.getValue(p);
    d && d.jump(a[p]), t[p] = yu[p](f, o);
  }), t;
}, gy = (t, e, r = {}, n = {}) => {
  e = { ...e }, n = { ...n };
  const i = Object.keys(e).filter(nf);
  let o = [], s = !1;
  const a = [];
  if (i.forEach((f) => {
    const p = t.getValue(f);
    if (!t.hasValue(f))
      return;
    let d = r[f], y = sn(d);
    const v = e[f];
    let w;
    if (ii(v)) {
      const I = v.length, N = v[0] === null ? 1 : 0;
      d = v[N], y = sn(d);
      for (let k = N; k < I; k++)
        w ? Vt(sn(v[k]) === w, "All keyframes must be of the same type") : (w = sn(v[k]), Vt(w === y || zn(y) && zn(w), "Keyframes must be of the same dimension as the current value"));
    } else
      w = sn(v);
    if (y !== w)
      if (zn(y) && zn(w)) {
        const I = p.get();
        typeof I == "string" && p.set(parseFloat(I)), typeof v == "string" ? e[f] = parseFloat(v) : Array.isArray(v) && w === Se && (e[f] = v.map(parseFloat));
      } else
        y != null && y.transform && (w != null && w.transform) && (d === 0 || v === 0) ? d === 0 ? p.set(w.transform(d)) : e[f] = y.transform(v) : (s || (o = py(t), s = !0), a.push(f), n[f] = n[f] !== void 0 ? n[f] : e[f], p.jump(v));
  }), a.length) {
    const f = a.indexOf("height") >= 0 ? window.pageYOffset : null, p = my(e, t, a);
    return o.length && o.forEach(([d, y]) => {
      t.getValue(d).set(y);
    }), t.render(), bi && f !== null && window.scrollTo({ top: f }), { target: p, transitionEnd: n };
  } else
    return { target: e, transitionEnd: n };
};
function yy(t, e, r, n) {
  return fy(e) ? gy(t, e, r, n) : { target: e, transitionEnd: n };
}
const vy = (t, e, r, n) => {
  const i = cy(t, e, n);
  return e = i.target, n = i.transitionEnd, yy(t, e, r, n);
}, Bo = { current: null }, of = { current: !1 };
function wy() {
  if (of.current = !0, !!bi)
    if (window.matchMedia) {
      const t = window.matchMedia("(prefers-reduced-motion)"), e = () => Bo.current = t.matches;
      t.addListener(e), e();
    } else
      Bo.current = !1;
}
function _y(t, e, r) {
  const { willChange: n } = e;
  for (const i in e) {
    const o = e[i], s = r[i];
    if (St(o))
      t.addValue(i, o), ai(n) && n.add(i), process.env.NODE_ENV === "development" && Si(o.version === "8.5.5", `Attempting to mix Framer Motion versions ${o.version} with 8.5.5 may not work as expected.`);
    else if (St(s))
      t.addValue(i, Gr(o, { owner: t })), ai(n) && n.remove(i);
    else if (s !== o)
      if (t.hasValue(i)) {
        const a = t.getValue(i);
        !a.hasAnimated && a.set(o);
      } else {
        const a = t.getStaticValue(i);
        t.addValue(i, Gr(a !== void 0 ? a : o, { owner: t }));
      }
  }
  for (const i in r)
    e[i] === void 0 && t.removeValue(i);
  return e;
}
const sf = Object.keys(xn), by = sf.length, vu = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class xy {
  constructor({ parent: e, props: r, reducedMotionConfig: n, visualState: i }, o = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.isPresent = !0, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.scheduleRender = () => _t.render(this.render, !1, !0);
    const { latestValues: s, renderState: a } = i;
    this.latestValues = s, this.baseTarget = { ...s }, this.initialValues = r.initial ? { ...s } : {}, this.renderState = a, this.parent = e, this.props = r, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = n, this.options = o, this.isControllingVariants = Ti(r), this.isVariantNode = nl(r), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
    const { willChange: f, ...p } = this.scrapeMotionValuesFromProps(r, {});
    for (const d in p) {
      const y = p[d];
      s[d] !== void 0 && St(y) && (y.set(s[d], !1), ai(f) && f.add(d));
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e, r) {
    return {};
  }
  mount(e) {
    var r;
    this.current = e, this.projection && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = (r = this.parent) === null || r === void 0 ? void 0 : r.addVariantChild(this)), this.values.forEach((n, i) => this.bindToMotionValue(i, n)), of.current || wy(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Bo.current, process.env.NODE_ENV !== "production" && Si(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.setProps(this.props);
  }
  unmount() {
    var e, r, n;
    (e = this.projection) === null || e === void 0 || e.unmount(), cr.update(this.notifyUpdate), cr.render(this.render), this.valueSubscriptions.forEach((i) => i()), (r = this.removeFromVariantTree) === null || r === void 0 || r.call(this), (n = this.parent) === null || n === void 0 || n.children.delete(this);
    for (const i in this.events)
      this.events[i].clear();
    this.current = null;
  }
  bindToMotionValue(e, r) {
    const n = Yr.has(e), i = r.on("change", (s) => {
      this.latestValues[e] = s, this.props.onUpdate && _t.update(this.notifyUpdate, !1, !0), n && this.projection && (this.projection.isTransformDirty = !0);
    }), o = r.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(e, () => {
      i(), o();
    });
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
  }
  loadFeatures({ children: e, ...r }, n, i, o, s, a) {
    const f = [];
    process.env.NODE_ENV !== "production" && i && n && Vt(!1, "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.");
    for (let p = 0; p < by; p++) {
      const d = sf[p], { isEnabled: y, Component: v } = xn[d];
      y(r) && v && f.push(Xu(v, {
        key: d,
        ...r,
        visualElement: this
      }));
    }
    if (!this.projection && s) {
      this.projection = new s(o, this.latestValues, this.parent && this.parent.projection);
      const { layoutId: p, layout: d, drag: y, dragConstraints: v, layoutScroll: w, layoutRoot: I } = r;
      this.projection.setOptions({
        layoutId: p,
        layout: d,
        alwaysMeasureLayout: !!y || v && Br(v),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof d == "string" ? d : "both",
        initialPromotionConfig: a,
        layoutScroll: w,
        layoutRoot: I
      });
    }
    return f;
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ct();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, r) {
    this.latestValues[e] = r;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(e, r = !0) {
    return this.makeTargetAnimatableFromInstance(e, this.props, r);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  setProps(e) {
    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender();
    const r = this.props;
    this.props = e;
    for (let n = 0; n < vu.length; n++) {
      const i = vu[n];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const o = e["on" + i];
      o && (this.propEventSubscriptions[i] = this.on(i, o));
    }
    this.prevMotionValues = _y(this, this.scrapeMotionValuesFromProps(e, r), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e) {
    var r;
    return (r = this.props.variants) === null || r === void 0 ? void 0 : r[e];
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    var e;
    return this.isVariantNode ? this : (e = this.parent) === null || e === void 0 ? void 0 : e.getClosestVariantNode();
  }
  getVariantContext(e = !1) {
    var r, n;
    if (e)
      return (r = this.parent) === null || r === void 0 ? void 0 : r.getVariantContext();
    if (!this.isControllingVariants) {
      const o = ((n = this.parent) === null || n === void 0 ? void 0 : n.getVariantContext()) || {};
      return this.props.initial !== void 0 && (o.initial = this.props.initial), o;
    }
    const i = {};
    for (let o = 0; o < Ty; o++) {
      const s = af[o], a = this.props[s];
      (bn(a) || a === !1) && (i[s] = a);
    }
    return i;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e) {
    var r;
    const n = this.getClosestVariantNode();
    if (n)
      return (r = n.variantChildren) === null || r === void 0 || r.add(e), () => n.variantChildren.delete(e);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e, r) {
    r !== this.values.get(e) && (this.removeValue(e), this.bindToMotionValue(e, r)), this.values.set(e, r), this.latestValues[e] = r.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e) {
    var r;
    this.values.delete(e), (r = this.valueSubscriptions.get(e)) === null || r === void 0 || r(), this.valueSubscriptions.delete(e), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, r) {
    if (this.props.values && this.props.values[e])
      return this.props.values[e];
    let n = this.values.get(e);
    return n === void 0 && r !== void 0 && (n = Gr(r, { owner: this }), this.addValue(e, n)), n;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e) {
    return this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.readValueFromInstance(this.current, e, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e, r) {
    this.baseTarget[e] = r;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e) {
    var r;
    const { initial: n } = this.props, i = typeof n == "string" || typeof n == "object" ? (r = Rs(this.props, n)) === null || r === void 0 ? void 0 : r[e] : void 0;
    if (n && i !== void 0)
      return i;
    const o = this.getBaseTargetFromProps(this.props, e);
    return o !== void 0 && !St(o) ? o : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e];
  }
  on(e, r) {
    return this.events[e] || (this.events[e] = new Ls()), this.events[e].add(r);
  }
  notify(e, ...r) {
    var n;
    (n = this.events[e]) === null || n === void 0 || n.notify(...r);
  }
}
const af = ["initial", ...Ys], Ty = af.length;
class uf extends xy {
  sortInstanceNodePosition(e, r) {
    return e.compareDocumentPosition(r) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, r) {
    var n;
    return (n = e.style) === null || n === void 0 ? void 0 : n[r];
  }
  removeValueFromRenderState(e, { vars: r, style: n }) {
    delete r[e], delete n[e];
  }
  makeTargetAnimatableFromInstance({ transition: e, transitionEnd: r, ...n }, { transformValues: i }, o) {
    let s = Bm(n, e || {}, this);
    if (i && (r && (r = i(r)), n && (n = i(n)), s && (s = i(s))), o) {
      Rm(this, n, s);
      const a = vy(this, n, s, r);
      r = a.transitionEnd, n = a.target;
    }
    return {
      transition: e,
      transitionEnd: r,
      ...n
    };
  }
}
function Ey(t) {
  return window.getComputedStyle(t);
}
class Ay extends uf {
  readValueFromInstance(e, r) {
    if (Yr.has(r)) {
      const n = Fs(r);
      return n && n.default || 0;
    } else {
      const n = Ey(e), i = (sl(r) ? n.getPropertyValue(r) : n[r]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: r }) {
    return tf(e, r);
  }
  build(e, r, n, i) {
    As(e, r, n, i.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, r) {
    return Os(e, r);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    St(e) && (this.childSubscription = e.on("change", (r) => {
      this.current && (this.current.textContent = `${r}`);
    }));
  }
  renderInstance(e, r, n, i) {
    fl(e, r, n, i);
  }
}
class My extends uf {
  constructor() {
    super(...arguments), this.isSVGTag = !1;
  }
  getBaseTargetFromProps(e, r) {
    return e[r];
  }
  readValueFromInstance(e, r) {
    var n;
    return Yr.has(r) ? ((n = Fs(r)) === null || n === void 0 ? void 0 : n.default) || 0 : (r = hl.has(r) ? r : Cs(r), e.getAttribute(r));
  }
  measureInstanceViewportBox() {
    return ct();
  }
  scrapeMotionValuesFromProps(e, r) {
    return pl(e, r);
  }
  build(e, r, n, i) {
    Ss(e, r, n, this.isSVGTag, i.transformTemplate);
  }
  renderInstance(e, r, n, i) {
    dl(e, r, n, i);
  }
  mount(e) {
    this.isSVGTag = Ps(e.tagName), super.mount(e);
  }
}
const Sy = (t, e) => Es(t) ? new My(e, { enableHardwareAcceleration: !1 }) : new Ay(e, { enableHardwareAcceleration: !0 });
function wu(t, e) {
  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
}
const an = {
  correct: (t, e) => {
    if (!e.target)
      return t;
    if (typeof t == "string")
      if (Se.test(t))
        t = parseFloat(t);
      else
        return t;
    const r = wu(t, e.target.x), n = wu(t, e.target.y);
    return `${r}% ${n}%`;
  }
}, _u = "_$css", Py = {
  correct: (t, { treeScale: e, projectionDelta: r }) => {
    const n = t, i = t.includes("var("), o = [];
    i && (t = t.replace(rf, (w) => (o.push(w), _u)));
    const s = lr.parse(t);
    if (s.length > 5)
      return n;
    const a = lr.createTransformer(t), f = typeof s[0] != "number" ? 1 : 0, p = r.x.scale * e.x, d = r.y.scale * e.y;
    s[0 + f] /= p, s[1 + f] /= d;
    const y = ot(p, d, 0.5);
    typeof s[2 + f] == "number" && (s[2 + f] /= y), typeof s[3 + f] == "number" && (s[3 + f] /= y);
    let v = a(s);
    if (i) {
      let w = 0;
      v = v.replace(_u, () => {
        const I = o[w];
        return w++, I;
      });
    }
    return v;
  }
};
class Cy extends ht.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e, layoutGroup: r, switchLayoutGroup: n, layoutId: i } = this.props, { projection: o } = e;
    _0(Ry), o && (r.group && r.group.add(o), n && n.register && i && n.register(o), o.root.didUpdate(), o.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), o.setOptions({
      ...o.options,
      onExitComplete: () => this.safeToRemove()
    })), pn.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: r, visualElement: n, drag: i, isPresent: o } = this.props, s = n.projection;
    return s && (s.isPresent = o, i || e.layoutDependency !== r || r === void 0 ? s.willUpdate() : this.safeToRemove(), e.isPresent !== o && (o ? s.promote() : s.relegate() || _t.postRender(() => {
      var a;
      !((a = s.getStack()) === null || a === void 0) && a.members.length || this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e && (e.root.didUpdate(), !e.currentAnimation && e.isLead() && this.safeToRemove());
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: r, switchLayoutGroup: n } = this.props, { projection: i } = e;
    i && (i.scheduleCheckAfterUnmount(), r != null && r.group && r.group.remove(i), n != null && n.deregister && n.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e == null || e();
  }
  render() {
    return null;
  }
}
function Oy(t) {
  const [e, r] = xl(), n = dt(Ts);
  return ht.createElement(Cy, { ...t, layoutGroup: n, switchLayoutGroup: dt(il), isPresent: e, safeToRemove: r });
}
const Ry = {
  borderRadius: {
    ...an,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: an,
  borderTopRightRadius: an,
  borderBottomLeftRadius: an,
  borderBottomRightRadius: an,
  boxShadow: Py
}, Iy = {
  measureLayout: Oy
};
function By(t, e, r = {}) {
  const n = St(t) ? t : Gr(t);
  return n.start(Gs("", n, e, r)), {
    stop: () => n.stop(),
    isAnimating: () => n.isAnimating()
  };
}
const cf = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], ky = cf.length, bu = (t) => typeof t == "string" ? parseFloat(t) : t, xu = (t) => typeof t == "number" || Se.test(t);
function Dy(t, e, r, n, i, o) {
  i ? (t.opacity = ot(
    0,
    // TODO Reinstate this if only child
    r.opacity !== void 0 ? r.opacity : 1,
    Ly(n)
  ), t.opacityExit = ot(e.opacity !== void 0 ? e.opacity : 1, 0, Ny(n))) : o && (t.opacity = ot(e.opacity !== void 0 ? e.opacity : 1, r.opacity !== void 0 ? r.opacity : 1, n));
  for (let s = 0; s < ky; s++) {
    const a = `border${cf[s]}Radius`;
    let f = Tu(e, a), p = Tu(r, a);
    if (f === void 0 && p === void 0)
      continue;
    f || (f = 0), p || (p = 0), f === 0 || p === 0 || xu(f) === xu(p) ? (t[a] = Math.max(ot(bu(f), bu(p), n), 0), (zt.test(p) || zt.test(f)) && (t[a] += "%")) : t[a] = p;
  }
  (e.rotate || r.rotate) && (t.rotate = ot(e.rotate || 0, r.rotate || 0, n));
}
function Tu(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius;
}
const Ly = lf(0, 0.5, Ks), Ny = lf(0.5, 0.95, Hs);
function lf(t, e, r) {
  return (n) => n < t ? 0 : n > e ? 1 : r(ui(t, e, n));
}
function Eu(t, e) {
  t.min = e.min, t.max = e.max;
}
function jt(t, e) {
  Eu(t.x, e.x), Eu(t.y, e.y);
}
function Au(t, e, r, n, i) {
  return t -= e, t = li(t, 1 / r, n), i !== void 0 && (t = li(t, 1 / i, n)), t;
}
function Uy(t, e = 0, r = 1, n = 0.5, i, o = t, s = t) {
  if (zt.test(e) && (e = parseFloat(e), e = ot(s.min, s.max, e / 100) - s.min), typeof e != "number")
    return;
  let a = ot(o.min, o.max, n);
  t === o && (a -= e), t.min = Au(t.min, e, r, a, i), t.max = Au(t.max, e, r, a, i);
}
function Mu(t, e, [r, n, i], o, s) {
  Uy(t, e[r], e[n], e[i], e.scale, o, s);
}
const Fy = ["x", "scaleX", "originX"], jy = ["y", "scaleY", "originY"];
function Su(t, e, r, n) {
  Mu(t.x, e, Fy, r == null ? void 0 : r.x, n == null ? void 0 : n.x), Mu(t.y, e, jy, r == null ? void 0 : r.y, n == null ? void 0 : n.y);
}
function Pu(t) {
  return t.translate === 0 && t.scale === 1;
}
function ff(t) {
  return Pu(t.x) && Pu(t.y);
}
function hf(t, e) {
  return t.x.min === e.x.min && t.x.max === e.x.max && t.y.min === e.y.min && t.y.max === e.y.max;
}
function Cu(t) {
  return Rt(t.x) / Rt(t.y);
}
class $y {
  constructor() {
    this.members = [];
  }
  add(e) {
    ks(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (Ds(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
      const r = this.members[this.members.length - 1];
      r && this.promote(r);
    }
  }
  relegate(e) {
    const r = this.members.findIndex((i) => e === i);
    if (r === 0)
      return !1;
    let n;
    for (let i = r; i >= 0; i--) {
      const o = this.members[i];
      if (o.isPresent !== !1) {
        n = o;
        break;
      }
    }
    return n ? (this.promote(n), !0) : !1;
  }
  promote(e, r) {
    var n;
    const i = this.lead;
    if (e !== i && (this.prevLead = i, this.lead = e, e.show(), i)) {
      i.instance && i.scheduleRender(), e.scheduleRender(), e.resumeFrom = i, r && (e.resumeFrom.preserveOpacity = !0), i.snapshot && (e.snapshot = i.snapshot, e.snapshot.latestValues = i.animationValues || i.latestValues), !((n = e.root) === null || n === void 0) && n.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: o } = e.options;
      o === !1 && i.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      var r, n, i, o, s;
      (n = (r = e.options).onExitComplete) === null || n === void 0 || n.call(r), (s = (i = e.resumingFrom) === null || i === void 0 ? void 0 : (o = i.options).onExitComplete) === null || s === void 0 || s.call(o);
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function Ou(t, e, r) {
  let n = "";
  const i = t.x.translate / e.x, o = t.y.translate / e.y;
  if ((i || o) && (n = `translate3d(${i}px, ${o}px, 0) `), (e.x !== 1 || e.y !== 1) && (n += `scale(${1 / e.x}, ${1 / e.y}) `), r) {
    const { rotate: f, rotateX: p, rotateY: d } = r;
    f && (n += `rotate(${f}deg) `), p && (n += `rotateX(${p}deg) `), d && (n += `rotateY(${d}deg) `);
  }
  const s = t.x.scale * e.x, a = t.y.scale * e.y;
  return (s !== 1 || a !== 1) && (n += `scale(${s}, ${a})`), n || "none";
}
const Vy = (t, e) => t.depth - e.depth;
class qy {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(e) {
    ks(this.children, e), this.isDirty = !0;
  }
  remove(e) {
    Ds(this.children, e), this.isDirty = !0;
  }
  forEach(e) {
    this.isDirty && this.children.sort(Vy), this.isDirty = !1, this.children.forEach(e);
  }
}
const Ru = ["", "X", "Y", "Z"], Iu = 1e3;
let Wy = 0;
function df({ attachResizeListener: t, defaultParent: e, measureScroll: r, checkIsScrollRoot: n, resetTransform: i }) {
  return class {
    constructor(s, a = {}, f = e == null ? void 0 : e()) {
      this.id = Wy++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isTransformDirty = !1, this.isProjectionDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.potentialNodes = /* @__PURE__ */ new Map(), this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.nodes.forEach(zy), this.nodes.forEach(Xy), this.nodes.forEach(Zy);
      }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.elementId = s, this.latestValues = a, this.root = f ? f.root || f : this, this.path = f ? [...f.path, f] : [], this.parent = f, this.depth = f ? f.depth + 1 : 0, s && this.root.registerPotentialNode(s, this);
      for (let p = 0; p < this.path.length; p++)
        this.path[p].shouldResetTransform = !0;
      this.root === this && (this.nodes = new qy());
    }
    addEventListener(s, a) {
      return this.eventHandlers.has(s) || this.eventHandlers.set(s, new Ls()), this.eventHandlers.get(s).add(a);
    }
    notifyListeners(s, ...a) {
      const f = this.eventHandlers.get(s);
      f == null || f.notify(...a);
    }
    hasListeners(s) {
      return this.eventHandlers.has(s);
    }
    registerPotentialNode(s, a) {
      this.potentialNodes.set(s, a);
    }
    /**
     * Lifecycles
     */
    mount(s, a = !1) {
      var f;
      if (this.instance)
        return;
      this.isSVG = s instanceof SVGElement && s.tagName !== "svg", this.instance = s;
      const { layoutId: p, layout: d, visualElement: y } = this.options;
      if (y && !y.current && y.mount(s), this.root.nodes.add(this), (f = this.parent) === null || f === void 0 || f.children.add(this), this.elementId && this.root.potentialNodes.delete(this.elementId), a && (d || p) && (this.isLayoutDirty = !0), t) {
        let v;
        const w = () => this.root.updateBlockedByResize = !1;
        t(s, () => {
          this.root.updateBlockedByResize = !0, v && v(), v = zl(w, 250), pn.hasAnimatedSinceResize && (pn.hasAnimatedSinceResize = !1, this.nodes.forEach(ku));
        });
      }
      p && this.root.registerSharedNode(p, this), this.options.animate !== !1 && y && (p || d) && this.addEventListener("didUpdate", ({ delta: v, hasLayoutChanged: w, hasRelativeTargetChanged: I, layout: N }) => {
        var k, M, S, Y, W;
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const Q = (M = (k = this.options.transition) !== null && k !== void 0 ? k : y.getDefaultTransition()) !== null && M !== void 0 ? M : rv, { onLayoutAnimationStart: X, onLayoutAnimationComplete: ne } = y.getProps(), ue = !this.targetLayout || !hf(this.targetLayout, N) || I, se = !w && I;
        if (this.options.layoutRoot || !((S = this.resumeFrom) === null || S === void 0) && S.instance || se || w && (ue || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(v, se);
          const ie = {
            ...Gl(Q, "layout"),
            onPlay: X,
            onComplete: ne
          };
          (y.shouldReduceMotion || this.options.layoutRoot) && (ie.delay = 0, ie.type = !1), this.startAnimation(ie);
        } else
          !w && this.animationProgress === 0 && ku(this), this.isLead() && ((W = (Y = this.options).onExitComplete) === null || W === void 0 || W.call(Y));
        this.targetLayout = N;
      });
    }
    unmount() {
      var s, a;
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this), (s = this.getStack()) === null || s === void 0 || s.remove(this), (a = this.parent) === null || a === void 0 || a.children.delete(this), this.instance = void 0, cr.preRender(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      var s;
      return this.isAnimationBlocked || ((s = this.parent) === null || s === void 0 ? void 0 : s.isTreeAnimationBlocked()) || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      var s;
      this.isUpdateBlocked() || (this.isUpdating = !0, (s = this.nodes) === null || s === void 0 || s.forEach(Jy), this.animationId++);
    }
    getTransformTemplate() {
      var s;
      return (s = this.options.visualElement) === null || s === void 0 ? void 0 : s.getProps().transformTemplate;
    }
    willUpdate(s = !0) {
      var a, f, p;
      if (this.root.isUpdateBlocked()) {
        (f = (a = this.options).onExitComplete) === null || f === void 0 || f.call(a);
        return;
      }
      if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let v = 0; v < this.path.length; v++) {
        const w = this.path[v];
        w.shouldResetTransform = !0, w.updateScroll("snapshot"), w.options.layoutRoot && w.willUpdate(!1);
      }
      const { layoutId: d, layout: y } = this.options;
      d === void 0 && !y || (this.prevTransformTemplateValue = (p = this.getTransformTemplate()) === null || p === void 0 ? void 0 : p(this.latestValues, ""), this.updateSnapshot(), s && this.notifyListeners("willUpdate"));
    }
    // Note: Currently only running on root node
    didUpdate() {
      if (this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Bu);
        return;
      }
      this.isUpdating && (this.isUpdating = !1, this.potentialNodes.size && (this.potentialNodes.forEach(nv), this.potentialNodes.clear()), this.nodes.forEach(Yy), this.nodes.forEach(Hy), this.nodes.forEach(Ky), this.clearAllSnapshots(), qi.update(), qi.preRender(), qi.render());
    }
    clearAllSnapshots() {
      this.nodes.forEach(Gy), this.sharedNodes.forEach(Qy);
    }
    scheduleUpdateProjection() {
      _t.preRender(this.updateProjection, !1, !0);
    }
    scheduleCheckAfterUnmount() {
      _t.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      var s;
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let f = 0; f < this.path.length; f++)
          this.path[f].updateScroll();
      const a = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = ct(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox), (s = this.options.visualElement) === null || s === void 0 || s.notify("LayoutMeasure", this.layout.layoutBox, a == null ? void 0 : a.layoutBox);
    }
    updateScroll(s = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1), a && (this.scroll = {
        animationId: this.root.animationId,
        phase: s,
        isRoot: n(this.instance),
        offset: r(this.instance)
      });
    }
    resetTransform() {
      var s;
      if (!i)
        return;
      const a = this.isLayoutDirty || this.shouldResetTransform, f = this.projectionDelta && !ff(this.projectionDelta), p = (s = this.getTransformTemplate()) === null || s === void 0 ? void 0 : s(this.latestValues, ""), d = p !== this.prevTransformTemplateValue;
      a && (f || pr(this.latestValues) || d) && (i(this.instance, p), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(s = !0) {
      const a = this.measurePageBox();
      let f = this.removeElementScroll(a);
      return s && (f = this.removeTransform(f)), iv(f), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: f,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: s } = this.options;
      if (!s)
        return ct();
      const a = s.measureViewportBox(), { scroll: f } = this.root;
      return f && (sr(a.x, f.offset.x), sr(a.y, f.offset.y)), a;
    }
    removeElementScroll(s) {
      const a = ct();
      jt(a, s);
      for (let f = 0; f < this.path.length; f++) {
        const p = this.path[f], { scroll: d, options: y } = p;
        if (p !== this.root && d && y.layoutScroll) {
          if (d.isRoot) {
            jt(a, s);
            const { scroll: v } = this.root;
            v && (sr(a.x, -v.offset.x), sr(a.y, -v.offset.y));
          }
          sr(a.x, d.offset.x), sr(a.y, d.offset.y);
        }
      }
      return a;
    }
    applyTransform(s, a = !1) {
      const f = ct();
      jt(f, s);
      for (let p = 0; p < this.path.length; p++) {
        const d = this.path[p];
        !a && d.options.layoutScroll && d.scroll && d !== d.root && Dr(f, {
          x: -d.scroll.offset.x,
          y: -d.scroll.offset.y
        }), pr(d.latestValues) && Dr(f, d.latestValues);
      }
      return pr(this.latestValues) && Dr(f, this.latestValues), f;
    }
    removeTransform(s) {
      var a;
      const f = ct();
      jt(f, s);
      for (let p = 0; p < this.path.length; p++) {
        const d = this.path[p];
        if (!d.instance || !pr(d.latestValues))
          continue;
        Co(d.latestValues) && d.updateSnapshot();
        const y = ct(), v = d.measurePageBox();
        jt(y, v), Su(f, d.latestValues, (a = d.snapshot) === null || a === void 0 ? void 0 : a.layoutBox, y);
      }
      return pr(this.latestValues) && Su(f, this.latestValues), f;
    }
    /**
     *
     */
    setTargetDelta(s) {
      this.targetDelta = s, this.isProjectionDirty = !0, this.root.scheduleUpdateProjection();
    }
    setOptions(s) {
      this.options = {
        ...this.options,
        ...s,
        crossfade: s.crossfade !== void 0 ? s.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    /**
     * Frame calculations
     */
    resolveTargetDelta() {
      var s;
      const a = this.getLead();
      if (this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), !this.isProjectionDirty && !this.attemptToResolveRelativeTarget)
        return;
      const { layout: f, layoutId: p } = this.options;
      if (!(!this.layout || !(f || p))) {
        if (!this.targetDelta && !this.relativeTarget) {
          const d = this.getClosestProjectingParent();
          d && d.layout ? (this.relativeParent = d, this.relativeTarget = ct(), this.relativeTargetOrigin = ct(), vn(this.relativeTargetOrigin, this.layout.layoutBox, d.layout.layoutBox), jt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = ct(), this.targetWithTransforms = ct()), this.relativeTarget && this.relativeTargetOrigin && (!((s = this.relativeParent) === null || s === void 0) && s.target) ? Vg(this.target, this.relativeTarget, this.relativeParent.target) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : jt(this.target, this.layout.layoutBox), ef(this.target, this.targetDelta)) : jt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {
          this.attemptToResolveRelativeTarget = !1;
          const d = this.getClosestProjectingParent();
          d && !!d.resumingFrom == !!this.resumingFrom && !d.options.layoutScroll && d.target ? (this.relativeParent = d, this.relativeTarget = ct(), this.relativeTargetOrigin = ct(), vn(this.relativeTargetOrigin, this.target, d.target), jt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || Co(this.parent.latestValues) || Ql(this.parent.latestValues)))
        return (this.parent.relativeTarget || this.parent.targetDelta || this.parent.options.layoutRoot) && this.parent.layout ? this.parent : this.parent.getClosestProjectingParent();
    }
    calcProjection() {
      var s;
      const { isProjectionDirty: a, isTransformDirty: f } = this;
      this.isProjectionDirty = this.isTransformDirty = !1;
      const p = this.getLead(), d = !!this.resumingFrom || this !== p;
      let y = !0;
      if (a && (y = !1), d && f && (y = !1), y)
        return;
      const { layout: v, layoutId: w } = this.options;
      if (this.isTreeAnimating = !!(!((s = this.parent) === null || s === void 0) && s.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(v || w))
        return;
      jt(this.layoutCorrected, this.layout.layoutBox), Zg(this.layoutCorrected, this.treeScale, this.path, d);
      const { target: I } = p;
      if (!I)
        return;
      this.projectionDelta || (this.projectionDelta = wn(), this.projectionDeltaWithTransform = wn());
      const N = this.treeScale.x, k = this.treeScale.y, M = this.projectionTransform;
      yn(this.projectionDelta, this.layoutCorrected, I, this.latestValues), this.projectionTransform = Ou(this.projectionDelta, this.treeScale), (this.projectionTransform !== M || this.treeScale.x !== N || this.treeScale.y !== k) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", I));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(s = !0) {
      var a, f, p;
      (f = (a = this.options).scheduleRender) === null || f === void 0 || f.call(a), s && ((p = this.getStack()) === null || p === void 0 || p.scheduleRender()), this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    setAnimationOrigin(s, a = !1) {
      var f, p;
      const d = this.snapshot, y = (d == null ? void 0 : d.latestValues) || {}, v = { ...this.latestValues }, w = wn();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const I = ct(), N = (d == null ? void 0 : d.source) !== ((f = this.layout) === null || f === void 0 ? void 0 : f.source), k = (((p = this.getStack()) === null || p === void 0 ? void 0 : p.members.length) || 0) <= 1, M = !!(N && !k && this.options.crossfade === !0 && !this.path.some(tv));
      this.animationProgress = 0, this.mixTargetDelta = (S) => {
        var Y;
        const W = S / 1e3;
        Du(w.x, s.x, W), Du(w.y, s.y, W), this.setTargetDelta(w), this.relativeTarget && this.relativeTargetOrigin && this.layout && (!((Y = this.relativeParent) === null || Y === void 0) && Y.layout) && (vn(I, this.layout.layoutBox, this.relativeParent.layout.layoutBox), ev(this.relativeTarget, this.relativeTargetOrigin, I, W)), N && (this.animationValues = v, Dy(v, y, this.latestValues, W, M, k)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = W;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(s) {
      var a, f;
      this.notifyListeners("animationStart"), (a = this.currentAnimation) === null || a === void 0 || a.stop(), this.resumingFrom && ((f = this.resumingFrom.currentAnimation) === null || f === void 0 || f.stop()), this.pendingAnimation && (cr.update(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = _t.update(() => {
        pn.hasAnimatedSinceResize = !0, this.currentAnimation = By(0, Iu, {
          ...s,
          onUpdate: (p) => {
            var d;
            this.mixTargetDelta(p), (d = s.onUpdate) === null || d === void 0 || d.call(s, p);
          },
          onComplete: () => {
            var p;
            (p = s.onComplete) === null || p === void 0 || p.call(s), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      var s;
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0), (s = this.getStack()) === null || s === void 0 || s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      var s;
      this.currentAnimation && ((s = this.mixTargetDelta) === null || s === void 0 || s.call(this, Iu), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const s = this.getLead();
      let { targetWithTransforms: a, target: f, layout: p, latestValues: d } = s;
      if (!(!a || !f || !p)) {
        if (this !== s && this.layout && p && pf(this.options.animationType, this.layout.layoutBox, p.layoutBox)) {
          f = this.target || ct();
          const y = Rt(this.layout.layoutBox.x);
          f.x.min = s.target.x.min, f.x.max = f.x.min + y;
          const v = Rt(this.layout.layoutBox.y);
          f.y.min = s.target.y.min, f.y.max = f.y.min + v;
        }
        jt(a, f), Dr(a, d), yn(this.projectionDeltaWithTransform, this.layoutCorrected, a, d);
      }
    }
    registerSharedNode(s, a) {
      var f, p, d;
      this.sharedNodes.has(s) || this.sharedNodes.set(s, new $y()), this.sharedNodes.get(s).add(a), a.promote({
        transition: (f = a.options.initialPromotionConfig) === null || f === void 0 ? void 0 : f.transition,
        preserveFollowOpacity: (d = (p = a.options.initialPromotionConfig) === null || p === void 0 ? void 0 : p.shouldPreserveFollowOpacity) === null || d === void 0 ? void 0 : d.call(p, a)
      });
    }
    isLead() {
      const s = this.getStack();
      return s ? s.lead === this : !0;
    }
    getLead() {
      var s;
      const { layoutId: a } = this.options;
      return a ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) || this : this;
    }
    getPrevLead() {
      var s;
      const { layoutId: a } = this.options;
      return a ? (s = this.getStack()) === null || s === void 0 ? void 0 : s.prevLead : void 0;
    }
    getStack() {
      const { layoutId: s } = this.options;
      if (s)
        return this.root.sharedNodes.get(s);
    }
    promote({ needsReset: s, transition: a, preserveFollowOpacity: f } = {}) {
      const p = this.getStack();
      p && p.promote(this, f), s && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const s = this.getStack();
      return s ? s.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement: s } = this.options;
      if (!s)
        return;
      let a = !1;
      const { latestValues: f } = s;
      if ((f.rotate || f.rotateX || f.rotateY || f.rotateZ) && (a = !0), !a)
        return;
      const p = {};
      for (let d = 0; d < Ru.length; d++) {
        const y = "rotate" + Ru[d];
        f[y] && (p[y] = f[y], s.setStaticValue(y, 0));
      }
      s == null || s.render();
      for (const d in p)
        s.setStaticValue(d, p[d]);
      s.scheduleRender();
    }
    getProjectionStyles(s = {}) {
      var a, f;
      const p = {};
      if (!this.instance || this.isSVG)
        return p;
      if (this.isVisible)
        p.visibility = "";
      else
        return { visibility: "hidden" };
      const d = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, p.opacity = "", p.pointerEvents = Yn(s.pointerEvents) || "", p.transform = d ? d(this.latestValues, "") : "none", p;
      const y = this.getLead();
      if (!this.projectionDelta || !this.layout || !y.target) {
        const N = {};
        return this.options.layoutId && (N.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, N.pointerEvents = Yn(s.pointerEvents) || ""), this.hasProjected && !pr(this.latestValues) && (N.transform = d ? d({}, "") : "none", this.hasProjected = !1), N;
      }
      const v = y.animationValues || y.latestValues;
      this.applyTransformsToTarget(), p.transform = Ou(this.projectionDeltaWithTransform, this.treeScale, v), d && (p.transform = d(v, p.transform));
      const { x: w, y: I } = this.projectionDelta;
      p.transformOrigin = `${w.origin * 100}% ${I.origin * 100}% 0`, y.animationValues ? p.opacity = y === this ? (f = (a = v.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && f !== void 0 ? f : 1 : this.preserveOpacity ? this.latestValues.opacity : v.opacityExit : p.opacity = y === this ? v.opacity !== void 0 ? v.opacity : "" : v.opacityExit !== void 0 ? v.opacityExit : 0;
      for (const N in ti) {
        if (v[N] === void 0)
          continue;
        const { correct: k, applyTo: M } = ti[N], S = p.transform === "none" ? v[N] : k(v[N], y);
        if (M) {
          const Y = M.length;
          for (let W = 0; W < Y; W++)
            p[M[W]] = S;
        } else
          p[N] = S;
      }
      return this.options.layoutId && (p.pointerEvents = y === this ? Yn(s.pointerEvents) || "" : "none"), p;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((s) => {
        var a;
        return (a = s.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
      }), this.root.nodes.forEach(Bu), this.root.sharedNodes.clear();
    }
  };
}
function Hy(t) {
  t.updateLayout();
}
function Ky(t) {
  var e, r, n;
  const i = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
  if (t.isLead() && t.layout && i && t.hasListeners("didUpdate")) {
    const { layoutBox: o, measuredBox: s } = t.layout, { animationType: a } = t.options, f = i.source !== t.layout.source;
    a === "size" ? Ht((w) => {
      const I = f ? i.measuredBox[w] : i.layoutBox[w], N = Rt(I);
      I.min = o[w].min, I.max = I.min + N;
    }) : pf(a, i.layoutBox, o) && Ht((w) => {
      const I = f ? i.measuredBox[w] : i.layoutBox[w], N = Rt(o[w]);
      I.max = I.min + N;
    });
    const p = wn();
    yn(p, o, i.layoutBox);
    const d = wn();
    f ? yn(d, t.applyTransform(s, !0), i.measuredBox) : yn(d, o, i.layoutBox);
    const y = !ff(p);
    let v = !1;
    if (!t.resumeFrom) {
      const w = t.getClosestProjectingParent();
      if (w && !w.resumeFrom) {
        const { snapshot: I, layout: N } = w;
        if (I && N) {
          const k = ct();
          vn(k, i.layoutBox, I.layoutBox);
          const M = ct();
          vn(M, o, N.layoutBox), hf(k, M) || (v = !0), w.options.layoutRoot && (t.relativeTarget = M, t.relativeTargetOrigin = k, t.relativeParent = w);
        }
      }
    }
    t.notifyListeners("didUpdate", {
      layout: o,
      snapshot: i,
      delta: d,
      layoutDelta: p,
      hasLayoutChanged: y,
      hasRelativeTargetChanged: v
    });
  } else
    t.isLead() && ((n = (r = t.options).onExitComplete) === null || n === void 0 || n.call(r));
  t.options.transition = void 0;
}
function zy(t) {
  t.isProjectionDirty || (t.isProjectionDirty = !!(t.parent && t.parent.isProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = !!(t.parent && t.parent.isTransformDirty));
}
function Gy(t) {
  t.clearSnapshot();
}
function Bu(t) {
  t.clearMeasurements();
}
function Yy(t) {
  const { visualElement: e } = t.options;
  e != null && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform();
}
function ku(t) {
  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0;
}
function Xy(t) {
  t.resolveTargetDelta();
}
function Zy(t) {
  t.calcProjection();
}
function Jy(t) {
  t.resetRotation();
}
function Qy(t) {
  t.removeLeadSnapshot();
}
function Du(t, e, r) {
  t.translate = ot(e.translate, 0, r), t.scale = ot(e.scale, 1, r), t.origin = e.origin, t.originPoint = e.originPoint;
}
function Lu(t, e, r, n) {
  t.min = ot(e.min, r.min, n), t.max = ot(e.max, r.max, n);
}
function ev(t, e, r, n) {
  Lu(t.x, e.x, r.x, n), Lu(t.y, e.y, r.y, n);
}
function tv(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0;
}
const rv = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function nv(t, e) {
  let r = t.root;
  for (let o = t.path.length - 1; o >= 0; o--)
    if (t.path[o].instance) {
      r = t.path[o];
      break;
    }
  const i = (r && r !== t.root ? r.instance : document).querySelector(`[data-projection-id="${e}"]`);
  i && t.mount(i, !0);
}
function Nu(t) {
  t.min = Math.round(t.min), t.max = Math.round(t.max);
}
function iv(t) {
  Nu(t.x), Nu(t.y);
}
function pf(t, e, r) {
  return t === "position" || t === "preserve-aspect" && !So(Cu(e), Cu(r), 0.2);
}
const ov = df({
  attachResizeListener: (t, e) => Ai(t, "resize", e),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), Qi = {
  current: void 0
}, sv = df({
  measureScroll: (t) => ({
    x: t.scrollLeft,
    y: t.scrollTop
  }),
  defaultParent: () => {
    if (!Qi.current) {
      const t = new ov(0, {});
      t.mount(window), t.setOptions({ layoutScroll: !0 }), Qi.current = t;
    }
    return Qi.current;
  },
  resetTransform: (t, e) => {
    t.style.transform = e !== void 0 ? e : "none";
  },
  checkIsScrollRoot: (t) => window.getComputedStyle(t).position === "fixed"
}), av = {
  ...Ug,
  ...om,
  ...sy,
  ...Iy
}, mf = /* @__PURE__ */ v0((t, e) => K0(t, e, av, Sy, sv));
function gf() {
  const t = Ot(!1);
  return ei(() => (t.current = !0, () => {
    t.current = !1;
  }), []), t;
}
function uv() {
  const t = gf(), [e, r] = wt(0), n = qr(() => {
    t.current && r(e + 1);
  }, [e]);
  return [qr(() => _t.postRender(n), [n]), e];
}
class cv extends ke.Component {
  getSnapshotBeforeUpdate(e) {
    const r = this.props.childRef.current;
    if (r && e.isPresent && !this.props.isPresent) {
      const n = this.props.sizeRef.current;
      n.height = r.offsetHeight || 0, n.width = r.offsetWidth || 0, n.top = r.offsetTop, n.left = r.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function lv({ children: t, isPresent: e }) {
  const r = jo(), n = Ot(null), i = Ot({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  return Rf(() => {
    const { width: o, height: s, top: a, left: f } = i.current;
    if (e || !n.current || !o || !s)
      return;
    n.current.dataset.motionPopId = r;
    const p = document.createElement("style");
    return document.head.appendChild(p), p.sheet && p.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${s}px !important;
            top: ${a}px !important;
            left: ${f}px !important;
          }
        `), () => {
      document.head.removeChild(p);
    };
  }, [e]), ke.createElement(cv, { isPresent: e, childRef: n, sizeRef: i }, ke.cloneElement(t, { ref: n }));
}
const eo = ({ children: t, initial: e, isPresent: r, onExitComplete: n, custom: i, presenceAffectsLayout: o, mode: s }) => {
  const a = Ei(fv), f = jo(), p = bt(
    () => ({
      id: f,
      initial: e,
      isPresent: r,
      custom: i,
      onExitComplete: (d) => {
        a.set(d, !0);
        for (const y of a.values())
          if (!y)
            return;
        n && n();
      },
      register: (d) => (a.set(d, !1), () => a.delete(d))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    o ? void 0 : [r]
  );
  return bt(() => {
    a.forEach((d, y) => a.set(y, !1));
  }, [r]), ke.useEffect(() => {
    !r && !a.size && n && n();
  }, [r]), s === "popLayout" && (t = ke.createElement(lv, { isPresent: r }, t)), ke.createElement(Rn.Provider, { value: p }, t);
};
function fv() {
  return /* @__PURE__ */ new Map();
}
const Rr = (t) => t.key || "";
function hv(t, e) {
  t.forEach((r) => {
    const n = Rr(r);
    e.set(n, r);
  });
}
function dv(t) {
  const e = [];
  return Bf.forEach(t, (r) => {
    kf(r) && e.push(r);
  }), e;
}
const pv = ({ children: t, custom: e, initial: r = !0, onExitComplete: n, exitBeforeEnter: i, presenceAffectsLayout: o = !0, mode: s = "sync" }) => {
  i && (s = "wait", process.env.NODE_ENV !== "production" && Si(!1, "Replace exitBeforeEnter with mode='wait'"));
  let [a] = uv();
  const f = dt(Ts).forceRender;
  f && (a = f);
  const p = gf(), d = dv(t);
  let y = d;
  const v = /* @__PURE__ */ new Set(), w = Ot(y), I = Ot(/* @__PURE__ */ new Map()).current, N = Ot(!0);
  if (ei(() => {
    N.current = !1, hv(d, I), w.current = y;
  }), Bs(() => {
    N.current = !0, I.clear(), v.clear();
  }), N.current)
    return ke.createElement(ke.Fragment, null, y.map((Y) => ke.createElement(eo, { key: Rr(Y), isPresent: !0, initial: r ? void 0 : !1, presenceAffectsLayout: o, mode: s }, Y)));
  y = [...y];
  const k = w.current.map(Rr), M = d.map(Rr), S = k.length;
  for (let Y = 0; Y < S; Y++) {
    const W = k[Y];
    M.indexOf(W) === -1 && v.add(W);
  }
  return s === "wait" && v.size && (y = []), v.forEach((Y) => {
    if (M.indexOf(Y) !== -1)
      return;
    const W = I.get(Y);
    if (!W)
      return;
    const Q = k.indexOf(Y), X = () => {
      I.delete(Y), v.delete(Y);
      const ne = w.current.findIndex((ue) => ue.key === Y);
      if (w.current.splice(ne, 1), !v.size) {
        if (w.current = d, p.current === !1)
          return;
        a(), n && n();
      }
    };
    y.splice(Q, 0, ke.createElement(eo, { key: Rr(W), isPresent: !1, onExitComplete: X, custom: e, presenceAffectsLayout: o, mode: s }, W));
  }), y = y.map((Y) => {
    const W = Y.key;
    return v.has(W) ? Y : ke.createElement(eo, { key: Rr(Y), isPresent: !0, presenceAffectsLayout: o, mode: s }, Y);
  }), process.env.NODE_ENV !== "production" && s === "wait" && y.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`), ke.createElement(ke.Fragment, null, v.size ? y : y.map((Y) => If(Y)));
};
function Xs({
  open: t,
  onClose: e,
  children: r,
  className: n,
  variants: i,
  noWatermark: o = !1
}) {
  const s = i0();
  return /* @__PURE__ */ Me(pv, {
    children: t && /* @__PURE__ */ Fe(wv, {
      className: "modal-screen",
      children: [/* @__PURE__ */ Me(yv, {
        className: "modal-background",
        variants: mv,
        initial: "hidden",
        animate: "shown",
        exit: "hidden",
        transition: {
          ease: "easeInOut",
          duration: 0.23
        },
        onClick: e,
        children: !o && /* @__PURE__ */ Fe(Pv, {
          children: ["Arweave Wallet Kit v", n0]
        })
      }, "bg"), /* @__PURE__ */ Me(_v, {
        className: "modal-aligner",
        children: /* @__PURE__ */ Me(Tv, {
          className: "modal-animator " + (n ? " " + n : ""),
          variants: i || vv(s),
          initial: "hidden",
          animate: "shown",
          exit: "hidden",
          children: /* @__PURE__ */ Me(Mv, {
            children: r
          })
        }, "modal-animator")
      }, "modal-aligner")]
    }, "modal-screen")
  });
}
const mv = {
  shown: {
    opacity: 1
  },
  hidden: {
    opacity: 0
  }
}, gv = () => mf.div, yv = /* @__PURE__ */ Ce(gv())({
  name: "BackgroundLayer",
  class: "bbvkbel",
  propsAsIs: !0
}), vv = (t = !1) => ({
  shown: {
    top: 0,
    opacity: 1,
    width: t ? "100vw" : "50vw",
    transition: {
      type: "spring",
      duration: 0.4,
      delayChildren: 0.2,
      staggerChildren: 0.05
    }
  },
  hidden: {
    top: "100%",
    width: t ? "100vw" : "50vw",
    opacity: 0.4,
    // TODO(crookse) What's the reason for stopping at 0.4? Asking because a pause in animation is seen.
    transition: {
      type: "spring",
      duration: 0.4
    }
  }
}), wv = /* @__PURE__ */ Ce("div")({
  name: "ModalScreen",
  class: "m1767o4q",
  propsAsIs: !1
}), _v = /* @__PURE__ */ Ce("div")({
  name: "ModalAligner",
  class: "mzdiz37",
  propsAsIs: !1
}), bv = () => mf.div, xv = () => (t) => t.theme.themeConfig.font.fontFamily, Tv = st(/* @__PURE__ */ Ce(bv())({
  name: "ModalAnimator",
  class: "m69h97z",
  propsAsIs: !0,
  vars: {
    "m69h97z-0": [xv()]
  }
})), Ev = () => (t) => t.theme.background, Av = () => (t) => ({
  default: 30,
  minimal: 12,
  none: 0
})[t.theme.themeConfig.radius] + "px", Mv = st(/* @__PURE__ */ Ce("div")({
  name: "ModalContents",
  class: "mh21eb7",
  propsAsIs: !1,
  vars: {
    "mh21eb7-0": [Ev()],
    "mh21eb7-1": [Av()]
  }
})), Sv = () => (t) => t.theme.themeConfig.font.fontFamily, Pv = st(/* @__PURE__ */ Ce("p")({
  name: "KitName",
  class: "k17wyawm",
  propsAsIs: !1,
  vars: {
    "k17wyawm-0": [Sv()]
  }
}));
function Zs(t = !1) {
  const [e, r] = wt(t);
  return {
    setOpen: r,
    open: e,
    bindings: {
      open: e,
      onClose: () => r(!1)
    }
  };
}
function Cv() {
  const t = Zs(), {
    state: e,
    dispatch: r
  } = xt(), [n, i] = wt();
  Le(() => {
    (async () => {
      const f = await sh((e == null ? void 0 : e.config.permissions) || [], !!(e != null && e.config.ensurePermissions));
      f && f.resumeSession ? (i(f), t.setOpen(!0)) : r({
        type: "UPDATE_STRATEGY",
        payload: !!f && f.id || !1
      });
    })();
  }, []);
  function o() {
    localStorage.removeItem(Sn), r({
      type: "DISCONNECT"
    });
  }
  async function s() {
    let f = !1;
    if (n != null && n.resumeSession) {
      f = n;
      try {
        await n.resumeSession();
      } catch {
        f = !1;
      }
    }
    i(void 0), t.setOpen(!1), r({
      type: "UPDATE_STRATEGY",
      payload: !!f && f.id || !1
    }), f || o();
  }
  function a() {
    i(void 0), t.setOpen(!1), o();
  }
  return /* @__PURE__ */ Fe(Bv, {
    variants: Ov,
    ...t.bindings,
    onClose: a,
    noWatermark: !0,
    children: [/* @__PURE__ */ Fe(Dv, {
      children: ["Would you like to restore your ", (n == null ? void 0 : n.name) + " " || "", "session?"]
    }), /* @__PURE__ */ Fe(Lv, {
      children: [/* @__PURE__ */ Me(ur, {
        onClick: s,
        children: "Restore"
      }), /* @__PURE__ */ Me(jv, {
        onClick: a,
        children: "Cancel"
      })]
    })]
  });
}
const Ov = {
  shown: {
    opacity: 1,
    translateY: "-1.5rem",
    transition: {
      type: "spring",
      duration: 0.4,
      delayChildren: 0.2,
      staggerChildren: 0.025
    }
  },
  hidden: {
    opacity: 0.4,
    translateY: "200%",
    transition: {
      type: "spring",
      duration: 0.4
    }
  }
}, Rv = () => Xs, Iv = () => (t) => ({
  default: 15,
  minimal: 8,
  none: 0
})[t.theme.themeConfig.radius] + "px", Bv = st(/* @__PURE__ */ Ce(Rv())({
  name: "BottomModal",
  class: "b7jc8fb",
  propsAsIs: !0,
  vars: {
    "b7jc8fb-0": [Iv()]
  }
})), kv = () => (t) => t.theme.primaryText, Dv = st(/* @__PURE__ */ Ce("p")({
  name: "Text",
  class: "typmncv",
  propsAsIs: !1,
  vars: {
    "typmncv-0": [kv()]
  }
})), Lv = /* @__PURE__ */ Ce("div")({
  name: "Buttons",
  class: "b14qolsb",
  propsAsIs: !1
}), Nv = () => ur, Uv = () => (t) => t.theme.primaryText, Fv = () => (t) => t.theme.theme, jv = st(/* @__PURE__ */ Ce(Nv())({
  name: "CloseButton",
  class: "c1jq17m8",
  propsAsIs: !0,
  vars: {
    "c1jq17m8-0": [Uv()],
    "c1jq17m8-1": [Fv()]
  }
}));
const $v = () => (t) => t.small ? ".7rem" : ".9rem", Vv = () => (t) => t.theme.secondaryText, jr = st(/* @__PURE__ */ Ce("p")({
  name: "Paragraph",
  class: "p1jty3xq",
  propsAsIs: !1,
  vars: {
    "p1jty3xq-0": [$v()],
    "p1jty3xq-1": [Vv()]
  }
}));
const qv = () => (t) => t.theme.themeConfig.font.fontFamily, Wv = () => (t) => t.small ? "1.05rem" : "1.2rem", Hv = () => (t) => t.themed ? uc(t.theme.themeConfig.titleHighlight) : t.theme.primaryText, Kv = () => (t) => t.themed ? "pointer" : "text", vr = st(/* @__PURE__ */ Ce("h1")({
  name: "Title",
  class: "t1sgzzc0",
  propsAsIs: !1,
  vars: {
    "t1sgzzc0-0": [qv()],
    "t1sgzzc0-1": [Wv()],
    "t1sgzzc0-2": [Hv()],
    "t1sgzzc0-3": [Kv()]
  }
})), zv = /* @__PURE__ */ Ce("div")({
  name: "TitleWithParagraph",
  class: "tb205ol",
  propsAsIs: !1
});
function Gv({
  logo: t,
  name: e,
  description: r,
  onClick: n,
  theme: i
}) {
  return /* @__PURE__ */ Fe(Yv, {
    children: [/* @__PURE__ */ Fe(Xv, {
      children: [/* @__PURE__ */ Me(vf, {
        colorTheme: i,
        clickable: !0,
        onClick: n,
        children: /* @__PURE__ */ Me(yf, {
          src: t,
          draggable: !1
        })
      }), /* @__PURE__ */ Fe(tw, {
        children: [/* @__PURE__ */ Me(vr, {
          small: !0,
          children: e
        }), /* @__PURE__ */ Me(jr, {
          small: !0,
          children: r
        })]
      })]
    }), /* @__PURE__ */ Me(ur, {
      onClick: n,
      children: "Go"
    })]
  });
}
const Yv = /* @__PURE__ */ Ce("div")({
  name: "Wrapper",
  class: "wzg6vks",
  propsAsIs: !1
}), Xv = /* @__PURE__ */ Ce("div")({
  name: "AppInfo",
  class: "a1vzc1qt",
  propsAsIs: !1
}), yf = /* @__PURE__ */ Ce("img")({
  name: "Logo",
  class: "l1rbotc6",
  propsAsIs: !1
}), Zv = () => (t) => ({
  default: 15,
  minimal: 6,
  none: 0
})[t.theme.themeConfig.radius] + "px", Jv = () => (t) => t.colorTheme || t.theme.primaryText, Qv = () => (t) => t.clickable ? "pointer" : "default", ew = () => (t) => t.clickable ? ".95" : "1", vf = st(/* @__PURE__ */ Ce("div")({
  name: "AppIcon",
  class: "acuhj7u",
  propsAsIs: !1,
  vars: {
    "acuhj7u-0": [Zv()],
    "acuhj7u-1": [Jv()],
    "acuhj7u-2": [Qv()],
    "acuhj7u-3": [ew()]
  }
})), tw = /* @__PURE__ */ Ce("div")({
  name: "AppNameAndDescription",
  class: "a143ijem",
  propsAsIs: !1
});
function rw({
  children: t
}) {
  return /* @__PURE__ */ Me(iw, {
    children: t
  });
}
const nw = () => (t) => t.theme.light, iw = st(/* @__PURE__ */ Ce("div")({
  name: "Wrapper",
  class: "wv1c1ab",
  propsAsIs: !1,
  vars: {
    "wv1c1ab-0": [nw()]
  }
}));
const ow = (t) => /* @__PURE__ */ Fe(sw, {
  viewBox: "0 0 48 48",
  xmlns: "http://www.w3.org/2000/svg",
  ...t,
  children: [/* @__PURE__ */ Me("circle", {
    cx: "24",
    cy: "24",
    fill: "none",
    r: "20",
    strokeDasharray: "80",
    strokeLinecap: "round",
    stroke: "currentColor",
    strokeWidth: "4"
  }), /* @__PURE__ */ Me("circle", {
    cx: "24",
    cy: "24",
    fill: "none",
    opacity: "0.3",
    r: "20",
    strokeLinecap: "round",
    stroke: "currentColor",
    strokeWidth: "4"
  })]
}), sw = /* @__PURE__ */ Ce("svg")({
  name: "SvgWrapper",
  class: "s9sva",
  propsAsIs: !1
});
function wf({
  children: t,
  onClose: e
}) {
  return /* @__PURE__ */ Fe(aw, {
    children: [t, /* @__PURE__ */ Me(lw, {
      onClick: e,
      children: /* @__PURE__ */ Me(mh, {})
    })]
  });
}
const aw = /* @__PURE__ */ Ce("div")({
  name: "HeadWrapper",
  class: "h1mmuqym",
  propsAsIs: !1
}), uw = () => (t) => t.theme.light, cw = () => (t) => t.theme.secondaryText, lw = st(/* @__PURE__ */ Ce("div")({
  name: "CloseButton",
  class: "c86k5gq",
  propsAsIs: !1,
  vars: {
    "c86k5gq-0": [uw()],
    "c86k5gq-1": [cw()]
  }
}));
function fw() {
  const t = Zs(), {
    state: e,
    dispatch: r
  } = xt();
  Le(() => {
    t.setOpen((e == null ? void 0 : e.activeModal) === "connect");
  }, [e == null ? void 0 : e.activeModal]), Le(() => {
    t.open || (o(void 0), r({
      type: "CLOSE_MODAL"
    }));
  }, [t.open]);
  const {
    connected: n
  } = Jo();
  Le(() => {
    !n || (e == null ? void 0 : e.activeModal) !== "connect" || r({
      type: "CLOSE_MODAL"
    });
  }, [n, e]);
  const [i, o] = wt(), s = bt(() => i ? Ir(i) : void 0, [i, dn]), [a, f] = wt(!1), [p, d] = wt(!1), [y, v] = wt(!1), [w, I] = wt(!1);
  async function N(X) {
    const ne = dn.find((se) => se.id === X);
    if (!ne)
      return;
    d(!0), o(X);
    let ue = !1;
    try {
      ue = await ne.isAvailable();
    } catch {
      ue = !1;
    }
    v(ue), d(!1), ue && await k(ne);
  }
  async function k(X) {
    I(!1), f(!0);
    try {
      await X.connect(e.config.permissions, e.config.appInfo, e.config.gatewayConfig), window.postMessage({
        type: "connect_result",
        res: !0
      }), r({
        type: "CLOSE_MODAL"
      }), fo(X.id), r({
        type: "UPDATE_STRATEGY",
        payload: X.id
      });
    } catch {
      Y(), I(!0), r({
        type: "UPDATE_STRATEGY",
        payload: !1
      });
    }
    f(!1);
  }
  function M() {
    window.postMessage({
      type: "connect_result",
      res: !1
    }), r({
      type: "CLOSE_MODAL"
    });
  }
  const S = bs();
  function Y() {
    try {
      document.querySelectorAll(".arconnect_connect_overlay_extension_temporary").forEach((X) => X.remove());
    } catch {
    }
  }
  const [W, Q] = wt(!1);
  return Le(() => {
    (async () => {
      const X = navigator.brave && await navigator.brave.isBrave();
      Q(X);
    })();
  }, []), /* @__PURE__ */ Fe(Xs, {
    ...t.bindings,
    onClose: M,
    children: [/* @__PURE__ */ Me(wf, {
      onClose: M,
      children: /* @__PURE__ */ Fe(vr, {
        themed: !!i,
        onClick: () => {
          i && o(void 0);
        },
        children: [i && /* @__PURE__ */ Me(xw, {}), s ? s.name : "Connect wallet"]
      })
    }), !i && /* @__PURE__ */ Me(hw, {
      children: dn.map((X, ne) => /* @__PURE__ */ Me(Gv, {
        name: X.name,
        description: X.description,
        logo: `${S}/${X.logo}`,
        theme: X.theme,
        onClick: () => N(X.id)
      }, ne))
    }) || /* @__PURE__ */ Me(dw, {
      children: /* @__PURE__ */ Fe(pw, {
        children: [/* @__PURE__ */ Me(vf, {
          colorTheme: s == null ? void 0 : s.theme,
          children: /* @__PURE__ */ Me(yf, {
            src: `${S}/${s == null ? void 0 : s.logo}`,
            draggable: !1
          })
        }), y && /* @__PURE__ */ Fe(_n, {
          children: [/* @__PURE__ */ Fe(vr, {
            small: !0,
            children: ["Connecting to ", (s == null ? void 0 : s.name) || "", "..."]
          }), /* @__PURE__ */ Me(jr, {
            children: "Confirm connection request in the wallet popup window"
          }), (s == null ? void 0 : s.id) === "othent" && W && /* @__PURE__ */ Fe(yw, {
            children: ["You might need to ", /* @__PURE__ */ Me("b", {
              children: "disable Brave shields"
            }), " for this to work properly."]
          }), w && s && /* @__PURE__ */ Me(ur, {
            onClick: () => k(s),
            children: "Retry"
          })]
        }) || !p && /* @__PURE__ */ Fe(_n, {
          children: [
            /* @__PURE__ */ Fe(vr, {
              small: !0,
              children: [(s == null ? void 0 : s.name) || "", " is not available."]
            }),
            /* @__PURE__ */ Me(jr, {
              children: "If you don't have it yet, you can try to download it"
            }),
            // @ts-expect-error
            (s == null ? void 0 : s.url) && /* @__PURE__ */ Me(ur, {
              onClick: () => {
                window.open(s.url);
              },
              children: "Download"
            })
          ]
        }), (a || p) && /* @__PURE__ */ Me(_w, {})]
      })
    }), /* @__PURE__ */ Fe(rw, {
      children: [/* @__PURE__ */ Fe(zv, {
        children: [/* @__PURE__ */ Me(vr, {
          small: !0,
          children: "Don't have a wallet?"
        }), /* @__PURE__ */ Me(jr, {
          small: !0,
          children: "Click to learn more about the permaweb & wallets."
        })]
      }), /* @__PURE__ */ Me(ur, {
        onClick: () => window.open("https://arwiki.wiki/#/en/wallets"),
        children: "Get"
      })]
    })]
  });
}
const hw = /* @__PURE__ */ Ce("div")({
  name: "Apps",
  class: "a1osnke6",
  propsAsIs: !1
}), dw = /* @__PURE__ */ Ce("div")({
  name: "Connecting",
  class: "c15u83h7",
  propsAsIs: !1
}), pw = /* @__PURE__ */ Ce("div")({
  name: "WalletData",
  class: "w5r445t",
  propsAsIs: !1
}), mw = () => jr, gw = () => (t) => ({
  default: 14,
  minimal: 8,
  none: 0
})[t.theme.themeConfig.radius] + "px", yw = st(/* @__PURE__ */ Ce(mw())({
  name: "BraveParagraph",
  class: "bukrfi8",
  propsAsIs: !0,
  vars: {
    "bukrfi8-0": [gw()]
  }
})), vw = () => ow, ww = () => (t) => t.theme.primaryText, _w = st(/* @__PURE__ */ Ce(vw())({
  name: "ConnectLoading",
  class: "c13sms3",
  propsAsIs: !0,
  vars: {
    "c13sms3-0": [ww()]
  }
})), bw = () => ph, xw = /* @__PURE__ */ Ce(bw())({
  name: "BackButton",
  class: "b1r2gdr0",
  propsAsIs: !0
});
function Tw() {
  const t = Zs(), {
    state: e,
    dispatch: r
  } = xt();
  Le(() => {
    t.setOpen((e == null ? void 0 : e.activeModal) === "profile");
  }, [e == null ? void 0 : e.activeModal]), Le(() => {
    t.open || r({
      type: "CLOSE_MODAL"
    });
  }, [t.open, r]);
  function n() {
    r({
      type: "CLOSE_MODAL"
    });
  }
  const i = Qc(), o = tl(), s = bs(), {
    disconnect: a
  } = Jo(), f = Gt();
  return /* @__PURE__ */ Fe(Xs, {
    ...t.bindings,
    onClose: n,
    children: [/* @__PURE__ */ Me(wf, {
      onClose: n,
      children: /* @__PURE__ */ Me(vr, {
        children: "Profile"
      })
    }), /* @__PURE__ */ Fe(Aw, {
      children: [/* @__PURE__ */ Fe(Cw, {
        profilePicture: o == null ? void 0 : o.avatar,
        children: [!(o != null && o.avatar) && /* @__PURE__ */ Me(kw, {}), /* @__PURE__ */ Me(Iw, {
          strategyTheme: f == null ? void 0 : f.theme,
          children: /* @__PURE__ */ Me("img", {
            src: f != null && f.logo ? `${s}/${f.logo}` : "",
            alt: (f == null ? void 0 : f.name) || "active strategy logo",
            draggable: !1
          })
        })]
      }), /* @__PURE__ */ Fe(vr, {
        children: [(o == null ? void 0 : o.currentLabel) || ac((e == null ? void 0 : e.activeAddress) || "", 8), /* @__PURE__ */ Me(gh, {
          onClick: () => navigator.clipboard.writeText(e.activeAddress || "")
        })]
      }), /* @__PURE__ */ Fe(jr, {
        children: [i.toLocaleString(void 0, {
          maximumFractionDigits: 4
        }), " AR"]
      }), /* @__PURE__ */ Fe(ur, {
        onClick: a,
        children: [/* @__PURE__ */ Me(yh, {}), "Disconnect"]
      })]
    })]
  });
}
const Ew = () => (t) => ({
  default: 18,
  minimal: 10,
  none: 0
})[t.theme.themeConfig.radius] + "px", Aw = st(/* @__PURE__ */ Ce("div")({
  name: "ProfileData",
  class: "p1hjgol5",
  propsAsIs: !1,
  vars: {
    "p1hjgol5-0": [Ew()]
  }
})), Mw = () => (t) => ({
  default: "100%",
  minimal: "8px",
  none: "none"
})[t.theme.themeConfig.radius], Sw = () => (t) => t.theme.theme, Pw = () => (t) => t.profilePicture ? `background-image: url(${t.profilePicture});` : "", Cw = st(/* @__PURE__ */ Ce("div")({
  name: "ProfilePicture",
  class: "publs4f",
  propsAsIs: !1,
  vars: {
    "publs4f-0": [Mw()],
    "publs4f-1": [Sw()],
    "publs4f-2": [Pw()]
  }
})), Ow = () => (t) => t.strategyTheme || t.theme.theme, Rw = () => (t) => t.theme.background, Iw = st(/* @__PURE__ */ Ce("div")({
  name: "ActiveStrategy",
  class: "alzinag",
  propsAsIs: !1,
  vars: {
    "alzinag-0": [Ow()],
    "alzinag-1": [Rw()]
  }
})), Bw = () => lc, kw = /* @__PURE__ */ Ce(Bw())({
  name: "ProfileIcon",
  class: "p1qewrlg",
  propsAsIs: !0
});
function Dw(t = Wo, e) {
  switch (e.type) {
    case "OPEN_MODAL":
      return {
        ...t,
        activeModal: e.payload
      };
    case "CLOSE_MODAL":
      return {
        ...t,
        activeModal: !1
      };
    case "DISCONNECT":
      return {
        ...t,
        activeStrategy: !1,
        activeAddress: void 0,
        givenPermissions: []
      };
    case "UPDATE_STRATEGY":
      return {
        ...t,
        activeStrategy: e.payload
      };
    case "UPDATE_CONFIG":
      return {
        ...t,
        config: e.payload
      };
    case "UPDATE_ADDRESS":
      return {
        ...t,
        activeAddress: e.payload
      };
    case "UPDATE_PERMISSIONS":
      return {
        ...t,
        givenPermissions: e.payload
      };
  }
  return t;
}
var ko = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Uu = Object.getOwnPropertySymbols, Lw = Object.prototype.hasOwnProperty, Nw = Object.prototype.propertyIsEnumerable;
function Uw(t) {
  if (t == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(t);
}
function Fw() {
  try {
    if (!Object.assign)
      return !1;
    var t = new String("abc");
    if (t[5] = "de", Object.getOwnPropertyNames(t)[0] === "5")
      return !1;
    for (var e = {}, r = 0; r < 10; r++)
      e["_" + String.fromCharCode(r)] = r;
    var n = Object.getOwnPropertyNames(e).map(function(o) {
      return e[o];
    });
    if (n.join("") !== "0123456789")
      return !1;
    var i = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(o) {
      i[o] = o;
    }), Object.keys(Object.assign({}, i)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return !1;
  }
}
var _f = Fw() ? Object.assign : function(t, e) {
  for (var r, n = Uw(t), i, o = 1; o < arguments.length; o++) {
    r = Object(arguments[o]);
    for (var s in r)
      Lw.call(r, s) && (n[s] = r[s]);
    if (Uu) {
      i = Uu(r);
      for (var a = 0; a < i.length; a++)
        Nw.call(r, i[a]) && (n[i[a]] = r[i[a]]);
    }
  }
  return n;
};
const jw = /* @__PURE__ */ Pn(_f);
var to, Fu;
function Js() {
  if (Fu)
    return to;
  Fu = 1;
  var t = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return to = t, to;
}
var ro, ju;
function bf() {
  return ju || (ju = 1, ro = Function.call.bind(Object.prototype.hasOwnProperty)), ro;
}
var no, $u;
function $w() {
  if ($u)
    return no;
  $u = 1;
  var t = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = Js(), r = {}, n = bf();
    t = function(o) {
      var s = "Warning: " + o;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function i(o, s, a, f, p) {
    if (process.env.NODE_ENV !== "production") {
      for (var d in o)
        if (n(o, d)) {
          var y;
          try {
            if (typeof o[d] != "function") {
              var v = Error(
                (f || "React class") + ": " + a + " type `" + d + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[d] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw v.name = "Invariant Violation", v;
            }
            y = o[d](s, d, f, a, null, e);
          } catch (I) {
            y = I;
          }
          if (y && !(y instanceof Error) && t(
            (f || "React class") + ": type specification of " + a + " `" + d + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof y + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), y instanceof Error && !(y.message in r)) {
            r[y.message] = !0;
            var w = p ? p() : "";
            t(
              "Failed " + a + " type: " + y.message + (w ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (r = {});
  }, no = i, no;
}
var io, Vu;
function Vw() {
  if (Vu)
    return io;
  Vu = 1;
  var t = zo(), e = _f, r = Js(), n = bf(), i = $w(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(a) {
    var f = "Warning: " + a;
    typeof console < "u" && console.error(f);
    try {
      throw new Error(f);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return io = function(a, f) {
    var p = typeof Symbol == "function" && Symbol.iterator, d = "@@iterator";
    function y(l) {
      var x = l && (p && l[p] || l[d]);
      if (typeof x == "function")
        return x;
    }
    var v = "<<anonymous>>", w = {
      array: M("array"),
      bigint: M("bigint"),
      bool: M("boolean"),
      func: M("function"),
      number: M("number"),
      object: M("object"),
      string: M("string"),
      symbol: M("symbol"),
      any: S(),
      arrayOf: Y,
      element: W(),
      elementType: Q(),
      instanceOf: X,
      node: ie(),
      objectOf: ue,
      oneOf: ne,
      oneOfType: se,
      shape: c,
      exact: m
    };
    function I(l, x) {
      return l === x ? l !== 0 || 1 / l === 1 / x : l !== l && x !== x;
    }
    function N(l, x) {
      this.message = l, this.data = x && typeof x == "object" ? x : {}, this.stack = "";
    }
    N.prototype = Error.prototype;
    function k(l) {
      if (process.env.NODE_ENV !== "production")
        var x = {}, re = 0;
      function ae(ce, me, ye, xe, ve, b, R) {
        if (xe = xe || v, b = b || ye, R !== r) {
          if (f) {
            var E = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw E.name = "Invariant Violation", E;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var V = xe + ":" + ye;
            !x[V] && // Avoid spamming the console because they are often not actionable except for lib authors
            re < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + b + "` prop on `" + xe + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), x[V] = !0, re++);
          }
        }
        return me[ye] == null ? ce ? me[ye] === null ? new N("The " + ve + " `" + b + "` is marked as required " + ("in `" + xe + "`, but its value is `null`.")) : new N("The " + ve + " `" + b + "` is marked as required in " + ("`" + xe + "`, but its value is `undefined`.")) : null : l(me, ye, xe, ve, b);
      }
      var G = ae.bind(null, !1);
      return G.isRequired = ae.bind(null, !0), G;
    }
    function M(l) {
      function x(re, ae, G, ce, me, ye) {
        var xe = re[ae], ve = C(xe);
        if (ve !== l) {
          var b = L(xe);
          return new N(
            "Invalid " + ce + " `" + me + "` of type " + ("`" + b + "` supplied to `" + G + "`, expected ") + ("`" + l + "`."),
            { expectedType: l }
          );
        }
        return null;
      }
      return k(x);
    }
    function S() {
      return k(s);
    }
    function Y(l) {
      function x(re, ae, G, ce, me) {
        if (typeof l != "function")
          return new N("Property `" + me + "` of component `" + G + "` has invalid PropType notation inside arrayOf.");
        var ye = re[ae];
        if (!Array.isArray(ye)) {
          var xe = C(ye);
          return new N("Invalid " + ce + " `" + me + "` of type " + ("`" + xe + "` supplied to `" + G + "`, expected an array."));
        }
        for (var ve = 0; ve < ye.length; ve++) {
          var b = l(ye, ve, G, ce, me + "[" + ve + "]", r);
          if (b instanceof Error)
            return b;
        }
        return null;
      }
      return k(x);
    }
    function W() {
      function l(x, re, ae, G, ce) {
        var me = x[re];
        if (!a(me)) {
          var ye = C(me);
          return new N("Invalid " + G + " `" + ce + "` of type " + ("`" + ye + "` supplied to `" + ae + "`, expected a single ReactElement."));
        }
        return null;
      }
      return k(l);
    }
    function Q() {
      function l(x, re, ae, G, ce) {
        var me = x[re];
        if (!t.isValidElementType(me)) {
          var ye = C(me);
          return new N("Invalid " + G + " `" + ce + "` of type " + ("`" + ye + "` supplied to `" + ae + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return k(l);
    }
    function X(l) {
      function x(re, ae, G, ce, me) {
        if (!(re[ae] instanceof l)) {
          var ye = l.name || v, xe = P(re[ae]);
          return new N("Invalid " + ce + " `" + me + "` of type " + ("`" + xe + "` supplied to `" + G + "`, expected ") + ("instance of `" + ye + "`."));
        }
        return null;
      }
      return k(x);
    }
    function ne(l) {
      if (!Array.isArray(l))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), s;
      function x(re, ae, G, ce, me) {
        for (var ye = re[ae], xe = 0; xe < l.length; xe++)
          if (I(ye, l[xe]))
            return null;
        var ve = JSON.stringify(l, function(R, E) {
          var V = L(E);
          return V === "symbol" ? String(E) : E;
        });
        return new N("Invalid " + ce + " `" + me + "` of value `" + String(ye) + "` " + ("supplied to `" + G + "`, expected one of " + ve + "."));
      }
      return k(x);
    }
    function ue(l) {
      function x(re, ae, G, ce, me) {
        if (typeof l != "function")
          return new N("Property `" + me + "` of component `" + G + "` has invalid PropType notation inside objectOf.");
        var ye = re[ae], xe = C(ye);
        if (xe !== "object")
          return new N("Invalid " + ce + " `" + me + "` of type " + ("`" + xe + "` supplied to `" + G + "`, expected an object."));
        for (var ve in ye)
          if (n(ye, ve)) {
            var b = l(ye, ve, G, ce, me + "." + ve, r);
            if (b instanceof Error)
              return b;
          }
        return null;
      }
      return k(x);
    }
    function se(l) {
      if (!Array.isArray(l))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var x = 0; x < l.length; x++) {
        var re = l[x];
        if (typeof re != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + H(re) + " at index " + x + "."
          ), s;
      }
      function ae(G, ce, me, ye, xe) {
        for (var ve = [], b = 0; b < l.length; b++) {
          var R = l[b], E = R(G, ce, me, ye, xe, r);
          if (E == null)
            return null;
          E.data && n(E.data, "expectedType") && ve.push(E.data.expectedType);
        }
        var V = ve.length > 0 ? ", expected one of type [" + ve.join(", ") + "]" : "";
        return new N("Invalid " + ye + " `" + xe + "` supplied to " + ("`" + me + "`" + V + "."));
      }
      return k(ae);
    }
    function ie() {
      function l(x, re, ae, G, ce) {
        return _(x[re]) ? null : new N("Invalid " + G + " `" + ce + "` supplied to " + ("`" + ae + "`, expected a ReactNode."));
      }
      return k(l);
    }
    function O(l, x, re, ae, G) {
      return new N(
        (l || "React class") + ": " + x + " type `" + re + "." + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + G + "`."
      );
    }
    function c(l) {
      function x(re, ae, G, ce, me) {
        var ye = re[ae], xe = C(ye);
        if (xe !== "object")
          return new N("Invalid " + ce + " `" + me + "` of type `" + xe + "` " + ("supplied to `" + G + "`, expected `object`."));
        for (var ve in l) {
          var b = l[ve];
          if (typeof b != "function")
            return O(G, ce, me, ve, L(b));
          var R = b(ye, ve, G, ce, me + "." + ve, r);
          if (R)
            return R;
        }
        return null;
      }
      return k(x);
    }
    function m(l) {
      function x(re, ae, G, ce, me) {
        var ye = re[ae], xe = C(ye);
        if (xe !== "object")
          return new N("Invalid " + ce + " `" + me + "` of type `" + xe + "` " + ("supplied to `" + G + "`, expected `object`."));
        var ve = e({}, re[ae], l);
        for (var b in ve) {
          var R = l[b];
          if (n(l, b) && typeof R != "function")
            return O(G, ce, me, b, L(R));
          if (!R)
            return new N(
              "Invalid " + ce + " `" + me + "` key `" + b + "` supplied to `" + G + "`.\nBad object: " + JSON.stringify(re[ae], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(l), null, "  ")
            );
          var E = R(ye, b, G, ce, me + "." + b, r);
          if (E)
            return E;
        }
        return null;
      }
      return k(x);
    }
    function _(l) {
      switch (typeof l) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !l;
        case "object":
          if (Array.isArray(l))
            return l.every(_);
          if (l === null || a(l))
            return !0;
          var x = y(l);
          if (x) {
            var re = x.call(l), ae;
            if (x !== l.entries) {
              for (; !(ae = re.next()).done; )
                if (!_(ae.value))
                  return !1;
            } else
              for (; !(ae = re.next()).done; ) {
                var G = ae.value;
                if (G && !_(G[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function T(l, x) {
      return l === "symbol" ? !0 : x ? x["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && x instanceof Symbol : !1;
    }
    function C(l) {
      var x = typeof l;
      return Array.isArray(l) ? "array" : l instanceof RegExp ? "object" : T(x, l) ? "symbol" : x;
    }
    function L(l) {
      if (typeof l > "u" || l === null)
        return "" + l;
      var x = C(l);
      if (x === "object") {
        if (l instanceof Date)
          return "date";
        if (l instanceof RegExp)
          return "regexp";
      }
      return x;
    }
    function H(l) {
      var x = L(l);
      switch (x) {
        case "array":
        case "object":
          return "an " + x;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + x;
        default:
          return x;
      }
    }
    function P(l) {
      return !l.constructor || !l.constructor.name ? v : l.constructor.name;
    }
    return w.checkPropTypes = i, w.resetWarningCache = i.resetWarningCache, w.PropTypes = w, w;
  }, io;
}
var oo, qu;
function qw() {
  if (qu)
    return oo;
  qu = 1;
  var t = Js();
  function e() {
  }
  function r() {
  }
  return r.resetWarningCache = e, oo = function() {
    function n(s, a, f, p, d, y) {
      if (y !== t) {
        var v = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw v.name = "Invariant Violation", v;
      }
    }
    n.isRequired = n;
    function i() {
      return n;
    }
    var o = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: i,
      element: n,
      elementType: n,
      instanceOf: i,
      node: n,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: r,
      resetWarningCache: e
    };
    return o.PropTypes = o, o;
  }, oo;
}
if (process.env.NODE_ENV !== "production") {
  var Ww = zo(), Hw = !0;
  ko.exports = Vw()(Ww.isElement, Hw);
} else
  ko.exports = qw()();
var Kw = ko.exports;
const ze = /* @__PURE__ */ Pn(Kw);
function zw(t) {
  return t && typeof t == "object" && "default" in t ? t.default : t;
}
var xf = ht, Gw = zw(xf);
function Wu(t, e, r) {
  return e in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function Yw(t, e) {
  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
}
var Xw = !!(typeof window < "u" && window.document && window.document.createElement);
function Zw(t, e, r) {
  if (typeof t != "function")
    throw new Error("Expected reducePropsToState to be a function.");
  if (typeof e != "function")
    throw new Error("Expected handleStateChangeOnClient to be a function.");
  if (typeof r < "u" && typeof r != "function")
    throw new Error("Expected mapStateOnServer to either be undefined or a function.");
  function n(i) {
    return i.displayName || i.name || "Component";
  }
  return function(o) {
    if (typeof o != "function")
      throw new Error("Expected WrappedComponent to be a React component.");
    var s = [], a;
    function f() {
      a = t(s.map(function(d) {
        return d.props;
      })), p.canUseDOM ? e(a) : r && (a = r(a));
    }
    var p = /* @__PURE__ */ function(d) {
      Yw(y, d);
      function y() {
        return d.apply(this, arguments) || this;
      }
      y.peek = function() {
        return a;
      }, y.rewind = function() {
        if (y.canUseDOM)
          throw new Error("You may only call rewind() on the server. Call peek() to read the current state.");
        var I = a;
        return a = void 0, s = [], I;
      };
      var v = y.prototype;
      return v.UNSAFE_componentWillMount = function() {
        s.push(this), f();
      }, v.componentDidUpdate = function() {
        f();
      }, v.componentWillUnmount = function() {
        var I = s.indexOf(this);
        s.splice(I, 1), f();
      }, v.render = function() {
        return Gw.createElement(o, this.props);
      }, y;
    }(xf.PureComponent);
    return Wu(p, "displayName", "SideEffect(" + n(o) + ")"), Wu(p, "canUseDOM", Xw), p;
  };
}
var Jw = Zw;
const Qw = /* @__PURE__ */ Pn(Jw);
var e1 = typeof Element < "u", t1 = typeof Map == "function", r1 = typeof Set == "function", n1 = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function Zn(t, e) {
  if (t === e)
    return !0;
  if (t && e && typeof t == "object" && typeof e == "object") {
    if (t.constructor !== e.constructor)
      return !1;
    var r, n, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != e.length)
        return !1;
      for (n = r; n-- !== 0; )
        if (!Zn(t[n], e[n]))
          return !1;
      return !0;
    }
    var o;
    if (t1 && t instanceof Map && e instanceof Map) {
      if (t.size !== e.size)
        return !1;
      for (o = t.entries(); !(n = o.next()).done; )
        if (!e.has(n.value[0]))
          return !1;
      for (o = t.entries(); !(n = o.next()).done; )
        if (!Zn(n.value[1], e.get(n.value[0])))
          return !1;
      return !0;
    }
    if (r1 && t instanceof Set && e instanceof Set) {
      if (t.size !== e.size)
        return !1;
      for (o = t.entries(); !(n = o.next()).done; )
        if (!e.has(n.value[0]))
          return !1;
      return !0;
    }
    if (n1 && ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) {
      if (r = t.length, r != e.length)
        return !1;
      for (n = r; n-- !== 0; )
        if (t[n] !== e[n])
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === e.source && t.flags === e.flags;
    if (t.valueOf !== Object.prototype.valueOf && typeof t.valueOf == "function" && typeof e.valueOf == "function")
      return t.valueOf() === e.valueOf();
    if (t.toString !== Object.prototype.toString && typeof t.toString == "function" && typeof e.toString == "function")
      return t.toString() === e.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(e).length)
      return !1;
    for (n = r; n-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(e, i[n]))
        return !1;
    if (e1 && t instanceof Element)
      return !1;
    for (n = r; n-- !== 0; )
      if (!((i[n] === "_owner" || i[n] === "__v" || i[n] === "__o") && t.$$typeof) && !Zn(t[i[n]], e[i[n]]))
        return !1;
    return !0;
  }
  return t !== t && e !== e;
}
var i1 = function(e, r) {
  try {
    return Zn(e, r);
  } catch (n) {
    if ((n.message || "").match(/stack|recursion/i))
      return console.warn("react-fast-compare cannot handle circular refs"), !1;
    throw n;
  }
};
const o1 = /* @__PURE__ */ Pn(i1);
var br = {
  BODY: "bodyAttributes",
  HTML: "htmlAttributes",
  TITLE: "titleAttributes"
}, Pe = {
  BASE: "base",
  BODY: "body",
  HEAD: "head",
  HTML: "html",
  LINK: "link",
  META: "meta",
  NOSCRIPT: "noscript",
  SCRIPT: "script",
  STYLE: "style",
  TITLE: "title"
}, Hu = Object.keys(Pe).map(function(t) {
  return Pe[t];
}), Ge = {
  CHARSET: "charset",
  CSS_TEXT: "cssText",
  HREF: "href",
  HTTPEQUIV: "http-equiv",
  INNER_HTML: "innerHTML",
  ITEM_PROP: "itemprop",
  NAME: "name",
  PROPERTY: "property",
  REL: "rel",
  SRC: "src",
  TARGET: "target"
}, fi = {
  accesskey: "accessKey",
  charset: "charSet",
  class: "className",
  contenteditable: "contentEditable",
  contextmenu: "contextMenu",
  "http-equiv": "httpEquiv",
  itemprop: "itemProp",
  tabindex: "tabIndex"
}, An = {
  DEFAULT_TITLE: "defaultTitle",
  DEFER: "defer",
  ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
  ON_CHANGE_CLIENT_STATE: "onChangeClientState",
  TITLE_TEMPLATE: "titleTemplate"
}, s1 = Object.keys(fi).reduce(function(t, e) {
  return t[fi[e]] = e, t;
}, {}), a1 = [Pe.NOSCRIPT, Pe.SCRIPT, Pe.STYLE], $t = "data-react-helmet", u1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
  return typeof t;
} : function(t) {
  return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
}, c1 = function(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}, l1 = function() {
  function t(e, r) {
    for (var n = 0; n < r.length; n++) {
      var i = r[n];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
    }
  }
  return function(e, r, n) {
    return r && t(e.prototype, r), n && t(e, n), e;
  };
}(), At = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e];
    for (var n in r)
      Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
  }
  return t;
}, f1 = function(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}, Ku = function(t, e) {
  var r = {};
  for (var n in t)
    e.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
  return r;
}, h1 = function(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}, Do = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return r === !1 ? String(e) : String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}, d1 = function(e) {
  var r = $r(e, Pe.TITLE), n = $r(e, An.TITLE_TEMPLATE);
  if (n && r)
    return n.replace(/%s/g, function() {
      return Array.isArray(r) ? r.join("") : r;
    });
  var i = $r(e, An.DEFAULT_TITLE);
  return r || i || void 0;
}, p1 = function(e) {
  return $r(e, An.ON_CHANGE_CLIENT_STATE) || function() {
  };
}, so = function(e, r) {
  return r.filter(function(n) {
    return typeof n[e] < "u";
  }).map(function(n) {
    return n[e];
  }).reduce(function(n, i) {
    return At({}, n, i);
  }, {});
}, m1 = function(e, r) {
  return r.filter(function(n) {
    return typeof n[Pe.BASE] < "u";
  }).map(function(n) {
    return n[Pe.BASE];
  }).reverse().reduce(function(n, i) {
    if (!n.length)
      for (var o = Object.keys(i), s = 0; s < o.length; s++) {
        var a = o[s], f = a.toLowerCase();
        if (e.indexOf(f) !== -1 && i[f])
          return n.concat(i);
      }
    return n;
  }, []);
}, un = function(e, r, n) {
  var i = {};
  return n.filter(function(o) {
    return Array.isArray(o[e]) ? !0 : (typeof o[e] < "u" && No("Helmet: " + e + ' should be of type "Array". Instead found type "' + u1(o[e]) + '"'), !1);
  }).map(function(o) {
    return o[e];
  }).reverse().reduce(function(o, s) {
    var a = {};
    s.filter(function(v) {
      for (var w = void 0, I = Object.keys(v), N = 0; N < I.length; N++) {
        var k = I[N], M = k.toLowerCase();
        r.indexOf(M) !== -1 && !(w === Ge.REL && v[w].toLowerCase() === "canonical") && !(M === Ge.REL && v[M].toLowerCase() === "stylesheet") && (w = M), r.indexOf(k) !== -1 && (k === Ge.INNER_HTML || k === Ge.CSS_TEXT || k === Ge.ITEM_PROP) && (w = k);
      }
      if (!w || !v[w])
        return !1;
      var S = v[w].toLowerCase();
      return i[w] || (i[w] = {}), a[w] || (a[w] = {}), i[w][S] ? !1 : (a[w][S] = !0, !0);
    }).reverse().forEach(function(v) {
      return o.push(v);
    });
    for (var f = Object.keys(a), p = 0; p < f.length; p++) {
      var d = f[p], y = jw({}, i[d], a[d]);
      i[d] = y;
    }
    return o;
  }, []).reverse();
}, $r = function(e, r) {
  for (var n = e.length - 1; n >= 0; n--) {
    var i = e[n];
    if (i.hasOwnProperty(r))
      return i[r];
  }
  return null;
}, g1 = function(e) {
  return {
    baseTag: m1([Ge.HREF, Ge.TARGET], e),
    bodyAttributes: so(br.BODY, e),
    defer: $r(e, An.DEFER),
    encode: $r(e, An.ENCODE_SPECIAL_CHARACTERS),
    htmlAttributes: so(br.HTML, e),
    linkTags: un(Pe.LINK, [Ge.REL, Ge.HREF], e),
    metaTags: un(Pe.META, [Ge.NAME, Ge.CHARSET, Ge.HTTPEQUIV, Ge.PROPERTY, Ge.ITEM_PROP], e),
    noscriptTags: un(Pe.NOSCRIPT, [Ge.INNER_HTML], e),
    onChangeClientState: p1(e),
    scriptTags: un(Pe.SCRIPT, [Ge.SRC, Ge.INNER_HTML], e),
    styleTags: un(Pe.STYLE, [Ge.CSS_TEXT], e),
    title: d1(e),
    titleAttributes: so(br.TITLE, e)
  };
}, Lo = function() {
  var t = Date.now();
  return function(e) {
    var r = Date.now();
    r - t > 16 ? (t = r, e(r)) : setTimeout(function() {
      Lo(e);
    }, 0);
  };
}(), zu = function(e) {
  return clearTimeout(e);
}, y1 = typeof window < "u" ? window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || Lo : global.requestAnimationFrame || Lo, v1 = typeof window < "u" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || zu : global.cancelAnimationFrame || zu, No = function(e) {
  return console && typeof console.warn == "function" && console.warn(e);
}, cn = null, w1 = function(e) {
  cn && v1(cn), e.defer ? cn = y1(function() {
    Gu(e, function() {
      cn = null;
    });
  }) : (Gu(e), cn = null);
}, Gu = function(e, r) {
  var n = e.baseTag, i = e.bodyAttributes, o = e.htmlAttributes, s = e.linkTags, a = e.metaTags, f = e.noscriptTags, p = e.onChangeClientState, d = e.scriptTags, y = e.styleTags, v = e.title, w = e.titleAttributes;
  Uo(Pe.BODY, i), Uo(Pe.HTML, o), _1(v, w);
  var I = {
    baseTag: Or(Pe.BASE, n),
    linkTags: Or(Pe.LINK, s),
    metaTags: Or(Pe.META, a),
    noscriptTags: Or(Pe.NOSCRIPT, f),
    scriptTags: Or(Pe.SCRIPT, d),
    styleTags: Or(Pe.STYLE, y)
  }, N = {}, k = {};
  Object.keys(I).forEach(function(M) {
    var S = I[M], Y = S.newTags, W = S.oldTags;
    Y.length && (N[M] = Y), W.length && (k[M] = I[M].oldTags);
  }), r && r(), p(e, N, k);
}, Tf = function(e) {
  return Array.isArray(e) ? e.join("") : e;
}, _1 = function(e, r) {
  typeof e < "u" && document.title !== e && (document.title = Tf(e)), Uo(Pe.TITLE, r);
}, Uo = function(e, r) {
  var n = document.getElementsByTagName(e)[0];
  if (n) {
    for (var i = n.getAttribute($t), o = i ? i.split(",") : [], s = [].concat(o), a = Object.keys(r), f = 0; f < a.length; f++) {
      var p = a[f], d = r[p] || "";
      n.getAttribute(p) !== d && n.setAttribute(p, d), o.indexOf(p) === -1 && o.push(p);
      var y = s.indexOf(p);
      y !== -1 && s.splice(y, 1);
    }
    for (var v = s.length - 1; v >= 0; v--)
      n.removeAttribute(s[v]);
    o.length === s.length ? n.removeAttribute($t) : n.getAttribute($t) !== a.join(",") && n.setAttribute($t, a.join(","));
  }
}, Or = function(e, r) {
  var n = document.head || document.querySelector(Pe.HEAD), i = n.querySelectorAll(e + "[" + $t + "]"), o = Array.prototype.slice.call(i), s = [], a = void 0;
  return r && r.length && r.forEach(function(f) {
    var p = document.createElement(e);
    for (var d in f)
      if (f.hasOwnProperty(d))
        if (d === Ge.INNER_HTML)
          p.innerHTML = f.innerHTML;
        else if (d === Ge.CSS_TEXT)
          p.styleSheet ? p.styleSheet.cssText = f.cssText : p.appendChild(document.createTextNode(f.cssText));
        else {
          var y = typeof f[d] > "u" ? "" : f[d];
          p.setAttribute(d, y);
        }
    p.setAttribute($t, "true"), o.some(function(v, w) {
      return a = w, p.isEqualNode(v);
    }) ? o.splice(a, 1) : s.push(p);
  }), o.forEach(function(f) {
    return f.parentNode.removeChild(f);
  }), s.forEach(function(f) {
    return n.appendChild(f);
  }), {
    oldTags: o,
    newTags: s
  };
}, Ef = function(e) {
  return Object.keys(e).reduce(function(r, n) {
    var i = typeof e[n] < "u" ? n + '="' + e[n] + '"' : "" + n;
    return r ? r + " " + i : i;
  }, "");
}, b1 = function(e, r, n, i) {
  var o = Ef(n), s = Tf(r);
  return o ? "<" + e + " " + $t + '="true" ' + o + ">" + Do(s, i) + "</" + e + ">" : "<" + e + " " + $t + '="true">' + Do(s, i) + "</" + e + ">";
}, x1 = function(e, r, n) {
  return r.reduce(function(i, o) {
    var s = Object.keys(o).filter(function(p) {
      return !(p === Ge.INNER_HTML || p === Ge.CSS_TEXT);
    }).reduce(function(p, d) {
      var y = typeof o[d] > "u" ? d : d + '="' + Do(o[d], n) + '"';
      return p ? p + " " + y : y;
    }, ""), a = o.innerHTML || o.cssText || "", f = a1.indexOf(e) === -1;
    return i + "<" + e + " " + $t + '="true" ' + s + (f ? "/>" : ">" + a + "</" + e + ">");
  }, "");
}, Af = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Object.keys(e).reduce(function(n, i) {
    return n[fi[i] || i] = e[i], n;
  }, r);
}, T1 = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Object.keys(e).reduce(function(n, i) {
    return n[s1[i] || i] = e[i], n;
  }, r);
}, E1 = function(e, r, n) {
  var i, o = (i = {
    key: r
  }, i[$t] = !0, i), s = Af(n, o);
  return [ht.createElement(Pe.TITLE, s, r)];
}, A1 = function(e, r) {
  return r.map(function(n, i) {
    var o, s = (o = {
      key: i
    }, o[$t] = !0, o);
    return Object.keys(n).forEach(function(a) {
      var f = fi[a] || a;
      if (f === Ge.INNER_HTML || f === Ge.CSS_TEXT) {
        var p = n.innerHTML || n.cssText;
        s.dangerouslySetInnerHTML = { __html: p };
      } else
        s[f] = n[a];
    }), ht.createElement(e, s);
  });
}, Zt = function(e, r, n) {
  switch (e) {
    case Pe.TITLE:
      return {
        toComponent: function() {
          return E1(e, r.title, r.titleAttributes);
        },
        toString: function() {
          return b1(e, r.title, r.titleAttributes, n);
        }
      };
    case br.BODY:
    case br.HTML:
      return {
        toComponent: function() {
          return Af(r);
        },
        toString: function() {
          return Ef(r);
        }
      };
    default:
      return {
        toComponent: function() {
          return A1(e, r);
        },
        toString: function() {
          return x1(e, r, n);
        }
      };
  }
}, Mf = function(e) {
  var r = e.baseTag, n = e.bodyAttributes, i = e.encode, o = e.htmlAttributes, s = e.linkTags, a = e.metaTags, f = e.noscriptTags, p = e.scriptTags, d = e.styleTags, y = e.title, v = y === void 0 ? "" : y, w = e.titleAttributes;
  return {
    base: Zt(Pe.BASE, r, i),
    bodyAttributes: Zt(br.BODY, n, i),
    htmlAttributes: Zt(br.HTML, o, i),
    link: Zt(Pe.LINK, s, i),
    meta: Zt(Pe.META, a, i),
    noscript: Zt(Pe.NOSCRIPT, f, i),
    script: Zt(Pe.SCRIPT, p, i),
    style: Zt(Pe.STYLE, d, i),
    title: Zt(Pe.TITLE, { title: v, titleAttributes: w }, i)
  };
}, M1 = function(e) {
  var r, n;
  return n = r = function(i) {
    f1(o, i);
    function o() {
      return c1(this, o), h1(this, i.apply(this, arguments));
    }
    return o.prototype.shouldComponentUpdate = function(a) {
      return !o1(this.props, a);
    }, o.prototype.mapNestedChildrenToProps = function(a, f) {
      if (!f)
        return null;
      switch (a.type) {
        case Pe.SCRIPT:
        case Pe.NOSCRIPT:
          return {
            innerHTML: f
          };
        case Pe.STYLE:
          return {
            cssText: f
          };
      }
      throw new Error("<" + a.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.");
    }, o.prototype.flattenArrayTypeChildren = function(a) {
      var f, p = a.child, d = a.arrayTypeChildren, y = a.newChildProps, v = a.nestedChildren;
      return At({}, d, (f = {}, f[p.type] = [].concat(d[p.type] || [], [At({}, y, this.mapNestedChildrenToProps(p, v))]), f));
    }, o.prototype.mapObjectTypeChildren = function(a) {
      var f, p, d = a.child, y = a.newProps, v = a.newChildProps, w = a.nestedChildren;
      switch (d.type) {
        case Pe.TITLE:
          return At({}, y, (f = {}, f[d.type] = w, f.titleAttributes = At({}, v), f));
        case Pe.BODY:
          return At({}, y, {
            bodyAttributes: At({}, v)
          });
        case Pe.HTML:
          return At({}, y, {
            htmlAttributes: At({}, v)
          });
      }
      return At({}, y, (p = {}, p[d.type] = At({}, v), p));
    }, o.prototype.mapArrayTypeChildrenToProps = function(a, f) {
      var p = At({}, f);
      return Object.keys(a).forEach(function(d) {
        var y;
        p = At({}, p, (y = {}, y[d] = a[d], y));
      }), p;
    }, o.prototype.warnOnInvalidChildren = function(a, f) {
      if (process.env.NODE_ENV !== "production") {
        if (!Hu.some(function(p) {
          return a.type === p;
        }))
          return typeof a.type == "function" ? No("You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.") : No("Only elements types " + Hu.join(", ") + " are allowed. Helmet does not support rendering <" + a.type + "> elements. Refer to our API for more information.");
        if (f && typeof f != "string" && (!Array.isArray(f) || f.some(function(p) {
          return typeof p != "string";
        })))
          throw new Error("Helmet expects a string as a child of <" + a.type + ">. Did you forget to wrap your children in braces? ( <" + a.type + ">{``}</" + a.type + "> ) Refer to our API for more information.");
      }
      return !0;
    }, o.prototype.mapChildrenToProps = function(a, f) {
      var p = this, d = {};
      return ht.Children.forEach(a, function(y) {
        if (!(!y || !y.props)) {
          var v = y.props, w = v.children, I = Ku(v, ["children"]), N = T1(I);
          switch (p.warnOnInvalidChildren(y, w), y.type) {
            case Pe.LINK:
            case Pe.META:
            case Pe.NOSCRIPT:
            case Pe.SCRIPT:
            case Pe.STYLE:
              d = p.flattenArrayTypeChildren({
                child: y,
                arrayTypeChildren: d,
                newChildProps: N,
                nestedChildren: w
              });
              break;
            default:
              f = p.mapObjectTypeChildren({
                child: y,
                newProps: f,
                newChildProps: N,
                nestedChildren: w
              });
              break;
          }
        }
      }), f = this.mapArrayTypeChildrenToProps(d, f), f;
    }, o.prototype.render = function() {
      var a = this.props, f = a.children, p = Ku(a, ["children"]), d = At({}, p);
      return f && (d = this.mapChildrenToProps(f, d)), ht.createElement(e, d);
    }, l1(o, null, [{
      key: "canUseDOM",
      // Component.peek comes from react-side-effect:
      // For testing, you may use a static peek() method available on the returned component.
      // It lets you get the current state without resetting the mounted instance stack.
      // Don’t use it for anything other than testing.
      /**
       * @param {Object} base: {"target": "_blank", "href": "http://mysite.com/"}
       * @param {Object} bodyAttributes: {"className": "root"}
       * @param {String} defaultTitle: "Default Title"
       * @param {Boolean} defer: true
       * @param {Boolean} encodeSpecialCharacters: true
       * @param {Object} htmlAttributes: {"lang": "en", "amp": undefined}
       * @param {Array} link: [{"rel": "canonical", "href": "http://mysite.com/example"}]
       * @param {Array} meta: [{"name": "description", "content": "Test description"}]
       * @param {Array} noscript: [{"innerHTML": "<img src='http://mysite.com/js/test.js'"}]
       * @param {Function} onChangeClientState: "(newState) => console.log(newState)"
       * @param {Array} script: [{"type": "text/javascript", "src": "http://mysite.com/js/test.js"}]
       * @param {Array} style: [{"type": "text/css", "cssText": "div { display: block; color: blue; }"}]
       * @param {String} title: "Title"
       * @param {Object} titleAttributes: {"itemprop": "name"}
       * @param {String} titleTemplate: "MySite.com - %s"
       */
      set: function(a) {
        e.canUseDOM = a;
      }
    }]), o;
  }(ht.Component), r.propTypes = {
    base: ze.object,
    bodyAttributes: ze.object,
    children: ze.oneOfType([ze.arrayOf(ze.node), ze.node]),
    defaultTitle: ze.string,
    defer: ze.bool,
    encodeSpecialCharacters: ze.bool,
    htmlAttributes: ze.object,
    link: ze.arrayOf(ze.object),
    meta: ze.arrayOf(ze.object),
    noscript: ze.arrayOf(ze.object),
    onChangeClientState: ze.func,
    script: ze.arrayOf(ze.object),
    style: ze.arrayOf(ze.object),
    title: ze.string,
    titleAttributes: ze.object,
    titleTemplate: ze.string
  }, r.defaultProps = {
    defer: !0,
    encodeSpecialCharacters: !0
  }, r.peek = e.peek, r.rewind = function() {
    var i = e.rewind();
    return i || (i = Mf({
      baseTag: [],
      bodyAttributes: {},
      encodeSpecialCharacters: !0,
      htmlAttributes: {},
      linkTags: [],
      metaTags: [],
      noscriptTags: [],
      scriptTags: [],
      styleTags: [],
      title: "",
      titleAttributes: {}
    })), i;
  }, n;
}, S1 = function() {
  return null;
}, P1 = Qw(g1, w1, Mf)(S1), Fo = M1(P1);
Fo.renderStatic = Fo.rewind;
function V1({
  children: t,
  theme: e = Yu,
  config: r = O1
}) {
  const [n, i] = Df(Dw, {
    ...Wo,
    config: r
  });
  Le(() => {
    i({
      type: "UPDATE_CONFIG",
      payload: r
    });
  }, [r]);
  const o = bt(
    () => ({
      ...Yu,
      ...e
    }),
    [e]
  );
  return /* @__PURE__ */ Me(cc.Provider, { value: { state: n, dispatch: i }, children: /* @__PURE__ */ Me(
    Xh,
    {
      theme: {
        ...o.displayTheme === "light" ? gc : Gh,
        displayTheme: o.displayTheme || "light",
        theme: uc(o.accent),
        themeConfig: o
      },
      children: /* @__PURE__ */ Fe(C1, { children: [
        /* @__PURE__ */ Fe(Fo, { children: [
          /* @__PURE__ */ Me("link", { rel: "preconnect", href: "https://fonts.googleapis.com" }),
          /* @__PURE__ */ Me(
            "link",
            {
              rel: "preconnect",
              href: "https://fonts.gstatic.com",
              crossOrigin: ""
            }
          ),
          /* @__PURE__ */ Me(
            "link",
            {
              href: "https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap",
              rel: "stylesheet"
            }
          )
        ] }),
        t,
        /* @__PURE__ */ Me(fw, {}),
        /* @__PURE__ */ Me(Tw, {}),
        /* @__PURE__ */ Me(Cv, {})
      ] })
    }
  ) });
}
const C1 = ({ children: t }) => (Jh(), uh(), /* @__PURE__ */ Me(_n, { children: t })), Yu = {
  displayTheme: "light",
  accent: {
    r: 0,
    g: 0,
    b: 0
  },
  titleHighlight: {
    r: 0,
    g: 122,
    b: 255
  },
  radius: "default",
  font: {
    fontFamily: "Manrope"
  }
}, O1 = {
  permissions: ["ACCESS_ADDRESS", "ACCESS_ALL_ADDRESSES"],
  ensurePermissions: !1
};
export {
  V1 as ArweaveWalletKit,
  j1 as ConnectButton,
  di as useActiveAddress,
  ch as useAddresses,
  D1 as useApi,
  Jo as useConnection,
  Zh as usePermissions,
  td as useProfileModal,
  L1 as usePublicKey,
  ah as useStrategy,
  N1 as useWalletNames
};
