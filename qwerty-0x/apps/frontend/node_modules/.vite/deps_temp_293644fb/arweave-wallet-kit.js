import {
  require_react
} from "./chunk-QBXGYTN6.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS,
  __toESM
} from "./chunk-4B2QHNJT.js";

// ../../node_modules/extend/index.js
var require_extend = __commonJS({
  "../../node_modules/extend/index.js"(exports2, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray2 = function isArray3(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject3 = function isPlainObject4(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name2) {
      if (name2 === "__proto__") {
        if (!hasOwn.call(obj, name2)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name2).value;
        }
      }
      return obj[name2];
    };
    module2.exports = function extend3() {
      var options, name2, src2, copy, copyIsArray, clone;
      var target = arguments[0];
      var i2 = 1;
      var length2 = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i2 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i2 < length2; ++i2) {
        options = arguments[i2];
        if (options != null) {
          for (name2 in options) {
            src2 = getProperty(target, name2);
            copy = getProperty(options, name2);
            if (target !== copy) {
              if (deep && copy && (isPlainObject3(copy) || (copyIsArray = isArray2(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src2 && isArray2(src2) ? src2 : [];
                } else {
                  clone = src2 && isPlainObject3(src2) ? src2 : {};
                }
                setProperty(target, { name: name2, newValue: extend3(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name: name2, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// ../../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray2;
    exports2.fromByteArray = fromByteArray2;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code2.length; i2 < len; ++i2) {
      lookup[i2] = code2[i2];
      revLookup[code2.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray2(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "../../node_modules/@noble/hashes/_assert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.anumber = anumber;
    exports2.number = anumber;
    exports2.abytes = abytes;
    exports2.bytes = abytes;
    exports2.ahash = ahash;
    exports2.aexists = aexists;
    exports2.aoutput = aoutput;
    function anumber(n2) {
      if (!Number.isSafeInteger(n2) || n2 < 0)
        throw new Error("positive integer expected, got " + n2);
    }
    function isBytes(a2) {
      return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
    }
    function abytes(b2, ...lengths) {
      if (!isBytes(b2))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b2.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
    }
    function ahash(h2) {
      if (typeof h2 !== "function" || typeof h2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      anumber(h2.outputLen);
      anumber(h2.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    var assert = {
      number: anumber,
      bytes: abytes,
      hash: ahash,
      exists: aexists,
      output: aoutput
    };
    exports2.default = assert;
  }
});

// ../../node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "../../node_modules/@noble/hashes/crypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// ../../node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "../../node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hash = exports2.nextTick = exports2.byteSwapIfBE = exports2.byteSwap = exports2.isLE = exports2.rotl = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
    exports2.isBytes = isBytes;
    exports2.byteSwap32 = byteSwap32;
    exports2.bytesToHex = bytesToHex;
    exports2.hexToBytes = hexToBytes;
    exports2.asyncLoop = asyncLoop;
    exports2.utf8ToBytes = utf8ToBytes;
    exports2.toBytes = toBytes;
    exports2.concatBytes = concatBytes;
    exports2.checkOpts = checkOpts;
    exports2.wrapConstructor = wrapConstructor;
    exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
    exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    exports2.randomBytes = randomBytes2;
    var crypto_1 = require_crypto();
    var _assert_js_1 = require_assert();
    function isBytes(a2) {
      return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
    }
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports2.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports2.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports2.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports2.rotl = rotl;
    exports2.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports2.byteSwap = byteSwap;
    exports2.byteSwapIfBE = exports2.isLE ? (n2) => n2 : (n2) => (0, exports2.byteSwap)(n2);
    function byteSwap32(arr) {
      for (let i2 = 0; i2 < arr.length; i2++) {
        arr[i2] = (0, exports2.byteSwap)(arr[i2]);
      }
    }
    var hexes = Array.from({ length: 256 }, (_3, i2) => i2.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.abytes)(bytes);
      let hex = "";
      for (let i2 = 0; i2 < bytes.length; i2++) {
        hex += hexes[bytes[i2]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch2) {
      if (ch2 >= asciis._0 && ch2 <= asciis._9)
        return ch2 - asciis._0;
      if (ch2 >= asciis.A && ch2 <= asciis.F)
        return ch2 - (asciis.A - 10);
      if (ch2 >= asciis.a && ch2 <= asciis.f)
        return ch2 - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl2 = hex.length;
      const al2 = hl2 / 2;
      if (hl2 % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl2);
      const array = new Uint8Array(al2);
      for (let ai2 = 0, hi2 = 0; ai2 < al2; ai2++, hi2 += 2) {
        const n12 = asciiToBase16(hex.charCodeAt(hi2));
        const n2 = asciiToBase16(hex.charCodeAt(hi2 + 1));
        if (n12 === void 0 || n2 === void 0) {
          const char = hex[hi2] + hex[hi2 + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
        }
        array[ai2] = n12 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {
    };
    exports2.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts2 = Date.now();
      for (let i2 = 0; i2 < iters; i2++) {
        cb(i2);
        const diff = Date.now() - ts2;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports2.nextTick)();
        ts2 += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("utf8ToBytes expected string, got " + typeof str);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.abytes)(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i2 = 0; i2 < arrays.length; i2++) {
        const a2 = arrays[i2];
        (0, _assert_js_1.abytes)(a2);
        sum += a2.length;
      }
      const res = new Uint8Array(sum);
      for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
        const a2 = arrays[i2];
        res.set(a2, pad);
        pad += a2.length;
      }
      return res;
    }
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports2.Hash = Hash;
    function checkOpts(defaults2, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults2, opts);
      return merged;
    }
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function randomBytes2(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return crypto_1.crypto.randomBytes(bytesLength);
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// ../../node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "../../node_modules/@noble/hashes/_md.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HashMD = exports2.Maj = exports2.Chi = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh2 = Number(value >> _32n & _u32_max);
      const wl2 = Number(value & _u32_max);
      const h2 = isLE ? 4 : 0;
      const l2 = isLE ? 0 : 4;
      view.setUint32(byteOffset + h2, wh2, isLE);
      view.setUint32(byteOffset + l2, wl2, isLE);
    }
    var Chi = (a2, b2, c2) => a2 & b2 ^ ~a2 & c2;
    exports2.Chi = Chi;
    var Maj = (a2, b2, c2) => a2 & b2 ^ a2 & c2 ^ b2 & c2;
    exports2.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.aexists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.aexists)(this);
        (0, _assert_js_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i2 = pos; i2 < blockLen; i2++)
          buffer[i2] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i2 = 0; i2 < outLen; i2++)
          oview.setUint32(4 * i2, state[i2], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to2) {
        to2 || (to2 = new this.constructor());
        to2.set(...this.get());
        const { blockLen, buffer, length: length2, finished, destroyed, pos } = this;
        to2.length = length2;
        to2.pos = pos;
        to2.finished = finished;
        to2.destroyed = destroyed;
        if (length2 % blockLen)
          to2.buffer.set(buffer);
        return to2;
      }
    };
    exports2.HashMD = HashMD;
  }
});

// ../../node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "../../node_modules/@noble/hashes/sha256.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha224 = exports2.sha256 = exports2.SHA256 = void 0;
    var _md_js_1 = require_md();
    var utils_js_1 = require_utils();
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A: A2, B: B3, C: C3, D: D2, E: E3, F: F2, G: G2, H: H2 } = this;
        return [A2, B3, C3, D2, E3, F2, G2, H2];
      }
      // prettier-ignore
      set(A2, B3, C3, D2, E3, F2, G2, H2) {
        this.A = A2 | 0;
        this.B = B3 | 0;
        this.C = C3 | 0;
        this.D = D2 | 0;
        this.E = E3 | 0;
        this.F = F2 | 0;
        this.G = G2 | 0;
        this.H = H2 | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          SHA256_W[i2] = view.getUint32(offset, false);
        for (let i2 = 16; i2 < 64; i2++) {
          const W15 = SHA256_W[i2 - 15];
          const W2 = SHA256_W[i2 - 2];
          const s02 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s12 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i2] = s12 + SHA256_W[i2 - 7] + s02 + SHA256_W[i2 - 16] | 0;
        }
        let { A: A2, B: B3, C: C3, D: D2, E: E3, F: F2, G: G2, H: H2 } = this;
        for (let i2 = 0; i2 < 64; i2++) {
          const sigma1 = (0, utils_js_1.rotr)(E3, 6) ^ (0, utils_js_1.rotr)(E3, 11) ^ (0, utils_js_1.rotr)(E3, 25);
          const T12 = H2 + sigma1 + (0, _md_js_1.Chi)(E3, F2, G2) + SHA256_K[i2] + SHA256_W[i2] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A2, 2) ^ (0, utils_js_1.rotr)(A2, 13) ^ (0, utils_js_1.rotr)(A2, 22);
          const T22 = sigma0 + (0, _md_js_1.Maj)(A2, B3, C3) | 0;
          H2 = G2;
          G2 = F2;
          F2 = E3;
          E3 = D2 + T12 | 0;
          D2 = C3;
          C3 = B3;
          B3 = A2;
          A2 = T12 + T22 | 0;
        }
        A2 = A2 + this.A | 0;
        B3 = B3 + this.B | 0;
        C3 = C3 + this.C | 0;
        D2 = D2 + this.D | 0;
        E3 = E3 + this.E | 0;
        F2 = F2 + this.F | 0;
        G2 = G2 + this.G | 0;
        H2 = H2 + this.H | 0;
        this.set(A2, B3, C3, D2, E3, F2, G2, H2);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    exports2.SHA256 = SHA256;
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// ../../node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "../../node_modules/@noble/hashes/_u64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.add5L = exports2.add5H = exports2.add4H = exports2.add4L = exports2.add3H = exports2.add3L = exports2.rotlBL = exports2.rotlBH = exports2.rotlSL = exports2.rotlSH = exports2.rotr32L = exports2.rotr32H = exports2.rotrBL = exports2.rotrBH = exports2.rotrSL = exports2.rotrSH = exports2.shrSL = exports2.shrSH = exports2.toBig = void 0;
    exports2.fromBig = fromBig;
    exports2.split = split;
    exports2.add = add;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n2, le = false) {
      if (le)
        return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
      return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
      let Ah2 = new Uint32Array(lst.length);
      let Al2 = new Uint32Array(lst.length);
      for (let i2 = 0; i2 < lst.length; i2++) {
        const { h: h2, l: l2 } = fromBig(lst[i2], le);
        [Ah2[i2], Al2[i2]] = [h2, l2];
      }
      return [Ah2, Al2];
    }
    var toBig = (h2, l2) => BigInt(h2 >>> 0) << _32n | BigInt(l2 >>> 0);
    exports2.toBig = toBig;
    var shrSH = (h2, _l2, s2) => h2 >>> s2;
    exports2.shrSH = shrSH;
    var shrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
    exports2.shrSL = shrSL;
    var rotrSH = (h2, l2, s2) => h2 >>> s2 | l2 << 32 - s2;
    exports2.rotrSH = rotrSH;
    var rotrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
    exports2.rotrSL = rotrSL;
    var rotrBH = (h2, l2, s2) => h2 << 64 - s2 | l2 >>> s2 - 32;
    exports2.rotrBH = rotrBH;
    var rotrBL = (h2, l2, s2) => h2 >>> s2 - 32 | l2 << 64 - s2;
    exports2.rotrBL = rotrBL;
    var rotr32H = (_h2, l2) => l2;
    exports2.rotr32H = rotr32H;
    var rotr32L = (h2, _l2) => h2;
    exports2.rotr32L = rotr32L;
    var rotlSH = (h2, l2, s2) => h2 << s2 | l2 >>> 32 - s2;
    exports2.rotlSH = rotlSH;
    var rotlSL = (h2, l2, s2) => l2 << s2 | h2 >>> 32 - s2;
    exports2.rotlSL = rotlSL;
    var rotlBH = (h2, l2, s2) => l2 << s2 - 32 | h2 >>> 64 - s2;
    exports2.rotlBH = rotlBH;
    var rotlBL = (h2, l2, s2) => h2 << s2 - 32 | l2 >>> 64 - s2;
    exports2.rotlBL = rotlBL;
    function add(Ah2, Al2, Bh2, Bl2) {
      const l2 = (Al2 >>> 0) + (Bl2 >>> 0);
      return { h: Ah2 + Bh2 + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
    }
    var add3L = (Al2, Bl2, Cl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0);
    exports2.add3L = add3L;
    var add3H = (low, Ah2, Bh2, Ch2) => Ah2 + Bh2 + Ch2 + (low / 2 ** 32 | 0) | 0;
    exports2.add3H = add3H;
    var add4L = (Al2, Bl2, Cl2, Dl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0);
    exports2.add4L = add4L;
    var add4H = (low, Ah2, Bh2, Ch2, Dh2) => Ah2 + Bh2 + Ch2 + Dh2 + (low / 2 ** 32 | 0) | 0;
    exports2.add4H = add4H;
    var add5L = (Al2, Bl2, Cl2, Dl2, El2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0) + (El2 >>> 0);
    exports2.add5L = add5L;
    var add5H = (low, Ah2, Bh2, Ch2, Dh2, Eh2) => Ah2 + Bh2 + Ch2 + Dh2 + Eh2 + (low / 2 ** 32 | 0) | 0;
    exports2.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports2.default = u64;
  }
});

// ../../node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "../../node_modules/@noble/hashes/sha512.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sha384 = exports2.sha512_256 = exports2.sha512_224 = exports2.sha512 = exports2.SHA384 = exports2.SHA512_256 = exports2.SHA512_224 = exports2.SHA512 = void 0;
    var _md_js_1 = require_md();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var [SHA512_Kh, SHA512_Kl] = (() => _u64_js_1.default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n2) => BigInt(n2))))();
    var SHA512_W_H = new Uint32Array(80);
    var SHA512_W_L = new Uint32Array(80);
    var SHA512 = class extends _md_js_1.HashMD {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah: Ah2, Al: Al2, Bh: Bh2, Bl: Bl2, Ch: Ch2, Cl: Cl2, Dh: Dh2, Dl: Dl2, Eh: Eh2, El: El2, Fh: Fh2, Fl: Fl2, Gh: Gh2, Gl: Gl2, Hh: Hh2, Hl: Hl2 } = this;
        return [Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2];
      }
      // prettier-ignore
      set(Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2) {
        this.Ah = Ah2 | 0;
        this.Al = Al2 | 0;
        this.Bh = Bh2 | 0;
        this.Bl = Bl2 | 0;
        this.Ch = Ch2 | 0;
        this.Cl = Cl2 | 0;
        this.Dh = Dh2 | 0;
        this.Dl = Dl2 | 0;
        this.Eh = Eh2 | 0;
        this.El = El2 | 0;
        this.Fh = Fh2 | 0;
        this.Fl = Fl2 | 0;
        this.Gh = Gh2 | 0;
        this.Gl = Gl2 | 0;
        this.Hh = Hh2 | 0;
        this.Hl = Hl2 | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4) {
          SHA512_W_H[i2] = view.getUint32(offset);
          SHA512_W_L[i2] = view.getUint32(offset += 4);
        }
        for (let i2 = 16; i2 < 80; i2++) {
          const W15h = SHA512_W_H[i2 - 15] | 0;
          const W15l = SHA512_W_L[i2 - 15] | 0;
          const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
          const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i2 - 2] | 0;
          const W2l = SHA512_W_L[i2 - 2] | 0;
          const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
          const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
          const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
          const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
          SHA512_W_H[i2] = SUMh | 0;
          SHA512_W_L[i2] = SUMl | 0;
        }
        let { Ah: Ah2, Al: Al2, Bh: Bh2, Bl: Bl2, Ch: Ch2, Cl: Cl2, Dh: Dh2, Dl: Dl2, Eh: Eh2, El: El2, Fh: Fh2, Fl: Fl2, Gh: Gh2, Gl: Gl2, Hh: Hh2, Hl: Hl2 } = this;
        for (let i2 = 0; i2 < 80; i2++) {
          const sigma1h = _u64_js_1.default.rotrSH(Eh2, El2, 14) ^ _u64_js_1.default.rotrSH(Eh2, El2, 18) ^ _u64_js_1.default.rotrBH(Eh2, El2, 41);
          const sigma1l = _u64_js_1.default.rotrSL(Eh2, El2, 14) ^ _u64_js_1.default.rotrSL(Eh2, El2, 18) ^ _u64_js_1.default.rotrBL(Eh2, El2, 41);
          const CHIh = Eh2 & Fh2 ^ ~Eh2 & Gh2;
          const CHIl = El2 & Fl2 ^ ~El2 & Gl2;
          const T1ll = _u64_js_1.default.add5L(Hl2, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
          const T1h = _u64_js_1.default.add5H(T1ll, Hh2, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
          const T1l = T1ll | 0;
          const sigma0h = _u64_js_1.default.rotrSH(Ah2, Al2, 28) ^ _u64_js_1.default.rotrBH(Ah2, Al2, 34) ^ _u64_js_1.default.rotrBH(Ah2, Al2, 39);
          const sigma0l = _u64_js_1.default.rotrSL(Ah2, Al2, 28) ^ _u64_js_1.default.rotrBL(Ah2, Al2, 34) ^ _u64_js_1.default.rotrBL(Ah2, Al2, 39);
          const MAJh = Ah2 & Bh2 ^ Ah2 & Ch2 ^ Bh2 & Ch2;
          const MAJl = Al2 & Bl2 ^ Al2 & Cl2 ^ Bl2 & Cl2;
          Hh2 = Gh2 | 0;
          Hl2 = Gl2 | 0;
          Gh2 = Fh2 | 0;
          Gl2 = Fl2 | 0;
          Fh2 = Eh2 | 0;
          Fl2 = El2 | 0;
          ({ h: Eh2, l: El2 } = _u64_js_1.default.add(Dh2 | 0, Dl2 | 0, T1h | 0, T1l | 0));
          Dh2 = Ch2 | 0;
          Dl2 = Cl2 | 0;
          Ch2 = Bh2 | 0;
          Cl2 = Bl2 | 0;
          Bh2 = Ah2 | 0;
          Bl2 = Al2 | 0;
          const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
          Ah2 = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
          Al2 = All | 0;
        }
        ({ h: Ah2, l: Al2 } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah2 | 0, Al2 | 0));
        ({ h: Bh2, l: Bl2 } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh2 | 0, Bl2 | 0));
        ({ h: Ch2, l: Cl2 } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch2 | 0, Cl2 | 0));
        ({ h: Dh2, l: Dl2 } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh2 | 0, Dl2 | 0));
        ({ h: Eh2, l: El2 } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh2 | 0, El2 | 0));
        ({ h: Fh2, l: Fl2 } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh2 | 0, Fl2 | 0));
        ({ h: Gh2, l: Gl2 } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh2 | 0, Gl2 | 0));
        ({ h: Hh2, l: Hl2 } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh2 | 0, Hl2 | 0));
        this.set(Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2);
      }
      roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports2.SHA512 = SHA512;
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 2352822216 | 0;
        this.Al = 424955298 | 0;
        this.Bh = 1944164710 | 0;
        this.Bl = 2312950998 | 0;
        this.Ch = 502970286 | 0;
        this.Cl = 855612546 | 0;
        this.Dh = 1738396948 | 0;
        this.Dl = 1479516111 | 0;
        this.Eh = 258812777 | 0;
        this.El = 2077511080 | 0;
        this.Fh = 2011393907 | 0;
        this.Fl = 79989058 | 0;
        this.Gh = 1067287976 | 0;
        this.Gl = 1780299464 | 0;
        this.Hh = 286451373 | 0;
        this.Hl = 2446758561 | 0;
        this.outputLen = 28;
      }
    };
    exports2.SHA512_224 = SHA512_224;
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    exports2.SHA512_256 = SHA512_256;
    var SHA384 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    exports2.SHA384 = SHA384;
    exports2.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
    exports2.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
    exports2.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
    exports2.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
  }
});

// ../../node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "../../node_modules/@noble/hashes/hmac.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hmac = exports2.HMAC = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash3, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.ahash)(hash3);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash3.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash3.create();
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.aexists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.aexists)(this);
        (0, _assert_js_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to2) {
        to2 || (to2 = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to2 = to2;
        to2.finished = finished;
        to2.destroyed = destroyed;
        to2.blockLen = blockLen;
        to2.outputLen = outputLen;
        to2.oHash = oHash._cloneInto(to2.oHash);
        to2.iHash = iHash._cloneInto(to2.iHash);
        return to2;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports2.HMAC = HMAC;
    var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
    exports2.hmac = hmac;
    exports2.hmac.create = (hash3, key) => new HMAC(hash3, key);
  }
});

// ../../node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "../../node_modules/@noble/hashes/pbkdf2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pbkdf2 = pbkdf22;
    exports2.pbkdf2Async = pbkdf2Async;
    var _assert_js_1 = require_assert();
    var hmac_js_1 = require_hmac();
    var utils_js_1 = require_utils();
    function pbkdf2Init(hash3, _password, _salt, _opts) {
      (0, _assert_js_1.ahash)(hash3);
      const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c: c2, dkLen, asyncTick } = opts;
      (0, _assert_js_1.anumber)(c2);
      (0, _assert_js_1.anumber)(dkLen);
      (0, _assert_js_1.anumber)(asyncTick);
      if (c2 < 1)
        throw new Error("PBKDF2: iterations (c) should be >= 1");
      const password = (0, utils_js_1.toBytes)(_password);
      const salt = (0, utils_js_1.toBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_js_1.hmac.create(hash3, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u2) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      u2.fill(0);
      return DK;
    }
    function pbkdf22(hash3, password, salt, opts) {
      const { c: c2, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u2 = new Uint8Array(PRF.outputLen);
      for (let ti2 = 1, pos = 0; pos < dkLen; ti2++, pos += PRF.outputLen) {
        const Ti2 = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti2, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
        Ti2.set(u2.subarray(0, Ti2.length));
        for (let ui2 = 1; ui2 < c2; ui2++) {
          PRF._cloneInto(prfW).update(u2).digestInto(u2);
          for (let i2 = 0; i2 < Ti2.length; i2++)
            Ti2[i2] ^= u2[i2];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u2);
    }
    async function pbkdf2Async(hash3, password, salt, opts) {
      const { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u2 = new Uint8Array(PRF.outputLen);
      for (let ti2 = 1, pos = 0; pos < dkLen; ti2++, pos += PRF.outputLen) {
        const Ti2 = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti2, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
        Ti2.set(u2.subarray(0, Ti2.length));
        await (0, utils_js_1.asyncLoop)(c2 - 1, asyncTick, () => {
          PRF._cloneInto(prfW).update(u2).digestInto(u2);
          for (let i2 = 0; i2 < Ti2.length; i2++)
            Ti2[i2] ^= u2[i2];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u2);
    }
  }
});

// ../../node_modules/bip39/src/wordlists/czech.json
var require_czech = __commonJS({
  "../../node_modules/bip39/src/wordlists/czech.json"(exports2, module2) {
    module2.exports = [
      "abdikace",
      "abeceda",
      "adresa",
      "agrese",
      "akce",
      "aktovka",
      "alej",
      "alkohol",
      "amputace",
      "ananas",
      "andulka",
      "anekdota",
      "anketa",
      "antika",
      "anulovat",
      "archa",
      "arogance",
      "asfalt",
      "asistent",
      "aspirace",
      "astma",
      "astronom",
      "atlas",
      "atletika",
      "atol",
      "autobus",
      "azyl",
      "babka",
      "bachor",
      "bacil",
      "baculka",
      "badatel",
      "bageta",
      "bagr",
      "bahno",
      "bakterie",
      "balada",
      "baletka",
      "balkon",
      "balonek",
      "balvan",
      "balza",
      "bambus",
      "bankomat",
      "barbar",
      "baret",
      "barman",
      "baroko",
      "barva",
      "baterka",
      "batoh",
      "bavlna",
      "bazalka",
      "bazilika",
      "bazuka",
      "bedna",
      "beran",
      "beseda",
      "bestie",
      "beton",
      "bezinka",
      "bezmoc",
      "beztak",
      "bicykl",
      "bidlo",
      "biftek",
      "bikiny",
      "bilance",
      "biograf",
      "biolog",
      "bitva",
      "bizon",
      "blahobyt",
      "blatouch",
      "blecha",
      "bledule",
      "blesk",
      "blikat",
      "blizna",
      "blokovat",
      "bloudit",
      "blud",
      "bobek",
      "bobr",
      "bodlina",
      "bodnout",
      "bohatost",
      "bojkot",
      "bojovat",
      "bokorys",
      "bolest",
      "borec",
      "borovice",
      "bota",
      "boubel",
      "bouchat",
      "bouda",
      "boule",
      "bourat",
      "boxer",
      "bradavka",
      "brambora",
      "branka",
      "bratr",
      "brepta",
      "briketa",
      "brko",
      "brloh",
      "bronz",
      "broskev",
      "brunetka",
      "brusinka",
      "brzda",
      "brzy",
      "bublina",
      "bubnovat",
      "buchta",
      "buditel",
      "budka",
      "budova",
      "bufet",
      "bujarost",
      "bukvice",
      "buldok",
      "bulva",
      "bunda",
      "bunkr",
      "burza",
      "butik",
      "buvol",
      "buzola",
      "bydlet",
      "bylina",
      "bytovka",
      "bzukot",
      "capart",
      "carevna",
      "cedr",
      "cedule",
      "cejch",
      "cejn",
      "cela",
      "celer",
      "celkem",
      "celnice",
      "cenina",
      "cennost",
      "cenovka",
      "centrum",
      "cenzor",
      "cestopis",
      "cetka",
      "chalupa",
      "chapadlo",
      "charita",
      "chata",
      "chechtat",
      "chemie",
      "chichot",
      "chirurg",
      "chlad",
      "chleba",
      "chlubit",
      "chmel",
      "chmura",
      "chobot",
      "chochol",
      "chodba",
      "cholera",
      "chomout",
      "chopit",
      "choroba",
      "chov",
      "chrapot",
      "chrlit",
      "chrt",
      "chrup",
      "chtivost",
      "chudina",
      "chutnat",
      "chvat",
      "chvilka",
      "chvost",
      "chyba",
      "chystat",
      "chytit",
      "cibule",
      "cigareta",
      "cihelna",
      "cihla",
      "cinkot",
      "cirkus",
      "cisterna",
      "citace",
      "citrus",
      "cizinec",
      "cizost",
      "clona",
      "cokoliv",
      "couvat",
      "ctitel",
      "ctnost",
      "cudnost",
      "cuketa",
      "cukr",
      "cupot",
      "cvaknout",
      "cval",
      "cvik",
      "cvrkot",
      "cyklista",
      "daleko",
      "dareba",
      "datel",
      "datum",
      "dcera",
      "debata",
      "dechovka",
      "decibel",
      "deficit",
      "deflace",
      "dekl",
      "dekret",
      "demokrat",
      "deprese",
      "derby",
      "deska",
      "detektiv",
      "dikobraz",
      "diktovat",
      "dioda",
      "diplom",
      "disk",
      "displej",
      "divadlo",
      "divoch",
      "dlaha",
      "dlouho",
      "dluhopis",
      "dnes",
      "dobro",
      "dobytek",
      "docent",
      "dochutit",
      "dodnes",
      "dohled",
      "dohoda",
      "dohra",
      "dojem",
      "dojnice",
      "doklad",
      "dokola",
      "doktor",
      "dokument",
      "dolar",
      "doleva",
      "dolina",
      "doma",
      "dominant",
      "domluvit",
      "domov",
      "donutit",
      "dopad",
      "dopis",
      "doplnit",
      "doposud",
      "doprovod",
      "dopustit",
      "dorazit",
      "dorost",
      "dort",
      "dosah",
      "doslov",
      "dostatek",
      "dosud",
      "dosyta",
      "dotaz",
      "dotek",
      "dotknout",
      "doufat",
      "doutnat",
      "dovozce",
      "dozadu",
      "doznat",
      "dozorce",
      "drahota",
      "drak",
      "dramatik",
      "dravec",
      "draze",
      "drdol",
      "drobnost",
      "drogerie",
      "drozd",
      "drsnost",
      "drtit",
      "drzost",
      "duben",
      "duchovno",
      "dudek",
      "duha",
      "duhovka",
      "dusit",
      "dusno",
      "dutost",
      "dvojice",
      "dvorec",
      "dynamit",
      "ekolog",
      "ekonomie",
      "elektron",
      "elipsa",
      "email",
      "emise",
      "emoce",
      "empatie",
      "epizoda",
      "epocha",
      "epopej",
      "epos",
      "esej",
      "esence",
      "eskorta",
      "eskymo",
      "etiketa",
      "euforie",
      "evoluce",
      "exekuce",
      "exkurze",
      "expedice",
      "exploze",
      "export",
      "extrakt",
      "facka",
      "fajfka",
      "fakulta",
      "fanatik",
      "fantazie",
      "farmacie",
      "favorit",
      "fazole",
      "federace",
      "fejeton",
      "fenka",
      "fialka",
      "figurant",
      "filozof",
      "filtr",
      "finance",
      "finta",
      "fixace",
      "fjord",
      "flanel",
      "flirt",
      "flotila",
      "fond",
      "fosfor",
      "fotbal",
      "fotka",
      "foton",
      "frakce",
      "freska",
      "fronta",
      "fukar",
      "funkce",
      "fyzika",
      "galeje",
      "garant",
      "genetika",
      "geolog",
      "gilotina",
      "glazura",
      "glejt",
      "golem",
      "golfista",
      "gotika",
      "graf",
      "gramofon",
      "granule",
      "grep",
      "gril",
      "grog",
      "groteska",
      "guma",
      "hadice",
      "hadr",
      "hala",
      "halenka",
      "hanba",
      "hanopis",
      "harfa",
      "harpuna",
      "havran",
      "hebkost",
      "hejkal",
      "hejno",
      "hejtman",
      "hektar",
      "helma",
      "hematom",
      "herec",
      "herna",
      "heslo",
      "hezky",
      "historik",
      "hladovka",
      "hlasivky",
      "hlava",
      "hledat",
      "hlen",
      "hlodavec",
      "hloh",
      "hloupost",
      "hltat",
      "hlubina",
      "hluchota",
      "hmat",
      "hmota",
      "hmyz",
      "hnis",
      "hnojivo",
      "hnout",
      "hoblina",
      "hoboj",
      "hoch",
      "hodiny",
      "hodlat",
      "hodnota",
      "hodovat",
      "hojnost",
      "hokej",
      "holinka",
      "holka",
      "holub",
      "homole",
      "honitba",
      "honorace",
      "horal",
      "horda",
      "horizont",
      "horko",
      "horlivec",
      "hormon",
      "hornina",
      "horoskop",
      "horstvo",
      "hospoda",
      "hostina",
      "hotovost",
      "houba",
      "houf",
      "houpat",
      "houska",
      "hovor",
      "hradba",
      "hranice",
      "hravost",
      "hrazda",
      "hrbolek",
      "hrdina",
      "hrdlo",
      "hrdost",
      "hrnek",
      "hrobka",
      "hromada",
      "hrot",
      "hrouda",
      "hrozen",
      "hrstka",
      "hrubost",
      "hryzat",
      "hubenost",
      "hubnout",
      "hudba",
      "hukot",
      "humr",
      "husita",
      "hustota",
      "hvozd",
      "hybnost",
      "hydrant",
      "hygiena",
      "hymna",
      "hysterik",
      "idylka",
      "ihned",
      "ikona",
      "iluze",
      "imunita",
      "infekce",
      "inflace",
      "inkaso",
      "inovace",
      "inspekce",
      "internet",
      "invalida",
      "investor",
      "inzerce",
      "ironie",
      "jablko",
      "jachta",
      "jahoda",
      "jakmile",
      "jakost",
      "jalovec",
      "jantar",
      "jarmark",
      "jaro",
      "jasan",
      "jasno",
      "jatka",
      "javor",
      "jazyk",
      "jedinec",
      "jedle",
      "jednatel",
      "jehlan",
      "jekot",
      "jelen",
      "jelito",
      "jemnost",
      "jenom",
      "jepice",
      "jeseter",
      "jevit",
      "jezdec",
      "jezero",
      "jinak",
      "jindy",
      "jinoch",
      "jiskra",
      "jistota",
      "jitrnice",
      "jizva",
      "jmenovat",
      "jogurt",
      "jurta",
      "kabaret",
      "kabel",
      "kabinet",
      "kachna",
      "kadet",
      "kadidlo",
      "kahan",
      "kajak",
      "kajuta",
      "kakao",
      "kaktus",
      "kalamita",
      "kalhoty",
      "kalibr",
      "kalnost",
      "kamera",
      "kamkoliv",
      "kamna",
      "kanibal",
      "kanoe",
      "kantor",
      "kapalina",
      "kapela",
      "kapitola",
      "kapka",
      "kaple",
      "kapota",
      "kapr",
      "kapusta",
      "kapybara",
      "karamel",
      "karotka",
      "karton",
      "kasa",
      "katalog",
      "katedra",
      "kauce",
      "kauza",
      "kavalec",
      "kazajka",
      "kazeta",
      "kazivost",
      "kdekoliv",
      "kdesi",
      "kedluben",
      "kemp",
      "keramika",
      "kino",
      "klacek",
      "kladivo",
      "klam",
      "klapot",
      "klasika",
      "klaun",
      "klec",
      "klenba",
      "klepat",
      "klesnout",
      "klid",
      "klima",
      "klisna",
      "klobouk",
      "klokan",
      "klopa",
      "kloub",
      "klubovna",
      "klusat",
      "kluzkost",
      "kmen",
      "kmitat",
      "kmotr",
      "kniha",
      "knot",
      "koalice",
      "koberec",
      "kobka",
      "kobliha",
      "kobyla",
      "kocour",
      "kohout",
      "kojenec",
      "kokos",
      "koktejl",
      "kolaps",
      "koleda",
      "kolize",
      "kolo",
      "komando",
      "kometa",
      "komik",
      "komnata",
      "komora",
      "kompas",
      "komunita",
      "konat",
      "koncept",
      "kondice",
      "konec",
      "konfese",
      "kongres",
      "konina",
      "konkurs",
      "kontakt",
      "konzerva",
      "kopanec",
      "kopie",
      "kopnout",
      "koprovka",
      "korbel",
      "korektor",
      "kormidlo",
      "koroptev",
      "korpus",
      "koruna",
      "koryto",
      "korzet",
      "kosatec",
      "kostka",
      "kotel",
      "kotleta",
      "kotoul",
      "koukat",
      "koupelna",
      "kousek",
      "kouzlo",
      "kovboj",
      "koza",
      "kozoroh",
      "krabice",
      "krach",
      "krajina",
      "kralovat",
      "krasopis",
      "kravata",
      "kredit",
      "krejcar",
      "kresba",
      "kreveta",
      "kriket",
      "kritik",
      "krize",
      "krkavec",
      "krmelec",
      "krmivo",
      "krocan",
      "krok",
      "kronika",
      "kropit",
      "kroupa",
      "krovka",
      "krtek",
      "kruhadlo",
      "krupice",
      "krutost",
      "krvinka",
      "krychle",
      "krypta",
      "krystal",
      "kryt",
      "kudlanka",
      "kufr",
      "kujnost",
      "kukla",
      "kulajda",
      "kulich",
      "kulka",
      "kulomet",
      "kultura",
      "kuna",
      "kupodivu",
      "kurt",
      "kurzor",
      "kutil",
      "kvalita",
      "kvasinka",
      "kvestor",
      "kynolog",
      "kyselina",
      "kytara",
      "kytice",
      "kytka",
      "kytovec",
      "kyvadlo",
      "labrador",
      "lachtan",
      "ladnost",
      "laik",
      "lakomec",
      "lamela",
      "lampa",
      "lanovka",
      "lasice",
      "laso",
      "lastura",
      "latinka",
      "lavina",
      "lebka",
      "leckdy",
      "leden",
      "lednice",
      "ledovka",
      "ledvina",
      "legenda",
      "legie",
      "legrace",
      "lehce",
      "lehkost",
      "lehnout",
      "lektvar",
      "lenochod",
      "lentilka",
      "lepenka",
      "lepidlo",
      "letadlo",
      "letec",
      "letmo",
      "letokruh",
      "levhart",
      "levitace",
      "levobok",
      "libra",
      "lichotka",
      "lidojed",
      "lidskost",
      "lihovina",
      "lijavec",
      "lilek",
      "limetka",
      "linie",
      "linka",
      "linoleum",
      "listopad",
      "litina",
      "litovat",
      "lobista",
      "lodivod",
      "logika",
      "logoped",
      "lokalita",
      "loket",
      "lomcovat",
      "lopata",
      "lopuch",
      "lord",
      "losos",
      "lotr",
      "loudal",
      "louh",
      "louka",
      "louskat",
      "lovec",
      "lstivost",
      "lucerna",
      "lucifer",
      "lump",
      "lusk",
      "lustrace",
      "lvice",
      "lyra",
      "lyrika",
      "lysina",
      "madam",
      "madlo",
      "magistr",
      "mahagon",
      "majetek",
      "majitel",
      "majorita",
      "makak",
      "makovice",
      "makrela",
      "malba",
      "malina",
      "malovat",
      "malvice",
      "maminka",
      "mandle",
      "manko",
      "marnost",
      "masakr",
      "maskot",
      "masopust",
      "matice",
      "matrika",
      "maturita",
      "mazanec",
      "mazivo",
      "mazlit",
      "mazurka",
      "mdloba",
      "mechanik",
      "meditace",
      "medovina",
      "melasa",
      "meloun",
      "mentolka",
      "metla",
      "metoda",
      "metr",
      "mezera",
      "migrace",
      "mihnout",
      "mihule",
      "mikina",
      "mikrofon",
      "milenec",
      "milimetr",
      "milost",
      "mimika",
      "mincovna",
      "minibar",
      "minomet",
      "minulost",
      "miska",
      "mistr",
      "mixovat",
      "mladost",
      "mlha",
      "mlhovina",
      "mlok",
      "mlsat",
      "mluvit",
      "mnich",
      "mnohem",
      "mobil",
      "mocnost",
      "modelka",
      "modlitba",
      "mohyla",
      "mokro",
      "molekula",
      "momentka",
      "monarcha",
      "monokl",
      "monstrum",
      "montovat",
      "monzun",
      "mosaz",
      "moskyt",
      "most",
      "motivace",
      "motorka",
      "motyka",
      "moucha",
      "moudrost",
      "mozaika",
      "mozek",
      "mozol",
      "mramor",
      "mravenec",
      "mrkev",
      "mrtvola",
      "mrzet",
      "mrzutost",
      "mstitel",
      "mudrc",
      "muflon",
      "mulat",
      "mumie",
      "munice",
      "muset",
      "mutace",
      "muzeum",
      "muzikant",
      "myslivec",
      "mzda",
      "nabourat",
      "nachytat",
      "nadace",
      "nadbytek",
      "nadhoz",
      "nadobro",
      "nadpis",
      "nahlas",
      "nahnat",
      "nahodile",
      "nahradit",
      "naivita",
      "najednou",
      "najisto",
      "najmout",
      "naklonit",
      "nakonec",
      "nakrmit",
      "nalevo",
      "namazat",
      "namluvit",
      "nanometr",
      "naoko",
      "naopak",
      "naostro",
      "napadat",
      "napevno",
      "naplnit",
      "napnout",
      "naposled",
      "naprosto",
      "narodit",
      "naruby",
      "narychlo",
      "nasadit",
      "nasekat",
      "naslepo",
      "nastat",
      "natolik",
      "navenek",
      "navrch",
      "navzdory",
      "nazvat",
      "nebe",
      "nechat",
      "necky",
      "nedaleko",
      "nedbat",
      "neduh",
      "negace",
      "nehet",
      "nehoda",
      "nejen",
      "nejprve",
      "neklid",
      "nelibost",
      "nemilost",
      "nemoc",
      "neochota",
      "neonka",
      "nepokoj",
      "nerost",
      "nerv",
      "nesmysl",
      "nesoulad",
      "netvor",
      "neuron",
      "nevina",
      "nezvykle",
      "nicota",
      "nijak",
      "nikam",
      "nikdy",
      "nikl",
      "nikterak",
      "nitro",
      "nocleh",
      "nohavice",
      "nominace",
      "nora",
      "norek",
      "nositel",
      "nosnost",
      "nouze",
      "noviny",
      "novota",
      "nozdra",
      "nuda",
      "nudle",
      "nuget",
      "nutit",
      "nutnost",
      "nutrie",
      "nymfa",
      "obal",
      "obarvit",
      "obava",
      "obdiv",
      "obec",
      "obehnat",
      "obejmout",
      "obezita",
      "obhajoba",
      "obilnice",
      "objasnit",
      "objekt",
      "obklopit",
      "oblast",
      "oblek",
      "obliba",
      "obloha",
      "obluda",
      "obnos",
      "obohatit",
      "obojek",
      "obout",
      "obrazec",
      "obrna",
      "obruba",
      "obrys",
      "obsah",
      "obsluha",
      "obstarat",
      "obuv",
      "obvaz",
      "obvinit",
      "obvod",
      "obvykle",
      "obyvatel",
      "obzor",
      "ocas",
      "ocel",
      "ocenit",
      "ochladit",
      "ochota",
      "ochrana",
      "ocitnout",
      "odboj",
      "odbyt",
      "odchod",
      "odcizit",
      "odebrat",
      "odeslat",
      "odevzdat",
      "odezva",
      "odhadce",
      "odhodit",
      "odjet",
      "odjinud",
      "odkaz",
      "odkoupit",
      "odliv",
      "odluka",
      "odmlka",
      "odolnost",
      "odpad",
      "odpis",
      "odplout",
      "odpor",
      "odpustit",
      "odpykat",
      "odrazka",
      "odsoudit",
      "odstup",
      "odsun",
      "odtok",
      "odtud",
      "odvaha",
      "odveta",
      "odvolat",
      "odvracet",
      "odznak",
      "ofina",
      "ofsajd",
      "ohlas",
      "ohnisko",
      "ohrada",
      "ohrozit",
      "ohryzek",
      "okap",
      "okenice",
      "oklika",
      "okno",
      "okouzlit",
      "okovy",
      "okrasa",
      "okres",
      "okrsek",
      "okruh",
      "okupant",
      "okurka",
      "okusit",
      "olejnina",
      "olizovat",
      "omak",
      "omeleta",
      "omezit",
      "omladina",
      "omlouvat",
      "omluva",
      "omyl",
      "onehdy",
      "opakovat",
      "opasek",
      "operace",
      "opice",
      "opilost",
      "opisovat",
      "opora",
      "opozice",
      "opravdu",
      "oproti",
      "orbital",
      "orchestr",
      "orgie",
      "orlice",
      "orloj",
      "ortel",
      "osada",
      "oschnout",
      "osika",
      "osivo",
      "oslava",
      "oslepit",
      "oslnit",
      "oslovit",
      "osnova",
      "osoba",
      "osolit",
      "ospalec",
      "osten",
      "ostraha",
      "ostuda",
      "ostych",
      "osvojit",
      "oteplit",
      "otisk",
      "otop",
      "otrhat",
      "otrlost",
      "otrok",
      "otruby",
      "otvor",
      "ovanout",
      "ovar",
      "oves",
      "ovlivnit",
      "ovoce",
      "oxid",
      "ozdoba",
      "pachatel",
      "pacient",
      "padouch",
      "pahorek",
      "pakt",
      "palanda",
      "palec",
      "palivo",
      "paluba",
      "pamflet",
      "pamlsek",
      "panenka",
      "panika",
      "panna",
      "panovat",
      "panstvo",
      "pantofle",
      "paprika",
      "parketa",
      "parodie",
      "parta",
      "paruka",
      "paryba",
      "paseka",
      "pasivita",
      "pastelka",
      "patent",
      "patrona",
      "pavouk",
      "pazneht",
      "pazourek",
      "pecka",
      "pedagog",
      "pejsek",
      "peklo",
      "peloton",
      "penalta",
      "pendrek",
      "penze",
      "periskop",
      "pero",
      "pestrost",
      "petarda",
      "petice",
      "petrolej",
      "pevnina",
      "pexeso",
      "pianista",
      "piha",
      "pijavice",
      "pikle",
      "piknik",
      "pilina",
      "pilnost",
      "pilulka",
      "pinzeta",
      "pipeta",
      "pisatel",
      "pistole",
      "pitevna",
      "pivnice",
      "pivovar",
      "placenta",
      "plakat",
      "plamen",
      "planeta",
      "plastika",
      "platit",
      "plavidlo",
      "plaz",
      "plech",
      "plemeno",
      "plenta",
      "ples",
      "pletivo",
      "plevel",
      "plivat",
      "plnit",
      "plno",
      "plocha",
      "plodina",
      "plomba",
      "plout",
      "pluk",
      "plyn",
      "pobavit",
      "pobyt",
      "pochod",
      "pocit",
      "poctivec",
      "podat",
      "podcenit",
      "podepsat",
      "podhled",
      "podivit",
      "podklad",
      "podmanit",
      "podnik",
      "podoba",
      "podpora",
      "podraz",
      "podstata",
      "podvod",
      "podzim",
      "poezie",
      "pohanka",
      "pohnutka",
      "pohovor",
      "pohroma",
      "pohyb",
      "pointa",
      "pojistka",
      "pojmout",
      "pokazit",
      "pokles",
      "pokoj",
      "pokrok",
      "pokuta",
      "pokyn",
      "poledne",
      "polibek",
      "polknout",
      "poloha",
      "polynom",
      "pomalu",
      "pominout",
      "pomlka",
      "pomoc",
      "pomsta",
      "pomyslet",
      "ponechat",
      "ponorka",
      "ponurost",
      "popadat",
      "popel",
      "popisek",
      "poplach",
      "poprosit",
      "popsat",
      "popud",
      "poradce",
      "porce",
      "porod",
      "porucha",
      "poryv",
      "posadit",
      "posed",
      "posila",
      "poskok",
      "poslanec",
      "posoudit",
      "pospolu",
      "postava",
      "posudek",
      "posyp",
      "potah",
      "potkan",
      "potlesk",
      "potomek",
      "potrava",
      "potupa",
      "potvora",
      "poukaz",
      "pouto",
      "pouzdro",
      "povaha",
      "povidla",
      "povlak",
      "povoz",
      "povrch",
      "povstat",
      "povyk",
      "povzdech",
      "pozdrav",
      "pozemek",
      "poznatek",
      "pozor",
      "pozvat",
      "pracovat",
      "prahory",
      "praktika",
      "prales",
      "praotec",
      "praporek",
      "prase",
      "pravda",
      "princip",
      "prkno",
      "probudit",
      "procento",
      "prodej",
      "profese",
      "prohra",
      "projekt",
      "prolomit",
      "promile",
      "pronikat",
      "propad",
      "prorok",
      "prosba",
      "proton",
      "proutek",
      "provaz",
      "prskavka",
      "prsten",
      "prudkost",
      "prut",
      "prvek",
      "prvohory",
      "psanec",
      "psovod",
      "pstruh",
      "ptactvo",
      "puberta",
      "puch",
      "pudl",
      "pukavec",
      "puklina",
      "pukrle",
      "pult",
      "pumpa",
      "punc",
      "pupen",
      "pusa",
      "pusinka",
      "pustina",
      "putovat",
      "putyka",
      "pyramida",
      "pysk",
      "pytel",
      "racek",
      "rachot",
      "radiace",
      "radnice",
      "radon",
      "raft",
      "ragby",
      "raketa",
      "rakovina",
      "rameno",
      "rampouch",
      "rande",
      "rarach",
      "rarita",
      "rasovna",
      "rastr",
      "ratolest",
      "razance",
      "razidlo",
      "reagovat",
      "reakce",
      "recept",
      "redaktor",
      "referent",
      "reflex",
      "rejnok",
      "reklama",
      "rekord",
      "rekrut",
      "rektor",
      "reputace",
      "revize",
      "revma",
      "revolver",
      "rezerva",
      "riskovat",
      "riziko",
      "robotika",
      "rodokmen",
      "rohovka",
      "rokle",
      "rokoko",
      "romaneto",
      "ropovod",
      "ropucha",
      "rorejs",
      "rosol",
      "rostlina",
      "rotmistr",
      "rotoped",
      "rotunda",
      "roubenka",
      "roucho",
      "roup",
      "roura",
      "rovina",
      "rovnice",
      "rozbor",
      "rozchod",
      "rozdat",
      "rozeznat",
      "rozhodce",
      "rozinka",
      "rozjezd",
      "rozkaz",
      "rozloha",
      "rozmar",
      "rozpad",
      "rozruch",
      "rozsah",
      "roztok",
      "rozum",
      "rozvod",
      "rubrika",
      "ruchadlo",
      "rukavice",
      "rukopis",
      "ryba",
      "rybolov",
      "rychlost",
      "rydlo",
      "rypadlo",
      "rytina",
      "ryzost",
      "sadista",
      "sahat",
      "sako",
      "samec",
      "samizdat",
      "samota",
      "sanitka",
      "sardinka",
      "sasanka",
      "satelit",
      "sazba",
      "sazenice",
      "sbor",
      "schovat",
      "sebranka",
      "secese",
      "sedadlo",
      "sediment",
      "sedlo",
      "sehnat",
      "sejmout",
      "sekera",
      "sekta",
      "sekunda",
      "sekvoje",
      "semeno",
      "seno",
      "servis",
      "sesadit",
      "seshora",
      "seskok",
      "seslat",
      "sestra",
      "sesuv",
      "sesypat",
      "setba",
      "setina",
      "setkat",
      "setnout",
      "setrvat",
      "sever",
      "seznam",
      "shoda",
      "shrnout",
      "sifon",
      "silnice",
      "sirka",
      "sirotek",
      "sirup",
      "situace",
      "skafandr",
      "skalisko",
      "skanzen",
      "skaut",
      "skeptik",
      "skica",
      "skladba",
      "sklenice",
      "sklo",
      "skluz",
      "skoba",
      "skokan",
      "skoro",
      "skripta",
      "skrz",
      "skupina",
      "skvost",
      "skvrna",
      "slabika",
      "sladidlo",
      "slanina",
      "slast",
      "slavnost",
      "sledovat",
      "slepec",
      "sleva",
      "slezina",
      "slib",
      "slina",
      "sliznice",
      "slon",
      "sloupek",
      "slovo",
      "sluch",
      "sluha",
      "slunce",
      "slupka",
      "slza",
      "smaragd",
      "smetana",
      "smilstvo",
      "smlouva",
      "smog",
      "smrad",
      "smrk",
      "smrtka",
      "smutek",
      "smysl",
      "snad",
      "snaha",
      "snob",
      "sobota",
      "socha",
      "sodovka",
      "sokol",
      "sopka",
      "sotva",
      "souboj",
      "soucit",
      "soudce",
      "souhlas",
      "soulad",
      "soumrak",
      "souprava",
      "soused",
      "soutok",
      "souviset",
      "spalovna",
      "spasitel",
      "spis",
      "splav",
      "spodek",
      "spojenec",
      "spolu",
      "sponzor",
      "spornost",
      "spousta",
      "sprcha",
      "spustit",
      "sranda",
      "sraz",
      "srdce",
      "srna",
      "srnec",
      "srovnat",
      "srpen",
      "srst",
      "srub",
      "stanice",
      "starosta",
      "statika",
      "stavba",
      "stehno",
      "stezka",
      "stodola",
      "stolek",
      "stopa",
      "storno",
      "stoupat",
      "strach",
      "stres",
      "strhnout",
      "strom",
      "struna",
      "studna",
      "stupnice",
      "stvol",
      "styk",
      "subjekt",
      "subtropy",
      "suchar",
      "sudost",
      "sukno",
      "sundat",
      "sunout",
      "surikata",
      "surovina",
      "svah",
      "svalstvo",
      "svetr",
      "svatba",
      "svazek",
      "svisle",
      "svitek",
      "svoboda",
      "svodidlo",
      "svorka",
      "svrab",
      "sykavka",
      "sykot",
      "synek",
      "synovec",
      "sypat",
      "sypkost",
      "syrovost",
      "sysel",
      "sytost",
      "tabletka",
      "tabule",
      "tahoun",
      "tajemno",
      "tajfun",
      "tajga",
      "tajit",
      "tajnost",
      "taktika",
      "tamhle",
      "tampon",
      "tancovat",
      "tanec",
      "tanker",
      "tapeta",
      "tavenina",
      "tazatel",
      "technika",
      "tehdy",
      "tekutina",
      "telefon",
      "temnota",
      "tendence",
      "tenista",
      "tenor",
      "teplota",
      "tepna",
      "teprve",
      "terapie",
      "termoska",
      "textil",
      "ticho",
      "tiskopis",
      "titulek",
      "tkadlec",
      "tkanina",
      "tlapka",
      "tleskat",
      "tlukot",
      "tlupa",
      "tmel",
      "toaleta",
      "topinka",
      "topol",
      "torzo",
      "touha",
      "toulec",
      "tradice",
      "traktor",
      "tramp",
      "trasa",
      "traverza",
      "trefit",
      "trest",
      "trezor",
      "trhavina",
      "trhlina",
      "trochu",
      "trojice",
      "troska",
      "trouba",
      "trpce",
      "trpitel",
      "trpkost",
      "trubec",
      "truchlit",
      "truhlice",
      "trus",
      "trvat",
      "tudy",
      "tuhnout",
      "tuhost",
      "tundra",
      "turista",
      "turnaj",
      "tuzemsko",
      "tvaroh",
      "tvorba",
      "tvrdost",
      "tvrz",
      "tygr",
      "tykev",
      "ubohost",
      "uboze",
      "ubrat",
      "ubrousek",
      "ubrus",
      "ubytovna",
      "ucho",
      "uctivost",
      "udivit",
      "uhradit",
      "ujednat",
      "ujistit",
      "ujmout",
      "ukazatel",
      "uklidnit",
      "uklonit",
      "ukotvit",
      "ukrojit",
      "ulice",
      "ulita",
      "ulovit",
      "umyvadlo",
      "unavit",
      "uniforma",
      "uniknout",
      "upadnout",
      "uplatnit",
      "uplynout",
      "upoutat",
      "upravit",
      "uran",
      "urazit",
      "usednout",
      "usilovat",
      "usmrtit",
      "usnadnit",
      "usnout",
      "usoudit",
      "ustlat",
      "ustrnout",
      "utahovat",
      "utkat",
      "utlumit",
      "utonout",
      "utopenec",
      "utrousit",
      "uvalit",
      "uvolnit",
      "uvozovka",
      "uzdravit",
      "uzel",
      "uzenina",
      "uzlina",
      "uznat",
      "vagon",
      "valcha",
      "valoun",
      "vana",
      "vandal",
      "vanilka",
      "varan",
      "varhany",
      "varovat",
      "vcelku",
      "vchod",
      "vdova",
      "vedro",
      "vegetace",
      "vejce",
      "velbloud",
      "veletrh",
      "velitel",
      "velmoc",
      "velryba",
      "venkov",
      "veranda",
      "verze",
      "veselka",
      "veskrze",
      "vesnice",
      "vespodu",
      "vesta",
      "veterina",
      "veverka",
      "vibrace",
      "vichr",
      "videohra",
      "vidina",
      "vidle",
      "vila",
      "vinice",
      "viset",
      "vitalita",
      "vize",
      "vizitka",
      "vjezd",
      "vklad",
      "vkus",
      "vlajka",
      "vlak",
      "vlasec",
      "vlevo",
      "vlhkost",
      "vliv",
      "vlnovka",
      "vloupat",
      "vnucovat",
      "vnuk",
      "voda",
      "vodivost",
      "vodoznak",
      "vodstvo",
      "vojensky",
      "vojna",
      "vojsko",
      "volant",
      "volba",
      "volit",
      "volno",
      "voskovka",
      "vozidlo",
      "vozovna",
      "vpravo",
      "vrabec",
      "vracet",
      "vrah",
      "vrata",
      "vrba",
      "vrcholek",
      "vrhat",
      "vrstva",
      "vrtule",
      "vsadit",
      "vstoupit",
      "vstup",
      "vtip",
      "vybavit",
      "vybrat",
      "vychovat",
      "vydat",
      "vydra",
      "vyfotit",
      "vyhledat",
      "vyhnout",
      "vyhodit",
      "vyhradit",
      "vyhubit",
      "vyjasnit",
      "vyjet",
      "vyjmout",
      "vyklopit",
      "vykonat",
      "vylekat",
      "vymazat",
      "vymezit",
      "vymizet",
      "vymyslet",
      "vynechat",
      "vynikat",
      "vynutit",
      "vypadat",
      "vyplatit",
      "vypravit",
      "vypustit",
      "vyrazit",
      "vyrovnat",
      "vyrvat",
      "vyslovit",
      "vysoko",
      "vystavit",
      "vysunout",
      "vysypat",
      "vytasit",
      "vytesat",
      "vytratit",
      "vyvinout",
      "vyvolat",
      "vyvrhel",
      "vyzdobit",
      "vyznat",
      "vzadu",
      "vzbudit",
      "vzchopit",
      "vzdor",
      "vzduch",
      "vzdychat",
      "vzestup",
      "vzhledem",
      "vzkaz",
      "vzlykat",
      "vznik",
      "vzorek",
      "vzpoura",
      "vztah",
      "vztek",
      "xylofon",
      "zabrat",
      "zabydlet",
      "zachovat",
      "zadarmo",
      "zadusit",
      "zafoukat",
      "zahltit",
      "zahodit",
      "zahrada",
      "zahynout",
      "zajatec",
      "zajet",
      "zajistit",
      "zaklepat",
      "zakoupit",
      "zalepit",
      "zamezit",
      "zamotat",
      "zamyslet",
      "zanechat",
      "zanikat",
      "zaplatit",
      "zapojit",
      "zapsat",
      "zarazit",
      "zastavit",
      "zasunout",
      "zatajit",
      "zatemnit",
      "zatknout",
      "zaujmout",
      "zavalit",
      "zavelet",
      "zavinit",
      "zavolat",
      "zavrtat",
      "zazvonit",
      "zbavit",
      "zbrusu",
      "zbudovat",
      "zbytek",
      "zdaleka",
      "zdarma",
      "zdatnost",
      "zdivo",
      "zdobit",
      "zdroj",
      "zdvih",
      "zdymadlo",
      "zelenina",
      "zeman",
      "zemina",
      "zeptat",
      "zezadu",
      "zezdola",
      "zhatit",
      "zhltnout",
      "zhluboka",
      "zhotovit",
      "zhruba",
      "zima",
      "zimnice",
      "zjemnit",
      "zklamat",
      "zkoumat",
      "zkratka",
      "zkumavka",
      "zlato",
      "zlehka",
      "zloba",
      "zlom",
      "zlost",
      "zlozvyk",
      "zmapovat",
      "zmar",
      "zmatek",
      "zmije",
      "zmizet",
      "zmocnit",
      "zmodrat",
      "zmrzlina",
      "zmutovat",
      "znak",
      "znalost",
      "znamenat",
      "znovu",
      "zobrazit",
      "zotavit",
      "zoubek",
      "zoufale",
      "zplodit",
      "zpomalit",
      "zprava",
      "zprostit",
      "zprudka",
      "zprvu",
      "zrada",
      "zranit",
      "zrcadlo",
      "zrnitost",
      "zrno",
      "zrovna",
      "zrychlit",
      "zrzavost",
      "zticha",
      "ztratit",
      "zubovina",
      "zubr",
      "zvednout",
      "zvenku",
      "zvesela",
      "zvon",
      "zvrat",
      "zvukovod",
      "zvyk"
    ];
  }
});

// ../../node_modules/bip39/src/wordlists/chinese_simplified.json
var require_chinese_simplified = __commonJS({
  "../../node_modules/bip39/src/wordlists/chinese_simplified.json"(exports2, module2) {
    module2.exports = [
      "的",
      "一",
      "是",
      "在",
      "不",
      "了",
      "有",
      "和",
      "人",
      "这",
      "中",
      "大",
      "为",
      "上",
      "个",
      "国",
      "我",
      "以",
      "要",
      "他",
      "时",
      "来",
      "用",
      "们",
      "生",
      "到",
      "作",
      "地",
      "于",
      "出",
      "就",
      "分",
      "对",
      "成",
      "会",
      "可",
      "主",
      "发",
      "年",
      "动",
      "同",
      "工",
      "也",
      "能",
      "下",
      "过",
      "子",
      "说",
      "产",
      "种",
      "面",
      "而",
      "方",
      "后",
      "多",
      "定",
      "行",
      "学",
      "法",
      "所",
      "民",
      "得",
      "经",
      "十",
      "三",
      "之",
      "进",
      "着",
      "等",
      "部",
      "度",
      "家",
      "电",
      "力",
      "里",
      "如",
      "水",
      "化",
      "高",
      "自",
      "二",
      "理",
      "起",
      "小",
      "物",
      "现",
      "实",
      "加",
      "量",
      "都",
      "两",
      "体",
      "制",
      "机",
      "当",
      "使",
      "点",
      "从",
      "业",
      "本",
      "去",
      "把",
      "性",
      "好",
      "应",
      "开",
      "它",
      "合",
      "还",
      "因",
      "由",
      "其",
      "些",
      "然",
      "前",
      "外",
      "天",
      "政",
      "四",
      "日",
      "那",
      "社",
      "义",
      "事",
      "平",
      "形",
      "相",
      "全",
      "表",
      "间",
      "样",
      "与",
      "关",
      "各",
      "重",
      "新",
      "线",
      "内",
      "数",
      "正",
      "心",
      "反",
      "你",
      "明",
      "看",
      "原",
      "又",
      "么",
      "利",
      "比",
      "或",
      "但",
      "质",
      "气",
      "第",
      "向",
      "道",
      "命",
      "此",
      "变",
      "条",
      "只",
      "没",
      "结",
      "解",
      "问",
      "意",
      "建",
      "月",
      "公",
      "无",
      "系",
      "军",
      "很",
      "情",
      "者",
      "最",
      "立",
      "代",
      "想",
      "已",
      "通",
      "并",
      "提",
      "直",
      "题",
      "党",
      "程",
      "展",
      "五",
      "果",
      "料",
      "象",
      "员",
      "革",
      "位",
      "入",
      "常",
      "文",
      "总",
      "次",
      "品",
      "式",
      "活",
      "设",
      "及",
      "管",
      "特",
      "件",
      "长",
      "求",
      "老",
      "头",
      "基",
      "资",
      "边",
      "流",
      "路",
      "级",
      "少",
      "图",
      "山",
      "统",
      "接",
      "知",
      "较",
      "将",
      "组",
      "见",
      "计",
      "别",
      "她",
      "手",
      "角",
      "期",
      "根",
      "论",
      "运",
      "农",
      "指",
      "几",
      "九",
      "区",
      "强",
      "放",
      "决",
      "西",
      "被",
      "干",
      "做",
      "必",
      "战",
      "先",
      "回",
      "则",
      "任",
      "取",
      "据",
      "处",
      "队",
      "南",
      "给",
      "色",
      "光",
      "门",
      "即",
      "保",
      "治",
      "北",
      "造",
      "百",
      "规",
      "热",
      "领",
      "七",
      "海",
      "口",
      "东",
      "导",
      "器",
      "压",
      "志",
      "世",
      "金",
      "增",
      "争",
      "济",
      "阶",
      "油",
      "思",
      "术",
      "极",
      "交",
      "受",
      "联",
      "什",
      "认",
      "六",
      "共",
      "权",
      "收",
      "证",
      "改",
      "清",
      "美",
      "再",
      "采",
      "转",
      "更",
      "单",
      "风",
      "切",
      "打",
      "白",
      "教",
      "速",
      "花",
      "带",
      "安",
      "场",
      "身",
      "车",
      "例",
      "真",
      "务",
      "具",
      "万",
      "每",
      "目",
      "至",
      "达",
      "走",
      "积",
      "示",
      "议",
      "声",
      "报",
      "斗",
      "完",
      "类",
      "八",
      "离",
      "华",
      "名",
      "确",
      "才",
      "科",
      "张",
      "信",
      "马",
      "节",
      "话",
      "米",
      "整",
      "空",
      "元",
      "况",
      "今",
      "集",
      "温",
      "传",
      "土",
      "许",
      "步",
      "群",
      "广",
      "石",
      "记",
      "需",
      "段",
      "研",
      "界",
      "拉",
      "林",
      "律",
      "叫",
      "且",
      "究",
      "观",
      "越",
      "织",
      "装",
      "影",
      "算",
      "低",
      "持",
      "音",
      "众",
      "书",
      "布",
      "复",
      "容",
      "儿",
      "须",
      "际",
      "商",
      "非",
      "验",
      "连",
      "断",
      "深",
      "难",
      "近",
      "矿",
      "千",
      "周",
      "委",
      "素",
      "技",
      "备",
      "半",
      "办",
      "青",
      "省",
      "列",
      "习",
      "响",
      "约",
      "支",
      "般",
      "史",
      "感",
      "劳",
      "便",
      "团",
      "往",
      "酸",
      "历",
      "市",
      "克",
      "何",
      "除",
      "消",
      "构",
      "府",
      "称",
      "太",
      "准",
      "精",
      "值",
      "号",
      "率",
      "族",
      "维",
      "划",
      "选",
      "标",
      "写",
      "存",
      "候",
      "毛",
      "亲",
      "快",
      "效",
      "斯",
      "院",
      "查",
      "江",
      "型",
      "眼",
      "王",
      "按",
      "格",
      "养",
      "易",
      "置",
      "派",
      "层",
      "片",
      "始",
      "却",
      "专",
      "状",
      "育",
      "厂",
      "京",
      "识",
      "适",
      "属",
      "圆",
      "包",
      "火",
      "住",
      "调",
      "满",
      "县",
      "局",
      "照",
      "参",
      "红",
      "细",
      "引",
      "听",
      "该",
      "铁",
      "价",
      "严",
      "首",
      "底",
      "液",
      "官",
      "德",
      "随",
      "病",
      "苏",
      "失",
      "尔",
      "死",
      "讲",
      "配",
      "女",
      "黄",
      "推",
      "显",
      "谈",
      "罪",
      "神",
      "艺",
      "呢",
      "席",
      "含",
      "企",
      "望",
      "密",
      "批",
      "营",
      "项",
      "防",
      "举",
      "球",
      "英",
      "氧",
      "势",
      "告",
      "李",
      "台",
      "落",
      "木",
      "帮",
      "轮",
      "破",
      "亚",
      "师",
      "围",
      "注",
      "远",
      "字",
      "材",
      "排",
      "供",
      "河",
      "态",
      "封",
      "另",
      "施",
      "减",
      "树",
      "溶",
      "怎",
      "止",
      "案",
      "言",
      "士",
      "均",
      "武",
      "固",
      "叶",
      "鱼",
      "波",
      "视",
      "仅",
      "费",
      "紧",
      "爱",
      "左",
      "章",
      "早",
      "朝",
      "害",
      "续",
      "轻",
      "服",
      "试",
      "食",
      "充",
      "兵",
      "源",
      "判",
      "护",
      "司",
      "足",
      "某",
      "练",
      "差",
      "致",
      "板",
      "田",
      "降",
      "黑",
      "犯",
      "负",
      "击",
      "范",
      "继",
      "兴",
      "似",
      "余",
      "坚",
      "曲",
      "输",
      "修",
      "故",
      "城",
      "夫",
      "够",
      "送",
      "笔",
      "船",
      "占",
      "右",
      "财",
      "吃",
      "富",
      "春",
      "职",
      "觉",
      "汉",
      "画",
      "功",
      "巴",
      "跟",
      "虽",
      "杂",
      "飞",
      "检",
      "吸",
      "助",
      "升",
      "阳",
      "互",
      "初",
      "创",
      "抗",
      "考",
      "投",
      "坏",
      "策",
      "古",
      "径",
      "换",
      "未",
      "跑",
      "留",
      "钢",
      "曾",
      "端",
      "责",
      "站",
      "简",
      "述",
      "钱",
      "副",
      "尽",
      "帝",
      "射",
      "草",
      "冲",
      "承",
      "独",
      "令",
      "限",
      "阿",
      "宣",
      "环",
      "双",
      "请",
      "超",
      "微",
      "让",
      "控",
      "州",
      "良",
      "轴",
      "找",
      "否",
      "纪",
      "益",
      "依",
      "优",
      "顶",
      "础",
      "载",
      "倒",
      "房",
      "突",
      "坐",
      "粉",
      "敌",
      "略",
      "客",
      "袁",
      "冷",
      "胜",
      "绝",
      "析",
      "块",
      "剂",
      "测",
      "丝",
      "协",
      "诉",
      "念",
      "陈",
      "仍",
      "罗",
      "盐",
      "友",
      "洋",
      "错",
      "苦",
      "夜",
      "刑",
      "移",
      "频",
      "逐",
      "靠",
      "混",
      "母",
      "短",
      "皮",
      "终",
      "聚",
      "汽",
      "村",
      "云",
      "哪",
      "既",
      "距",
      "卫",
      "停",
      "烈",
      "央",
      "察",
      "烧",
      "迅",
      "境",
      "若",
      "印",
      "洲",
      "刻",
      "括",
      "激",
      "孔",
      "搞",
      "甚",
      "室",
      "待",
      "核",
      "校",
      "散",
      "侵",
      "吧",
      "甲",
      "游",
      "久",
      "菜",
      "味",
      "旧",
      "模",
      "湖",
      "货",
      "损",
      "预",
      "阻",
      "毫",
      "普",
      "稳",
      "乙",
      "妈",
      "植",
      "息",
      "扩",
      "银",
      "语",
      "挥",
      "酒",
      "守",
      "拿",
      "序",
      "纸",
      "医",
      "缺",
      "雨",
      "吗",
      "针",
      "刘",
      "啊",
      "急",
      "唱",
      "误",
      "训",
      "愿",
      "审",
      "附",
      "获",
      "茶",
      "鲜",
      "粮",
      "斤",
      "孩",
      "脱",
      "硫",
      "肥",
      "善",
      "龙",
      "演",
      "父",
      "渐",
      "血",
      "欢",
      "械",
      "掌",
      "歌",
      "沙",
      "刚",
      "攻",
      "谓",
      "盾",
      "讨",
      "晚",
      "粒",
      "乱",
      "燃",
      "矛",
      "乎",
      "杀",
      "药",
      "宁",
      "鲁",
      "贵",
      "钟",
      "煤",
      "读",
      "班",
      "伯",
      "香",
      "介",
      "迫",
      "句",
      "丰",
      "培",
      "握",
      "兰",
      "担",
      "弦",
      "蛋",
      "沉",
      "假",
      "穿",
      "执",
      "答",
      "乐",
      "谁",
      "顺",
      "烟",
      "缩",
      "征",
      "脸",
      "喜",
      "松",
      "脚",
      "困",
      "异",
      "免",
      "背",
      "星",
      "福",
      "买",
      "染",
      "井",
      "概",
      "慢",
      "怕",
      "磁",
      "倍",
      "祖",
      "皇",
      "促",
      "静",
      "补",
      "评",
      "翻",
      "肉",
      "践",
      "尼",
      "衣",
      "宽",
      "扬",
      "棉",
      "希",
      "伤",
      "操",
      "垂",
      "秋",
      "宜",
      "氢",
      "套",
      "督",
      "振",
      "架",
      "亮",
      "末",
      "宪",
      "庆",
      "编",
      "牛",
      "触",
      "映",
      "雷",
      "销",
      "诗",
      "座",
      "居",
      "抓",
      "裂",
      "胞",
      "呼",
      "娘",
      "景",
      "威",
      "绿",
      "晶",
      "厚",
      "盟",
      "衡",
      "鸡",
      "孙",
      "延",
      "危",
      "胶",
      "屋",
      "乡",
      "临",
      "陆",
      "顾",
      "掉",
      "呀",
      "灯",
      "岁",
      "措",
      "束",
      "耐",
      "剧",
      "玉",
      "赵",
      "跳",
      "哥",
      "季",
      "课",
      "凯",
      "胡",
      "额",
      "款",
      "绍",
      "卷",
      "齐",
      "伟",
      "蒸",
      "殖",
      "永",
      "宗",
      "苗",
      "川",
      "炉",
      "岩",
      "弱",
      "零",
      "杨",
      "奏",
      "沿",
      "露",
      "杆",
      "探",
      "滑",
      "镇",
      "饭",
      "浓",
      "航",
      "怀",
      "赶",
      "库",
      "夺",
      "伊",
      "灵",
      "税",
      "途",
      "灭",
      "赛",
      "归",
      "召",
      "鼓",
      "播",
      "盘",
      "裁",
      "险",
      "康",
      "唯",
      "录",
      "菌",
      "纯",
      "借",
      "糖",
      "盖",
      "横",
      "符",
      "私",
      "努",
      "堂",
      "域",
      "枪",
      "润",
      "幅",
      "哈",
      "竟",
      "熟",
      "虫",
      "泽",
      "脑",
      "壤",
      "碳",
      "欧",
      "遍",
      "侧",
      "寨",
      "敢",
      "彻",
      "虑",
      "斜",
      "薄",
      "庭",
      "纳",
      "弹",
      "饲",
      "伸",
      "折",
      "麦",
      "湿",
      "暗",
      "荷",
      "瓦",
      "塞",
      "床",
      "筑",
      "恶",
      "户",
      "访",
      "塔",
      "奇",
      "透",
      "梁",
      "刀",
      "旋",
      "迹",
      "卡",
      "氯",
      "遇",
      "份",
      "毒",
      "泥",
      "退",
      "洗",
      "摆",
      "灰",
      "彩",
      "卖",
      "耗",
      "夏",
      "择",
      "忙",
      "铜",
      "献",
      "硬",
      "予",
      "繁",
      "圈",
      "雪",
      "函",
      "亦",
      "抽",
      "篇",
      "阵",
      "阴",
      "丁",
      "尺",
      "追",
      "堆",
      "雄",
      "迎",
      "泛",
      "爸",
      "楼",
      "避",
      "谋",
      "吨",
      "野",
      "猪",
      "旗",
      "累",
      "偏",
      "典",
      "馆",
      "索",
      "秦",
      "脂",
      "潮",
      "爷",
      "豆",
      "忽",
      "托",
      "惊",
      "塑",
      "遗",
      "愈",
      "朱",
      "替",
      "纤",
      "粗",
      "倾",
      "尚",
      "痛",
      "楚",
      "谢",
      "奋",
      "购",
      "磨",
      "君",
      "池",
      "旁",
      "碎",
      "骨",
      "监",
      "捕",
      "弟",
      "暴",
      "割",
      "贯",
      "殊",
      "释",
      "词",
      "亡",
      "壁",
      "顿",
      "宝",
      "午",
      "尘",
      "闻",
      "揭",
      "炮",
      "残",
      "冬",
      "桥",
      "妇",
      "警",
      "综",
      "招",
      "吴",
      "付",
      "浮",
      "遭",
      "徐",
      "您",
      "摇",
      "谷",
      "赞",
      "箱",
      "隔",
      "订",
      "男",
      "吹",
      "园",
      "纷",
      "唐",
      "败",
      "宋",
      "玻",
      "巨",
      "耕",
      "坦",
      "荣",
      "闭",
      "湾",
      "键",
      "凡",
      "驻",
      "锅",
      "救",
      "恩",
      "剥",
      "凝",
      "碱",
      "齿",
      "截",
      "炼",
      "麻",
      "纺",
      "禁",
      "废",
      "盛",
      "版",
      "缓",
      "净",
      "睛",
      "昌",
      "婚",
      "涉",
      "筒",
      "嘴",
      "插",
      "岸",
      "朗",
      "庄",
      "街",
      "藏",
      "姑",
      "贸",
      "腐",
      "奴",
      "啦",
      "惯",
      "乘",
      "伙",
      "恢",
      "匀",
      "纱",
      "扎",
      "辩",
      "耳",
      "彪",
      "臣",
      "亿",
      "璃",
      "抵",
      "脉",
      "秀",
      "萨",
      "俄",
      "网",
      "舞",
      "店",
      "喷",
      "纵",
      "寸",
      "汗",
      "挂",
      "洪",
      "贺",
      "闪",
      "柬",
      "爆",
      "烯",
      "津",
      "稻",
      "墙",
      "软",
      "勇",
      "像",
      "滚",
      "厘",
      "蒙",
      "芳",
      "肯",
      "坡",
      "柱",
      "荡",
      "腿",
      "仪",
      "旅",
      "尾",
      "轧",
      "冰",
      "贡",
      "登",
      "黎",
      "削",
      "钻",
      "勒",
      "逃",
      "障",
      "氨",
      "郭",
      "峰",
      "币",
      "港",
      "伏",
      "轨",
      "亩",
      "毕",
      "擦",
      "莫",
      "刺",
      "浪",
      "秘",
      "援",
      "株",
      "健",
      "售",
      "股",
      "岛",
      "甘",
      "泡",
      "睡",
      "童",
      "铸",
      "汤",
      "阀",
      "休",
      "汇",
      "舍",
      "牧",
      "绕",
      "炸",
      "哲",
      "磷",
      "绩",
      "朋",
      "淡",
      "尖",
      "启",
      "陷",
      "柴",
      "呈",
      "徒",
      "颜",
      "泪",
      "稍",
      "忘",
      "泵",
      "蓝",
      "拖",
      "洞",
      "授",
      "镜",
      "辛",
      "壮",
      "锋",
      "贫",
      "虚",
      "弯",
      "摩",
      "泰",
      "幼",
      "廷",
      "尊",
      "窗",
      "纲",
      "弄",
      "隶",
      "疑",
      "氏",
      "宫",
      "姐",
      "震",
      "瑞",
      "怪",
      "尤",
      "琴",
      "循",
      "描",
      "膜",
      "违",
      "夹",
      "腰",
      "缘",
      "珠",
      "穷",
      "森",
      "枝",
      "竹",
      "沟",
      "催",
      "绳",
      "忆",
      "邦",
      "剩",
      "幸",
      "浆",
      "栏",
      "拥",
      "牙",
      "贮",
      "礼",
      "滤",
      "钠",
      "纹",
      "罢",
      "拍",
      "咱",
      "喊",
      "袖",
      "埃",
      "勤",
      "罚",
      "焦",
      "潜",
      "伍",
      "墨",
      "欲",
      "缝",
      "姓",
      "刊",
      "饱",
      "仿",
      "奖",
      "铝",
      "鬼",
      "丽",
      "跨",
      "默",
      "挖",
      "链",
      "扫",
      "喝",
      "袋",
      "炭",
      "污",
      "幕",
      "诸",
      "弧",
      "励",
      "梅",
      "奶",
      "洁",
      "灾",
      "舟",
      "鉴",
      "苯",
      "讼",
      "抱",
      "毁",
      "懂",
      "寒",
      "智",
      "埔",
      "寄",
      "届",
      "跃",
      "渡",
      "挑",
      "丹",
      "艰",
      "贝",
      "碰",
      "拔",
      "爹",
      "戴",
      "码",
      "梦",
      "芽",
      "熔",
      "赤",
      "渔",
      "哭",
      "敬",
      "颗",
      "奔",
      "铅",
      "仲",
      "虎",
      "稀",
      "妹",
      "乏",
      "珍",
      "申",
      "桌",
      "遵",
      "允",
      "隆",
      "螺",
      "仓",
      "魏",
      "锐",
      "晓",
      "氮",
      "兼",
      "隐",
      "碍",
      "赫",
      "拨",
      "忠",
      "肃",
      "缸",
      "牵",
      "抢",
      "博",
      "巧",
      "壳",
      "兄",
      "杜",
      "讯",
      "诚",
      "碧",
      "祥",
      "柯",
      "页",
      "巡",
      "矩",
      "悲",
      "灌",
      "龄",
      "伦",
      "票",
      "寻",
      "桂",
      "铺",
      "圣",
      "恐",
      "恰",
      "郑",
      "趣",
      "抬",
      "荒",
      "腾",
      "贴",
      "柔",
      "滴",
      "猛",
      "阔",
      "辆",
      "妻",
      "填",
      "撤",
      "储",
      "签",
      "闹",
      "扰",
      "紫",
      "砂",
      "递",
      "戏",
      "吊",
      "陶",
      "伐",
      "喂",
      "疗",
      "瓶",
      "婆",
      "抚",
      "臂",
      "摸",
      "忍",
      "虾",
      "蜡",
      "邻",
      "胸",
      "巩",
      "挤",
      "偶",
      "弃",
      "槽",
      "劲",
      "乳",
      "邓",
      "吉",
      "仁",
      "烂",
      "砖",
      "租",
      "乌",
      "舰",
      "伴",
      "瓜",
      "浅",
      "丙",
      "暂",
      "燥",
      "橡",
      "柳",
      "迷",
      "暖",
      "牌",
      "秧",
      "胆",
      "详",
      "簧",
      "踏",
      "瓷",
      "谱",
      "呆",
      "宾",
      "糊",
      "洛",
      "辉",
      "愤",
      "竞",
      "隙",
      "怒",
      "粘",
      "乃",
      "绪",
      "肩",
      "籍",
      "敏",
      "涂",
      "熙",
      "皆",
      "侦",
      "悬",
      "掘",
      "享",
      "纠",
      "醒",
      "狂",
      "锁",
      "淀",
      "恨",
      "牲",
      "霸",
      "爬",
      "赏",
      "逆",
      "玩",
      "陵",
      "祝",
      "秒",
      "浙",
      "貌",
      "役",
      "彼",
      "悉",
      "鸭",
      "趋",
      "凤",
      "晨",
      "畜",
      "辈",
      "秩",
      "卵",
      "署",
      "梯",
      "炎",
      "滩",
      "棋",
      "驱",
      "筛",
      "峡",
      "冒",
      "啥",
      "寿",
      "译",
      "浸",
      "泉",
      "帽",
      "迟",
      "硅",
      "疆",
      "贷",
      "漏",
      "稿",
      "冠",
      "嫩",
      "胁",
      "芯",
      "牢",
      "叛",
      "蚀",
      "奥",
      "鸣",
      "岭",
      "羊",
      "凭",
      "串",
      "塘",
      "绘",
      "酵",
      "融",
      "盆",
      "锡",
      "庙",
      "筹",
      "冻",
      "辅",
      "摄",
      "袭",
      "筋",
      "拒",
      "僚",
      "旱",
      "钾",
      "鸟",
      "漆",
      "沈",
      "眉",
      "疏",
      "添",
      "棒",
      "穗",
      "硝",
      "韩",
      "逼",
      "扭",
      "侨",
      "凉",
      "挺",
      "碗",
      "栽",
      "炒",
      "杯",
      "患",
      "馏",
      "劝",
      "豪",
      "辽",
      "勃",
      "鸿",
      "旦",
      "吏",
      "拜",
      "狗",
      "埋",
      "辊",
      "掩",
      "饮",
      "搬",
      "骂",
      "辞",
      "勾",
      "扣",
      "估",
      "蒋",
      "绒",
      "雾",
      "丈",
      "朵",
      "姆",
      "拟",
      "宇",
      "辑",
      "陕",
      "雕",
      "偿",
      "蓄",
      "崇",
      "剪",
      "倡",
      "厅",
      "咬",
      "驶",
      "薯",
      "刷",
      "斥",
      "番",
      "赋",
      "奉",
      "佛",
      "浇",
      "漫",
      "曼",
      "扇",
      "钙",
      "桃",
      "扶",
      "仔",
      "返",
      "俗",
      "亏",
      "腔",
      "鞋",
      "棱",
      "覆",
      "框",
      "悄",
      "叔",
      "撞",
      "骗",
      "勘",
      "旺",
      "沸",
      "孤",
      "吐",
      "孟",
      "渠",
      "屈",
      "疾",
      "妙",
      "惜",
      "仰",
      "狠",
      "胀",
      "谐",
      "抛",
      "霉",
      "桑",
      "岗",
      "嘛",
      "衰",
      "盗",
      "渗",
      "脏",
      "赖",
      "涌",
      "甜",
      "曹",
      "阅",
      "肌",
      "哩",
      "厉",
      "烃",
      "纬",
      "毅",
      "昨",
      "伪",
      "症",
      "煮",
      "叹",
      "钉",
      "搭",
      "茎",
      "笼",
      "酷",
      "偷",
      "弓",
      "锥",
      "恒",
      "杰",
      "坑",
      "鼻",
      "翼",
      "纶",
      "叙",
      "狱",
      "逮",
      "罐",
      "络",
      "棚",
      "抑",
      "膨",
      "蔬",
      "寺",
      "骤",
      "穆",
      "冶",
      "枯",
      "册",
      "尸",
      "凸",
      "绅",
      "坯",
      "牺",
      "焰",
      "轰",
      "欣",
      "晋",
      "瘦",
      "御",
      "锭",
      "锦",
      "丧",
      "旬",
      "锻",
      "垄",
      "搜",
      "扑",
      "邀",
      "亭",
      "酯",
      "迈",
      "舒",
      "脆",
      "酶",
      "闲",
      "忧",
      "酚",
      "顽",
      "羽",
      "涨",
      "卸",
      "仗",
      "陪",
      "辟",
      "惩",
      "杭",
      "姚",
      "肚",
      "捉",
      "飘",
      "漂",
      "昆",
      "欺",
      "吾",
      "郎",
      "烷",
      "汁",
      "呵",
      "饰",
      "萧",
      "雅",
      "邮",
      "迁",
      "燕",
      "撒",
      "姻",
      "赴",
      "宴",
      "烦",
      "债",
      "帐",
      "斑",
      "铃",
      "旨",
      "醇",
      "董",
      "饼",
      "雏",
      "姿",
      "拌",
      "傅",
      "腹",
      "妥",
      "揉",
      "贤",
      "拆",
      "歪",
      "葡",
      "胺",
      "丢",
      "浩",
      "徽",
      "昂",
      "垫",
      "挡",
      "览",
      "贪",
      "慰",
      "缴",
      "汪",
      "慌",
      "冯",
      "诺",
      "姜",
      "谊",
      "凶",
      "劣",
      "诬",
      "耀",
      "昏",
      "躺",
      "盈",
      "骑",
      "乔",
      "溪",
      "丛",
      "卢",
      "抹",
      "闷",
      "咨",
      "刮",
      "驾",
      "缆",
      "悟",
      "摘",
      "铒",
      "掷",
      "颇",
      "幻",
      "柄",
      "惠",
      "惨",
      "佳",
      "仇",
      "腊",
      "窝",
      "涤",
      "剑",
      "瞧",
      "堡",
      "泼",
      "葱",
      "罩",
      "霍",
      "捞",
      "胎",
      "苍",
      "滨",
      "俩",
      "捅",
      "湘",
      "砍",
      "霞",
      "邵",
      "萄",
      "疯",
      "淮",
      "遂",
      "熊",
      "粪",
      "烘",
      "宿",
      "档",
      "戈",
      "驳",
      "嫂",
      "裕",
      "徙",
      "箭",
      "捐",
      "肠",
      "撑",
      "晒",
      "辨",
      "殿",
      "莲",
      "摊",
      "搅",
      "酱",
      "屏",
      "疫",
      "哀",
      "蔡",
      "堵",
      "沫",
      "皱",
      "畅",
      "叠",
      "阁",
      "莱",
      "敲",
      "辖",
      "钩",
      "痕",
      "坝",
      "巷",
      "饿",
      "祸",
      "丘",
      "玄",
      "溜",
      "曰",
      "逻",
      "彭",
      "尝",
      "卿",
      "妨",
      "艇",
      "吞",
      "韦",
      "怨",
      "矮",
      "歇"
    ];
  }
});

// ../../node_modules/bip39/src/wordlists/chinese_traditional.json
var require_chinese_traditional = __commonJS({
  "../../node_modules/bip39/src/wordlists/chinese_traditional.json"(exports2, module2) {
    module2.exports = [
      "的",
      "一",
      "是",
      "在",
      "不",
      "了",
      "有",
      "和",
      "人",
      "這",
      "中",
      "大",
      "為",
      "上",
      "個",
      "國",
      "我",
      "以",
      "要",
      "他",
      "時",
      "來",
      "用",
      "們",
      "生",
      "到",
      "作",
      "地",
      "於",
      "出",
      "就",
      "分",
      "對",
      "成",
      "會",
      "可",
      "主",
      "發",
      "年",
      "動",
      "同",
      "工",
      "也",
      "能",
      "下",
      "過",
      "子",
      "說",
      "產",
      "種",
      "面",
      "而",
      "方",
      "後",
      "多",
      "定",
      "行",
      "學",
      "法",
      "所",
      "民",
      "得",
      "經",
      "十",
      "三",
      "之",
      "進",
      "著",
      "等",
      "部",
      "度",
      "家",
      "電",
      "力",
      "裡",
      "如",
      "水",
      "化",
      "高",
      "自",
      "二",
      "理",
      "起",
      "小",
      "物",
      "現",
      "實",
      "加",
      "量",
      "都",
      "兩",
      "體",
      "制",
      "機",
      "當",
      "使",
      "點",
      "從",
      "業",
      "本",
      "去",
      "把",
      "性",
      "好",
      "應",
      "開",
      "它",
      "合",
      "還",
      "因",
      "由",
      "其",
      "些",
      "然",
      "前",
      "外",
      "天",
      "政",
      "四",
      "日",
      "那",
      "社",
      "義",
      "事",
      "平",
      "形",
      "相",
      "全",
      "表",
      "間",
      "樣",
      "與",
      "關",
      "各",
      "重",
      "新",
      "線",
      "內",
      "數",
      "正",
      "心",
      "反",
      "你",
      "明",
      "看",
      "原",
      "又",
      "麼",
      "利",
      "比",
      "或",
      "但",
      "質",
      "氣",
      "第",
      "向",
      "道",
      "命",
      "此",
      "變",
      "條",
      "只",
      "沒",
      "結",
      "解",
      "問",
      "意",
      "建",
      "月",
      "公",
      "無",
      "系",
      "軍",
      "很",
      "情",
      "者",
      "最",
      "立",
      "代",
      "想",
      "已",
      "通",
      "並",
      "提",
      "直",
      "題",
      "黨",
      "程",
      "展",
      "五",
      "果",
      "料",
      "象",
      "員",
      "革",
      "位",
      "入",
      "常",
      "文",
      "總",
      "次",
      "品",
      "式",
      "活",
      "設",
      "及",
      "管",
      "特",
      "件",
      "長",
      "求",
      "老",
      "頭",
      "基",
      "資",
      "邊",
      "流",
      "路",
      "級",
      "少",
      "圖",
      "山",
      "統",
      "接",
      "知",
      "較",
      "將",
      "組",
      "見",
      "計",
      "別",
      "她",
      "手",
      "角",
      "期",
      "根",
      "論",
      "運",
      "農",
      "指",
      "幾",
      "九",
      "區",
      "強",
      "放",
      "決",
      "西",
      "被",
      "幹",
      "做",
      "必",
      "戰",
      "先",
      "回",
      "則",
      "任",
      "取",
      "據",
      "處",
      "隊",
      "南",
      "給",
      "色",
      "光",
      "門",
      "即",
      "保",
      "治",
      "北",
      "造",
      "百",
      "規",
      "熱",
      "領",
      "七",
      "海",
      "口",
      "東",
      "導",
      "器",
      "壓",
      "志",
      "世",
      "金",
      "增",
      "爭",
      "濟",
      "階",
      "油",
      "思",
      "術",
      "極",
      "交",
      "受",
      "聯",
      "什",
      "認",
      "六",
      "共",
      "權",
      "收",
      "證",
      "改",
      "清",
      "美",
      "再",
      "採",
      "轉",
      "更",
      "單",
      "風",
      "切",
      "打",
      "白",
      "教",
      "速",
      "花",
      "帶",
      "安",
      "場",
      "身",
      "車",
      "例",
      "真",
      "務",
      "具",
      "萬",
      "每",
      "目",
      "至",
      "達",
      "走",
      "積",
      "示",
      "議",
      "聲",
      "報",
      "鬥",
      "完",
      "類",
      "八",
      "離",
      "華",
      "名",
      "確",
      "才",
      "科",
      "張",
      "信",
      "馬",
      "節",
      "話",
      "米",
      "整",
      "空",
      "元",
      "況",
      "今",
      "集",
      "溫",
      "傳",
      "土",
      "許",
      "步",
      "群",
      "廣",
      "石",
      "記",
      "需",
      "段",
      "研",
      "界",
      "拉",
      "林",
      "律",
      "叫",
      "且",
      "究",
      "觀",
      "越",
      "織",
      "裝",
      "影",
      "算",
      "低",
      "持",
      "音",
      "眾",
      "書",
      "布",
      "复",
      "容",
      "兒",
      "須",
      "際",
      "商",
      "非",
      "驗",
      "連",
      "斷",
      "深",
      "難",
      "近",
      "礦",
      "千",
      "週",
      "委",
      "素",
      "技",
      "備",
      "半",
      "辦",
      "青",
      "省",
      "列",
      "習",
      "響",
      "約",
      "支",
      "般",
      "史",
      "感",
      "勞",
      "便",
      "團",
      "往",
      "酸",
      "歷",
      "市",
      "克",
      "何",
      "除",
      "消",
      "構",
      "府",
      "稱",
      "太",
      "準",
      "精",
      "值",
      "號",
      "率",
      "族",
      "維",
      "劃",
      "選",
      "標",
      "寫",
      "存",
      "候",
      "毛",
      "親",
      "快",
      "效",
      "斯",
      "院",
      "查",
      "江",
      "型",
      "眼",
      "王",
      "按",
      "格",
      "養",
      "易",
      "置",
      "派",
      "層",
      "片",
      "始",
      "卻",
      "專",
      "狀",
      "育",
      "廠",
      "京",
      "識",
      "適",
      "屬",
      "圓",
      "包",
      "火",
      "住",
      "調",
      "滿",
      "縣",
      "局",
      "照",
      "參",
      "紅",
      "細",
      "引",
      "聽",
      "該",
      "鐵",
      "價",
      "嚴",
      "首",
      "底",
      "液",
      "官",
      "德",
      "隨",
      "病",
      "蘇",
      "失",
      "爾",
      "死",
      "講",
      "配",
      "女",
      "黃",
      "推",
      "顯",
      "談",
      "罪",
      "神",
      "藝",
      "呢",
      "席",
      "含",
      "企",
      "望",
      "密",
      "批",
      "營",
      "項",
      "防",
      "舉",
      "球",
      "英",
      "氧",
      "勢",
      "告",
      "李",
      "台",
      "落",
      "木",
      "幫",
      "輪",
      "破",
      "亞",
      "師",
      "圍",
      "注",
      "遠",
      "字",
      "材",
      "排",
      "供",
      "河",
      "態",
      "封",
      "另",
      "施",
      "減",
      "樹",
      "溶",
      "怎",
      "止",
      "案",
      "言",
      "士",
      "均",
      "武",
      "固",
      "葉",
      "魚",
      "波",
      "視",
      "僅",
      "費",
      "緊",
      "愛",
      "左",
      "章",
      "早",
      "朝",
      "害",
      "續",
      "輕",
      "服",
      "試",
      "食",
      "充",
      "兵",
      "源",
      "判",
      "護",
      "司",
      "足",
      "某",
      "練",
      "差",
      "致",
      "板",
      "田",
      "降",
      "黑",
      "犯",
      "負",
      "擊",
      "范",
      "繼",
      "興",
      "似",
      "餘",
      "堅",
      "曲",
      "輸",
      "修",
      "故",
      "城",
      "夫",
      "夠",
      "送",
      "筆",
      "船",
      "佔",
      "右",
      "財",
      "吃",
      "富",
      "春",
      "職",
      "覺",
      "漢",
      "畫",
      "功",
      "巴",
      "跟",
      "雖",
      "雜",
      "飛",
      "檢",
      "吸",
      "助",
      "昇",
      "陽",
      "互",
      "初",
      "創",
      "抗",
      "考",
      "投",
      "壞",
      "策",
      "古",
      "徑",
      "換",
      "未",
      "跑",
      "留",
      "鋼",
      "曾",
      "端",
      "責",
      "站",
      "簡",
      "述",
      "錢",
      "副",
      "盡",
      "帝",
      "射",
      "草",
      "衝",
      "承",
      "獨",
      "令",
      "限",
      "阿",
      "宣",
      "環",
      "雙",
      "請",
      "超",
      "微",
      "讓",
      "控",
      "州",
      "良",
      "軸",
      "找",
      "否",
      "紀",
      "益",
      "依",
      "優",
      "頂",
      "礎",
      "載",
      "倒",
      "房",
      "突",
      "坐",
      "粉",
      "敵",
      "略",
      "客",
      "袁",
      "冷",
      "勝",
      "絕",
      "析",
      "塊",
      "劑",
      "測",
      "絲",
      "協",
      "訴",
      "念",
      "陳",
      "仍",
      "羅",
      "鹽",
      "友",
      "洋",
      "錯",
      "苦",
      "夜",
      "刑",
      "移",
      "頻",
      "逐",
      "靠",
      "混",
      "母",
      "短",
      "皮",
      "終",
      "聚",
      "汽",
      "村",
      "雲",
      "哪",
      "既",
      "距",
      "衛",
      "停",
      "烈",
      "央",
      "察",
      "燒",
      "迅",
      "境",
      "若",
      "印",
      "洲",
      "刻",
      "括",
      "激",
      "孔",
      "搞",
      "甚",
      "室",
      "待",
      "核",
      "校",
      "散",
      "侵",
      "吧",
      "甲",
      "遊",
      "久",
      "菜",
      "味",
      "舊",
      "模",
      "湖",
      "貨",
      "損",
      "預",
      "阻",
      "毫",
      "普",
      "穩",
      "乙",
      "媽",
      "植",
      "息",
      "擴",
      "銀",
      "語",
      "揮",
      "酒",
      "守",
      "拿",
      "序",
      "紙",
      "醫",
      "缺",
      "雨",
      "嗎",
      "針",
      "劉",
      "啊",
      "急",
      "唱",
      "誤",
      "訓",
      "願",
      "審",
      "附",
      "獲",
      "茶",
      "鮮",
      "糧",
      "斤",
      "孩",
      "脫",
      "硫",
      "肥",
      "善",
      "龍",
      "演",
      "父",
      "漸",
      "血",
      "歡",
      "械",
      "掌",
      "歌",
      "沙",
      "剛",
      "攻",
      "謂",
      "盾",
      "討",
      "晚",
      "粒",
      "亂",
      "燃",
      "矛",
      "乎",
      "殺",
      "藥",
      "寧",
      "魯",
      "貴",
      "鐘",
      "煤",
      "讀",
      "班",
      "伯",
      "香",
      "介",
      "迫",
      "句",
      "豐",
      "培",
      "握",
      "蘭",
      "擔",
      "弦",
      "蛋",
      "沉",
      "假",
      "穿",
      "執",
      "答",
      "樂",
      "誰",
      "順",
      "煙",
      "縮",
      "徵",
      "臉",
      "喜",
      "松",
      "腳",
      "困",
      "異",
      "免",
      "背",
      "星",
      "福",
      "買",
      "染",
      "井",
      "概",
      "慢",
      "怕",
      "磁",
      "倍",
      "祖",
      "皇",
      "促",
      "靜",
      "補",
      "評",
      "翻",
      "肉",
      "踐",
      "尼",
      "衣",
      "寬",
      "揚",
      "棉",
      "希",
      "傷",
      "操",
      "垂",
      "秋",
      "宜",
      "氫",
      "套",
      "督",
      "振",
      "架",
      "亮",
      "末",
      "憲",
      "慶",
      "編",
      "牛",
      "觸",
      "映",
      "雷",
      "銷",
      "詩",
      "座",
      "居",
      "抓",
      "裂",
      "胞",
      "呼",
      "娘",
      "景",
      "威",
      "綠",
      "晶",
      "厚",
      "盟",
      "衡",
      "雞",
      "孫",
      "延",
      "危",
      "膠",
      "屋",
      "鄉",
      "臨",
      "陸",
      "顧",
      "掉",
      "呀",
      "燈",
      "歲",
      "措",
      "束",
      "耐",
      "劇",
      "玉",
      "趙",
      "跳",
      "哥",
      "季",
      "課",
      "凱",
      "胡",
      "額",
      "款",
      "紹",
      "卷",
      "齊",
      "偉",
      "蒸",
      "殖",
      "永",
      "宗",
      "苗",
      "川",
      "爐",
      "岩",
      "弱",
      "零",
      "楊",
      "奏",
      "沿",
      "露",
      "桿",
      "探",
      "滑",
      "鎮",
      "飯",
      "濃",
      "航",
      "懷",
      "趕",
      "庫",
      "奪",
      "伊",
      "靈",
      "稅",
      "途",
      "滅",
      "賽",
      "歸",
      "召",
      "鼓",
      "播",
      "盤",
      "裁",
      "險",
      "康",
      "唯",
      "錄",
      "菌",
      "純",
      "借",
      "糖",
      "蓋",
      "橫",
      "符",
      "私",
      "努",
      "堂",
      "域",
      "槍",
      "潤",
      "幅",
      "哈",
      "竟",
      "熟",
      "蟲",
      "澤",
      "腦",
      "壤",
      "碳",
      "歐",
      "遍",
      "側",
      "寨",
      "敢",
      "徹",
      "慮",
      "斜",
      "薄",
      "庭",
      "納",
      "彈",
      "飼",
      "伸",
      "折",
      "麥",
      "濕",
      "暗",
      "荷",
      "瓦",
      "塞",
      "床",
      "築",
      "惡",
      "戶",
      "訪",
      "塔",
      "奇",
      "透",
      "梁",
      "刀",
      "旋",
      "跡",
      "卡",
      "氯",
      "遇",
      "份",
      "毒",
      "泥",
      "退",
      "洗",
      "擺",
      "灰",
      "彩",
      "賣",
      "耗",
      "夏",
      "擇",
      "忙",
      "銅",
      "獻",
      "硬",
      "予",
      "繁",
      "圈",
      "雪",
      "函",
      "亦",
      "抽",
      "篇",
      "陣",
      "陰",
      "丁",
      "尺",
      "追",
      "堆",
      "雄",
      "迎",
      "泛",
      "爸",
      "樓",
      "避",
      "謀",
      "噸",
      "野",
      "豬",
      "旗",
      "累",
      "偏",
      "典",
      "館",
      "索",
      "秦",
      "脂",
      "潮",
      "爺",
      "豆",
      "忽",
      "托",
      "驚",
      "塑",
      "遺",
      "愈",
      "朱",
      "替",
      "纖",
      "粗",
      "傾",
      "尚",
      "痛",
      "楚",
      "謝",
      "奮",
      "購",
      "磨",
      "君",
      "池",
      "旁",
      "碎",
      "骨",
      "監",
      "捕",
      "弟",
      "暴",
      "割",
      "貫",
      "殊",
      "釋",
      "詞",
      "亡",
      "壁",
      "頓",
      "寶",
      "午",
      "塵",
      "聞",
      "揭",
      "炮",
      "殘",
      "冬",
      "橋",
      "婦",
      "警",
      "綜",
      "招",
      "吳",
      "付",
      "浮",
      "遭",
      "徐",
      "您",
      "搖",
      "谷",
      "贊",
      "箱",
      "隔",
      "訂",
      "男",
      "吹",
      "園",
      "紛",
      "唐",
      "敗",
      "宋",
      "玻",
      "巨",
      "耕",
      "坦",
      "榮",
      "閉",
      "灣",
      "鍵",
      "凡",
      "駐",
      "鍋",
      "救",
      "恩",
      "剝",
      "凝",
      "鹼",
      "齒",
      "截",
      "煉",
      "麻",
      "紡",
      "禁",
      "廢",
      "盛",
      "版",
      "緩",
      "淨",
      "睛",
      "昌",
      "婚",
      "涉",
      "筒",
      "嘴",
      "插",
      "岸",
      "朗",
      "莊",
      "街",
      "藏",
      "姑",
      "貿",
      "腐",
      "奴",
      "啦",
      "慣",
      "乘",
      "夥",
      "恢",
      "勻",
      "紗",
      "扎",
      "辯",
      "耳",
      "彪",
      "臣",
      "億",
      "璃",
      "抵",
      "脈",
      "秀",
      "薩",
      "俄",
      "網",
      "舞",
      "店",
      "噴",
      "縱",
      "寸",
      "汗",
      "掛",
      "洪",
      "賀",
      "閃",
      "柬",
      "爆",
      "烯",
      "津",
      "稻",
      "牆",
      "軟",
      "勇",
      "像",
      "滾",
      "厘",
      "蒙",
      "芳",
      "肯",
      "坡",
      "柱",
      "盪",
      "腿",
      "儀",
      "旅",
      "尾",
      "軋",
      "冰",
      "貢",
      "登",
      "黎",
      "削",
      "鑽",
      "勒",
      "逃",
      "障",
      "氨",
      "郭",
      "峰",
      "幣",
      "港",
      "伏",
      "軌",
      "畝",
      "畢",
      "擦",
      "莫",
      "刺",
      "浪",
      "秘",
      "援",
      "株",
      "健",
      "售",
      "股",
      "島",
      "甘",
      "泡",
      "睡",
      "童",
      "鑄",
      "湯",
      "閥",
      "休",
      "匯",
      "舍",
      "牧",
      "繞",
      "炸",
      "哲",
      "磷",
      "績",
      "朋",
      "淡",
      "尖",
      "啟",
      "陷",
      "柴",
      "呈",
      "徒",
      "顏",
      "淚",
      "稍",
      "忘",
      "泵",
      "藍",
      "拖",
      "洞",
      "授",
      "鏡",
      "辛",
      "壯",
      "鋒",
      "貧",
      "虛",
      "彎",
      "摩",
      "泰",
      "幼",
      "廷",
      "尊",
      "窗",
      "綱",
      "弄",
      "隸",
      "疑",
      "氏",
      "宮",
      "姐",
      "震",
      "瑞",
      "怪",
      "尤",
      "琴",
      "循",
      "描",
      "膜",
      "違",
      "夾",
      "腰",
      "緣",
      "珠",
      "窮",
      "森",
      "枝",
      "竹",
      "溝",
      "催",
      "繩",
      "憶",
      "邦",
      "剩",
      "幸",
      "漿",
      "欄",
      "擁",
      "牙",
      "貯",
      "禮",
      "濾",
      "鈉",
      "紋",
      "罷",
      "拍",
      "咱",
      "喊",
      "袖",
      "埃",
      "勤",
      "罰",
      "焦",
      "潛",
      "伍",
      "墨",
      "欲",
      "縫",
      "姓",
      "刊",
      "飽",
      "仿",
      "獎",
      "鋁",
      "鬼",
      "麗",
      "跨",
      "默",
      "挖",
      "鏈",
      "掃",
      "喝",
      "袋",
      "炭",
      "污",
      "幕",
      "諸",
      "弧",
      "勵",
      "梅",
      "奶",
      "潔",
      "災",
      "舟",
      "鑑",
      "苯",
      "訟",
      "抱",
      "毀",
      "懂",
      "寒",
      "智",
      "埔",
      "寄",
      "屆",
      "躍",
      "渡",
      "挑",
      "丹",
      "艱",
      "貝",
      "碰",
      "拔",
      "爹",
      "戴",
      "碼",
      "夢",
      "芽",
      "熔",
      "赤",
      "漁",
      "哭",
      "敬",
      "顆",
      "奔",
      "鉛",
      "仲",
      "虎",
      "稀",
      "妹",
      "乏",
      "珍",
      "申",
      "桌",
      "遵",
      "允",
      "隆",
      "螺",
      "倉",
      "魏",
      "銳",
      "曉",
      "氮",
      "兼",
      "隱",
      "礙",
      "赫",
      "撥",
      "忠",
      "肅",
      "缸",
      "牽",
      "搶",
      "博",
      "巧",
      "殼",
      "兄",
      "杜",
      "訊",
      "誠",
      "碧",
      "祥",
      "柯",
      "頁",
      "巡",
      "矩",
      "悲",
      "灌",
      "齡",
      "倫",
      "票",
      "尋",
      "桂",
      "鋪",
      "聖",
      "恐",
      "恰",
      "鄭",
      "趣",
      "抬",
      "荒",
      "騰",
      "貼",
      "柔",
      "滴",
      "猛",
      "闊",
      "輛",
      "妻",
      "填",
      "撤",
      "儲",
      "簽",
      "鬧",
      "擾",
      "紫",
      "砂",
      "遞",
      "戲",
      "吊",
      "陶",
      "伐",
      "餵",
      "療",
      "瓶",
      "婆",
      "撫",
      "臂",
      "摸",
      "忍",
      "蝦",
      "蠟",
      "鄰",
      "胸",
      "鞏",
      "擠",
      "偶",
      "棄",
      "槽",
      "勁",
      "乳",
      "鄧",
      "吉",
      "仁",
      "爛",
      "磚",
      "租",
      "烏",
      "艦",
      "伴",
      "瓜",
      "淺",
      "丙",
      "暫",
      "燥",
      "橡",
      "柳",
      "迷",
      "暖",
      "牌",
      "秧",
      "膽",
      "詳",
      "簧",
      "踏",
      "瓷",
      "譜",
      "呆",
      "賓",
      "糊",
      "洛",
      "輝",
      "憤",
      "競",
      "隙",
      "怒",
      "粘",
      "乃",
      "緒",
      "肩",
      "籍",
      "敏",
      "塗",
      "熙",
      "皆",
      "偵",
      "懸",
      "掘",
      "享",
      "糾",
      "醒",
      "狂",
      "鎖",
      "淀",
      "恨",
      "牲",
      "霸",
      "爬",
      "賞",
      "逆",
      "玩",
      "陵",
      "祝",
      "秒",
      "浙",
      "貌",
      "役",
      "彼",
      "悉",
      "鴨",
      "趨",
      "鳳",
      "晨",
      "畜",
      "輩",
      "秩",
      "卵",
      "署",
      "梯",
      "炎",
      "灘",
      "棋",
      "驅",
      "篩",
      "峽",
      "冒",
      "啥",
      "壽",
      "譯",
      "浸",
      "泉",
      "帽",
      "遲",
      "矽",
      "疆",
      "貸",
      "漏",
      "稿",
      "冠",
      "嫩",
      "脅",
      "芯",
      "牢",
      "叛",
      "蝕",
      "奧",
      "鳴",
      "嶺",
      "羊",
      "憑",
      "串",
      "塘",
      "繪",
      "酵",
      "融",
      "盆",
      "錫",
      "廟",
      "籌",
      "凍",
      "輔",
      "攝",
      "襲",
      "筋",
      "拒",
      "僚",
      "旱",
      "鉀",
      "鳥",
      "漆",
      "沈",
      "眉",
      "疏",
      "添",
      "棒",
      "穗",
      "硝",
      "韓",
      "逼",
      "扭",
      "僑",
      "涼",
      "挺",
      "碗",
      "栽",
      "炒",
      "杯",
      "患",
      "餾",
      "勸",
      "豪",
      "遼",
      "勃",
      "鴻",
      "旦",
      "吏",
      "拜",
      "狗",
      "埋",
      "輥",
      "掩",
      "飲",
      "搬",
      "罵",
      "辭",
      "勾",
      "扣",
      "估",
      "蔣",
      "絨",
      "霧",
      "丈",
      "朵",
      "姆",
      "擬",
      "宇",
      "輯",
      "陝",
      "雕",
      "償",
      "蓄",
      "崇",
      "剪",
      "倡",
      "廳",
      "咬",
      "駛",
      "薯",
      "刷",
      "斥",
      "番",
      "賦",
      "奉",
      "佛",
      "澆",
      "漫",
      "曼",
      "扇",
      "鈣",
      "桃",
      "扶",
      "仔",
      "返",
      "俗",
      "虧",
      "腔",
      "鞋",
      "棱",
      "覆",
      "框",
      "悄",
      "叔",
      "撞",
      "騙",
      "勘",
      "旺",
      "沸",
      "孤",
      "吐",
      "孟",
      "渠",
      "屈",
      "疾",
      "妙",
      "惜",
      "仰",
      "狠",
      "脹",
      "諧",
      "拋",
      "黴",
      "桑",
      "崗",
      "嘛",
      "衰",
      "盜",
      "滲",
      "臟",
      "賴",
      "湧",
      "甜",
      "曹",
      "閱",
      "肌",
      "哩",
      "厲",
      "烴",
      "緯",
      "毅",
      "昨",
      "偽",
      "症",
      "煮",
      "嘆",
      "釘",
      "搭",
      "莖",
      "籠",
      "酷",
      "偷",
      "弓",
      "錐",
      "恆",
      "傑",
      "坑",
      "鼻",
      "翼",
      "綸",
      "敘",
      "獄",
      "逮",
      "罐",
      "絡",
      "棚",
      "抑",
      "膨",
      "蔬",
      "寺",
      "驟",
      "穆",
      "冶",
      "枯",
      "冊",
      "屍",
      "凸",
      "紳",
      "坯",
      "犧",
      "焰",
      "轟",
      "欣",
      "晉",
      "瘦",
      "禦",
      "錠",
      "錦",
      "喪",
      "旬",
      "鍛",
      "壟",
      "搜",
      "撲",
      "邀",
      "亭",
      "酯",
      "邁",
      "舒",
      "脆",
      "酶",
      "閒",
      "憂",
      "酚",
      "頑",
      "羽",
      "漲",
      "卸",
      "仗",
      "陪",
      "闢",
      "懲",
      "杭",
      "姚",
      "肚",
      "捉",
      "飄",
      "漂",
      "昆",
      "欺",
      "吾",
      "郎",
      "烷",
      "汁",
      "呵",
      "飾",
      "蕭",
      "雅",
      "郵",
      "遷",
      "燕",
      "撒",
      "姻",
      "赴",
      "宴",
      "煩",
      "債",
      "帳",
      "斑",
      "鈴",
      "旨",
      "醇",
      "董",
      "餅",
      "雛",
      "姿",
      "拌",
      "傅",
      "腹",
      "妥",
      "揉",
      "賢",
      "拆",
      "歪",
      "葡",
      "胺",
      "丟",
      "浩",
      "徽",
      "昂",
      "墊",
      "擋",
      "覽",
      "貪",
      "慰",
      "繳",
      "汪",
      "慌",
      "馮",
      "諾",
      "姜",
      "誼",
      "兇",
      "劣",
      "誣",
      "耀",
      "昏",
      "躺",
      "盈",
      "騎",
      "喬",
      "溪",
      "叢",
      "盧",
      "抹",
      "悶",
      "諮",
      "刮",
      "駕",
      "纜",
      "悟",
      "摘",
      "鉺",
      "擲",
      "頗",
      "幻",
      "柄",
      "惠",
      "慘",
      "佳",
      "仇",
      "臘",
      "窩",
      "滌",
      "劍",
      "瞧",
      "堡",
      "潑",
      "蔥",
      "罩",
      "霍",
      "撈",
      "胎",
      "蒼",
      "濱",
      "倆",
      "捅",
      "湘",
      "砍",
      "霞",
      "邵",
      "萄",
      "瘋",
      "淮",
      "遂",
      "熊",
      "糞",
      "烘",
      "宿",
      "檔",
      "戈",
      "駁",
      "嫂",
      "裕",
      "徙",
      "箭",
      "捐",
      "腸",
      "撐",
      "曬",
      "辨",
      "殿",
      "蓮",
      "攤",
      "攪",
      "醬",
      "屏",
      "疫",
      "哀",
      "蔡",
      "堵",
      "沫",
      "皺",
      "暢",
      "疊",
      "閣",
      "萊",
      "敲",
      "轄",
      "鉤",
      "痕",
      "壩",
      "巷",
      "餓",
      "禍",
      "丘",
      "玄",
      "溜",
      "曰",
      "邏",
      "彭",
      "嘗",
      "卿",
      "妨",
      "艇",
      "吞",
      "韋",
      "怨",
      "矮",
      "歇"
    ];
  }
});

// ../../node_modules/bip39/src/wordlists/korean.json
var require_korean = __commonJS({
  "../../node_modules/bip39/src/wordlists/korean.json"(exports2, module2) {
    module2.exports = [
      "가격",
      "가끔",
      "가난",
      "가능",
      "가득",
      "가르침",
      "가뭄",
      "가방",
      "가상",
      "가슴",
      "가운데",
      "가을",
      "가이드",
      "가입",
      "가장",
      "가정",
      "가족",
      "가죽",
      "각오",
      "각자",
      "간격",
      "간부",
      "간섭",
      "간장",
      "간접",
      "간판",
      "갈등",
      "갈비",
      "갈색",
      "갈증",
      "감각",
      "감기",
      "감소",
      "감수성",
      "감자",
      "감정",
      "갑자기",
      "강남",
      "강당",
      "강도",
      "강력히",
      "강변",
      "강북",
      "강사",
      "강수량",
      "강아지",
      "강원도",
      "강의",
      "강제",
      "강조",
      "같이",
      "개구리",
      "개나리",
      "개방",
      "개별",
      "개선",
      "개성",
      "개인",
      "객관적",
      "거실",
      "거액",
      "거울",
      "거짓",
      "거품",
      "걱정",
      "건강",
      "건물",
      "건설",
      "건조",
      "건축",
      "걸음",
      "검사",
      "검토",
      "게시판",
      "게임",
      "겨울",
      "견해",
      "결과",
      "결국",
      "결론",
      "결석",
      "결승",
      "결심",
      "결정",
      "결혼",
      "경계",
      "경고",
      "경기",
      "경력",
      "경복궁",
      "경비",
      "경상도",
      "경영",
      "경우",
      "경쟁",
      "경제",
      "경주",
      "경찰",
      "경치",
      "경향",
      "경험",
      "계곡",
      "계단",
      "계란",
      "계산",
      "계속",
      "계약",
      "계절",
      "계층",
      "계획",
      "고객",
      "고구려",
      "고궁",
      "고급",
      "고등학생",
      "고무신",
      "고민",
      "고양이",
      "고장",
      "고전",
      "고집",
      "고춧가루",
      "고통",
      "고향",
      "곡식",
      "골목",
      "골짜기",
      "골프",
      "공간",
      "공개",
      "공격",
      "공군",
      "공급",
      "공기",
      "공동",
      "공무원",
      "공부",
      "공사",
      "공식",
      "공업",
      "공연",
      "공원",
      "공장",
      "공짜",
      "공책",
      "공통",
      "공포",
      "공항",
      "공휴일",
      "과목",
      "과일",
      "과장",
      "과정",
      "과학",
      "관객",
      "관계",
      "관광",
      "관념",
      "관람",
      "관련",
      "관리",
      "관습",
      "관심",
      "관점",
      "관찰",
      "광경",
      "광고",
      "광장",
      "광주",
      "괴로움",
      "굉장히",
      "교과서",
      "교문",
      "교복",
      "교실",
      "교양",
      "교육",
      "교장",
      "교직",
      "교통",
      "교환",
      "교훈",
      "구경",
      "구름",
      "구멍",
      "구별",
      "구분",
      "구석",
      "구성",
      "구속",
      "구역",
      "구입",
      "구청",
      "구체적",
      "국가",
      "국기",
      "국내",
      "국립",
      "국물",
      "국민",
      "국수",
      "국어",
      "국왕",
      "국적",
      "국제",
      "국회",
      "군대",
      "군사",
      "군인",
      "궁극적",
      "권리",
      "권위",
      "권투",
      "귀국",
      "귀신",
      "규정",
      "규칙",
      "균형",
      "그날",
      "그냥",
      "그늘",
      "그러나",
      "그룹",
      "그릇",
      "그림",
      "그제서야",
      "그토록",
      "극복",
      "극히",
      "근거",
      "근교",
      "근래",
      "근로",
      "근무",
      "근본",
      "근원",
      "근육",
      "근처",
      "글씨",
      "글자",
      "금강산",
      "금고",
      "금년",
      "금메달",
      "금액",
      "금연",
      "금요일",
      "금지",
      "긍정적",
      "기간",
      "기관",
      "기념",
      "기능",
      "기독교",
      "기둥",
      "기록",
      "기름",
      "기법",
      "기본",
      "기분",
      "기쁨",
      "기숙사",
      "기술",
      "기억",
      "기업",
      "기온",
      "기운",
      "기원",
      "기적",
      "기준",
      "기침",
      "기혼",
      "기획",
      "긴급",
      "긴장",
      "길이",
      "김밥",
      "김치",
      "김포공항",
      "깍두기",
      "깜빡",
      "깨달음",
      "깨소금",
      "껍질",
      "꼭대기",
      "꽃잎",
      "나들이",
      "나란히",
      "나머지",
      "나물",
      "나침반",
      "나흘",
      "낙엽",
      "난방",
      "날개",
      "날씨",
      "날짜",
      "남녀",
      "남대문",
      "남매",
      "남산",
      "남자",
      "남편",
      "남학생",
      "낭비",
      "낱말",
      "내년",
      "내용",
      "내일",
      "냄비",
      "냄새",
      "냇물",
      "냉동",
      "냉면",
      "냉방",
      "냉장고",
      "넥타이",
      "넷째",
      "노동",
      "노란색",
      "노력",
      "노인",
      "녹음",
      "녹차",
      "녹화",
      "논리",
      "논문",
      "논쟁",
      "놀이",
      "농구",
      "농담",
      "농민",
      "농부",
      "농업",
      "농장",
      "농촌",
      "높이",
      "눈동자",
      "눈물",
      "눈썹",
      "뉴욕",
      "느낌",
      "늑대",
      "능동적",
      "능력",
      "다방",
      "다양성",
      "다음",
      "다이어트",
      "다행",
      "단계",
      "단골",
      "단독",
      "단맛",
      "단순",
      "단어",
      "단위",
      "단점",
      "단체",
      "단추",
      "단편",
      "단풍",
      "달걀",
      "달러",
      "달력",
      "달리",
      "닭고기",
      "담당",
      "담배",
      "담요",
      "담임",
      "답변",
      "답장",
      "당근",
      "당분간",
      "당연히",
      "당장",
      "대규모",
      "대낮",
      "대단히",
      "대답",
      "대도시",
      "대략",
      "대량",
      "대륙",
      "대문",
      "대부분",
      "대신",
      "대응",
      "대장",
      "대전",
      "대접",
      "대중",
      "대책",
      "대출",
      "대충",
      "대통령",
      "대학",
      "대한민국",
      "대합실",
      "대형",
      "덩어리",
      "데이트",
      "도대체",
      "도덕",
      "도둑",
      "도망",
      "도서관",
      "도심",
      "도움",
      "도입",
      "도자기",
      "도저히",
      "도전",
      "도중",
      "도착",
      "독감",
      "독립",
      "독서",
      "독일",
      "독창적",
      "동화책",
      "뒷모습",
      "뒷산",
      "딸아이",
      "마누라",
      "마늘",
      "마당",
      "마라톤",
      "마련",
      "마무리",
      "마사지",
      "마약",
      "마요네즈",
      "마을",
      "마음",
      "마이크",
      "마중",
      "마지막",
      "마찬가지",
      "마찰",
      "마흔",
      "막걸리",
      "막내",
      "막상",
      "만남",
      "만두",
      "만세",
      "만약",
      "만일",
      "만점",
      "만족",
      "만화",
      "많이",
      "말기",
      "말씀",
      "말투",
      "맘대로",
      "망원경",
      "매년",
      "매달",
      "매력",
      "매번",
      "매스컴",
      "매일",
      "매장",
      "맥주",
      "먹이",
      "먼저",
      "먼지",
      "멀리",
      "메일",
      "며느리",
      "며칠",
      "면담",
      "멸치",
      "명단",
      "명령",
      "명예",
      "명의",
      "명절",
      "명칭",
      "명함",
      "모금",
      "모니터",
      "모델",
      "모든",
      "모범",
      "모습",
      "모양",
      "모임",
      "모조리",
      "모집",
      "모퉁이",
      "목걸이",
      "목록",
      "목사",
      "목소리",
      "목숨",
      "목적",
      "목표",
      "몰래",
      "몸매",
      "몸무게",
      "몸살",
      "몸속",
      "몸짓",
      "몸통",
      "몹시",
      "무관심",
      "무궁화",
      "무더위",
      "무덤",
      "무릎",
      "무슨",
      "무엇",
      "무역",
      "무용",
      "무조건",
      "무지개",
      "무척",
      "문구",
      "문득",
      "문법",
      "문서",
      "문제",
      "문학",
      "문화",
      "물가",
      "물건",
      "물결",
      "물고기",
      "물론",
      "물리학",
      "물음",
      "물질",
      "물체",
      "미국",
      "미디어",
      "미사일",
      "미술",
      "미역",
      "미용실",
      "미움",
      "미인",
      "미팅",
      "미혼",
      "민간",
      "민족",
      "민주",
      "믿음",
      "밀가루",
      "밀리미터",
      "밑바닥",
      "바가지",
      "바구니",
      "바나나",
      "바늘",
      "바닥",
      "바닷가",
      "바람",
      "바이러스",
      "바탕",
      "박물관",
      "박사",
      "박수",
      "반대",
      "반드시",
      "반말",
      "반발",
      "반성",
      "반응",
      "반장",
      "반죽",
      "반지",
      "반찬",
      "받침",
      "발가락",
      "발걸음",
      "발견",
      "발달",
      "발레",
      "발목",
      "발바닥",
      "발생",
      "발음",
      "발자국",
      "발전",
      "발톱",
      "발표",
      "밤하늘",
      "밥그릇",
      "밥맛",
      "밥상",
      "밥솥",
      "방금",
      "방면",
      "방문",
      "방바닥",
      "방법",
      "방송",
      "방식",
      "방안",
      "방울",
      "방지",
      "방학",
      "방해",
      "방향",
      "배경",
      "배꼽",
      "배달",
      "배드민턴",
      "백두산",
      "백색",
      "백성",
      "백인",
      "백제",
      "백화점",
      "버릇",
      "버섯",
      "버튼",
      "번개",
      "번역",
      "번지",
      "번호",
      "벌금",
      "벌레",
      "벌써",
      "범위",
      "범인",
      "범죄",
      "법률",
      "법원",
      "법적",
      "법칙",
      "베이징",
      "벨트",
      "변경",
      "변동",
      "변명",
      "변신",
      "변호사",
      "변화",
      "별도",
      "별명",
      "별일",
      "병실",
      "병아리",
      "병원",
      "보관",
      "보너스",
      "보라색",
      "보람",
      "보름",
      "보상",
      "보안",
      "보자기",
      "보장",
      "보전",
      "보존",
      "보통",
      "보편적",
      "보험",
      "복도",
      "복사",
      "복숭아",
      "복습",
      "볶음",
      "본격적",
      "본래",
      "본부",
      "본사",
      "본성",
      "본인",
      "본질",
      "볼펜",
      "봉사",
      "봉지",
      "봉투",
      "부근",
      "부끄러움",
      "부담",
      "부동산",
      "부문",
      "부분",
      "부산",
      "부상",
      "부엌",
      "부인",
      "부작용",
      "부장",
      "부정",
      "부족",
      "부지런히",
      "부친",
      "부탁",
      "부품",
      "부회장",
      "북부",
      "북한",
      "분노",
      "분량",
      "분리",
      "분명",
      "분석",
      "분야",
      "분위기",
      "분필",
      "분홍색",
      "불고기",
      "불과",
      "불교",
      "불꽃",
      "불만",
      "불법",
      "불빛",
      "불안",
      "불이익",
      "불행",
      "브랜드",
      "비극",
      "비난",
      "비닐",
      "비둘기",
      "비디오",
      "비로소",
      "비만",
      "비명",
      "비밀",
      "비바람",
      "비빔밥",
      "비상",
      "비용",
      "비율",
      "비중",
      "비타민",
      "비판",
      "빌딩",
      "빗물",
      "빗방울",
      "빗줄기",
      "빛깔",
      "빨간색",
      "빨래",
      "빨리",
      "사건",
      "사계절",
      "사나이",
      "사냥",
      "사람",
      "사랑",
      "사립",
      "사모님",
      "사물",
      "사방",
      "사상",
      "사생활",
      "사설",
      "사슴",
      "사실",
      "사업",
      "사용",
      "사월",
      "사장",
      "사전",
      "사진",
      "사촌",
      "사춘기",
      "사탕",
      "사투리",
      "사흘",
      "산길",
      "산부인과",
      "산업",
      "산책",
      "살림",
      "살인",
      "살짝",
      "삼계탕",
      "삼국",
      "삼십",
      "삼월",
      "삼촌",
      "상관",
      "상금",
      "상대",
      "상류",
      "상반기",
      "상상",
      "상식",
      "상업",
      "상인",
      "상자",
      "상점",
      "상처",
      "상추",
      "상태",
      "상표",
      "상품",
      "상황",
      "새벽",
      "색깔",
      "색연필",
      "생각",
      "생명",
      "생물",
      "생방송",
      "생산",
      "생선",
      "생신",
      "생일",
      "생활",
      "서랍",
      "서른",
      "서명",
      "서민",
      "서비스",
      "서양",
      "서울",
      "서적",
      "서점",
      "서쪽",
      "서클",
      "석사",
      "석유",
      "선거",
      "선물",
      "선배",
      "선생",
      "선수",
      "선원",
      "선장",
      "선전",
      "선택",
      "선풍기",
      "설거지",
      "설날",
      "설렁탕",
      "설명",
      "설문",
      "설사",
      "설악산",
      "설치",
      "설탕",
      "섭씨",
      "성공",
      "성당",
      "성명",
      "성별",
      "성인",
      "성장",
      "성적",
      "성질",
      "성함",
      "세금",
      "세미나",
      "세상",
      "세월",
      "세종대왕",
      "세탁",
      "센터",
      "센티미터",
      "셋째",
      "소규모",
      "소극적",
      "소금",
      "소나기",
      "소년",
      "소득",
      "소망",
      "소문",
      "소설",
      "소속",
      "소아과",
      "소용",
      "소원",
      "소음",
      "소중히",
      "소지품",
      "소질",
      "소풍",
      "소형",
      "속담",
      "속도",
      "속옷",
      "손가락",
      "손길",
      "손녀",
      "손님",
      "손등",
      "손목",
      "손뼉",
      "손실",
      "손질",
      "손톱",
      "손해",
      "솔직히",
      "솜씨",
      "송아지",
      "송이",
      "송편",
      "쇠고기",
      "쇼핑",
      "수건",
      "수년",
      "수단",
      "수돗물",
      "수동적",
      "수면",
      "수명",
      "수박",
      "수상",
      "수석",
      "수술",
      "수시로",
      "수업",
      "수염",
      "수영",
      "수입",
      "수준",
      "수집",
      "수출",
      "수컷",
      "수필",
      "수학",
      "수험생",
      "수화기",
      "숙녀",
      "숙소",
      "숙제",
      "순간",
      "순서",
      "순수",
      "순식간",
      "순위",
      "숟가락",
      "술병",
      "술집",
      "숫자",
      "스님",
      "스물",
      "스스로",
      "스승",
      "스웨터",
      "스위치",
      "스케이트",
      "스튜디오",
      "스트레스",
      "스포츠",
      "슬쩍",
      "슬픔",
      "습관",
      "습기",
      "승객",
      "승리",
      "승부",
      "승용차",
      "승진",
      "시각",
      "시간",
      "시골",
      "시금치",
      "시나리오",
      "시댁",
      "시리즈",
      "시멘트",
      "시민",
      "시부모",
      "시선",
      "시설",
      "시스템",
      "시아버지",
      "시어머니",
      "시월",
      "시인",
      "시일",
      "시작",
      "시장",
      "시절",
      "시점",
      "시중",
      "시즌",
      "시집",
      "시청",
      "시합",
      "시험",
      "식구",
      "식기",
      "식당",
      "식량",
      "식료품",
      "식물",
      "식빵",
      "식사",
      "식생활",
      "식초",
      "식탁",
      "식품",
      "신고",
      "신규",
      "신념",
      "신문",
      "신발",
      "신비",
      "신사",
      "신세",
      "신용",
      "신제품",
      "신청",
      "신체",
      "신화",
      "실감",
      "실내",
      "실력",
      "실례",
      "실망",
      "실수",
      "실습",
      "실시",
      "실장",
      "실정",
      "실질적",
      "실천",
      "실체",
      "실컷",
      "실태",
      "실패",
      "실험",
      "실현",
      "심리",
      "심부름",
      "심사",
      "심장",
      "심정",
      "심판",
      "쌍둥이",
      "씨름",
      "씨앗",
      "아가씨",
      "아나운서",
      "아드님",
      "아들",
      "아쉬움",
      "아스팔트",
      "아시아",
      "아울러",
      "아저씨",
      "아줌마",
      "아직",
      "아침",
      "아파트",
      "아프리카",
      "아픔",
      "아홉",
      "아흔",
      "악기",
      "악몽",
      "악수",
      "안개",
      "안경",
      "안과",
      "안내",
      "안녕",
      "안동",
      "안방",
      "안부",
      "안주",
      "알루미늄",
      "알코올",
      "암시",
      "암컷",
      "압력",
      "앞날",
      "앞문",
      "애인",
      "애정",
      "액수",
      "앨범",
      "야간",
      "야단",
      "야옹",
      "약간",
      "약국",
      "약속",
      "약수",
      "약점",
      "약품",
      "약혼녀",
      "양념",
      "양력",
      "양말",
      "양배추",
      "양주",
      "양파",
      "어둠",
      "어려움",
      "어른",
      "어젯밤",
      "어쨌든",
      "어쩌다가",
      "어쩐지",
      "언니",
      "언덕",
      "언론",
      "언어",
      "얼굴",
      "얼른",
      "얼음",
      "얼핏",
      "엄마",
      "업무",
      "업종",
      "업체",
      "엉덩이",
      "엉망",
      "엉터리",
      "엊그제",
      "에너지",
      "에어컨",
      "엔진",
      "여건",
      "여고생",
      "여관",
      "여군",
      "여권",
      "여대생",
      "여덟",
      "여동생",
      "여든",
      "여론",
      "여름",
      "여섯",
      "여성",
      "여왕",
      "여인",
      "여전히",
      "여직원",
      "여학생",
      "여행",
      "역사",
      "역시",
      "역할",
      "연결",
      "연구",
      "연극",
      "연기",
      "연락",
      "연설",
      "연세",
      "연속",
      "연습",
      "연애",
      "연예인",
      "연인",
      "연장",
      "연주",
      "연출",
      "연필",
      "연합",
      "연휴",
      "열기",
      "열매",
      "열쇠",
      "열심히",
      "열정",
      "열차",
      "열흘",
      "염려",
      "엽서",
      "영국",
      "영남",
      "영상",
      "영양",
      "영역",
      "영웅",
      "영원히",
      "영하",
      "영향",
      "영혼",
      "영화",
      "옆구리",
      "옆방",
      "옆집",
      "예감",
      "예금",
      "예방",
      "예산",
      "예상",
      "예선",
      "예술",
      "예습",
      "예식장",
      "예약",
      "예전",
      "예절",
      "예정",
      "예컨대",
      "옛날",
      "오늘",
      "오락",
      "오랫동안",
      "오렌지",
      "오로지",
      "오른발",
      "오븐",
      "오십",
      "오염",
      "오월",
      "오전",
      "오직",
      "오징어",
      "오페라",
      "오피스텔",
      "오히려",
      "옥상",
      "옥수수",
      "온갖",
      "온라인",
      "온몸",
      "온종일",
      "온통",
      "올가을",
      "올림픽",
      "올해",
      "옷차림",
      "와이셔츠",
      "와인",
      "완성",
      "완전",
      "왕비",
      "왕자",
      "왜냐하면",
      "왠지",
      "외갓집",
      "외국",
      "외로움",
      "외삼촌",
      "외출",
      "외침",
      "외할머니",
      "왼발",
      "왼손",
      "왼쪽",
      "요금",
      "요일",
      "요즘",
      "요청",
      "용기",
      "용서",
      "용어",
      "우산",
      "우선",
      "우승",
      "우연히",
      "우정",
      "우체국",
      "우편",
      "운동",
      "운명",
      "운반",
      "운전",
      "운행",
      "울산",
      "울음",
      "움직임",
      "웃어른",
      "웃음",
      "워낙",
      "원고",
      "원래",
      "원서",
      "원숭이",
      "원인",
      "원장",
      "원피스",
      "월급",
      "월드컵",
      "월세",
      "월요일",
      "웨이터",
      "위반",
      "위법",
      "위성",
      "위원",
      "위험",
      "위협",
      "윗사람",
      "유난히",
      "유럽",
      "유명",
      "유물",
      "유산",
      "유적",
      "유치원",
      "유학",
      "유행",
      "유형",
      "육군",
      "육상",
      "육십",
      "육체",
      "은행",
      "음력",
      "음료",
      "음반",
      "음성",
      "음식",
      "음악",
      "음주",
      "의견",
      "의논",
      "의문",
      "의복",
      "의식",
      "의심",
      "의외로",
      "의욕",
      "의원",
      "의학",
      "이것",
      "이곳",
      "이념",
      "이놈",
      "이달",
      "이대로",
      "이동",
      "이렇게",
      "이력서",
      "이론적",
      "이름",
      "이민",
      "이발소",
      "이별",
      "이불",
      "이빨",
      "이상",
      "이성",
      "이슬",
      "이야기",
      "이용",
      "이웃",
      "이월",
      "이윽고",
      "이익",
      "이전",
      "이중",
      "이튿날",
      "이틀",
      "이혼",
      "인간",
      "인격",
      "인공",
      "인구",
      "인근",
      "인기",
      "인도",
      "인류",
      "인물",
      "인생",
      "인쇄",
      "인연",
      "인원",
      "인재",
      "인종",
      "인천",
      "인체",
      "인터넷",
      "인하",
      "인형",
      "일곱",
      "일기",
      "일단",
      "일대",
      "일등",
      "일반",
      "일본",
      "일부",
      "일상",
      "일생",
      "일손",
      "일요일",
      "일월",
      "일정",
      "일종",
      "일주일",
      "일찍",
      "일체",
      "일치",
      "일행",
      "일회용",
      "임금",
      "임무",
      "입대",
      "입력",
      "입맛",
      "입사",
      "입술",
      "입시",
      "입원",
      "입장",
      "입학",
      "자가용",
      "자격",
      "자극",
      "자동",
      "자랑",
      "자부심",
      "자식",
      "자신",
      "자연",
      "자원",
      "자율",
      "자전거",
      "자정",
      "자존심",
      "자판",
      "작가",
      "작년",
      "작성",
      "작업",
      "작용",
      "작은딸",
      "작품",
      "잔디",
      "잔뜩",
      "잔치",
      "잘못",
      "잠깐",
      "잠수함",
      "잠시",
      "잠옷",
      "잠자리",
      "잡지",
      "장관",
      "장군",
      "장기간",
      "장래",
      "장례",
      "장르",
      "장마",
      "장면",
      "장모",
      "장미",
      "장비",
      "장사",
      "장소",
      "장식",
      "장애인",
      "장인",
      "장점",
      "장차",
      "장학금",
      "재능",
      "재빨리",
      "재산",
      "재생",
      "재작년",
      "재정",
      "재채기",
      "재판",
      "재학",
      "재활용",
      "저것",
      "저고리",
      "저곳",
      "저녁",
      "저런",
      "저렇게",
      "저번",
      "저울",
      "저절로",
      "저축",
      "적극",
      "적당히",
      "적성",
      "적용",
      "적응",
      "전개",
      "전공",
      "전기",
      "전달",
      "전라도",
      "전망",
      "전문",
      "전반",
      "전부",
      "전세",
      "전시",
      "전용",
      "전자",
      "전쟁",
      "전주",
      "전철",
      "전체",
      "전통",
      "전혀",
      "전후",
      "절대",
      "절망",
      "절반",
      "절약",
      "절차",
      "점검",
      "점수",
      "점심",
      "점원",
      "점점",
      "점차",
      "접근",
      "접시",
      "접촉",
      "젓가락",
      "정거장",
      "정도",
      "정류장",
      "정리",
      "정말",
      "정면",
      "정문",
      "정반대",
      "정보",
      "정부",
      "정비",
      "정상",
      "정성",
      "정오",
      "정원",
      "정장",
      "정지",
      "정치",
      "정확히",
      "제공",
      "제과점",
      "제대로",
      "제목",
      "제발",
      "제법",
      "제삿날",
      "제안",
      "제일",
      "제작",
      "제주도",
      "제출",
      "제품",
      "제한",
      "조각",
      "조건",
      "조금",
      "조깅",
      "조명",
      "조미료",
      "조상",
      "조선",
      "조용히",
      "조절",
      "조정",
      "조직",
      "존댓말",
      "존재",
      "졸업",
      "졸음",
      "종교",
      "종로",
      "종류",
      "종소리",
      "종업원",
      "종종",
      "종합",
      "좌석",
      "죄인",
      "주관적",
      "주름",
      "주말",
      "주머니",
      "주먹",
      "주문",
      "주민",
      "주방",
      "주변",
      "주식",
      "주인",
      "주일",
      "주장",
      "주전자",
      "주택",
      "준비",
      "줄거리",
      "줄기",
      "줄무늬",
      "중간",
      "중계방송",
      "중국",
      "중년",
      "중단",
      "중독",
      "중반",
      "중부",
      "중세",
      "중소기업",
      "중순",
      "중앙",
      "중요",
      "중학교",
      "즉석",
      "즉시",
      "즐거움",
      "증가",
      "증거",
      "증권",
      "증상",
      "증세",
      "지각",
      "지갑",
      "지경",
      "지극히",
      "지금",
      "지급",
      "지능",
      "지름길",
      "지리산",
      "지방",
      "지붕",
      "지식",
      "지역",
      "지우개",
      "지원",
      "지적",
      "지점",
      "지진",
      "지출",
      "직선",
      "직업",
      "직원",
      "직장",
      "진급",
      "진동",
      "진로",
      "진료",
      "진리",
      "진짜",
      "진찰",
      "진출",
      "진통",
      "진행",
      "질문",
      "질병",
      "질서",
      "짐작",
      "집단",
      "집안",
      "집중",
      "짜증",
      "찌꺼기",
      "차남",
      "차라리",
      "차량",
      "차림",
      "차별",
      "차선",
      "차츰",
      "착각",
      "찬물",
      "찬성",
      "참가",
      "참기름",
      "참새",
      "참석",
      "참여",
      "참외",
      "참조",
      "찻잔",
      "창가",
      "창고",
      "창구",
      "창문",
      "창밖",
      "창작",
      "창조",
      "채널",
      "채점",
      "책가방",
      "책방",
      "책상",
      "책임",
      "챔피언",
      "처벌",
      "처음",
      "천국",
      "천둥",
      "천장",
      "천재",
      "천천히",
      "철도",
      "철저히",
      "철학",
      "첫날",
      "첫째",
      "청년",
      "청바지",
      "청소",
      "청춘",
      "체계",
      "체력",
      "체온",
      "체육",
      "체중",
      "체험",
      "초등학생",
      "초반",
      "초밥",
      "초상화",
      "초순",
      "초여름",
      "초원",
      "초저녁",
      "초점",
      "초청",
      "초콜릿",
      "촛불",
      "총각",
      "총리",
      "총장",
      "촬영",
      "최근",
      "최상",
      "최선",
      "최신",
      "최악",
      "최종",
      "추석",
      "추억",
      "추진",
      "추천",
      "추측",
      "축구",
      "축소",
      "축제",
      "축하",
      "출근",
      "출발",
      "출산",
      "출신",
      "출연",
      "출입",
      "출장",
      "출판",
      "충격",
      "충고",
      "충돌",
      "충분히",
      "충청도",
      "취업",
      "취직",
      "취향",
      "치약",
      "친구",
      "친척",
      "칠십",
      "칠월",
      "칠판",
      "침대",
      "침묵",
      "침실",
      "칫솔",
      "칭찬",
      "카메라",
      "카운터",
      "칼국수",
      "캐릭터",
      "캠퍼스",
      "캠페인",
      "커튼",
      "컨디션",
      "컬러",
      "컴퓨터",
      "코끼리",
      "코미디",
      "콘서트",
      "콜라",
      "콤플렉스",
      "콩나물",
      "쾌감",
      "쿠데타",
      "크림",
      "큰길",
      "큰딸",
      "큰소리",
      "큰아들",
      "큰어머니",
      "큰일",
      "큰절",
      "클래식",
      "클럽",
      "킬로",
      "타입",
      "타자기",
      "탁구",
      "탁자",
      "탄생",
      "태권도",
      "태양",
      "태풍",
      "택시",
      "탤런트",
      "터널",
      "터미널",
      "테니스",
      "테스트",
      "테이블",
      "텔레비전",
      "토론",
      "토마토",
      "토요일",
      "통계",
      "통과",
      "통로",
      "통신",
      "통역",
      "통일",
      "통장",
      "통제",
      "통증",
      "통합",
      "통화",
      "퇴근",
      "퇴원",
      "퇴직금",
      "튀김",
      "트럭",
      "특급",
      "특별",
      "특성",
      "특수",
      "특징",
      "특히",
      "튼튼히",
      "티셔츠",
      "파란색",
      "파일",
      "파출소",
      "판결",
      "판단",
      "판매",
      "판사",
      "팔십",
      "팔월",
      "팝송",
      "패션",
      "팩스",
      "팩시밀리",
      "팬티",
      "퍼센트",
      "페인트",
      "편견",
      "편의",
      "편지",
      "편히",
      "평가",
      "평균",
      "평생",
      "평소",
      "평양",
      "평일",
      "평화",
      "포스터",
      "포인트",
      "포장",
      "포함",
      "표면",
      "표정",
      "표준",
      "표현",
      "품목",
      "품질",
      "풍경",
      "풍속",
      "풍습",
      "프랑스",
      "프린터",
      "플라스틱",
      "피곤",
      "피망",
      "피아노",
      "필름",
      "필수",
      "필요",
      "필자",
      "필통",
      "핑계",
      "하느님",
      "하늘",
      "하드웨어",
      "하룻밤",
      "하반기",
      "하숙집",
      "하순",
      "하여튼",
      "하지만",
      "하천",
      "하품",
      "하필",
      "학과",
      "학교",
      "학급",
      "학기",
      "학년",
      "학력",
      "학번",
      "학부모",
      "학비",
      "학생",
      "학술",
      "학습",
      "학용품",
      "학원",
      "학위",
      "학자",
      "학점",
      "한계",
      "한글",
      "한꺼번에",
      "한낮",
      "한눈",
      "한동안",
      "한때",
      "한라산",
      "한마디",
      "한문",
      "한번",
      "한복",
      "한식",
      "한여름",
      "한쪽",
      "할머니",
      "할아버지",
      "할인",
      "함께",
      "함부로",
      "합격",
      "합리적",
      "항공",
      "항구",
      "항상",
      "항의",
      "해결",
      "해군",
      "해답",
      "해당",
      "해물",
      "해석",
      "해설",
      "해수욕장",
      "해안",
      "핵심",
      "핸드백",
      "햄버거",
      "햇볕",
      "햇살",
      "행동",
      "행복",
      "행사",
      "행운",
      "행위",
      "향기",
      "향상",
      "향수",
      "허락",
      "허용",
      "헬기",
      "현관",
      "현금",
      "현대",
      "현상",
      "현실",
      "현장",
      "현재",
      "현지",
      "혈액",
      "협력",
      "형부",
      "형사",
      "형수",
      "형식",
      "형제",
      "형태",
      "형편",
      "혜택",
      "호기심",
      "호남",
      "호랑이",
      "호박",
      "호텔",
      "호흡",
      "혹시",
      "홀로",
      "홈페이지",
      "홍보",
      "홍수",
      "홍차",
      "화면",
      "화분",
      "화살",
      "화요일",
      "화장",
      "화학",
      "확보",
      "확인",
      "확장",
      "확정",
      "환갑",
      "환경",
      "환영",
      "환율",
      "환자",
      "활기",
      "활동",
      "활발히",
      "활용",
      "활짝",
      "회견",
      "회관",
      "회복",
      "회색",
      "회원",
      "회장",
      "회전",
      "횟수",
      "횡단보도",
      "효율적",
      "후반",
      "후춧가루",
      "훈련",
      "훨씬",
      "휴식",
      "휴일",
      "흉내",
      "흐름",
      "흑백",
      "흑인",
      "흔적",
      "흔히",
      "흥미",
      "흥분",
      "희곡",
      "희망",
      "희생",
      "흰색",
      "힘껏"
    ];
  }
});

// ../../node_modules/bip39/src/wordlists/french.json
var require_french = __commonJS({
  "../../node_modules/bip39/src/wordlists/french.json"(exports2, module2) {
    module2.exports = [
      "abaisser",
      "abandon",
      "abdiquer",
      "abeille",
      "abolir",
      "aborder",
      "aboutir",
      "aboyer",
      "abrasif",
      "abreuver",
      "abriter",
      "abroger",
      "abrupt",
      "absence",
      "absolu",
      "absurde",
      "abusif",
      "abyssal",
      "académie",
      "acajou",
      "acarien",
      "accabler",
      "accepter",
      "acclamer",
      "accolade",
      "accroche",
      "accuser",
      "acerbe",
      "achat",
      "acheter",
      "aciduler",
      "acier",
      "acompte",
      "acquérir",
      "acronyme",
      "acteur",
      "actif",
      "actuel",
      "adepte",
      "adéquat",
      "adhésif",
      "adjectif",
      "adjuger",
      "admettre",
      "admirer",
      "adopter",
      "adorer",
      "adoucir",
      "adresse",
      "adroit",
      "adulte",
      "adverbe",
      "aérer",
      "aéronef",
      "affaire",
      "affecter",
      "affiche",
      "affreux",
      "affubler",
      "agacer",
      "agencer",
      "agile",
      "agiter",
      "agrafer",
      "agréable",
      "agrume",
      "aider",
      "aiguille",
      "ailier",
      "aimable",
      "aisance",
      "ajouter",
      "ajuster",
      "alarmer",
      "alchimie",
      "alerte",
      "algèbre",
      "algue",
      "aliéner",
      "aliment",
      "alléger",
      "alliage",
      "allouer",
      "allumer",
      "alourdir",
      "alpaga",
      "altesse",
      "alvéole",
      "amateur",
      "ambigu",
      "ambre",
      "aménager",
      "amertume",
      "amidon",
      "amiral",
      "amorcer",
      "amour",
      "amovible",
      "amphibie",
      "ampleur",
      "amusant",
      "analyse",
      "anaphore",
      "anarchie",
      "anatomie",
      "ancien",
      "anéantir",
      "angle",
      "angoisse",
      "anguleux",
      "animal",
      "annexer",
      "annonce",
      "annuel",
      "anodin",
      "anomalie",
      "anonyme",
      "anormal",
      "antenne",
      "antidote",
      "anxieux",
      "apaiser",
      "apéritif",
      "aplanir",
      "apologie",
      "appareil",
      "appeler",
      "apporter",
      "appuyer",
      "aquarium",
      "aqueduc",
      "arbitre",
      "arbuste",
      "ardeur",
      "ardoise",
      "argent",
      "arlequin",
      "armature",
      "armement",
      "armoire",
      "armure",
      "arpenter",
      "arracher",
      "arriver",
      "arroser",
      "arsenic",
      "artériel",
      "article",
      "aspect",
      "asphalte",
      "aspirer",
      "assaut",
      "asservir",
      "assiette",
      "associer",
      "assurer",
      "asticot",
      "astre",
      "astuce",
      "atelier",
      "atome",
      "atrium",
      "atroce",
      "attaque",
      "attentif",
      "attirer",
      "attraper",
      "aubaine",
      "auberge",
      "audace",
      "audible",
      "augurer",
      "aurore",
      "automne",
      "autruche",
      "avaler",
      "avancer",
      "avarice",
      "avenir",
      "averse",
      "aveugle",
      "aviateur",
      "avide",
      "avion",
      "aviser",
      "avoine",
      "avouer",
      "avril",
      "axial",
      "axiome",
      "badge",
      "bafouer",
      "bagage",
      "baguette",
      "baignade",
      "balancer",
      "balcon",
      "baleine",
      "balisage",
      "bambin",
      "bancaire",
      "bandage",
      "banlieue",
      "bannière",
      "banquier",
      "barbier",
      "baril",
      "baron",
      "barque",
      "barrage",
      "bassin",
      "bastion",
      "bataille",
      "bateau",
      "batterie",
      "baudrier",
      "bavarder",
      "belette",
      "bélier",
      "belote",
      "bénéfice",
      "berceau",
      "berger",
      "berline",
      "bermuda",
      "besace",
      "besogne",
      "bétail",
      "beurre",
      "biberon",
      "bicycle",
      "bidule",
      "bijou",
      "bilan",
      "bilingue",
      "billard",
      "binaire",
      "biologie",
      "biopsie",
      "biotype",
      "biscuit",
      "bison",
      "bistouri",
      "bitume",
      "bizarre",
      "blafard",
      "blague",
      "blanchir",
      "blessant",
      "blinder",
      "blond",
      "bloquer",
      "blouson",
      "bobard",
      "bobine",
      "boire",
      "boiser",
      "bolide",
      "bonbon",
      "bondir",
      "bonheur",
      "bonifier",
      "bonus",
      "bordure",
      "borne",
      "botte",
      "boucle",
      "boueux",
      "bougie",
      "boulon",
      "bouquin",
      "bourse",
      "boussole",
      "boutique",
      "boxeur",
      "branche",
      "brasier",
      "brave",
      "brebis",
      "brèche",
      "breuvage",
      "bricoler",
      "brigade",
      "brillant",
      "brioche",
      "brique",
      "brochure",
      "broder",
      "bronzer",
      "brousse",
      "broyeur",
      "brume",
      "brusque",
      "brutal",
      "bruyant",
      "buffle",
      "buisson",
      "bulletin",
      "bureau",
      "burin",
      "bustier",
      "butiner",
      "butoir",
      "buvable",
      "buvette",
      "cabanon",
      "cabine",
      "cachette",
      "cadeau",
      "cadre",
      "caféine",
      "caillou",
      "caisson",
      "calculer",
      "calepin",
      "calibre",
      "calmer",
      "calomnie",
      "calvaire",
      "camarade",
      "caméra",
      "camion",
      "campagne",
      "canal",
      "caneton",
      "canon",
      "cantine",
      "canular",
      "capable",
      "caporal",
      "caprice",
      "capsule",
      "capter",
      "capuche",
      "carabine",
      "carbone",
      "caresser",
      "caribou",
      "carnage",
      "carotte",
      "carreau",
      "carton",
      "cascade",
      "casier",
      "casque",
      "cassure",
      "causer",
      "caution",
      "cavalier",
      "caverne",
      "caviar",
      "cédille",
      "ceinture",
      "céleste",
      "cellule",
      "cendrier",
      "censurer",
      "central",
      "cercle",
      "cérébral",
      "cerise",
      "cerner",
      "cerveau",
      "cesser",
      "chagrin",
      "chaise",
      "chaleur",
      "chambre",
      "chance",
      "chapitre",
      "charbon",
      "chasseur",
      "chaton",
      "chausson",
      "chavirer",
      "chemise",
      "chenille",
      "chéquier",
      "chercher",
      "cheval",
      "chien",
      "chiffre",
      "chignon",
      "chimère",
      "chiot",
      "chlorure",
      "chocolat",
      "choisir",
      "chose",
      "chouette",
      "chrome",
      "chute",
      "cigare",
      "cigogne",
      "cimenter",
      "cinéma",
      "cintrer",
      "circuler",
      "cirer",
      "cirque",
      "citerne",
      "citoyen",
      "citron",
      "civil",
      "clairon",
      "clameur",
      "claquer",
      "classe",
      "clavier",
      "client",
      "cligner",
      "climat",
      "clivage",
      "cloche",
      "clonage",
      "cloporte",
      "cobalt",
      "cobra",
      "cocasse",
      "cocotier",
      "coder",
      "codifier",
      "coffre",
      "cogner",
      "cohésion",
      "coiffer",
      "coincer",
      "colère",
      "colibri",
      "colline",
      "colmater",
      "colonel",
      "combat",
      "comédie",
      "commande",
      "compact",
      "concert",
      "conduire",
      "confier",
      "congeler",
      "connoter",
      "consonne",
      "contact",
      "convexe",
      "copain",
      "copie",
      "corail",
      "corbeau",
      "cordage",
      "corniche",
      "corpus",
      "correct",
      "cortège",
      "cosmique",
      "costume",
      "coton",
      "coude",
      "coupure",
      "courage",
      "couteau",
      "couvrir",
      "coyote",
      "crabe",
      "crainte",
      "cravate",
      "crayon",
      "créature",
      "créditer",
      "crémeux",
      "creuser",
      "crevette",
      "cribler",
      "crier",
      "cristal",
      "critère",
      "croire",
      "croquer",
      "crotale",
      "crucial",
      "cruel",
      "crypter",
      "cubique",
      "cueillir",
      "cuillère",
      "cuisine",
      "cuivre",
      "culminer",
      "cultiver",
      "cumuler",
      "cupide",
      "curatif",
      "curseur",
      "cyanure",
      "cycle",
      "cylindre",
      "cynique",
      "daigner",
      "damier",
      "danger",
      "danseur",
      "dauphin",
      "débattre",
      "débiter",
      "déborder",
      "débrider",
      "débutant",
      "décaler",
      "décembre",
      "déchirer",
      "décider",
      "déclarer",
      "décorer",
      "décrire",
      "décupler",
      "dédale",
      "déductif",
      "déesse",
      "défensif",
      "défiler",
      "défrayer",
      "dégager",
      "dégivrer",
      "déglutir",
      "dégrafer",
      "déjeuner",
      "délice",
      "déloger",
      "demander",
      "demeurer",
      "démolir",
      "dénicher",
      "dénouer",
      "dentelle",
      "dénuder",
      "départ",
      "dépenser",
      "déphaser",
      "déplacer",
      "déposer",
      "déranger",
      "dérober",
      "désastre",
      "descente",
      "désert",
      "désigner",
      "désobéir",
      "dessiner",
      "destrier",
      "détacher",
      "détester",
      "détourer",
      "détresse",
      "devancer",
      "devenir",
      "deviner",
      "devoir",
      "diable",
      "dialogue",
      "diamant",
      "dicter",
      "différer",
      "digérer",
      "digital",
      "digne",
      "diluer",
      "dimanche",
      "diminuer",
      "dioxyde",
      "directif",
      "diriger",
      "discuter",
      "disposer",
      "dissiper",
      "distance",
      "divertir",
      "diviser",
      "docile",
      "docteur",
      "dogme",
      "doigt",
      "domaine",
      "domicile",
      "dompter",
      "donateur",
      "donjon",
      "donner",
      "dopamine",
      "dortoir",
      "dorure",
      "dosage",
      "doseur",
      "dossier",
      "dotation",
      "douanier",
      "double",
      "douceur",
      "douter",
      "doyen",
      "dragon",
      "draper",
      "dresser",
      "dribbler",
      "droiture",
      "duperie",
      "duplexe",
      "durable",
      "durcir",
      "dynastie",
      "éblouir",
      "écarter",
      "écharpe",
      "échelle",
      "éclairer",
      "éclipse",
      "éclore",
      "écluse",
      "école",
      "économie",
      "écorce",
      "écouter",
      "écraser",
      "écrémer",
      "écrivain",
      "écrou",
      "écume",
      "écureuil",
      "édifier",
      "éduquer",
      "effacer",
      "effectif",
      "effigie",
      "effort",
      "effrayer",
      "effusion",
      "égaliser",
      "égarer",
      "éjecter",
      "élaborer",
      "élargir",
      "électron",
      "élégant",
      "éléphant",
      "élève",
      "éligible",
      "élitisme",
      "éloge",
      "élucider",
      "éluder",
      "emballer",
      "embellir",
      "embryon",
      "émeraude",
      "émission",
      "emmener",
      "émotion",
      "émouvoir",
      "empereur",
      "employer",
      "emporter",
      "emprise",
      "émulsion",
      "encadrer",
      "enchère",
      "enclave",
      "encoche",
      "endiguer",
      "endosser",
      "endroit",
      "enduire",
      "énergie",
      "enfance",
      "enfermer",
      "enfouir",
      "engager",
      "engin",
      "englober",
      "énigme",
      "enjamber",
      "enjeu",
      "enlever",
      "ennemi",
      "ennuyeux",
      "enrichir",
      "enrobage",
      "enseigne",
      "entasser",
      "entendre",
      "entier",
      "entourer",
      "entraver",
      "énumérer",
      "envahir",
      "enviable",
      "envoyer",
      "enzyme",
      "éolien",
      "épaissir",
      "épargne",
      "épatant",
      "épaule",
      "épicerie",
      "épidémie",
      "épier",
      "épilogue",
      "épine",
      "épisode",
      "épitaphe",
      "époque",
      "épreuve",
      "éprouver",
      "épuisant",
      "équerre",
      "équipe",
      "ériger",
      "érosion",
      "erreur",
      "éruption",
      "escalier",
      "espadon",
      "espèce",
      "espiègle",
      "espoir",
      "esprit",
      "esquiver",
      "essayer",
      "essence",
      "essieu",
      "essorer",
      "estime",
      "estomac",
      "estrade",
      "étagère",
      "étaler",
      "étanche",
      "étatique",
      "éteindre",
      "étendoir",
      "éternel",
      "éthanol",
      "éthique",
      "ethnie",
      "étirer",
      "étoffer",
      "étoile",
      "étonnant",
      "étourdir",
      "étrange",
      "étroit",
      "étude",
      "euphorie",
      "évaluer",
      "évasion",
      "éventail",
      "évidence",
      "éviter",
      "évolutif",
      "évoquer",
      "exact",
      "exagérer",
      "exaucer",
      "exceller",
      "excitant",
      "exclusif",
      "excuse",
      "exécuter",
      "exemple",
      "exercer",
      "exhaler",
      "exhorter",
      "exigence",
      "exiler",
      "exister",
      "exotique",
      "expédier",
      "explorer",
      "exposer",
      "exprimer",
      "exquis",
      "extensif",
      "extraire",
      "exulter",
      "fable",
      "fabuleux",
      "facette",
      "facile",
      "facture",
      "faiblir",
      "falaise",
      "fameux",
      "famille",
      "farceur",
      "farfelu",
      "farine",
      "farouche",
      "fasciner",
      "fatal",
      "fatigue",
      "faucon",
      "fautif",
      "faveur",
      "favori",
      "fébrile",
      "féconder",
      "fédérer",
      "félin",
      "femme",
      "fémur",
      "fendoir",
      "féodal",
      "fermer",
      "féroce",
      "ferveur",
      "festival",
      "feuille",
      "feutre",
      "février",
      "fiasco",
      "ficeler",
      "fictif",
      "fidèle",
      "figure",
      "filature",
      "filetage",
      "filière",
      "filleul",
      "filmer",
      "filou",
      "filtrer",
      "financer",
      "finir",
      "fiole",
      "firme",
      "fissure",
      "fixer",
      "flairer",
      "flamme",
      "flasque",
      "flatteur",
      "fléau",
      "flèche",
      "fleur",
      "flexion",
      "flocon",
      "flore",
      "fluctuer",
      "fluide",
      "fluvial",
      "folie",
      "fonderie",
      "fongible",
      "fontaine",
      "forcer",
      "forgeron",
      "formuler",
      "fortune",
      "fossile",
      "foudre",
      "fougère",
      "fouiller",
      "foulure",
      "fourmi",
      "fragile",
      "fraise",
      "franchir",
      "frapper",
      "frayeur",
      "frégate",
      "freiner",
      "frelon",
      "frémir",
      "frénésie",
      "frère",
      "friable",
      "friction",
      "frisson",
      "frivole",
      "froid",
      "fromage",
      "frontal",
      "frotter",
      "fruit",
      "fugitif",
      "fuite",
      "fureur",
      "furieux",
      "furtif",
      "fusion",
      "futur",
      "gagner",
      "galaxie",
      "galerie",
      "gambader",
      "garantir",
      "gardien",
      "garnir",
      "garrigue",
      "gazelle",
      "gazon",
      "géant",
      "gélatine",
      "gélule",
      "gendarme",
      "général",
      "génie",
      "genou",
      "gentil",
      "géologie",
      "géomètre",
      "géranium",
      "germe",
      "gestuel",
      "geyser",
      "gibier",
      "gicler",
      "girafe",
      "givre",
      "glace",
      "glaive",
      "glisser",
      "globe",
      "gloire",
      "glorieux",
      "golfeur",
      "gomme",
      "gonfler",
      "gorge",
      "gorille",
      "goudron",
      "gouffre",
      "goulot",
      "goupille",
      "gourmand",
      "goutte",
      "graduel",
      "graffiti",
      "graine",
      "grand",
      "grappin",
      "gratuit",
      "gravir",
      "grenat",
      "griffure",
      "griller",
      "grimper",
      "grogner",
      "gronder",
      "grotte",
      "groupe",
      "gruger",
      "grutier",
      "gruyère",
      "guépard",
      "guerrier",
      "guide",
      "guimauve",
      "guitare",
      "gustatif",
      "gymnaste",
      "gyrostat",
      "habitude",
      "hachoir",
      "halte",
      "hameau",
      "hangar",
      "hanneton",
      "haricot",
      "harmonie",
      "harpon",
      "hasard",
      "hélium",
      "hématome",
      "herbe",
      "hérisson",
      "hermine",
      "héron",
      "hésiter",
      "heureux",
      "hiberner",
      "hibou",
      "hilarant",
      "histoire",
      "hiver",
      "homard",
      "hommage",
      "homogène",
      "honneur",
      "honorer",
      "honteux",
      "horde",
      "horizon",
      "horloge",
      "hormone",
      "horrible",
      "houleux",
      "housse",
      "hublot",
      "huileux",
      "humain",
      "humble",
      "humide",
      "humour",
      "hurler",
      "hydromel",
      "hygiène",
      "hymne",
      "hypnose",
      "idylle",
      "ignorer",
      "iguane",
      "illicite",
      "illusion",
      "image",
      "imbiber",
      "imiter",
      "immense",
      "immobile",
      "immuable",
      "impact",
      "impérial",
      "implorer",
      "imposer",
      "imprimer",
      "imputer",
      "incarner",
      "incendie",
      "incident",
      "incliner",
      "incolore",
      "indexer",
      "indice",
      "inductif",
      "inédit",
      "ineptie",
      "inexact",
      "infini",
      "infliger",
      "informer",
      "infusion",
      "ingérer",
      "inhaler",
      "inhiber",
      "injecter",
      "injure",
      "innocent",
      "inoculer",
      "inonder",
      "inscrire",
      "insecte",
      "insigne",
      "insolite",
      "inspirer",
      "instinct",
      "insulter",
      "intact",
      "intense",
      "intime",
      "intrigue",
      "intuitif",
      "inutile",
      "invasion",
      "inventer",
      "inviter",
      "invoquer",
      "ironique",
      "irradier",
      "irréel",
      "irriter",
      "isoler",
      "ivoire",
      "ivresse",
      "jaguar",
      "jaillir",
      "jambe",
      "janvier",
      "jardin",
      "jauger",
      "jaune",
      "javelot",
      "jetable",
      "jeton",
      "jeudi",
      "jeunesse",
      "joindre",
      "joncher",
      "jongler",
      "joueur",
      "jouissif",
      "journal",
      "jovial",
      "joyau",
      "joyeux",
      "jubiler",
      "jugement",
      "junior",
      "jupon",
      "juriste",
      "justice",
      "juteux",
      "juvénile",
      "kayak",
      "kimono",
      "kiosque",
      "label",
      "labial",
      "labourer",
      "lacérer",
      "lactose",
      "lagune",
      "laine",
      "laisser",
      "laitier",
      "lambeau",
      "lamelle",
      "lampe",
      "lanceur",
      "langage",
      "lanterne",
      "lapin",
      "largeur",
      "larme",
      "laurier",
      "lavabo",
      "lavoir",
      "lecture",
      "légal",
      "léger",
      "légume",
      "lessive",
      "lettre",
      "levier",
      "lexique",
      "lézard",
      "liasse",
      "libérer",
      "libre",
      "licence",
      "licorne",
      "liège",
      "lièvre",
      "ligature",
      "ligoter",
      "ligue",
      "limer",
      "limite",
      "limonade",
      "limpide",
      "linéaire",
      "lingot",
      "lionceau",
      "liquide",
      "lisière",
      "lister",
      "lithium",
      "litige",
      "littoral",
      "livreur",
      "logique",
      "lointain",
      "loisir",
      "lombric",
      "loterie",
      "louer",
      "lourd",
      "loutre",
      "louve",
      "loyal",
      "lubie",
      "lucide",
      "lucratif",
      "lueur",
      "lugubre",
      "luisant",
      "lumière",
      "lunaire",
      "lundi",
      "luron",
      "lutter",
      "luxueux",
      "machine",
      "magasin",
      "magenta",
      "magique",
      "maigre",
      "maillon",
      "maintien",
      "mairie",
      "maison",
      "majorer",
      "malaxer",
      "maléfice",
      "malheur",
      "malice",
      "mallette",
      "mammouth",
      "mandater",
      "maniable",
      "manquant",
      "manteau",
      "manuel",
      "marathon",
      "marbre",
      "marchand",
      "mardi",
      "maritime",
      "marqueur",
      "marron",
      "marteler",
      "mascotte",
      "massif",
      "matériel",
      "matière",
      "matraque",
      "maudire",
      "maussade",
      "mauve",
      "maximal",
      "méchant",
      "méconnu",
      "médaille",
      "médecin",
      "méditer",
      "méduse",
      "meilleur",
      "mélange",
      "mélodie",
      "membre",
      "mémoire",
      "menacer",
      "mener",
      "menhir",
      "mensonge",
      "mentor",
      "mercredi",
      "mérite",
      "merle",
      "messager",
      "mesure",
      "métal",
      "météore",
      "méthode",
      "métier",
      "meuble",
      "miauler",
      "microbe",
      "miette",
      "mignon",
      "migrer",
      "milieu",
      "million",
      "mimique",
      "mince",
      "minéral",
      "minimal",
      "minorer",
      "minute",
      "miracle",
      "miroiter",
      "missile",
      "mixte",
      "mobile",
      "moderne",
      "moelleux",
      "mondial",
      "moniteur",
      "monnaie",
      "monotone",
      "monstre",
      "montagne",
      "monument",
      "moqueur",
      "morceau",
      "morsure",
      "mortier",
      "moteur",
      "motif",
      "mouche",
      "moufle",
      "moulin",
      "mousson",
      "mouton",
      "mouvant",
      "multiple",
      "munition",
      "muraille",
      "murène",
      "murmure",
      "muscle",
      "muséum",
      "musicien",
      "mutation",
      "muter",
      "mutuel",
      "myriade",
      "myrtille",
      "mystère",
      "mythique",
      "nageur",
      "nappe",
      "narquois",
      "narrer",
      "natation",
      "nation",
      "nature",
      "naufrage",
      "nautique",
      "navire",
      "nébuleux",
      "nectar",
      "néfaste",
      "négation",
      "négliger",
      "négocier",
      "neige",
      "nerveux",
      "nettoyer",
      "neurone",
      "neutron",
      "neveu",
      "niche",
      "nickel",
      "nitrate",
      "niveau",
      "noble",
      "nocif",
      "nocturne",
      "noirceur",
      "noisette",
      "nomade",
      "nombreux",
      "nommer",
      "normatif",
      "notable",
      "notifier",
      "notoire",
      "nourrir",
      "nouveau",
      "novateur",
      "novembre",
      "novice",
      "nuage",
      "nuancer",
      "nuire",
      "nuisible",
      "numéro",
      "nuptial",
      "nuque",
      "nutritif",
      "obéir",
      "objectif",
      "obliger",
      "obscur",
      "observer",
      "obstacle",
      "obtenir",
      "obturer",
      "occasion",
      "occuper",
      "océan",
      "octobre",
      "octroyer",
      "octupler",
      "oculaire",
      "odeur",
      "odorant",
      "offenser",
      "officier",
      "offrir",
      "ogive",
      "oiseau",
      "oisillon",
      "olfactif",
      "olivier",
      "ombrage",
      "omettre",
      "onctueux",
      "onduler",
      "onéreux",
      "onirique",
      "opale",
      "opaque",
      "opérer",
      "opinion",
      "opportun",
      "opprimer",
      "opter",
      "optique",
      "orageux",
      "orange",
      "orbite",
      "ordonner",
      "oreille",
      "organe",
      "orgueil",
      "orifice",
      "ornement",
      "orque",
      "ortie",
      "osciller",
      "osmose",
      "ossature",
      "otarie",
      "ouragan",
      "ourson",
      "outil",
      "outrager",
      "ouvrage",
      "ovation",
      "oxyde",
      "oxygène",
      "ozone",
      "paisible",
      "palace",
      "palmarès",
      "palourde",
      "palper",
      "panache",
      "panda",
      "pangolin",
      "paniquer",
      "panneau",
      "panorama",
      "pantalon",
      "papaye",
      "papier",
      "papoter",
      "papyrus",
      "paradoxe",
      "parcelle",
      "paresse",
      "parfumer",
      "parler",
      "parole",
      "parrain",
      "parsemer",
      "partager",
      "parure",
      "parvenir",
      "passion",
      "pastèque",
      "paternel",
      "patience",
      "patron",
      "pavillon",
      "pavoiser",
      "payer",
      "paysage",
      "peigne",
      "peintre",
      "pelage",
      "pélican",
      "pelle",
      "pelouse",
      "peluche",
      "pendule",
      "pénétrer",
      "pénible",
      "pensif",
      "pénurie",
      "pépite",
      "péplum",
      "perdrix",
      "perforer",
      "période",
      "permuter",
      "perplexe",
      "persil",
      "perte",
      "peser",
      "pétale",
      "petit",
      "pétrir",
      "peuple",
      "pharaon",
      "phobie",
      "phoque",
      "photon",
      "phrase",
      "physique",
      "piano",
      "pictural",
      "pièce",
      "pierre",
      "pieuvre",
      "pilote",
      "pinceau",
      "pipette",
      "piquer",
      "pirogue",
      "piscine",
      "piston",
      "pivoter",
      "pixel",
      "pizza",
      "placard",
      "plafond",
      "plaisir",
      "planer",
      "plaque",
      "plastron",
      "plateau",
      "pleurer",
      "plexus",
      "pliage",
      "plomb",
      "plonger",
      "pluie",
      "plumage",
      "pochette",
      "poésie",
      "poète",
      "pointe",
      "poirier",
      "poisson",
      "poivre",
      "polaire",
      "policier",
      "pollen",
      "polygone",
      "pommade",
      "pompier",
      "ponctuel",
      "pondérer",
      "poney",
      "portique",
      "position",
      "posséder",
      "posture",
      "potager",
      "poteau",
      "potion",
      "pouce",
      "poulain",
      "poumon",
      "pourpre",
      "poussin",
      "pouvoir",
      "prairie",
      "pratique",
      "précieux",
      "prédire",
      "préfixe",
      "prélude",
      "prénom",
      "présence",
      "prétexte",
      "prévoir",
      "primitif",
      "prince",
      "prison",
      "priver",
      "problème",
      "procéder",
      "prodige",
      "profond",
      "progrès",
      "proie",
      "projeter",
      "prologue",
      "promener",
      "propre",
      "prospère",
      "protéger",
      "prouesse",
      "proverbe",
      "prudence",
      "pruneau",
      "psychose",
      "public",
      "puceron",
      "puiser",
      "pulpe",
      "pulsar",
      "punaise",
      "punitif",
      "pupitre",
      "purifier",
      "puzzle",
      "pyramide",
      "quasar",
      "querelle",
      "question",
      "quiétude",
      "quitter",
      "quotient",
      "racine",
      "raconter",
      "radieux",
      "ragondin",
      "raideur",
      "raisin",
      "ralentir",
      "rallonge",
      "ramasser",
      "rapide",
      "rasage",
      "ratisser",
      "ravager",
      "ravin",
      "rayonner",
      "réactif",
      "réagir",
      "réaliser",
      "réanimer",
      "recevoir",
      "réciter",
      "réclamer",
      "récolter",
      "recruter",
      "reculer",
      "recycler",
      "rédiger",
      "redouter",
      "refaire",
      "réflexe",
      "réformer",
      "refrain",
      "refuge",
      "régalien",
      "région",
      "réglage",
      "régulier",
      "réitérer",
      "rejeter",
      "rejouer",
      "relatif",
      "relever",
      "relief",
      "remarque",
      "remède",
      "remise",
      "remonter",
      "remplir",
      "remuer",
      "renard",
      "renfort",
      "renifler",
      "renoncer",
      "rentrer",
      "renvoi",
      "replier",
      "reporter",
      "reprise",
      "reptile",
      "requin",
      "réserve",
      "résineux",
      "résoudre",
      "respect",
      "rester",
      "résultat",
      "rétablir",
      "retenir",
      "réticule",
      "retomber",
      "retracer",
      "réunion",
      "réussir",
      "revanche",
      "revivre",
      "révolte",
      "révulsif",
      "richesse",
      "rideau",
      "rieur",
      "rigide",
      "rigoler",
      "rincer",
      "riposter",
      "risible",
      "risque",
      "rituel",
      "rival",
      "rivière",
      "rocheux",
      "romance",
      "rompre",
      "ronce",
      "rondin",
      "roseau",
      "rosier",
      "rotatif",
      "rotor",
      "rotule",
      "rouge",
      "rouille",
      "rouleau",
      "routine",
      "royaume",
      "ruban",
      "rubis",
      "ruche",
      "ruelle",
      "rugueux",
      "ruiner",
      "ruisseau",
      "ruser",
      "rustique",
      "rythme",
      "sabler",
      "saboter",
      "sabre",
      "sacoche",
      "safari",
      "sagesse",
      "saisir",
      "salade",
      "salive",
      "salon",
      "saluer",
      "samedi",
      "sanction",
      "sanglier",
      "sarcasme",
      "sardine",
      "saturer",
      "saugrenu",
      "saumon",
      "sauter",
      "sauvage",
      "savant",
      "savonner",
      "scalpel",
      "scandale",
      "scélérat",
      "scénario",
      "sceptre",
      "schéma",
      "science",
      "scinder",
      "score",
      "scrutin",
      "sculpter",
      "séance",
      "sécable",
      "sécher",
      "secouer",
      "sécréter",
      "sédatif",
      "séduire",
      "seigneur",
      "séjour",
      "sélectif",
      "semaine",
      "sembler",
      "semence",
      "séminal",
      "sénateur",
      "sensible",
      "sentence",
      "séparer",
      "séquence",
      "serein",
      "sergent",
      "sérieux",
      "serrure",
      "sérum",
      "service",
      "sésame",
      "sévir",
      "sevrage",
      "sextuple",
      "sidéral",
      "siècle",
      "siéger",
      "siffler",
      "sigle",
      "signal",
      "silence",
      "silicium",
      "simple",
      "sincère",
      "sinistre",
      "siphon",
      "sirop",
      "sismique",
      "situer",
      "skier",
      "social",
      "socle",
      "sodium",
      "soigneux",
      "soldat",
      "soleil",
      "solitude",
      "soluble",
      "sombre",
      "sommeil",
      "somnoler",
      "sonde",
      "songeur",
      "sonnette",
      "sonore",
      "sorcier",
      "sortir",
      "sosie",
      "sottise",
      "soucieux",
      "soudure",
      "souffle",
      "soulever",
      "soupape",
      "source",
      "soutirer",
      "souvenir",
      "spacieux",
      "spatial",
      "spécial",
      "sphère",
      "spiral",
      "stable",
      "station",
      "sternum",
      "stimulus",
      "stipuler",
      "strict",
      "studieux",
      "stupeur",
      "styliste",
      "sublime",
      "substrat",
      "subtil",
      "subvenir",
      "succès",
      "sucre",
      "suffixe",
      "suggérer",
      "suiveur",
      "sulfate",
      "superbe",
      "supplier",
      "surface",
      "suricate",
      "surmener",
      "surprise",
      "sursaut",
      "survie",
      "suspect",
      "syllabe",
      "symbole",
      "symétrie",
      "synapse",
      "syntaxe",
      "système",
      "tabac",
      "tablier",
      "tactile",
      "tailler",
      "talent",
      "talisman",
      "talonner",
      "tambour",
      "tamiser",
      "tangible",
      "tapis",
      "taquiner",
      "tarder",
      "tarif",
      "tartine",
      "tasse",
      "tatami",
      "tatouage",
      "taupe",
      "taureau",
      "taxer",
      "témoin",
      "temporel",
      "tenaille",
      "tendre",
      "teneur",
      "tenir",
      "tension",
      "terminer",
      "terne",
      "terrible",
      "tétine",
      "texte",
      "thème",
      "théorie",
      "thérapie",
      "thorax",
      "tibia",
      "tiède",
      "timide",
      "tirelire",
      "tiroir",
      "tissu",
      "titane",
      "titre",
      "tituber",
      "toboggan",
      "tolérant",
      "tomate",
      "tonique",
      "tonneau",
      "toponyme",
      "torche",
      "tordre",
      "tornade",
      "torpille",
      "torrent",
      "torse",
      "tortue",
      "totem",
      "toucher",
      "tournage",
      "tousser",
      "toxine",
      "traction",
      "trafic",
      "tragique",
      "trahir",
      "train",
      "trancher",
      "travail",
      "trèfle",
      "tremper",
      "trésor",
      "treuil",
      "triage",
      "tribunal",
      "tricoter",
      "trilogie",
      "triomphe",
      "tripler",
      "triturer",
      "trivial",
      "trombone",
      "tronc",
      "tropical",
      "troupeau",
      "tuile",
      "tulipe",
      "tumulte",
      "tunnel",
      "turbine",
      "tuteur",
      "tutoyer",
      "tuyau",
      "tympan",
      "typhon",
      "typique",
      "tyran",
      "ubuesque",
      "ultime",
      "ultrason",
      "unanime",
      "unifier",
      "union",
      "unique",
      "unitaire",
      "univers",
      "uranium",
      "urbain",
      "urticant",
      "usage",
      "usine",
      "usuel",
      "usure",
      "utile",
      "utopie",
      "vacarme",
      "vaccin",
      "vagabond",
      "vague",
      "vaillant",
      "vaincre",
      "vaisseau",
      "valable",
      "valise",
      "vallon",
      "valve",
      "vampire",
      "vanille",
      "vapeur",
      "varier",
      "vaseux",
      "vassal",
      "vaste",
      "vecteur",
      "vedette",
      "végétal",
      "véhicule",
      "veinard",
      "véloce",
      "vendredi",
      "vénérer",
      "venger",
      "venimeux",
      "ventouse",
      "verdure",
      "vérin",
      "vernir",
      "verrou",
      "verser",
      "vertu",
      "veston",
      "vétéran",
      "vétuste",
      "vexant",
      "vexer",
      "viaduc",
      "viande",
      "victoire",
      "vidange",
      "vidéo",
      "vignette",
      "vigueur",
      "vilain",
      "village",
      "vinaigre",
      "violon",
      "vipère",
      "virement",
      "virtuose",
      "virus",
      "visage",
      "viseur",
      "vision",
      "visqueux",
      "visuel",
      "vital",
      "vitesse",
      "viticole",
      "vitrine",
      "vivace",
      "vivipare",
      "vocation",
      "voguer",
      "voile",
      "voisin",
      "voiture",
      "volaille",
      "volcan",
      "voltiger",
      "volume",
      "vorace",
      "vortex",
      "voter",
      "vouloir",
      "voyage",
      "voyelle",
      "wagon",
      "xénon",
      "yacht",
      "zèbre",
      "zénith",
      "zeste",
      "zoologie"
    ];
  }
});

// ../../node_modules/bip39/src/wordlists/italian.json
var require_italian = __commonJS({
  "../../node_modules/bip39/src/wordlists/italian.json"(exports2, module2) {
    module2.exports = [
      "abaco",
      "abbaglio",
      "abbinato",
      "abete",
      "abisso",
      "abolire",
      "abrasivo",
      "abrogato",
      "accadere",
      "accenno",
      "accusato",
      "acetone",
      "achille",
      "acido",
      "acqua",
      "acre",
      "acrilico",
      "acrobata",
      "acuto",
      "adagio",
      "addebito",
      "addome",
      "adeguato",
      "aderire",
      "adipe",
      "adottare",
      "adulare",
      "affabile",
      "affetto",
      "affisso",
      "affranto",
      "aforisma",
      "afoso",
      "africano",
      "agave",
      "agente",
      "agevole",
      "aggancio",
      "agire",
      "agitare",
      "agonismo",
      "agricolo",
      "agrumeto",
      "aguzzo",
      "alabarda",
      "alato",
      "albatro",
      "alberato",
      "albo",
      "albume",
      "alce",
      "alcolico",
      "alettone",
      "alfa",
      "algebra",
      "aliante",
      "alibi",
      "alimento",
      "allagato",
      "allegro",
      "allievo",
      "allodola",
      "allusivo",
      "almeno",
      "alogeno",
      "alpaca",
      "alpestre",
      "altalena",
      "alterno",
      "alticcio",
      "altrove",
      "alunno",
      "alveolo",
      "alzare",
      "amalgama",
      "amanita",
      "amarena",
      "ambito",
      "ambrato",
      "ameba",
      "america",
      "ametista",
      "amico",
      "ammasso",
      "ammenda",
      "ammirare",
      "ammonito",
      "amore",
      "ampio",
      "ampliare",
      "amuleto",
      "anacardo",
      "anagrafe",
      "analista",
      "anarchia",
      "anatra",
      "anca",
      "ancella",
      "ancora",
      "andare",
      "andrea",
      "anello",
      "angelo",
      "angolare",
      "angusto",
      "anima",
      "annegare",
      "annidato",
      "anno",
      "annuncio",
      "anonimo",
      "anticipo",
      "anzi",
      "apatico",
      "apertura",
      "apode",
      "apparire",
      "appetito",
      "appoggio",
      "approdo",
      "appunto",
      "aprile",
      "arabica",
      "arachide",
      "aragosta",
      "araldica",
      "arancio",
      "aratura",
      "arazzo",
      "arbitro",
      "archivio",
      "ardito",
      "arenile",
      "argento",
      "argine",
      "arguto",
      "aria",
      "armonia",
      "arnese",
      "arredato",
      "arringa",
      "arrosto",
      "arsenico",
      "arso",
      "artefice",
      "arzillo",
      "asciutto",
      "ascolto",
      "asepsi",
      "asettico",
      "asfalto",
      "asino",
      "asola",
      "aspirato",
      "aspro",
      "assaggio",
      "asse",
      "assoluto",
      "assurdo",
      "asta",
      "astenuto",
      "astice",
      "astratto",
      "atavico",
      "ateismo",
      "atomico",
      "atono",
      "attesa",
      "attivare",
      "attorno",
      "attrito",
      "attuale",
      "ausilio",
      "austria",
      "autista",
      "autonomo",
      "autunno",
      "avanzato",
      "avere",
      "avvenire",
      "avviso",
      "avvolgere",
      "azione",
      "azoto",
      "azzimo",
      "azzurro",
      "babele",
      "baccano",
      "bacino",
      "baco",
      "badessa",
      "badilata",
      "bagnato",
      "baita",
      "balcone",
      "baldo",
      "balena",
      "ballata",
      "balzano",
      "bambino",
      "bandire",
      "baraonda",
      "barbaro",
      "barca",
      "baritono",
      "barlume",
      "barocco",
      "basilico",
      "basso",
      "batosta",
      "battuto",
      "baule",
      "bava",
      "bavosa",
      "becco",
      "beffa",
      "belgio",
      "belva",
      "benda",
      "benevole",
      "benigno",
      "benzina",
      "bere",
      "berlina",
      "beta",
      "bibita",
      "bici",
      "bidone",
      "bifido",
      "biga",
      "bilancia",
      "bimbo",
      "binocolo",
      "biologo",
      "bipede",
      "bipolare",
      "birbante",
      "birra",
      "biscotto",
      "bisesto",
      "bisnonno",
      "bisonte",
      "bisturi",
      "bizzarro",
      "blando",
      "blatta",
      "bollito",
      "bonifico",
      "bordo",
      "bosco",
      "botanico",
      "bottino",
      "bozzolo",
      "braccio",
      "bradipo",
      "brama",
      "branca",
      "bravura",
      "bretella",
      "brevetto",
      "brezza",
      "briglia",
      "brillante",
      "brindare",
      "broccolo",
      "brodo",
      "bronzina",
      "brullo",
      "bruno",
      "bubbone",
      "buca",
      "budino",
      "buffone",
      "buio",
      "bulbo",
      "buono",
      "burlone",
      "burrasca",
      "bussola",
      "busta",
      "cadetto",
      "caduco",
      "calamaro",
      "calcolo",
      "calesse",
      "calibro",
      "calmo",
      "caloria",
      "cambusa",
      "camerata",
      "camicia",
      "cammino",
      "camola",
      "campale",
      "canapa",
      "candela",
      "cane",
      "canino",
      "canotto",
      "cantina",
      "capace",
      "capello",
      "capitolo",
      "capogiro",
      "cappero",
      "capra",
      "capsula",
      "carapace",
      "carcassa",
      "cardo",
      "carisma",
      "carovana",
      "carretto",
      "cartolina",
      "casaccio",
      "cascata",
      "caserma",
      "caso",
      "cassone",
      "castello",
      "casuale",
      "catasta",
      "catena",
      "catrame",
      "cauto",
      "cavillo",
      "cedibile",
      "cedrata",
      "cefalo",
      "celebre",
      "cellulare",
      "cena",
      "cenone",
      "centesimo",
      "ceramica",
      "cercare",
      "certo",
      "cerume",
      "cervello",
      "cesoia",
      "cespo",
      "ceto",
      "chela",
      "chiaro",
      "chicca",
      "chiedere",
      "chimera",
      "china",
      "chirurgo",
      "chitarra",
      "ciao",
      "ciclismo",
      "cifrare",
      "cigno",
      "cilindro",
      "ciottolo",
      "circa",
      "cirrosi",
      "citrico",
      "cittadino",
      "ciuffo",
      "civetta",
      "civile",
      "classico",
      "clinica",
      "cloro",
      "cocco",
      "codardo",
      "codice",
      "coerente",
      "cognome",
      "collare",
      "colmato",
      "colore",
      "colposo",
      "coltivato",
      "colza",
      "coma",
      "cometa",
      "commando",
      "comodo",
      "computer",
      "comune",
      "conciso",
      "condurre",
      "conferma",
      "congelare",
      "coniuge",
      "connesso",
      "conoscere",
      "consumo",
      "continuo",
      "convegno",
      "coperto",
      "copione",
      "coppia",
      "copricapo",
      "corazza",
      "cordata",
      "coricato",
      "cornice",
      "corolla",
      "corpo",
      "corredo",
      "corsia",
      "cortese",
      "cosmico",
      "costante",
      "cottura",
      "covato",
      "cratere",
      "cravatta",
      "creato",
      "credere",
      "cremoso",
      "crescita",
      "creta",
      "criceto",
      "crinale",
      "crisi",
      "critico",
      "croce",
      "cronaca",
      "crostata",
      "cruciale",
      "crusca",
      "cucire",
      "cuculo",
      "cugino",
      "cullato",
      "cupola",
      "curatore",
      "cursore",
      "curvo",
      "cuscino",
      "custode",
      "dado",
      "daino",
      "dalmata",
      "damerino",
      "daniela",
      "dannoso",
      "danzare",
      "datato",
      "davanti",
      "davvero",
      "debutto",
      "decennio",
      "deciso",
      "declino",
      "decollo",
      "decreto",
      "dedicato",
      "definito",
      "deforme",
      "degno",
      "delegare",
      "delfino",
      "delirio",
      "delta",
      "demenza",
      "denotato",
      "dentro",
      "deposito",
      "derapata",
      "derivare",
      "deroga",
      "descritto",
      "deserto",
      "desiderio",
      "desumere",
      "detersivo",
      "devoto",
      "diametro",
      "dicembre",
      "diedro",
      "difeso",
      "diffuso",
      "digerire",
      "digitale",
      "diluvio",
      "dinamico",
      "dinnanzi",
      "dipinto",
      "diploma",
      "dipolo",
      "diradare",
      "dire",
      "dirotto",
      "dirupo",
      "disagio",
      "discreto",
      "disfare",
      "disgelo",
      "disposto",
      "distanza",
      "disumano",
      "dito",
      "divano",
      "divelto",
      "dividere",
      "divorato",
      "doblone",
      "docente",
      "doganale",
      "dogma",
      "dolce",
      "domato",
      "domenica",
      "dominare",
      "dondolo",
      "dono",
      "dormire",
      "dote",
      "dottore",
      "dovuto",
      "dozzina",
      "drago",
      "druido",
      "dubbio",
      "dubitare",
      "ducale",
      "duna",
      "duomo",
      "duplice",
      "duraturo",
      "ebano",
      "eccesso",
      "ecco",
      "eclissi",
      "economia",
      "edera",
      "edicola",
      "edile",
      "editoria",
      "educare",
      "egemonia",
      "egli",
      "egoismo",
      "egregio",
      "elaborato",
      "elargire",
      "elegante",
      "elencato",
      "eletto",
      "elevare",
      "elfico",
      "elica",
      "elmo",
      "elsa",
      "eluso",
      "emanato",
      "emblema",
      "emesso",
      "emiro",
      "emotivo",
      "emozione",
      "empirico",
      "emulo",
      "endemico",
      "enduro",
      "energia",
      "enfasi",
      "enoteca",
      "entrare",
      "enzima",
      "epatite",
      "epilogo",
      "episodio",
      "epocale",
      "eppure",
      "equatore",
      "erario",
      "erba",
      "erboso",
      "erede",
      "eremita",
      "erigere",
      "ermetico",
      "eroe",
      "erosivo",
      "errante",
      "esagono",
      "esame",
      "esanime",
      "esaudire",
      "esca",
      "esempio",
      "esercito",
      "esibito",
      "esigente",
      "esistere",
      "esito",
      "esofago",
      "esortato",
      "esoso",
      "espanso",
      "espresso",
      "essenza",
      "esso",
      "esteso",
      "estimare",
      "estonia",
      "estroso",
      "esultare",
      "etilico",
      "etnico",
      "etrusco",
      "etto",
      "euclideo",
      "europa",
      "evaso",
      "evidenza",
      "evitato",
      "evoluto",
      "evviva",
      "fabbrica",
      "faccenda",
      "fachiro",
      "falco",
      "famiglia",
      "fanale",
      "fanfara",
      "fango",
      "fantasma",
      "fare",
      "farfalla",
      "farinoso",
      "farmaco",
      "fascia",
      "fastoso",
      "fasullo",
      "faticare",
      "fato",
      "favoloso",
      "febbre",
      "fecola",
      "fede",
      "fegato",
      "felpa",
      "feltro",
      "femmina",
      "fendere",
      "fenomeno",
      "fermento",
      "ferro",
      "fertile",
      "fessura",
      "festivo",
      "fetta",
      "feudo",
      "fiaba",
      "fiducia",
      "fifa",
      "figurato",
      "filo",
      "finanza",
      "finestra",
      "finire",
      "fiore",
      "fiscale",
      "fisico",
      "fiume",
      "flacone",
      "flamenco",
      "flebo",
      "flemma",
      "florido",
      "fluente",
      "fluoro",
      "fobico",
      "focaccia",
      "focoso",
      "foderato",
      "foglio",
      "folata",
      "folclore",
      "folgore",
      "fondente",
      "fonetico",
      "fonia",
      "fontana",
      "forbito",
      "forchetta",
      "foresta",
      "formica",
      "fornaio",
      "foro",
      "fortezza",
      "forzare",
      "fosfato",
      "fosso",
      "fracasso",
      "frana",
      "frassino",
      "fratello",
      "freccetta",
      "frenata",
      "fresco",
      "frigo",
      "frollino",
      "fronde",
      "frugale",
      "frutta",
      "fucilata",
      "fucsia",
      "fuggente",
      "fulmine",
      "fulvo",
      "fumante",
      "fumetto",
      "fumoso",
      "fune",
      "funzione",
      "fuoco",
      "furbo",
      "furgone",
      "furore",
      "fuso",
      "futile",
      "gabbiano",
      "gaffe",
      "galateo",
      "gallina",
      "galoppo",
      "gambero",
      "gamma",
      "garanzia",
      "garbo",
      "garofano",
      "garzone",
      "gasdotto",
      "gasolio",
      "gastrico",
      "gatto",
      "gaudio",
      "gazebo",
      "gazzella",
      "geco",
      "gelatina",
      "gelso",
      "gemello",
      "gemmato",
      "gene",
      "genitore",
      "gennaio",
      "genotipo",
      "gergo",
      "ghepardo",
      "ghiaccio",
      "ghisa",
      "giallo",
      "gilda",
      "ginepro",
      "giocare",
      "gioiello",
      "giorno",
      "giove",
      "girato",
      "girone",
      "gittata",
      "giudizio",
      "giurato",
      "giusto",
      "globulo",
      "glutine",
      "gnomo",
      "gobba",
      "golf",
      "gomito",
      "gommone",
      "gonfio",
      "gonna",
      "governo",
      "gracile",
      "grado",
      "grafico",
      "grammo",
      "grande",
      "grattare",
      "gravoso",
      "grazia",
      "greca",
      "gregge",
      "grifone",
      "grigio",
      "grinza",
      "grotta",
      "gruppo",
      "guadagno",
      "guaio",
      "guanto",
      "guardare",
      "gufo",
      "guidare",
      "ibernato",
      "icona",
      "identico",
      "idillio",
      "idolo",
      "idra",
      "idrico",
      "idrogeno",
      "igiene",
      "ignaro",
      "ignorato",
      "ilare",
      "illeso",
      "illogico",
      "illudere",
      "imballo",
      "imbevuto",
      "imbocco",
      "imbuto",
      "immane",
      "immerso",
      "immolato",
      "impacco",
      "impeto",
      "impiego",
      "importo",
      "impronta",
      "inalare",
      "inarcare",
      "inattivo",
      "incanto",
      "incendio",
      "inchino",
      "incisivo",
      "incluso",
      "incontro",
      "incrocio",
      "incubo",
      "indagine",
      "india",
      "indole",
      "inedito",
      "infatti",
      "infilare",
      "inflitto",
      "ingaggio",
      "ingegno",
      "inglese",
      "ingordo",
      "ingrosso",
      "innesco",
      "inodore",
      "inoltrare",
      "inondato",
      "insano",
      "insetto",
      "insieme",
      "insonnia",
      "insulina",
      "intasato",
      "intero",
      "intonaco",
      "intuito",
      "inumidire",
      "invalido",
      "invece",
      "invito",
      "iperbole",
      "ipnotico",
      "ipotesi",
      "ippica",
      "iride",
      "irlanda",
      "ironico",
      "irrigato",
      "irrorare",
      "isolato",
      "isotopo",
      "isterico",
      "istituto",
      "istrice",
      "italia",
      "iterare",
      "labbro",
      "labirinto",
      "lacca",
      "lacerato",
      "lacrima",
      "lacuna",
      "laddove",
      "lago",
      "lampo",
      "lancetta",
      "lanterna",
      "lardoso",
      "larga",
      "laringe",
      "lastra",
      "latenza",
      "latino",
      "lattuga",
      "lavagna",
      "lavoro",
      "legale",
      "leggero",
      "lembo",
      "lentezza",
      "lenza",
      "leone",
      "lepre",
      "lesivo",
      "lessato",
      "lesto",
      "letterale",
      "leva",
      "levigato",
      "libero",
      "lido",
      "lievito",
      "lilla",
      "limatura",
      "limitare",
      "limpido",
      "lineare",
      "lingua",
      "liquido",
      "lira",
      "lirica",
      "lisca",
      "lite",
      "litigio",
      "livrea",
      "locanda",
      "lode",
      "logica",
      "lombare",
      "londra",
      "longevo",
      "loquace",
      "lorenzo",
      "loto",
      "lotteria",
      "luce",
      "lucidato",
      "lumaca",
      "luminoso",
      "lungo",
      "lupo",
      "luppolo",
      "lusinga",
      "lusso",
      "lutto",
      "macabro",
      "macchina",
      "macero",
      "macinato",
      "madama",
      "magico",
      "maglia",
      "magnete",
      "magro",
      "maiolica",
      "malafede",
      "malgrado",
      "malinteso",
      "malsano",
      "malto",
      "malumore",
      "mana",
      "mancia",
      "mandorla",
      "mangiare",
      "manifesto",
      "mannaro",
      "manovra",
      "mansarda",
      "mantide",
      "manubrio",
      "mappa",
      "maratona",
      "marcire",
      "maretta",
      "marmo",
      "marsupio",
      "maschera",
      "massaia",
      "mastino",
      "materasso",
      "matricola",
      "mattone",
      "maturo",
      "mazurca",
      "meandro",
      "meccanico",
      "mecenate",
      "medesimo",
      "meditare",
      "mega",
      "melassa",
      "melis",
      "melodia",
      "meninge",
      "meno",
      "mensola",
      "mercurio",
      "merenda",
      "merlo",
      "meschino",
      "mese",
      "messere",
      "mestolo",
      "metallo",
      "metodo",
      "mettere",
      "miagolare",
      "mica",
      "micelio",
      "michele",
      "microbo",
      "midollo",
      "miele",
      "migliore",
      "milano",
      "milite",
      "mimosa",
      "minerale",
      "mini",
      "minore",
      "mirino",
      "mirtillo",
      "miscela",
      "missiva",
      "misto",
      "misurare",
      "mitezza",
      "mitigare",
      "mitra",
      "mittente",
      "mnemonico",
      "modello",
      "modifica",
      "modulo",
      "mogano",
      "mogio",
      "mole",
      "molosso",
      "monastero",
      "monco",
      "mondina",
      "monetario",
      "monile",
      "monotono",
      "monsone",
      "montato",
      "monviso",
      "mora",
      "mordere",
      "morsicato",
      "mostro",
      "motivato",
      "motosega",
      "motto",
      "movenza",
      "movimento",
      "mozzo",
      "mucca",
      "mucosa",
      "muffa",
      "mughetto",
      "mugnaio",
      "mulatto",
      "mulinello",
      "multiplo",
      "mummia",
      "munto",
      "muovere",
      "murale",
      "musa",
      "muscolo",
      "musica",
      "mutevole",
      "muto",
      "nababbo",
      "nafta",
      "nanometro",
      "narciso",
      "narice",
      "narrato",
      "nascere",
      "nastrare",
      "naturale",
      "nautica",
      "naviglio",
      "nebulosa",
      "necrosi",
      "negativo",
      "negozio",
      "nemmeno",
      "neofita",
      "neretto",
      "nervo",
      "nessuno",
      "nettuno",
      "neutrale",
      "neve",
      "nevrotico",
      "nicchia",
      "ninfa",
      "nitido",
      "nobile",
      "nocivo",
      "nodo",
      "nome",
      "nomina",
      "nordico",
      "normale",
      "norvegese",
      "nostrano",
      "notare",
      "notizia",
      "notturno",
      "novella",
      "nucleo",
      "nulla",
      "numero",
      "nuovo",
      "nutrire",
      "nuvola",
      "nuziale",
      "oasi",
      "obbedire",
      "obbligo",
      "obelisco",
      "oblio",
      "obolo",
      "obsoleto",
      "occasione",
      "occhio",
      "occidente",
      "occorrere",
      "occultare",
      "ocra",
      "oculato",
      "odierno",
      "odorare",
      "offerta",
      "offrire",
      "offuscato",
      "oggetto",
      "oggi",
      "ognuno",
      "olandese",
      "olfatto",
      "oliato",
      "oliva",
      "ologramma",
      "oltre",
      "omaggio",
      "ombelico",
      "ombra",
      "omega",
      "omissione",
      "ondoso",
      "onere",
      "onice",
      "onnivoro",
      "onorevole",
      "onta",
      "operato",
      "opinione",
      "opposto",
      "oracolo",
      "orafo",
      "ordine",
      "orecchino",
      "orefice",
      "orfano",
      "organico",
      "origine",
      "orizzonte",
      "orma",
      "ormeggio",
      "ornativo",
      "orologio",
      "orrendo",
      "orribile",
      "ortensia",
      "ortica",
      "orzata",
      "orzo",
      "osare",
      "oscurare",
      "osmosi",
      "ospedale",
      "ospite",
      "ossa",
      "ossidare",
      "ostacolo",
      "oste",
      "otite",
      "otre",
      "ottagono",
      "ottimo",
      "ottobre",
      "ovale",
      "ovest",
      "ovino",
      "oviparo",
      "ovocito",
      "ovunque",
      "ovviare",
      "ozio",
      "pacchetto",
      "pace",
      "pacifico",
      "padella",
      "padrone",
      "paese",
      "paga",
      "pagina",
      "palazzina",
      "palesare",
      "pallido",
      "palo",
      "palude",
      "pandoro",
      "pannello",
      "paolo",
      "paonazzo",
      "paprica",
      "parabola",
      "parcella",
      "parere",
      "pargolo",
      "pari",
      "parlato",
      "parola",
      "partire",
      "parvenza",
      "parziale",
      "passivo",
      "pasticca",
      "patacca",
      "patologia",
      "pattume",
      "pavone",
      "peccato",
      "pedalare",
      "pedonale",
      "peggio",
      "peloso",
      "penare",
      "pendice",
      "penisola",
      "pennuto",
      "penombra",
      "pensare",
      "pentola",
      "pepe",
      "pepita",
      "perbene",
      "percorso",
      "perdonato",
      "perforare",
      "pergamena",
      "periodo",
      "permesso",
      "perno",
      "perplesso",
      "persuaso",
      "pertugio",
      "pervaso",
      "pesatore",
      "pesista",
      "peso",
      "pestifero",
      "petalo",
      "pettine",
      "petulante",
      "pezzo",
      "piacere",
      "pianta",
      "piattino",
      "piccino",
      "picozza",
      "piega",
      "pietra",
      "piffero",
      "pigiama",
      "pigolio",
      "pigro",
      "pila",
      "pilifero",
      "pillola",
      "pilota",
      "pimpante",
      "pineta",
      "pinna",
      "pinolo",
      "pioggia",
      "piombo",
      "piramide",
      "piretico",
      "pirite",
      "pirolisi",
      "pitone",
      "pizzico",
      "placebo",
      "planare",
      "plasma",
      "platano",
      "plenario",
      "pochezza",
      "poderoso",
      "podismo",
      "poesia",
      "poggiare",
      "polenta",
      "poligono",
      "pollice",
      "polmonite",
      "polpetta",
      "polso",
      "poltrona",
      "polvere",
      "pomice",
      "pomodoro",
      "ponte",
      "popoloso",
      "porfido",
      "poroso",
      "porpora",
      "porre",
      "portata",
      "posa",
      "positivo",
      "possesso",
      "postulato",
      "potassio",
      "potere",
      "pranzo",
      "prassi",
      "pratica",
      "precluso",
      "predica",
      "prefisso",
      "pregiato",
      "prelievo",
      "premere",
      "prenotare",
      "preparato",
      "presenza",
      "pretesto",
      "prevalso",
      "prima",
      "principe",
      "privato",
      "problema",
      "procura",
      "produrre",
      "profumo",
      "progetto",
      "prolunga",
      "promessa",
      "pronome",
      "proposta",
      "proroga",
      "proteso",
      "prova",
      "prudente",
      "prugna",
      "prurito",
      "psiche",
      "pubblico",
      "pudica",
      "pugilato",
      "pugno",
      "pulce",
      "pulito",
      "pulsante",
      "puntare",
      "pupazzo",
      "pupilla",
      "puro",
      "quadro",
      "qualcosa",
      "quasi",
      "querela",
      "quota",
      "raccolto",
      "raddoppio",
      "radicale",
      "radunato",
      "raffica",
      "ragazzo",
      "ragione",
      "ragno",
      "ramarro",
      "ramingo",
      "ramo",
      "randagio",
      "rantolare",
      "rapato",
      "rapina",
      "rappreso",
      "rasatura",
      "raschiato",
      "rasente",
      "rassegna",
      "rastrello",
      "rata",
      "ravveduto",
      "reale",
      "recepire",
      "recinto",
      "recluta",
      "recondito",
      "recupero",
      "reddito",
      "redimere",
      "regalato",
      "registro",
      "regola",
      "regresso",
      "relazione",
      "remare",
      "remoto",
      "renna",
      "replica",
      "reprimere",
      "reputare",
      "resa",
      "residente",
      "responso",
      "restauro",
      "rete",
      "retina",
      "retorica",
      "rettifica",
      "revocato",
      "riassunto",
      "ribadire",
      "ribelle",
      "ribrezzo",
      "ricarica",
      "ricco",
      "ricevere",
      "riciclato",
      "ricordo",
      "ricreduto",
      "ridicolo",
      "ridurre",
      "rifasare",
      "riflesso",
      "riforma",
      "rifugio",
      "rigare",
      "rigettato",
      "righello",
      "rilassato",
      "rilevato",
      "rimanere",
      "rimbalzo",
      "rimedio",
      "rimorchio",
      "rinascita",
      "rincaro",
      "rinforzo",
      "rinnovo",
      "rinomato",
      "rinsavito",
      "rintocco",
      "rinuncia",
      "rinvenire",
      "riparato",
      "ripetuto",
      "ripieno",
      "riportare",
      "ripresa",
      "ripulire",
      "risata",
      "rischio",
      "riserva",
      "risibile",
      "riso",
      "rispetto",
      "ristoro",
      "risultato",
      "risvolto",
      "ritardo",
      "ritegno",
      "ritmico",
      "ritrovo",
      "riunione",
      "riva",
      "riverso",
      "rivincita",
      "rivolto",
      "rizoma",
      "roba",
      "robotico",
      "robusto",
      "roccia",
      "roco",
      "rodaggio",
      "rodere",
      "roditore",
      "rogito",
      "rollio",
      "romantico",
      "rompere",
      "ronzio",
      "rosolare",
      "rospo",
      "rotante",
      "rotondo",
      "rotula",
      "rovescio",
      "rubizzo",
      "rubrica",
      "ruga",
      "rullino",
      "rumine",
      "rumoroso",
      "ruolo",
      "rupe",
      "russare",
      "rustico",
      "sabato",
      "sabbiare",
      "sabotato",
      "sagoma",
      "salasso",
      "saldatura",
      "salgemma",
      "salivare",
      "salmone",
      "salone",
      "saltare",
      "saluto",
      "salvo",
      "sapere",
      "sapido",
      "saporito",
      "saraceno",
      "sarcasmo",
      "sarto",
      "sassoso",
      "satellite",
      "satira",
      "satollo",
      "saturno",
      "savana",
      "savio",
      "saziato",
      "sbadiglio",
      "sbalzo",
      "sbancato",
      "sbarra",
      "sbattere",
      "sbavare",
      "sbendare",
      "sbirciare",
      "sbloccato",
      "sbocciato",
      "sbrinare",
      "sbruffone",
      "sbuffare",
      "scabroso",
      "scadenza",
      "scala",
      "scambiare",
      "scandalo",
      "scapola",
      "scarso",
      "scatenare",
      "scavato",
      "scelto",
      "scenico",
      "scettro",
      "scheda",
      "schiena",
      "sciarpa",
      "scienza",
      "scindere",
      "scippo",
      "sciroppo",
      "scivolo",
      "sclerare",
      "scodella",
      "scolpito",
      "scomparto",
      "sconforto",
      "scoprire",
      "scorta",
      "scossone",
      "scozzese",
      "scriba",
      "scrollare",
      "scrutinio",
      "scuderia",
      "scultore",
      "scuola",
      "scuro",
      "scusare",
      "sdebitare",
      "sdoganare",
      "seccatura",
      "secondo",
      "sedano",
      "seggiola",
      "segnalato",
      "segregato",
      "seguito",
      "selciato",
      "selettivo",
      "sella",
      "selvaggio",
      "semaforo",
      "sembrare",
      "seme",
      "seminato",
      "sempre",
      "senso",
      "sentire",
      "sepolto",
      "sequenza",
      "serata",
      "serbato",
      "sereno",
      "serio",
      "serpente",
      "serraglio",
      "servire",
      "sestina",
      "setola",
      "settimana",
      "sfacelo",
      "sfaldare",
      "sfamato",
      "sfarzoso",
      "sfaticato",
      "sfera",
      "sfida",
      "sfilato",
      "sfinge",
      "sfocato",
      "sfoderare",
      "sfogo",
      "sfoltire",
      "sforzato",
      "sfratto",
      "sfruttato",
      "sfuggito",
      "sfumare",
      "sfuso",
      "sgabello",
      "sgarbato",
      "sgonfiare",
      "sgorbio",
      "sgrassato",
      "sguardo",
      "sibilo",
      "siccome",
      "sierra",
      "sigla",
      "signore",
      "silenzio",
      "sillaba",
      "simbolo",
      "simpatico",
      "simulato",
      "sinfonia",
      "singolo",
      "sinistro",
      "sino",
      "sintesi",
      "sinusoide",
      "sipario",
      "sisma",
      "sistole",
      "situato",
      "slitta",
      "slogatura",
      "sloveno",
      "smarrito",
      "smemorato",
      "smentito",
      "smeraldo",
      "smilzo",
      "smontare",
      "smottato",
      "smussato",
      "snellire",
      "snervato",
      "snodo",
      "sobbalzo",
      "sobrio",
      "soccorso",
      "sociale",
      "sodale",
      "soffitto",
      "sogno",
      "soldato",
      "solenne",
      "solido",
      "sollazzo",
      "solo",
      "solubile",
      "solvente",
      "somatico",
      "somma",
      "sonda",
      "sonetto",
      "sonnifero",
      "sopire",
      "soppeso",
      "sopra",
      "sorgere",
      "sorpasso",
      "sorriso",
      "sorso",
      "sorteggio",
      "sorvolato",
      "sospiro",
      "sosta",
      "sottile",
      "spada",
      "spalla",
      "spargere",
      "spatola",
      "spavento",
      "spazzola",
      "specie",
      "spedire",
      "spegnere",
      "spelatura",
      "speranza",
      "spessore",
      "spettrale",
      "spezzato",
      "spia",
      "spigoloso",
      "spillato",
      "spinoso",
      "spirale",
      "splendido",
      "sportivo",
      "sposo",
      "spranga",
      "sprecare",
      "spronato",
      "spruzzo",
      "spuntino",
      "squillo",
      "sradicare",
      "srotolato",
      "stabile",
      "stacco",
      "staffa",
      "stagnare",
      "stampato",
      "stantio",
      "starnuto",
      "stasera",
      "statuto",
      "stelo",
      "steppa",
      "sterzo",
      "stiletto",
      "stima",
      "stirpe",
      "stivale",
      "stizzoso",
      "stonato",
      "storico",
      "strappo",
      "stregato",
      "stridulo",
      "strozzare",
      "strutto",
      "stuccare",
      "stufo",
      "stupendo",
      "subentro",
      "succoso",
      "sudore",
      "suggerito",
      "sugo",
      "sultano",
      "suonare",
      "superbo",
      "supporto",
      "surgelato",
      "surrogato",
      "sussurro",
      "sutura",
      "svagare",
      "svedese",
      "sveglio",
      "svelare",
      "svenuto",
      "svezia",
      "sviluppo",
      "svista",
      "svizzera",
      "svolta",
      "svuotare",
      "tabacco",
      "tabulato",
      "tacciare",
      "taciturno",
      "tale",
      "talismano",
      "tampone",
      "tannino",
      "tara",
      "tardivo",
      "targato",
      "tariffa",
      "tarpare",
      "tartaruga",
      "tasto",
      "tattico",
      "taverna",
      "tavolata",
      "tazza",
      "teca",
      "tecnico",
      "telefono",
      "temerario",
      "tempo",
      "temuto",
      "tendone",
      "tenero",
      "tensione",
      "tentacolo",
      "teorema",
      "terme",
      "terrazzo",
      "terzetto",
      "tesi",
      "tesserato",
      "testato",
      "tetro",
      "tettoia",
      "tifare",
      "tigella",
      "timbro",
      "tinto",
      "tipico",
      "tipografo",
      "tiraggio",
      "tiro",
      "titanio",
      "titolo",
      "titubante",
      "tizio",
      "tizzone",
      "toccare",
      "tollerare",
      "tolto",
      "tombola",
      "tomo",
      "tonfo",
      "tonsilla",
      "topazio",
      "topologia",
      "toppa",
      "torba",
      "tornare",
      "torrone",
      "tortora",
      "toscano",
      "tossire",
      "tostatura",
      "totano",
      "trabocco",
      "trachea",
      "trafila",
      "tragedia",
      "tralcio",
      "tramonto",
      "transito",
      "trapano",
      "trarre",
      "trasloco",
      "trattato",
      "trave",
      "treccia",
      "tremolio",
      "trespolo",
      "tributo",
      "tricheco",
      "trifoglio",
      "trillo",
      "trincea",
      "trio",
      "tristezza",
      "triturato",
      "trivella",
      "tromba",
      "trono",
      "troppo",
      "trottola",
      "trovare",
      "truccato",
      "tubatura",
      "tuffato",
      "tulipano",
      "tumulto",
      "tunisia",
      "turbare",
      "turchino",
      "tuta",
      "tutela",
      "ubicato",
      "uccello",
      "uccisore",
      "udire",
      "uditivo",
      "uffa",
      "ufficio",
      "uguale",
      "ulisse",
      "ultimato",
      "umano",
      "umile",
      "umorismo",
      "uncinetto",
      "ungere",
      "ungherese",
      "unicorno",
      "unificato",
      "unisono",
      "unitario",
      "unte",
      "uovo",
      "upupa",
      "uragano",
      "urgenza",
      "urlo",
      "usanza",
      "usato",
      "uscito",
      "usignolo",
      "usuraio",
      "utensile",
      "utilizzo",
      "utopia",
      "vacante",
      "vaccinato",
      "vagabondo",
      "vagliato",
      "valanga",
      "valgo",
      "valico",
      "valletta",
      "valoroso",
      "valutare",
      "valvola",
      "vampata",
      "vangare",
      "vanitoso",
      "vano",
      "vantaggio",
      "vanvera",
      "vapore",
      "varano",
      "varcato",
      "variante",
      "vasca",
      "vedetta",
      "vedova",
      "veduto",
      "vegetale",
      "veicolo",
      "velcro",
      "velina",
      "velluto",
      "veloce",
      "venato",
      "vendemmia",
      "vento",
      "verace",
      "verbale",
      "vergogna",
      "verifica",
      "vero",
      "verruca",
      "verticale",
      "vescica",
      "vessillo",
      "vestale",
      "veterano",
      "vetrina",
      "vetusto",
      "viandante",
      "vibrante",
      "vicenda",
      "vichingo",
      "vicinanza",
      "vidimare",
      "vigilia",
      "vigneto",
      "vigore",
      "vile",
      "villano",
      "vimini",
      "vincitore",
      "viola",
      "vipera",
      "virgola",
      "virologo",
      "virulento",
      "viscoso",
      "visione",
      "vispo",
      "vissuto",
      "visura",
      "vita",
      "vitello",
      "vittima",
      "vivanda",
      "vivido",
      "viziare",
      "voce",
      "voga",
      "volatile",
      "volere",
      "volpe",
      "voragine",
      "vulcano",
      "zampogna",
      "zanna",
      "zappato",
      "zattera",
      "zavorra",
      "zefiro",
      "zelante",
      "zelo",
      "zenzero",
      "zerbino",
      "zibetto",
      "zinco",
      "zircone",
      "zitto",
      "zolla",
      "zotico",
      "zucchero",
      "zufolo",
      "zulu",
      "zuppa"
    ];
  }
});

// ../../node_modules/bip39/src/wordlists/spanish.json
var require_spanish = __commonJS({
  "../../node_modules/bip39/src/wordlists/spanish.json"(exports2, module2) {
    module2.exports = [
      "ábaco",
      "abdomen",
      "abeja",
      "abierto",
      "abogado",
      "abono",
      "aborto",
      "abrazo",
      "abrir",
      "abuelo",
      "abuso",
      "acabar",
      "academia",
      "acceso",
      "acción",
      "aceite",
      "acelga",
      "acento",
      "aceptar",
      "ácido",
      "aclarar",
      "acné",
      "acoger",
      "acoso",
      "activo",
      "acto",
      "actriz",
      "actuar",
      "acudir",
      "acuerdo",
      "acusar",
      "adicto",
      "admitir",
      "adoptar",
      "adorno",
      "aduana",
      "adulto",
      "aéreo",
      "afectar",
      "afición",
      "afinar",
      "afirmar",
      "ágil",
      "agitar",
      "agonía",
      "agosto",
      "agotar",
      "agregar",
      "agrio",
      "agua",
      "agudo",
      "águila",
      "aguja",
      "ahogo",
      "ahorro",
      "aire",
      "aislar",
      "ajedrez",
      "ajeno",
      "ajuste",
      "alacrán",
      "alambre",
      "alarma",
      "alba",
      "álbum",
      "alcalde",
      "aldea",
      "alegre",
      "alejar",
      "alerta",
      "aleta",
      "alfiler",
      "alga",
      "algodón",
      "aliado",
      "aliento",
      "alivio",
      "alma",
      "almeja",
      "almíbar",
      "altar",
      "alteza",
      "altivo",
      "alto",
      "altura",
      "alumno",
      "alzar",
      "amable",
      "amante",
      "amapola",
      "amargo",
      "amasar",
      "ámbar",
      "ámbito",
      "ameno",
      "amigo",
      "amistad",
      "amor",
      "amparo",
      "amplio",
      "ancho",
      "anciano",
      "ancla",
      "andar",
      "andén",
      "anemia",
      "ángulo",
      "anillo",
      "ánimo",
      "anís",
      "anotar",
      "antena",
      "antiguo",
      "antojo",
      "anual",
      "anular",
      "anuncio",
      "añadir",
      "añejo",
      "año",
      "apagar",
      "aparato",
      "apetito",
      "apio",
      "aplicar",
      "apodo",
      "aporte",
      "apoyo",
      "aprender",
      "aprobar",
      "apuesta",
      "apuro",
      "arado",
      "araña",
      "arar",
      "árbitro",
      "árbol",
      "arbusto",
      "archivo",
      "arco",
      "arder",
      "ardilla",
      "arduo",
      "área",
      "árido",
      "aries",
      "armonía",
      "arnés",
      "aroma",
      "arpa",
      "arpón",
      "arreglo",
      "arroz",
      "arruga",
      "arte",
      "artista",
      "asa",
      "asado",
      "asalto",
      "ascenso",
      "asegurar",
      "aseo",
      "asesor",
      "asiento",
      "asilo",
      "asistir",
      "asno",
      "asombro",
      "áspero",
      "astilla",
      "astro",
      "astuto",
      "asumir",
      "asunto",
      "atajo",
      "ataque",
      "atar",
      "atento",
      "ateo",
      "ático",
      "atleta",
      "átomo",
      "atraer",
      "atroz",
      "atún",
      "audaz",
      "audio",
      "auge",
      "aula",
      "aumento",
      "ausente",
      "autor",
      "aval",
      "avance",
      "avaro",
      "ave",
      "avellana",
      "avena",
      "avestruz",
      "avión",
      "aviso",
      "ayer",
      "ayuda",
      "ayuno",
      "azafrán",
      "azar",
      "azote",
      "azúcar",
      "azufre",
      "azul",
      "baba",
      "babor",
      "bache",
      "bahía",
      "baile",
      "bajar",
      "balanza",
      "balcón",
      "balde",
      "bambú",
      "banco",
      "banda",
      "baño",
      "barba",
      "barco",
      "barniz",
      "barro",
      "báscula",
      "bastón",
      "basura",
      "batalla",
      "batería",
      "batir",
      "batuta",
      "baúl",
      "bazar",
      "bebé",
      "bebida",
      "bello",
      "besar",
      "beso",
      "bestia",
      "bicho",
      "bien",
      "bingo",
      "blanco",
      "bloque",
      "blusa",
      "boa",
      "bobina",
      "bobo",
      "boca",
      "bocina",
      "boda",
      "bodega",
      "boina",
      "bola",
      "bolero",
      "bolsa",
      "bomba",
      "bondad",
      "bonito",
      "bono",
      "bonsái",
      "borde",
      "borrar",
      "bosque",
      "bote",
      "botín",
      "bóveda",
      "bozal",
      "bravo",
      "brazo",
      "brecha",
      "breve",
      "brillo",
      "brinco",
      "brisa",
      "broca",
      "broma",
      "bronce",
      "brote",
      "bruja",
      "brusco",
      "bruto",
      "buceo",
      "bucle",
      "bueno",
      "buey",
      "bufanda",
      "bufón",
      "búho",
      "buitre",
      "bulto",
      "burbuja",
      "burla",
      "burro",
      "buscar",
      "butaca",
      "buzón",
      "caballo",
      "cabeza",
      "cabina",
      "cabra",
      "cacao",
      "cadáver",
      "cadena",
      "caer",
      "café",
      "caída",
      "caimán",
      "caja",
      "cajón",
      "cal",
      "calamar",
      "calcio",
      "caldo",
      "calidad",
      "calle",
      "calma",
      "calor",
      "calvo",
      "cama",
      "cambio",
      "camello",
      "camino",
      "campo",
      "cáncer",
      "candil",
      "canela",
      "canguro",
      "canica",
      "canto",
      "caña",
      "cañón",
      "caoba",
      "caos",
      "capaz",
      "capitán",
      "capote",
      "captar",
      "capucha",
      "cara",
      "carbón",
      "cárcel",
      "careta",
      "carga",
      "cariño",
      "carne",
      "carpeta",
      "carro",
      "carta",
      "casa",
      "casco",
      "casero",
      "caspa",
      "castor",
      "catorce",
      "catre",
      "caudal",
      "causa",
      "cazo",
      "cebolla",
      "ceder",
      "cedro",
      "celda",
      "célebre",
      "celoso",
      "célula",
      "cemento",
      "ceniza",
      "centro",
      "cerca",
      "cerdo",
      "cereza",
      "cero",
      "cerrar",
      "certeza",
      "césped",
      "cetro",
      "chacal",
      "chaleco",
      "champú",
      "chancla",
      "chapa",
      "charla",
      "chico",
      "chiste",
      "chivo",
      "choque",
      "choza",
      "chuleta",
      "chupar",
      "ciclón",
      "ciego",
      "cielo",
      "cien",
      "cierto",
      "cifra",
      "cigarro",
      "cima",
      "cinco",
      "cine",
      "cinta",
      "ciprés",
      "circo",
      "ciruela",
      "cisne",
      "cita",
      "ciudad",
      "clamor",
      "clan",
      "claro",
      "clase",
      "clave",
      "cliente",
      "clima",
      "clínica",
      "cobre",
      "cocción",
      "cochino",
      "cocina",
      "coco",
      "código",
      "codo",
      "cofre",
      "coger",
      "cohete",
      "cojín",
      "cojo",
      "cola",
      "colcha",
      "colegio",
      "colgar",
      "colina",
      "collar",
      "colmo",
      "columna",
      "combate",
      "comer",
      "comida",
      "cómodo",
      "compra",
      "conde",
      "conejo",
      "conga",
      "conocer",
      "consejo",
      "contar",
      "copa",
      "copia",
      "corazón",
      "corbata",
      "corcho",
      "cordón",
      "corona",
      "correr",
      "coser",
      "cosmos",
      "costa",
      "cráneo",
      "cráter",
      "crear",
      "crecer",
      "creído",
      "crema",
      "cría",
      "crimen",
      "cripta",
      "crisis",
      "cromo",
      "crónica",
      "croqueta",
      "crudo",
      "cruz",
      "cuadro",
      "cuarto",
      "cuatro",
      "cubo",
      "cubrir",
      "cuchara",
      "cuello",
      "cuento",
      "cuerda",
      "cuesta",
      "cueva",
      "cuidar",
      "culebra",
      "culpa",
      "culto",
      "cumbre",
      "cumplir",
      "cuna",
      "cuneta",
      "cuota",
      "cupón",
      "cúpula",
      "curar",
      "curioso",
      "curso",
      "curva",
      "cutis",
      "dama",
      "danza",
      "dar",
      "dardo",
      "dátil",
      "deber",
      "débil",
      "década",
      "decir",
      "dedo",
      "defensa",
      "definir",
      "dejar",
      "delfín",
      "delgado",
      "delito",
      "demora",
      "denso",
      "dental",
      "deporte",
      "derecho",
      "derrota",
      "desayuno",
      "deseo",
      "desfile",
      "desnudo",
      "destino",
      "desvío",
      "detalle",
      "detener",
      "deuda",
      "día",
      "diablo",
      "diadema",
      "diamante",
      "diana",
      "diario",
      "dibujo",
      "dictar",
      "diente",
      "dieta",
      "diez",
      "difícil",
      "digno",
      "dilema",
      "diluir",
      "dinero",
      "directo",
      "dirigir",
      "disco",
      "diseño",
      "disfraz",
      "diva",
      "divino",
      "doble",
      "doce",
      "dolor",
      "domingo",
      "don",
      "donar",
      "dorado",
      "dormir",
      "dorso",
      "dos",
      "dosis",
      "dragón",
      "droga",
      "ducha",
      "duda",
      "duelo",
      "dueño",
      "dulce",
      "dúo",
      "duque",
      "durar",
      "dureza",
      "duro",
      "ébano",
      "ebrio",
      "echar",
      "eco",
      "ecuador",
      "edad",
      "edición",
      "edificio",
      "editor",
      "educar",
      "efecto",
      "eficaz",
      "eje",
      "ejemplo",
      "elefante",
      "elegir",
      "elemento",
      "elevar",
      "elipse",
      "élite",
      "elixir",
      "elogio",
      "eludir",
      "embudo",
      "emitir",
      "emoción",
      "empate",
      "empeño",
      "empleo",
      "empresa",
      "enano",
      "encargo",
      "enchufe",
      "encía",
      "enemigo",
      "enero",
      "enfado",
      "enfermo",
      "engaño",
      "enigma",
      "enlace",
      "enorme",
      "enredo",
      "ensayo",
      "enseñar",
      "entero",
      "entrar",
      "envase",
      "envío",
      "época",
      "equipo",
      "erizo",
      "escala",
      "escena",
      "escolar",
      "escribir",
      "escudo",
      "esencia",
      "esfera",
      "esfuerzo",
      "espada",
      "espejo",
      "espía",
      "esposa",
      "espuma",
      "esquí",
      "estar",
      "este",
      "estilo",
      "estufa",
      "etapa",
      "eterno",
      "ética",
      "etnia",
      "evadir",
      "evaluar",
      "evento",
      "evitar",
      "exacto",
      "examen",
      "exceso",
      "excusa",
      "exento",
      "exigir",
      "exilio",
      "existir",
      "éxito",
      "experto",
      "explicar",
      "exponer",
      "extremo",
      "fábrica",
      "fábula",
      "fachada",
      "fácil",
      "factor",
      "faena",
      "faja",
      "falda",
      "fallo",
      "falso",
      "faltar",
      "fama",
      "familia",
      "famoso",
      "faraón",
      "farmacia",
      "farol",
      "farsa",
      "fase",
      "fatiga",
      "fauna",
      "favor",
      "fax",
      "febrero",
      "fecha",
      "feliz",
      "feo",
      "feria",
      "feroz",
      "fértil",
      "fervor",
      "festín",
      "fiable",
      "fianza",
      "fiar",
      "fibra",
      "ficción",
      "ficha",
      "fideo",
      "fiebre",
      "fiel",
      "fiera",
      "fiesta",
      "figura",
      "fijar",
      "fijo",
      "fila",
      "filete",
      "filial",
      "filtro",
      "fin",
      "finca",
      "fingir",
      "finito",
      "firma",
      "flaco",
      "flauta",
      "flecha",
      "flor",
      "flota",
      "fluir",
      "flujo",
      "flúor",
      "fobia",
      "foca",
      "fogata",
      "fogón",
      "folio",
      "folleto",
      "fondo",
      "forma",
      "forro",
      "fortuna",
      "forzar",
      "fosa",
      "foto",
      "fracaso",
      "frágil",
      "franja",
      "frase",
      "fraude",
      "freír",
      "freno",
      "fresa",
      "frío",
      "frito",
      "fruta",
      "fuego",
      "fuente",
      "fuerza",
      "fuga",
      "fumar",
      "función",
      "funda",
      "furgón",
      "furia",
      "fusil",
      "fútbol",
      "futuro",
      "gacela",
      "gafas",
      "gaita",
      "gajo",
      "gala",
      "galería",
      "gallo",
      "gamba",
      "ganar",
      "gancho",
      "ganga",
      "ganso",
      "garaje",
      "garza",
      "gasolina",
      "gastar",
      "gato",
      "gavilán",
      "gemelo",
      "gemir",
      "gen",
      "género",
      "genio",
      "gente",
      "geranio",
      "gerente",
      "germen",
      "gesto",
      "gigante",
      "gimnasio",
      "girar",
      "giro",
      "glaciar",
      "globo",
      "gloria",
      "gol",
      "golfo",
      "goloso",
      "golpe",
      "goma",
      "gordo",
      "gorila",
      "gorra",
      "gota",
      "goteo",
      "gozar",
      "grada",
      "gráfico",
      "grano",
      "grasa",
      "gratis",
      "grave",
      "grieta",
      "grillo",
      "gripe",
      "gris",
      "grito",
      "grosor",
      "grúa",
      "grueso",
      "grumo",
      "grupo",
      "guante",
      "guapo",
      "guardia",
      "guerra",
      "guía",
      "guiño",
      "guion",
      "guiso",
      "guitarra",
      "gusano",
      "gustar",
      "haber",
      "hábil",
      "hablar",
      "hacer",
      "hacha",
      "hada",
      "hallar",
      "hamaca",
      "harina",
      "haz",
      "hazaña",
      "hebilla",
      "hebra",
      "hecho",
      "helado",
      "helio",
      "hembra",
      "herir",
      "hermano",
      "héroe",
      "hervir",
      "hielo",
      "hierro",
      "hígado",
      "higiene",
      "hijo",
      "himno",
      "historia",
      "hocico",
      "hogar",
      "hoguera",
      "hoja",
      "hombre",
      "hongo",
      "honor",
      "honra",
      "hora",
      "hormiga",
      "horno",
      "hostil",
      "hoyo",
      "hueco",
      "huelga",
      "huerta",
      "hueso",
      "huevo",
      "huida",
      "huir",
      "humano",
      "húmedo",
      "humilde",
      "humo",
      "hundir",
      "huracán",
      "hurto",
      "icono",
      "ideal",
      "idioma",
      "ídolo",
      "iglesia",
      "iglú",
      "igual",
      "ilegal",
      "ilusión",
      "imagen",
      "imán",
      "imitar",
      "impar",
      "imperio",
      "imponer",
      "impulso",
      "incapaz",
      "índice",
      "inerte",
      "infiel",
      "informe",
      "ingenio",
      "inicio",
      "inmenso",
      "inmune",
      "innato",
      "insecto",
      "instante",
      "interés",
      "íntimo",
      "intuir",
      "inútil",
      "invierno",
      "ira",
      "iris",
      "ironía",
      "isla",
      "islote",
      "jabalí",
      "jabón",
      "jamón",
      "jarabe",
      "jardín",
      "jarra",
      "jaula",
      "jazmín",
      "jefe",
      "jeringa",
      "jinete",
      "jornada",
      "joroba",
      "joven",
      "joya",
      "juerga",
      "jueves",
      "juez",
      "jugador",
      "jugo",
      "juguete",
      "juicio",
      "junco",
      "jungla",
      "junio",
      "juntar",
      "júpiter",
      "jurar",
      "justo",
      "juvenil",
      "juzgar",
      "kilo",
      "koala",
      "labio",
      "lacio",
      "lacra",
      "lado",
      "ladrón",
      "lagarto",
      "lágrima",
      "laguna",
      "laico",
      "lamer",
      "lámina",
      "lámpara",
      "lana",
      "lancha",
      "langosta",
      "lanza",
      "lápiz",
      "largo",
      "larva",
      "lástima",
      "lata",
      "látex",
      "latir",
      "laurel",
      "lavar",
      "lazo",
      "leal",
      "lección",
      "leche",
      "lector",
      "leer",
      "legión",
      "legumbre",
      "lejano",
      "lengua",
      "lento",
      "leña",
      "león",
      "leopardo",
      "lesión",
      "letal",
      "letra",
      "leve",
      "leyenda",
      "libertad",
      "libro",
      "licor",
      "líder",
      "lidiar",
      "lienzo",
      "liga",
      "ligero",
      "lima",
      "límite",
      "limón",
      "limpio",
      "lince",
      "lindo",
      "línea",
      "lingote",
      "lino",
      "linterna",
      "líquido",
      "liso",
      "lista",
      "litera",
      "litio",
      "litro",
      "llaga",
      "llama",
      "llanto",
      "llave",
      "llegar",
      "llenar",
      "llevar",
      "llorar",
      "llover",
      "lluvia",
      "lobo",
      "loción",
      "loco",
      "locura",
      "lógica",
      "logro",
      "lombriz",
      "lomo",
      "lonja",
      "lote",
      "lucha",
      "lucir",
      "lugar",
      "lujo",
      "luna",
      "lunes",
      "lupa",
      "lustro",
      "luto",
      "luz",
      "maceta",
      "macho",
      "madera",
      "madre",
      "maduro",
      "maestro",
      "mafia",
      "magia",
      "mago",
      "maíz",
      "maldad",
      "maleta",
      "malla",
      "malo",
      "mamá",
      "mambo",
      "mamut",
      "manco",
      "mando",
      "manejar",
      "manga",
      "maniquí",
      "manjar",
      "mano",
      "manso",
      "manta",
      "mañana",
      "mapa",
      "máquina",
      "mar",
      "marco",
      "marea",
      "marfil",
      "margen",
      "marido",
      "mármol",
      "marrón",
      "martes",
      "marzo",
      "masa",
      "máscara",
      "masivo",
      "matar",
      "materia",
      "matiz",
      "matriz",
      "máximo",
      "mayor",
      "mazorca",
      "mecha",
      "medalla",
      "medio",
      "médula",
      "mejilla",
      "mejor",
      "melena",
      "melón",
      "memoria",
      "menor",
      "mensaje",
      "mente",
      "menú",
      "mercado",
      "merengue",
      "mérito",
      "mes",
      "mesón",
      "meta",
      "meter",
      "método",
      "metro",
      "mezcla",
      "miedo",
      "miel",
      "miembro",
      "miga",
      "mil",
      "milagro",
      "militar",
      "millón",
      "mimo",
      "mina",
      "minero",
      "mínimo",
      "minuto",
      "miope",
      "mirar",
      "misa",
      "miseria",
      "misil",
      "mismo",
      "mitad",
      "mito",
      "mochila",
      "moción",
      "moda",
      "modelo",
      "moho",
      "mojar",
      "molde",
      "moler",
      "molino",
      "momento",
      "momia",
      "monarca",
      "moneda",
      "monja",
      "monto",
      "moño",
      "morada",
      "morder",
      "moreno",
      "morir",
      "morro",
      "morsa",
      "mortal",
      "mosca",
      "mostrar",
      "motivo",
      "mover",
      "móvil",
      "mozo",
      "mucho",
      "mudar",
      "mueble",
      "muela",
      "muerte",
      "muestra",
      "mugre",
      "mujer",
      "mula",
      "muleta",
      "multa",
      "mundo",
      "muñeca",
      "mural",
      "muro",
      "músculo",
      "museo",
      "musgo",
      "música",
      "muslo",
      "nácar",
      "nación",
      "nadar",
      "naipe",
      "naranja",
      "nariz",
      "narrar",
      "nasal",
      "natal",
      "nativo",
      "natural",
      "náusea",
      "naval",
      "nave",
      "navidad",
      "necio",
      "néctar",
      "negar",
      "negocio",
      "negro",
      "neón",
      "nervio",
      "neto",
      "neutro",
      "nevar",
      "nevera",
      "nicho",
      "nido",
      "niebla",
      "nieto",
      "niñez",
      "niño",
      "nítido",
      "nivel",
      "nobleza",
      "noche",
      "nómina",
      "noria",
      "norma",
      "norte",
      "nota",
      "noticia",
      "novato",
      "novela",
      "novio",
      "nube",
      "nuca",
      "núcleo",
      "nudillo",
      "nudo",
      "nuera",
      "nueve",
      "nuez",
      "nulo",
      "número",
      "nutria",
      "oasis",
      "obeso",
      "obispo",
      "objeto",
      "obra",
      "obrero",
      "observar",
      "obtener",
      "obvio",
      "oca",
      "ocaso",
      "océano",
      "ochenta",
      "ocho",
      "ocio",
      "ocre",
      "octavo",
      "octubre",
      "oculto",
      "ocupar",
      "ocurrir",
      "odiar",
      "odio",
      "odisea",
      "oeste",
      "ofensa",
      "oferta",
      "oficio",
      "ofrecer",
      "ogro",
      "oído",
      "oír",
      "ojo",
      "ola",
      "oleada",
      "olfato",
      "olivo",
      "olla",
      "olmo",
      "olor",
      "olvido",
      "ombligo",
      "onda",
      "onza",
      "opaco",
      "opción",
      "ópera",
      "opinar",
      "oponer",
      "optar",
      "óptica",
      "opuesto",
      "oración",
      "orador",
      "oral",
      "órbita",
      "orca",
      "orden",
      "oreja",
      "órgano",
      "orgía",
      "orgullo",
      "oriente",
      "origen",
      "orilla",
      "oro",
      "orquesta",
      "oruga",
      "osadía",
      "oscuro",
      "osezno",
      "oso",
      "ostra",
      "otoño",
      "otro",
      "oveja",
      "óvulo",
      "óxido",
      "oxígeno",
      "oyente",
      "ozono",
      "pacto",
      "padre",
      "paella",
      "página",
      "pago",
      "país",
      "pájaro",
      "palabra",
      "palco",
      "paleta",
      "pálido",
      "palma",
      "paloma",
      "palpar",
      "pan",
      "panal",
      "pánico",
      "pantera",
      "pañuelo",
      "papá",
      "papel",
      "papilla",
      "paquete",
      "parar",
      "parcela",
      "pared",
      "parir",
      "paro",
      "párpado",
      "parque",
      "párrafo",
      "parte",
      "pasar",
      "paseo",
      "pasión",
      "paso",
      "pasta",
      "pata",
      "patio",
      "patria",
      "pausa",
      "pauta",
      "pavo",
      "payaso",
      "peatón",
      "pecado",
      "pecera",
      "pecho",
      "pedal",
      "pedir",
      "pegar",
      "peine",
      "pelar",
      "peldaño",
      "pelea",
      "peligro",
      "pellejo",
      "pelo",
      "peluca",
      "pena",
      "pensar",
      "peñón",
      "peón",
      "peor",
      "pepino",
      "pequeño",
      "pera",
      "percha",
      "perder",
      "pereza",
      "perfil",
      "perico",
      "perla",
      "permiso",
      "perro",
      "persona",
      "pesa",
      "pesca",
      "pésimo",
      "pestaña",
      "pétalo",
      "petróleo",
      "pez",
      "pezuña",
      "picar",
      "pichón",
      "pie",
      "piedra",
      "pierna",
      "pieza",
      "pijama",
      "pilar",
      "piloto",
      "pimienta",
      "pino",
      "pintor",
      "pinza",
      "piña",
      "piojo",
      "pipa",
      "pirata",
      "pisar",
      "piscina",
      "piso",
      "pista",
      "pitón",
      "pizca",
      "placa",
      "plan",
      "plata",
      "playa",
      "plaza",
      "pleito",
      "pleno",
      "plomo",
      "pluma",
      "plural",
      "pobre",
      "poco",
      "poder",
      "podio",
      "poema",
      "poesía",
      "poeta",
      "polen",
      "policía",
      "pollo",
      "polvo",
      "pomada",
      "pomelo",
      "pomo",
      "pompa",
      "poner",
      "porción",
      "portal",
      "posada",
      "poseer",
      "posible",
      "poste",
      "potencia",
      "potro",
      "pozo",
      "prado",
      "precoz",
      "pregunta",
      "premio",
      "prensa",
      "preso",
      "previo",
      "primo",
      "príncipe",
      "prisión",
      "privar",
      "proa",
      "probar",
      "proceso",
      "producto",
      "proeza",
      "profesor",
      "programa",
      "prole",
      "promesa",
      "pronto",
      "propio",
      "próximo",
      "prueba",
      "público",
      "puchero",
      "pudor",
      "pueblo",
      "puerta",
      "puesto",
      "pulga",
      "pulir",
      "pulmón",
      "pulpo",
      "pulso",
      "puma",
      "punto",
      "puñal",
      "puño",
      "pupa",
      "pupila",
      "puré",
      "quedar",
      "queja",
      "quemar",
      "querer",
      "queso",
      "quieto",
      "química",
      "quince",
      "quitar",
      "rábano",
      "rabia",
      "rabo",
      "ración",
      "radical",
      "raíz",
      "rama",
      "rampa",
      "rancho",
      "rango",
      "rapaz",
      "rápido",
      "rapto",
      "rasgo",
      "raspa",
      "rato",
      "rayo",
      "raza",
      "razón",
      "reacción",
      "realidad",
      "rebaño",
      "rebote",
      "recaer",
      "receta",
      "rechazo",
      "recoger",
      "recreo",
      "recto",
      "recurso",
      "red",
      "redondo",
      "reducir",
      "reflejo",
      "reforma",
      "refrán",
      "refugio",
      "regalo",
      "regir",
      "regla",
      "regreso",
      "rehén",
      "reino",
      "reír",
      "reja",
      "relato",
      "relevo",
      "relieve",
      "relleno",
      "reloj",
      "remar",
      "remedio",
      "remo",
      "rencor",
      "rendir",
      "renta",
      "reparto",
      "repetir",
      "reposo",
      "reptil",
      "res",
      "rescate",
      "resina",
      "respeto",
      "resto",
      "resumen",
      "retiro",
      "retorno",
      "retrato",
      "reunir",
      "revés",
      "revista",
      "rey",
      "rezar",
      "rico",
      "riego",
      "rienda",
      "riesgo",
      "rifa",
      "rígido",
      "rigor",
      "rincón",
      "riñón",
      "río",
      "riqueza",
      "risa",
      "ritmo",
      "rito",
      "rizo",
      "roble",
      "roce",
      "rociar",
      "rodar",
      "rodeo",
      "rodilla",
      "roer",
      "rojizo",
      "rojo",
      "romero",
      "romper",
      "ron",
      "ronco",
      "ronda",
      "ropa",
      "ropero",
      "rosa",
      "rosca",
      "rostro",
      "rotar",
      "rubí",
      "rubor",
      "rudo",
      "rueda",
      "rugir",
      "ruido",
      "ruina",
      "ruleta",
      "rulo",
      "rumbo",
      "rumor",
      "ruptura",
      "ruta",
      "rutina",
      "sábado",
      "saber",
      "sabio",
      "sable",
      "sacar",
      "sagaz",
      "sagrado",
      "sala",
      "saldo",
      "salero",
      "salir",
      "salmón",
      "salón",
      "salsa",
      "salto",
      "salud",
      "salvar",
      "samba",
      "sanción",
      "sandía",
      "sanear",
      "sangre",
      "sanidad",
      "sano",
      "santo",
      "sapo",
      "saque",
      "sardina",
      "sartén",
      "sastre",
      "satán",
      "sauna",
      "saxofón",
      "sección",
      "seco",
      "secreto",
      "secta",
      "sed",
      "seguir",
      "seis",
      "sello",
      "selva",
      "semana",
      "semilla",
      "senda",
      "sensor",
      "señal",
      "señor",
      "separar",
      "sepia",
      "sequía",
      "ser",
      "serie",
      "sermón",
      "servir",
      "sesenta",
      "sesión",
      "seta",
      "setenta",
      "severo",
      "sexo",
      "sexto",
      "sidra",
      "siesta",
      "siete",
      "siglo",
      "signo",
      "sílaba",
      "silbar",
      "silencio",
      "silla",
      "símbolo",
      "simio",
      "sirena",
      "sistema",
      "sitio",
      "situar",
      "sobre",
      "socio",
      "sodio",
      "sol",
      "solapa",
      "soldado",
      "soledad",
      "sólido",
      "soltar",
      "solución",
      "sombra",
      "sondeo",
      "sonido",
      "sonoro",
      "sonrisa",
      "sopa",
      "soplar",
      "soporte",
      "sordo",
      "sorpresa",
      "sorteo",
      "sostén",
      "sótano",
      "suave",
      "subir",
      "suceso",
      "sudor",
      "suegra",
      "suelo",
      "sueño",
      "suerte",
      "sufrir",
      "sujeto",
      "sultán",
      "sumar",
      "superar",
      "suplir",
      "suponer",
      "supremo",
      "sur",
      "surco",
      "sureño",
      "surgir",
      "susto",
      "sutil",
      "tabaco",
      "tabique",
      "tabla",
      "tabú",
      "taco",
      "tacto",
      "tajo",
      "talar",
      "talco",
      "talento",
      "talla",
      "talón",
      "tamaño",
      "tambor",
      "tango",
      "tanque",
      "tapa",
      "tapete",
      "tapia",
      "tapón",
      "taquilla",
      "tarde",
      "tarea",
      "tarifa",
      "tarjeta",
      "tarot",
      "tarro",
      "tarta",
      "tatuaje",
      "tauro",
      "taza",
      "tazón",
      "teatro",
      "techo",
      "tecla",
      "técnica",
      "tejado",
      "tejer",
      "tejido",
      "tela",
      "teléfono",
      "tema",
      "temor",
      "templo",
      "tenaz",
      "tender",
      "tener",
      "tenis",
      "tenso",
      "teoría",
      "terapia",
      "terco",
      "término",
      "ternura",
      "terror",
      "tesis",
      "tesoro",
      "testigo",
      "tetera",
      "texto",
      "tez",
      "tibio",
      "tiburón",
      "tiempo",
      "tienda",
      "tierra",
      "tieso",
      "tigre",
      "tijera",
      "tilde",
      "timbre",
      "tímido",
      "timo",
      "tinta",
      "tío",
      "típico",
      "tipo",
      "tira",
      "tirón",
      "titán",
      "títere",
      "título",
      "tiza",
      "toalla",
      "tobillo",
      "tocar",
      "tocino",
      "todo",
      "toga",
      "toldo",
      "tomar",
      "tono",
      "tonto",
      "topar",
      "tope",
      "toque",
      "tórax",
      "torero",
      "tormenta",
      "torneo",
      "toro",
      "torpedo",
      "torre",
      "torso",
      "tortuga",
      "tos",
      "tosco",
      "toser",
      "tóxico",
      "trabajo",
      "tractor",
      "traer",
      "tráfico",
      "trago",
      "traje",
      "tramo",
      "trance",
      "trato",
      "trauma",
      "trazar",
      "trébol",
      "tregua",
      "treinta",
      "tren",
      "trepar",
      "tres",
      "tribu",
      "trigo",
      "tripa",
      "triste",
      "triunfo",
      "trofeo",
      "trompa",
      "tronco",
      "tropa",
      "trote",
      "trozo",
      "truco",
      "trueno",
      "trufa",
      "tubería",
      "tubo",
      "tuerto",
      "tumba",
      "tumor",
      "túnel",
      "túnica",
      "turbina",
      "turismo",
      "turno",
      "tutor",
      "ubicar",
      "úlcera",
      "umbral",
      "unidad",
      "unir",
      "universo",
      "uno",
      "untar",
      "uña",
      "urbano",
      "urbe",
      "urgente",
      "urna",
      "usar",
      "usuario",
      "útil",
      "utopía",
      "uva",
      "vaca",
      "vacío",
      "vacuna",
      "vagar",
      "vago",
      "vaina",
      "vajilla",
      "vale",
      "válido",
      "valle",
      "valor",
      "válvula",
      "vampiro",
      "vara",
      "variar",
      "varón",
      "vaso",
      "vecino",
      "vector",
      "vehículo",
      "veinte",
      "vejez",
      "vela",
      "velero",
      "veloz",
      "vena",
      "vencer",
      "venda",
      "veneno",
      "vengar",
      "venir",
      "venta",
      "venus",
      "ver",
      "verano",
      "verbo",
      "verde",
      "vereda",
      "verja",
      "verso",
      "verter",
      "vía",
      "viaje",
      "vibrar",
      "vicio",
      "víctima",
      "vida",
      "vídeo",
      "vidrio",
      "viejo",
      "viernes",
      "vigor",
      "vil",
      "villa",
      "vinagre",
      "vino",
      "viñedo",
      "violín",
      "viral",
      "virgo",
      "virtud",
      "visor",
      "víspera",
      "vista",
      "vitamina",
      "viudo",
      "vivaz",
      "vivero",
      "vivir",
      "vivo",
      "volcán",
      "volumen",
      "volver",
      "voraz",
      "votar",
      "voto",
      "voz",
      "vuelo",
      "vulgar",
      "yacer",
      "yate",
      "yegua",
      "yema",
      "yerno",
      "yeso",
      "yodo",
      "yoga",
      "yogur",
      "zafiro",
      "zanja",
      "zapato",
      "zarza",
      "zona",
      "zorro",
      "zumo",
      "zurdo"
    ];
  }
});

// ../../node_modules/bip39/src/wordlists/japanese.json
var require_japanese = __commonJS({
  "../../node_modules/bip39/src/wordlists/japanese.json"(exports2, module2) {
    module2.exports = [
      "あいこくしん",
      "あいさつ",
      "あいだ",
      "あおぞら",
      "あかちゃん",
      "あきる",
      "あけがた",
      "あける",
      "あこがれる",
      "あさい",
      "あさひ",
      "あしあと",
      "あじわう",
      "あずかる",
      "あずき",
      "あそぶ",
      "あたえる",
      "あたためる",
      "あたりまえ",
      "あたる",
      "あつい",
      "あつかう",
      "あっしゅく",
      "あつまり",
      "あつめる",
      "あてな",
      "あてはまる",
      "あひる",
      "あぶら",
      "あぶる",
      "あふれる",
      "あまい",
      "あまど",
      "あまやかす",
      "あまり",
      "あみもの",
      "あめりか",
      "あやまる",
      "あゆむ",
      "あらいぐま",
      "あらし",
      "あらすじ",
      "あらためる",
      "あらゆる",
      "あらわす",
      "ありがとう",
      "あわせる",
      "あわてる",
      "あんい",
      "あんがい",
      "あんこ",
      "あんぜん",
      "あんてい",
      "あんない",
      "あんまり",
      "いいだす",
      "いおん",
      "いがい",
      "いがく",
      "いきおい",
      "いきなり",
      "いきもの",
      "いきる",
      "いくじ",
      "いくぶん",
      "いけばな",
      "いけん",
      "いこう",
      "いこく",
      "いこつ",
      "いさましい",
      "いさん",
      "いしき",
      "いじゅう",
      "いじょう",
      "いじわる",
      "いずみ",
      "いずれ",
      "いせい",
      "いせえび",
      "いせかい",
      "いせき",
      "いぜん",
      "いそうろう",
      "いそがしい",
      "いだい",
      "いだく",
      "いたずら",
      "いたみ",
      "いたりあ",
      "いちおう",
      "いちじ",
      "いちど",
      "いちば",
      "いちぶ",
      "いちりゅう",
      "いつか",
      "いっしゅん",
      "いっせい",
      "いっそう",
      "いったん",
      "いっち",
      "いってい",
      "いっぽう",
      "いてざ",
      "いてん",
      "いどう",
      "いとこ",
      "いない",
      "いなか",
      "いねむり",
      "いのち",
      "いのる",
      "いはつ",
      "いばる",
      "いはん",
      "いびき",
      "いひん",
      "いふく",
      "いへん",
      "いほう",
      "いみん",
      "いもうと",
      "いもたれ",
      "いもり",
      "いやがる",
      "いやす",
      "いよかん",
      "いよく",
      "いらい",
      "いらすと",
      "いりぐち",
      "いりょう",
      "いれい",
      "いれもの",
      "いれる",
      "いろえんぴつ",
      "いわい",
      "いわう",
      "いわかん",
      "いわば",
      "いわゆる",
      "いんげんまめ",
      "いんさつ",
      "いんしょう",
      "いんよう",
      "うえき",
      "うえる",
      "うおざ",
      "うがい",
      "うかぶ",
      "うかべる",
      "うきわ",
      "うくらいな",
      "うくれれ",
      "うけたまわる",
      "うけつけ",
      "うけとる",
      "うけもつ",
      "うける",
      "うごかす",
      "うごく",
      "うこん",
      "うさぎ",
      "うしなう",
      "うしろがみ",
      "うすい",
      "うすぎ",
      "うすぐらい",
      "うすめる",
      "うせつ",
      "うちあわせ",
      "うちがわ",
      "うちき",
      "うちゅう",
      "うっかり",
      "うつくしい",
      "うったえる",
      "うつる",
      "うどん",
      "うなぎ",
      "うなじ",
      "うなずく",
      "うなる",
      "うねる",
      "うのう",
      "うぶげ",
      "うぶごえ",
      "うまれる",
      "うめる",
      "うもう",
      "うやまう",
      "うよく",
      "うらがえす",
      "うらぐち",
      "うらない",
      "うりあげ",
      "うりきれ",
      "うるさい",
      "うれしい",
      "うれゆき",
      "うれる",
      "うろこ",
      "うわき",
      "うわさ",
      "うんこう",
      "うんちん",
      "うんてん",
      "うんどう",
      "えいえん",
      "えいが",
      "えいきょう",
      "えいご",
      "えいせい",
      "えいぶん",
      "えいよう",
      "えいわ",
      "えおり",
      "えがお",
      "えがく",
      "えきたい",
      "えくせる",
      "えしゃく",
      "えすて",
      "えつらん",
      "えのぐ",
      "えほうまき",
      "えほん",
      "えまき",
      "えもじ",
      "えもの",
      "えらい",
      "えらぶ",
      "えりあ",
      "えんえん",
      "えんかい",
      "えんぎ",
      "えんげき",
      "えんしゅう",
      "えんぜつ",
      "えんそく",
      "えんちょう",
      "えんとつ",
      "おいかける",
      "おいこす",
      "おいしい",
      "おいつく",
      "おうえん",
      "おうさま",
      "おうじ",
      "おうせつ",
      "おうたい",
      "おうふく",
      "おうべい",
      "おうよう",
      "おえる",
      "おおい",
      "おおう",
      "おおどおり",
      "おおや",
      "おおよそ",
      "おかえり",
      "おかず",
      "おがむ",
      "おかわり",
      "おぎなう",
      "おきる",
      "おくさま",
      "おくじょう",
      "おくりがな",
      "おくる",
      "おくれる",
      "おこす",
      "おこなう",
      "おこる",
      "おさえる",
      "おさない",
      "おさめる",
      "おしいれ",
      "おしえる",
      "おじぎ",
      "おじさん",
      "おしゃれ",
      "おそらく",
      "おそわる",
      "おたがい",
      "おたく",
      "おだやか",
      "おちつく",
      "おっと",
      "おつり",
      "おでかけ",
      "おとしもの",
      "おとなしい",
      "おどり",
      "おどろかす",
      "おばさん",
      "おまいり",
      "おめでとう",
      "おもいで",
      "おもう",
      "おもたい",
      "おもちゃ",
      "おやつ",
      "おやゆび",
      "およぼす",
      "おらんだ",
      "おろす",
      "おんがく",
      "おんけい",
      "おんしゃ",
      "おんせん",
      "おんだん",
      "おんちゅう",
      "おんどけい",
      "かあつ",
      "かいが",
      "がいき",
      "がいけん",
      "がいこう",
      "かいさつ",
      "かいしゃ",
      "かいすいよく",
      "かいぜん",
      "かいぞうど",
      "かいつう",
      "かいてん",
      "かいとう",
      "かいふく",
      "がいへき",
      "かいほう",
      "かいよう",
      "がいらい",
      "かいわ",
      "かえる",
      "かおり",
      "かかえる",
      "かがく",
      "かがし",
      "かがみ",
      "かくご",
      "かくとく",
      "かざる",
      "がぞう",
      "かたい",
      "かたち",
      "がちょう",
      "がっきゅう",
      "がっこう",
      "がっさん",
      "がっしょう",
      "かなざわし",
      "かのう",
      "がはく",
      "かぶか",
      "かほう",
      "かほご",
      "かまう",
      "かまぼこ",
      "かめれおん",
      "かゆい",
      "かようび",
      "からい",
      "かるい",
      "かろう",
      "かわく",
      "かわら",
      "がんか",
      "かんけい",
      "かんこう",
      "かんしゃ",
      "かんそう",
      "かんたん",
      "かんち",
      "がんばる",
      "きあい",
      "きあつ",
      "きいろ",
      "ぎいん",
      "きうい",
      "きうん",
      "きえる",
      "きおう",
      "きおく",
      "きおち",
      "きおん",
      "きかい",
      "きかく",
      "きかんしゃ",
      "ききて",
      "きくばり",
      "きくらげ",
      "きけんせい",
      "きこう",
      "きこえる",
      "きこく",
      "きさい",
      "きさく",
      "きさま",
      "きさらぎ",
      "ぎじかがく",
      "ぎしき",
      "ぎじたいけん",
      "ぎじにってい",
      "ぎじゅつしゃ",
      "きすう",
      "きせい",
      "きせき",
      "きせつ",
      "きそう",
      "きぞく",
      "きぞん",
      "きたえる",
      "きちょう",
      "きつえん",
      "ぎっちり",
      "きつつき",
      "きつね",
      "きてい",
      "きどう",
      "きどく",
      "きない",
      "きなが",
      "きなこ",
      "きぬごし",
      "きねん",
      "きのう",
      "きのした",
      "きはく",
      "きびしい",
      "きひん",
      "きふく",
      "きぶん",
      "きぼう",
      "きほん",
      "きまる",
      "きみつ",
      "きむずかしい",
      "きめる",
      "きもだめし",
      "きもち",
      "きもの",
      "きゃく",
      "きやく",
      "ぎゅうにく",
      "きよう",
      "きょうりゅう",
      "きらい",
      "きらく",
      "きりん",
      "きれい",
      "きれつ",
      "きろく",
      "ぎろん",
      "きわめる",
      "ぎんいろ",
      "きんかくじ",
      "きんじょ",
      "きんようび",
      "ぐあい",
      "くいず",
      "くうかん",
      "くうき",
      "くうぐん",
      "くうこう",
      "ぐうせい",
      "くうそう",
      "ぐうたら",
      "くうふく",
      "くうぼ",
      "くかん",
      "くきょう",
      "くげん",
      "ぐこう",
      "くさい",
      "くさき",
      "くさばな",
      "くさる",
      "くしゃみ",
      "くしょう",
      "くすのき",
      "くすりゆび",
      "くせげ",
      "くせん",
      "ぐたいてき",
      "くださる",
      "くたびれる",
      "くちこみ",
      "くちさき",
      "くつした",
      "ぐっすり",
      "くつろぐ",
      "くとうてん",
      "くどく",
      "くなん",
      "くねくね",
      "くのう",
      "くふう",
      "くみあわせ",
      "くみたてる",
      "くめる",
      "くやくしょ",
      "くらす",
      "くらべる",
      "くるま",
      "くれる",
      "くろう",
      "くわしい",
      "ぐんかん",
      "ぐんしょく",
      "ぐんたい",
      "ぐんて",
      "けあな",
      "けいかく",
      "けいけん",
      "けいこ",
      "けいさつ",
      "げいじゅつ",
      "けいたい",
      "げいのうじん",
      "けいれき",
      "けいろ",
      "けおとす",
      "けおりもの",
      "げきか",
      "げきげん",
      "げきだん",
      "げきちん",
      "げきとつ",
      "げきは",
      "げきやく",
      "げこう",
      "げこくじょう",
      "げざい",
      "けさき",
      "げざん",
      "けしき",
      "けしごむ",
      "けしょう",
      "げすと",
      "けたば",
      "けちゃっぷ",
      "けちらす",
      "けつあつ",
      "けつい",
      "けつえき",
      "けっこん",
      "けつじょ",
      "けっせき",
      "けってい",
      "けつまつ",
      "げつようび",
      "げつれい",
      "けつろん",
      "げどく",
      "けとばす",
      "けとる",
      "けなげ",
      "けなす",
      "けなみ",
      "けぬき",
      "げねつ",
      "けねん",
      "けはい",
      "げひん",
      "けぶかい",
      "げぼく",
      "けまり",
      "けみかる",
      "けむし",
      "けむり",
      "けもの",
      "けらい",
      "けろけろ",
      "けわしい",
      "けんい",
      "けんえつ",
      "けんお",
      "けんか",
      "げんき",
      "けんげん",
      "けんこう",
      "けんさく",
      "けんしゅう",
      "けんすう",
      "げんそう",
      "けんちく",
      "けんてい",
      "けんとう",
      "けんない",
      "けんにん",
      "げんぶつ",
      "けんま",
      "けんみん",
      "けんめい",
      "けんらん",
      "けんり",
      "こあくま",
      "こいぬ",
      "こいびと",
      "ごうい",
      "こうえん",
      "こうおん",
      "こうかん",
      "ごうきゅう",
      "ごうけい",
      "こうこう",
      "こうさい",
      "こうじ",
      "こうすい",
      "ごうせい",
      "こうそく",
      "こうたい",
      "こうちゃ",
      "こうつう",
      "こうてい",
      "こうどう",
      "こうない",
      "こうはい",
      "ごうほう",
      "ごうまん",
      "こうもく",
      "こうりつ",
      "こえる",
      "こおり",
      "ごかい",
      "ごがつ",
      "ごかん",
      "こくご",
      "こくさい",
      "こくとう",
      "こくない",
      "こくはく",
      "こぐま",
      "こけい",
      "こける",
      "ここのか",
      "こころ",
      "こさめ",
      "こしつ",
      "こすう",
      "こせい",
      "こせき",
      "こぜん",
      "こそだて",
      "こたい",
      "こたえる",
      "こたつ",
      "こちょう",
      "こっか",
      "こつこつ",
      "こつばん",
      "こつぶ",
      "こてい",
      "こてん",
      "ことがら",
      "ことし",
      "ことば",
      "ことり",
      "こなごな",
      "こねこね",
      "このまま",
      "このみ",
      "このよ",
      "ごはん",
      "こひつじ",
      "こふう",
      "こふん",
      "こぼれる",
      "ごまあぶら",
      "こまかい",
      "ごますり",
      "こまつな",
      "こまる",
      "こむぎこ",
      "こもじ",
      "こもち",
      "こもの",
      "こもん",
      "こやく",
      "こやま",
      "こゆう",
      "こゆび",
      "こよい",
      "こよう",
      "こりる",
      "これくしょん",
      "ころっけ",
      "こわもて",
      "こわれる",
      "こんいん",
      "こんかい",
      "こんき",
      "こんしゅう",
      "こんすい",
      "こんだて",
      "こんとん",
      "こんなん",
      "こんびに",
      "こんぽん",
      "こんまけ",
      "こんや",
      "こんれい",
      "こんわく",
      "ざいえき",
      "さいかい",
      "さいきん",
      "ざいげん",
      "ざいこ",
      "さいしょ",
      "さいせい",
      "ざいたく",
      "ざいちゅう",
      "さいてき",
      "ざいりょう",
      "さうな",
      "さかいし",
      "さがす",
      "さかな",
      "さかみち",
      "さがる",
      "さぎょう",
      "さくし",
      "さくひん",
      "さくら",
      "さこく",
      "さこつ",
      "さずかる",
      "ざせき",
      "さたん",
      "さつえい",
      "ざつおん",
      "ざっか",
      "ざつがく",
      "さっきょく",
      "ざっし",
      "さつじん",
      "ざっそう",
      "さつたば",
      "さつまいも",
      "さてい",
      "さといも",
      "さとう",
      "さとおや",
      "さとし",
      "さとる",
      "さのう",
      "さばく",
      "さびしい",
      "さべつ",
      "さほう",
      "さほど",
      "さます",
      "さみしい",
      "さみだれ",
      "さむけ",
      "さめる",
      "さやえんどう",
      "さゆう",
      "さよう",
      "さよく",
      "さらだ",
      "ざるそば",
      "さわやか",
      "さわる",
      "さんいん",
      "さんか",
      "さんきゃく",
      "さんこう",
      "さんさい",
      "ざんしょ",
      "さんすう",
      "さんせい",
      "さんそ",
      "さんち",
      "さんま",
      "さんみ",
      "さんらん",
      "しあい",
      "しあげ",
      "しあさって",
      "しあわせ",
      "しいく",
      "しいん",
      "しうち",
      "しえい",
      "しおけ",
      "しかい",
      "しかく",
      "じかん",
      "しごと",
      "しすう",
      "じだい",
      "したうけ",
      "したぎ",
      "したて",
      "したみ",
      "しちょう",
      "しちりん",
      "しっかり",
      "しつじ",
      "しつもん",
      "してい",
      "してき",
      "してつ",
      "じてん",
      "じどう",
      "しなぎれ",
      "しなもの",
      "しなん",
      "しねま",
      "しねん",
      "しのぐ",
      "しのぶ",
      "しはい",
      "しばかり",
      "しはつ",
      "しはらい",
      "しはん",
      "しひょう",
      "しふく",
      "じぶん",
      "しへい",
      "しほう",
      "しほん",
      "しまう",
      "しまる",
      "しみん",
      "しむける",
      "じむしょ",
      "しめい",
      "しめる",
      "しもん",
      "しゃいん",
      "しゃうん",
      "しゃおん",
      "じゃがいも",
      "しやくしょ",
      "しゃくほう",
      "しゃけん",
      "しゃこ",
      "しゃざい",
      "しゃしん",
      "しゃせん",
      "しゃそう",
      "しゃたい",
      "しゃちょう",
      "しゃっきん",
      "じゃま",
      "しゃりん",
      "しゃれい",
      "じゆう",
      "じゅうしょ",
      "しゅくはく",
      "じゅしん",
      "しゅっせき",
      "しゅみ",
      "しゅらば",
      "じゅんばん",
      "しょうかい",
      "しょくたく",
      "しょっけん",
      "しょどう",
      "しょもつ",
      "しらせる",
      "しらべる",
      "しんか",
      "しんこう",
      "じんじゃ",
      "しんせいじ",
      "しんちく",
      "しんりん",
      "すあげ",
      "すあし",
      "すあな",
      "ずあん",
      "すいえい",
      "すいか",
      "すいとう",
      "ずいぶん",
      "すいようび",
      "すうがく",
      "すうじつ",
      "すうせん",
      "すおどり",
      "すきま",
      "すくう",
      "すくない",
      "すける",
      "すごい",
      "すこし",
      "ずさん",
      "すずしい",
      "すすむ",
      "すすめる",
      "すっかり",
      "ずっしり",
      "ずっと",
      "すてき",
      "すてる",
      "すねる",
      "すのこ",
      "すはだ",
      "すばらしい",
      "ずひょう",
      "ずぶぬれ",
      "すぶり",
      "すふれ",
      "すべて",
      "すべる",
      "ずほう",
      "すぼん",
      "すまい",
      "すめし",
      "すもう",
      "すやき",
      "すらすら",
      "するめ",
      "すれちがう",
      "すろっと",
      "すわる",
      "すんぜん",
      "すんぽう",
      "せあぶら",
      "せいかつ",
      "せいげん",
      "せいじ",
      "せいよう",
      "せおう",
      "せかいかん",
      "せきにん",
      "せきむ",
      "せきゆ",
      "せきらんうん",
      "せけん",
      "せこう",
      "せすじ",
      "せたい",
      "せたけ",
      "せっかく",
      "せっきゃく",
      "ぜっく",
      "せっけん",
      "せっこつ",
      "せっさたくま",
      "せつぞく",
      "せつだん",
      "せつでん",
      "せっぱん",
      "せつび",
      "せつぶん",
      "せつめい",
      "せつりつ",
      "せなか",
      "せのび",
      "せはば",
      "せびろ",
      "せぼね",
      "せまい",
      "せまる",
      "せめる",
      "せもたれ",
      "せりふ",
      "ぜんあく",
      "せんい",
      "せんえい",
      "せんか",
      "せんきょ",
      "せんく",
      "せんげん",
      "ぜんご",
      "せんさい",
      "せんしゅ",
      "せんすい",
      "せんせい",
      "せんぞ",
      "せんたく",
      "せんちょう",
      "せんてい",
      "せんとう",
      "せんぬき",
      "せんねん",
      "せんぱい",
      "ぜんぶ",
      "ぜんぽう",
      "せんむ",
      "せんめんじょ",
      "せんもん",
      "せんやく",
      "せんゆう",
      "せんよう",
      "ぜんら",
      "ぜんりゃく",
      "せんれい",
      "せんろ",
      "そあく",
      "そいとげる",
      "そいね",
      "そうがんきょう",
      "そうき",
      "そうご",
      "そうしん",
      "そうだん",
      "そうなん",
      "そうび",
      "そうめん",
      "そうり",
      "そえもの",
      "そえん",
      "そがい",
      "そげき",
      "そこう",
      "そこそこ",
      "そざい",
      "そしな",
      "そせい",
      "そせん",
      "そそぐ",
      "そだてる",
      "そつう",
      "そつえん",
      "そっかん",
      "そつぎょう",
      "そっけつ",
      "そっこう",
      "そっせん",
      "そっと",
      "そとがわ",
      "そとづら",
      "そなえる",
      "そなた",
      "そふぼ",
      "そぼく",
      "そぼろ",
      "そまつ",
      "そまる",
      "そむく",
      "そむりえ",
      "そめる",
      "そもそも",
      "そよかぜ",
      "そらまめ",
      "そろう",
      "そんかい",
      "そんけい",
      "そんざい",
      "そんしつ",
      "そんぞく",
      "そんちょう",
      "ぞんび",
      "ぞんぶん",
      "そんみん",
      "たあい",
      "たいいん",
      "たいうん",
      "たいえき",
      "たいおう",
      "だいがく",
      "たいき",
      "たいぐう",
      "たいけん",
      "たいこ",
      "たいざい",
      "だいじょうぶ",
      "だいすき",
      "たいせつ",
      "たいそう",
      "だいたい",
      "たいちょう",
      "たいてい",
      "だいどころ",
      "たいない",
      "たいねつ",
      "たいのう",
      "たいはん",
      "だいひょう",
      "たいふう",
      "たいへん",
      "たいほ",
      "たいまつばな",
      "たいみんぐ",
      "たいむ",
      "たいめん",
      "たいやき",
      "たいよう",
      "たいら",
      "たいりょく",
      "たいる",
      "たいわん",
      "たうえ",
      "たえる",
      "たおす",
      "たおる",
      "たおれる",
      "たかい",
      "たかね",
      "たきび",
      "たくさん",
      "たこく",
      "たこやき",
      "たさい",
      "たしざん",
      "だじゃれ",
      "たすける",
      "たずさわる",
      "たそがれ",
      "たたかう",
      "たたく",
      "ただしい",
      "たたみ",
      "たちばな",
      "だっかい",
      "だっきゃく",
      "だっこ",
      "だっしゅつ",
      "だったい",
      "たてる",
      "たとえる",
      "たなばた",
      "たにん",
      "たぬき",
      "たのしみ",
      "たはつ",
      "たぶん",
      "たべる",
      "たぼう",
      "たまご",
      "たまる",
      "だむる",
      "ためいき",
      "ためす",
      "ためる",
      "たもつ",
      "たやすい",
      "たよる",
      "たらす",
      "たりきほんがん",
      "たりょう",
      "たりる",
      "たると",
      "たれる",
      "たれんと",
      "たろっと",
      "たわむれる",
      "だんあつ",
      "たんい",
      "たんおん",
      "たんか",
      "たんき",
      "たんけん",
      "たんご",
      "たんさん",
      "たんじょうび",
      "だんせい",
      "たんそく",
      "たんたい",
      "だんち",
      "たんてい",
      "たんとう",
      "だんな",
      "たんにん",
      "だんねつ",
      "たんのう",
      "たんぴん",
      "だんぼう",
      "たんまつ",
      "たんめい",
      "だんれつ",
      "だんろ",
      "だんわ",
      "ちあい",
      "ちあん",
      "ちいき",
      "ちいさい",
      "ちえん",
      "ちかい",
      "ちから",
      "ちきゅう",
      "ちきん",
      "ちけいず",
      "ちけん",
      "ちこく",
      "ちさい",
      "ちしき",
      "ちしりょう",
      "ちせい",
      "ちそう",
      "ちたい",
      "ちたん",
      "ちちおや",
      "ちつじょ",
      "ちてき",
      "ちてん",
      "ちぬき",
      "ちぬり",
      "ちのう",
      "ちひょう",
      "ちへいせん",
      "ちほう",
      "ちまた",
      "ちみつ",
      "ちみどろ",
      "ちめいど",
      "ちゃんこなべ",
      "ちゅうい",
      "ちゆりょく",
      "ちょうし",
      "ちょさくけん",
      "ちらし",
      "ちらみ",
      "ちりがみ",
      "ちりょう",
      "ちるど",
      "ちわわ",
      "ちんたい",
      "ちんもく",
      "ついか",
      "ついたち",
      "つうか",
      "つうじょう",
      "つうはん",
      "つうわ",
      "つかう",
      "つかれる",
      "つくね",
      "つくる",
      "つけね",
      "つける",
      "つごう",
      "つたえる",
      "つづく",
      "つつじ",
      "つつむ",
      "つとめる",
      "つながる",
      "つなみ",
      "つねづね",
      "つのる",
      "つぶす",
      "つまらない",
      "つまる",
      "つみき",
      "つめたい",
      "つもり",
      "つもる",
      "つよい",
      "つるぼ",
      "つるみく",
      "つわもの",
      "つわり",
      "てあし",
      "てあて",
      "てあみ",
      "ていおん",
      "ていか",
      "ていき",
      "ていけい",
      "ていこく",
      "ていさつ",
      "ていし",
      "ていせい",
      "ていたい",
      "ていど",
      "ていねい",
      "ていひょう",
      "ていへん",
      "ていぼう",
      "てうち",
      "ておくれ",
      "てきとう",
      "てくび",
      "でこぼこ",
      "てさぎょう",
      "てさげ",
      "てすり",
      "てそう",
      "てちがい",
      "てちょう",
      "てつがく",
      "てつづき",
      "でっぱ",
      "てつぼう",
      "てつや",
      "でぬかえ",
      "てぬき",
      "てぬぐい",
      "てのひら",
      "てはい",
      "てぶくろ",
      "てふだ",
      "てほどき",
      "てほん",
      "てまえ",
      "てまきずし",
      "てみじか",
      "てみやげ",
      "てらす",
      "てれび",
      "てわけ",
      "てわたし",
      "でんあつ",
      "てんいん",
      "てんかい",
      "てんき",
      "てんぐ",
      "てんけん",
      "てんごく",
      "てんさい",
      "てんし",
      "てんすう",
      "でんち",
      "てんてき",
      "てんとう",
      "てんない",
      "てんぷら",
      "てんぼうだい",
      "てんめつ",
      "てんらんかい",
      "でんりょく",
      "でんわ",
      "どあい",
      "といれ",
      "どうかん",
      "とうきゅう",
      "どうぐ",
      "とうし",
      "とうむぎ",
      "とおい",
      "とおか",
      "とおく",
      "とおす",
      "とおる",
      "とかい",
      "とかす",
      "ときおり",
      "ときどき",
      "とくい",
      "とくしゅう",
      "とくてん",
      "とくに",
      "とくべつ",
      "とけい",
      "とける",
      "とこや",
      "とさか",
      "としょかん",
      "とそう",
      "とたん",
      "とちゅう",
      "とっきゅう",
      "とっくん",
      "とつぜん",
      "とつにゅう",
      "とどける",
      "ととのえる",
      "とない",
      "となえる",
      "となり",
      "とのさま",
      "とばす",
      "どぶがわ",
      "とほう",
      "とまる",
      "とめる",
      "ともだち",
      "ともる",
      "どようび",
      "とらえる",
      "とんかつ",
      "どんぶり",
      "ないかく",
      "ないこう",
      "ないしょ",
      "ないす",
      "ないせん",
      "ないそう",
      "なおす",
      "ながい",
      "なくす",
      "なげる",
      "なこうど",
      "なさけ",
      "なたでここ",
      "なっとう",
      "なつやすみ",
      "ななおし",
      "なにごと",
      "なにもの",
      "なにわ",
      "なのか",
      "なふだ",
      "なまいき",
      "なまえ",
      "なまみ",
      "なみだ",
      "なめらか",
      "なめる",
      "なやむ",
      "ならう",
      "ならび",
      "ならぶ",
      "なれる",
      "なわとび",
      "なわばり",
      "にあう",
      "にいがた",
      "にうけ",
      "におい",
      "にかい",
      "にがて",
      "にきび",
      "にくしみ",
      "にくまん",
      "にげる",
      "にさんかたんそ",
      "にしき",
      "にせもの",
      "にちじょう",
      "にちようび",
      "にっか",
      "にっき",
      "にっけい",
      "にっこう",
      "にっさん",
      "にっしょく",
      "にっすう",
      "にっせき",
      "にってい",
      "になう",
      "にほん",
      "にまめ",
      "にもつ",
      "にやり",
      "にゅういん",
      "にりんしゃ",
      "にわとり",
      "にんい",
      "にんか",
      "にんき",
      "にんげん",
      "にんしき",
      "にんずう",
      "にんそう",
      "にんたい",
      "にんち",
      "にんてい",
      "にんにく",
      "にんぷ",
      "にんまり",
      "にんむ",
      "にんめい",
      "にんよう",
      "ぬいくぎ",
      "ぬかす",
      "ぬぐいとる",
      "ぬぐう",
      "ぬくもり",
      "ぬすむ",
      "ぬまえび",
      "ぬめり",
      "ぬらす",
      "ぬんちゃく",
      "ねあげ",
      "ねいき",
      "ねいる",
      "ねいろ",
      "ねぐせ",
      "ねくたい",
      "ねくら",
      "ねこぜ",
      "ねこむ",
      "ねさげ",
      "ねすごす",
      "ねそべる",
      "ねだん",
      "ねつい",
      "ねっしん",
      "ねつぞう",
      "ねったいぎょ",
      "ねぶそく",
      "ねふだ",
      "ねぼう",
      "ねほりはほり",
      "ねまき",
      "ねまわし",
      "ねみみ",
      "ねむい",
      "ねむたい",
      "ねもと",
      "ねらう",
      "ねわざ",
      "ねんいり",
      "ねんおし",
      "ねんかん",
      "ねんきん",
      "ねんぐ",
      "ねんざ",
      "ねんし",
      "ねんちゃく",
      "ねんど",
      "ねんぴ",
      "ねんぶつ",
      "ねんまつ",
      "ねんりょう",
      "ねんれい",
      "のいず",
      "のおづま",
      "のがす",
      "のきなみ",
      "のこぎり",
      "のこす",
      "のこる",
      "のせる",
      "のぞく",
      "のぞむ",
      "のたまう",
      "のちほど",
      "のっく",
      "のばす",
      "のはら",
      "のべる",
      "のぼる",
      "のみもの",
      "のやま",
      "のらいぬ",
      "のらねこ",
      "のりもの",
      "のりゆき",
      "のれん",
      "のんき",
      "ばあい",
      "はあく",
      "ばあさん",
      "ばいか",
      "ばいく",
      "はいけん",
      "はいご",
      "はいしん",
      "はいすい",
      "はいせん",
      "はいそう",
      "はいち",
      "ばいばい",
      "はいれつ",
      "はえる",
      "はおる",
      "はかい",
      "ばかり",
      "はかる",
      "はくしゅ",
      "はけん",
      "はこぶ",
      "はさみ",
      "はさん",
      "はしご",
      "ばしょ",
      "はしる",
      "はせる",
      "ぱそこん",
      "はそん",
      "はたん",
      "はちみつ",
      "はつおん",
      "はっかく",
      "はづき",
      "はっきり",
      "はっくつ",
      "はっけん",
      "はっこう",
      "はっさん",
      "はっしん",
      "はったつ",
      "はっちゅう",
      "はってん",
      "はっぴょう",
      "はっぽう",
      "はなす",
      "はなび",
      "はにかむ",
      "はぶらし",
      "はみがき",
      "はむかう",
      "はめつ",
      "はやい",
      "はやし",
      "はらう",
      "はろうぃん",
      "はわい",
      "はんい",
      "はんえい",
      "はんおん",
      "はんかく",
      "はんきょう",
      "ばんぐみ",
      "はんこ",
      "はんしゃ",
      "はんすう",
      "はんだん",
      "ぱんち",
      "ぱんつ",
      "はんてい",
      "はんとし",
      "はんのう",
      "はんぱ",
      "はんぶん",
      "はんぺん",
      "はんぼうき",
      "はんめい",
      "はんらん",
      "はんろん",
      "ひいき",
      "ひうん",
      "ひえる",
      "ひかく",
      "ひかり",
      "ひかる",
      "ひかん",
      "ひくい",
      "ひけつ",
      "ひこうき",
      "ひこく",
      "ひさい",
      "ひさしぶり",
      "ひさん",
      "びじゅつかん",
      "ひしょ",
      "ひそか",
      "ひそむ",
      "ひたむき",
      "ひだり",
      "ひたる",
      "ひつぎ",
      "ひっこし",
      "ひっし",
      "ひつじゅひん",
      "ひっす",
      "ひつぜん",
      "ぴったり",
      "ぴっちり",
      "ひつよう",
      "ひてい",
      "ひとごみ",
      "ひなまつり",
      "ひなん",
      "ひねる",
      "ひはん",
      "ひびく",
      "ひひょう",
      "ひほう",
      "ひまわり",
      "ひまん",
      "ひみつ",
      "ひめい",
      "ひめじし",
      "ひやけ",
      "ひやす",
      "ひよう",
      "びょうき",
      "ひらがな",
      "ひらく",
      "ひりつ",
      "ひりょう",
      "ひるま",
      "ひるやすみ",
      "ひれい",
      "ひろい",
      "ひろう",
      "ひろき",
      "ひろゆき",
      "ひんかく",
      "ひんけつ",
      "ひんこん",
      "ひんしゅ",
      "ひんそう",
      "ぴんち",
      "ひんぱん",
      "びんぼう",
      "ふあん",
      "ふいうち",
      "ふうけい",
      "ふうせん",
      "ぷうたろう",
      "ふうとう",
      "ふうふ",
      "ふえる",
      "ふおん",
      "ふかい",
      "ふきん",
      "ふくざつ",
      "ふくぶくろ",
      "ふこう",
      "ふさい",
      "ふしぎ",
      "ふじみ",
      "ふすま",
      "ふせい",
      "ふせぐ",
      "ふそく",
      "ぶたにく",
      "ふたん",
      "ふちょう",
      "ふつう",
      "ふつか",
      "ふっかつ",
      "ふっき",
      "ふっこく",
      "ぶどう",
      "ふとる",
      "ふとん",
      "ふのう",
      "ふはい",
      "ふひょう",
      "ふへん",
      "ふまん",
      "ふみん",
      "ふめつ",
      "ふめん",
      "ふよう",
      "ふりこ",
      "ふりる",
      "ふるい",
      "ふんいき",
      "ぶんがく",
      "ぶんぐ",
      "ふんしつ",
      "ぶんせき",
      "ふんそう",
      "ぶんぽう",
      "へいあん",
      "へいおん",
      "へいがい",
      "へいき",
      "へいげん",
      "へいこう",
      "へいさ",
      "へいしゃ",
      "へいせつ",
      "へいそ",
      "へいたく",
      "へいてん",
      "へいねつ",
      "へいわ",
      "へきが",
      "へこむ",
      "べにいろ",
      "べにしょうが",
      "へらす",
      "へんかん",
      "べんきょう",
      "べんごし",
      "へんさい",
      "へんたい",
      "べんり",
      "ほあん",
      "ほいく",
      "ぼうぎょ",
      "ほうこく",
      "ほうそう",
      "ほうほう",
      "ほうもん",
      "ほうりつ",
      "ほえる",
      "ほおん",
      "ほかん",
      "ほきょう",
      "ぼきん",
      "ほくろ",
      "ほけつ",
      "ほけん",
      "ほこう",
      "ほこる",
      "ほしい",
      "ほしつ",
      "ほしゅ",
      "ほしょう",
      "ほせい",
      "ほそい",
      "ほそく",
      "ほたて",
      "ほたる",
      "ぽちぶくろ",
      "ほっきょく",
      "ほっさ",
      "ほったん",
      "ほとんど",
      "ほめる",
      "ほんい",
      "ほんき",
      "ほんけ",
      "ほんしつ",
      "ほんやく",
      "まいにち",
      "まかい",
      "まかせる",
      "まがる",
      "まける",
      "まこと",
      "まさつ",
      "まじめ",
      "ますく",
      "まぜる",
      "まつり",
      "まとめ",
      "まなぶ",
      "まぬけ",
      "まねく",
      "まほう",
      "まもる",
      "まゆげ",
      "まよう",
      "まろやか",
      "まわす",
      "まわり",
      "まわる",
      "まんが",
      "まんきつ",
      "まんぞく",
      "まんなか",
      "みいら",
      "みうち",
      "みえる",
      "みがく",
      "みかた",
      "みかん",
      "みけん",
      "みこん",
      "みじかい",
      "みすい",
      "みすえる",
      "みせる",
      "みっか",
      "みつかる",
      "みつける",
      "みてい",
      "みとめる",
      "みなと",
      "みなみかさい",
      "みねらる",
      "みのう",
      "みのがす",
      "みほん",
      "みもと",
      "みやげ",
      "みらい",
      "みりょく",
      "みわく",
      "みんか",
      "みんぞく",
      "むいか",
      "むえき",
      "むえん",
      "むかい",
      "むかう",
      "むかえ",
      "むかし",
      "むぎちゃ",
      "むける",
      "むげん",
      "むさぼる",
      "むしあつい",
      "むしば",
      "むじゅん",
      "むしろ",
      "むすう",
      "むすこ",
      "むすぶ",
      "むすめ",
      "むせる",
      "むせん",
      "むちゅう",
      "むなしい",
      "むのう",
      "むやみ",
      "むよう",
      "むらさき",
      "むりょう",
      "むろん",
      "めいあん",
      "めいうん",
      "めいえん",
      "めいかく",
      "めいきょく",
      "めいさい",
      "めいし",
      "めいそう",
      "めいぶつ",
      "めいれい",
      "めいわく",
      "めぐまれる",
      "めざす",
      "めした",
      "めずらしい",
      "めだつ",
      "めまい",
      "めやす",
      "めんきょ",
      "めんせき",
      "めんどう",
      "もうしあげる",
      "もうどうけん",
      "もえる",
      "もくし",
      "もくてき",
      "もくようび",
      "もちろん",
      "もどる",
      "もらう",
      "もんく",
      "もんだい",
      "やおや",
      "やける",
      "やさい",
      "やさしい",
      "やすい",
      "やすたろう",
      "やすみ",
      "やせる",
      "やそう",
      "やたい",
      "やちん",
      "やっと",
      "やっぱり",
      "やぶる",
      "やめる",
      "ややこしい",
      "やよい",
      "やわらかい",
      "ゆうき",
      "ゆうびんきょく",
      "ゆうべ",
      "ゆうめい",
      "ゆけつ",
      "ゆしゅつ",
      "ゆせん",
      "ゆそう",
      "ゆたか",
      "ゆちゃく",
      "ゆでる",
      "ゆにゅう",
      "ゆびわ",
      "ゆらい",
      "ゆれる",
      "ようい",
      "ようか",
      "ようきゅう",
      "ようじ",
      "ようす",
      "ようちえん",
      "よかぜ",
      "よかん",
      "よきん",
      "よくせい",
      "よくぼう",
      "よけい",
      "よごれる",
      "よさん",
      "よしゅう",
      "よそう",
      "よそく",
      "よっか",
      "よてい",
      "よどがわく",
      "よねつ",
      "よやく",
      "よゆう",
      "よろこぶ",
      "よろしい",
      "らいう",
      "らくがき",
      "らくご",
      "らくさつ",
      "らくだ",
      "らしんばん",
      "らせん",
      "らぞく",
      "らたい",
      "らっか",
      "られつ",
      "りえき",
      "りかい",
      "りきさく",
      "りきせつ",
      "りくぐん",
      "りくつ",
      "りけん",
      "りこう",
      "りせい",
      "りそう",
      "りそく",
      "りてん",
      "りねん",
      "りゆう",
      "りゅうがく",
      "りよう",
      "りょうり",
      "りょかん",
      "りょくちゃ",
      "りょこう",
      "りりく",
      "りれき",
      "りろん",
      "りんご",
      "るいけい",
      "るいさい",
      "るいじ",
      "るいせき",
      "るすばん",
      "るりがわら",
      "れいかん",
      "れいぎ",
      "れいせい",
      "れいぞうこ",
      "れいとう",
      "れいぼう",
      "れきし",
      "れきだい",
      "れんあい",
      "れんけい",
      "れんこん",
      "れんさい",
      "れんしゅう",
      "れんぞく",
      "れんらく",
      "ろうか",
      "ろうご",
      "ろうじん",
      "ろうそく",
      "ろくが",
      "ろこつ",
      "ろじうら",
      "ろしゅつ",
      "ろせん",
      "ろてん",
      "ろめん",
      "ろれつ",
      "ろんぎ",
      "ろんぱ",
      "ろんぶん",
      "ろんり",
      "わかす",
      "わかめ",
      "わかやま",
      "わかれる",
      "わしつ",
      "わじまし",
      "わすれもの",
      "わらう",
      "われる"
    ];
  }
});

// ../../node_modules/bip39/src/wordlists/portuguese.json
var require_portuguese = __commonJS({
  "../../node_modules/bip39/src/wordlists/portuguese.json"(exports2, module2) {
    module2.exports = [
      "abacate",
      "abaixo",
      "abalar",
      "abater",
      "abduzir",
      "abelha",
      "aberto",
      "abismo",
      "abotoar",
      "abranger",
      "abreviar",
      "abrigar",
      "abrupto",
      "absinto",
      "absoluto",
      "absurdo",
      "abutre",
      "acabado",
      "acalmar",
      "acampar",
      "acanhar",
      "acaso",
      "aceitar",
      "acelerar",
      "acenar",
      "acervo",
      "acessar",
      "acetona",
      "achatar",
      "acidez",
      "acima",
      "acionado",
      "acirrar",
      "aclamar",
      "aclive",
      "acolhida",
      "acomodar",
      "acoplar",
      "acordar",
      "acumular",
      "acusador",
      "adaptar",
      "adega",
      "adentro",
      "adepto",
      "adequar",
      "aderente",
      "adesivo",
      "adeus",
      "adiante",
      "aditivo",
      "adjetivo",
      "adjunto",
      "admirar",
      "adorar",
      "adquirir",
      "adubo",
      "adverso",
      "advogado",
      "aeronave",
      "afastar",
      "aferir",
      "afetivo",
      "afinador",
      "afivelar",
      "aflito",
      "afluente",
      "afrontar",
      "agachar",
      "agarrar",
      "agasalho",
      "agenciar",
      "agilizar",
      "agiota",
      "agitado",
      "agora",
      "agradar",
      "agreste",
      "agrupar",
      "aguardar",
      "agulha",
      "ajoelhar",
      "ajudar",
      "ajustar",
      "alameda",
      "alarme",
      "alastrar",
      "alavanca",
      "albergue",
      "albino",
      "alcatra",
      "aldeia",
      "alecrim",
      "alegria",
      "alertar",
      "alface",
      "alfinete",
      "algum",
      "alheio",
      "aliar",
      "alicate",
      "alienar",
      "alinhar",
      "aliviar",
      "almofada",
      "alocar",
      "alpiste",
      "alterar",
      "altitude",
      "alucinar",
      "alugar",
      "aluno",
      "alusivo",
      "alvo",
      "amaciar",
      "amador",
      "amarelo",
      "amassar",
      "ambas",
      "ambiente",
      "ameixa",
      "amenizar",
      "amido",
      "amistoso",
      "amizade",
      "amolador",
      "amontoar",
      "amoroso",
      "amostra",
      "amparar",
      "ampliar",
      "ampola",
      "anagrama",
      "analisar",
      "anarquia",
      "anatomia",
      "andaime",
      "anel",
      "anexo",
      "angular",
      "animar",
      "anjo",
      "anomalia",
      "anotado",
      "ansioso",
      "anterior",
      "anuidade",
      "anunciar",
      "anzol",
      "apagador",
      "apalpar",
      "apanhado",
      "apego",
      "apelido",
      "apertada",
      "apesar",
      "apetite",
      "apito",
      "aplauso",
      "aplicada",
      "apoio",
      "apontar",
      "aposta",
      "aprendiz",
      "aprovar",
      "aquecer",
      "arame",
      "aranha",
      "arara",
      "arcada",
      "ardente",
      "areia",
      "arejar",
      "arenito",
      "aresta",
      "argiloso",
      "argola",
      "arma",
      "arquivo",
      "arraial",
      "arrebate",
      "arriscar",
      "arroba",
      "arrumar",
      "arsenal",
      "arterial",
      "artigo",
      "arvoredo",
      "asfaltar",
      "asilado",
      "aspirar",
      "assador",
      "assinar",
      "assoalho",
      "assunto",
      "astral",
      "atacado",
      "atadura",
      "atalho",
      "atarefar",
      "atear",
      "atender",
      "aterro",
      "ateu",
      "atingir",
      "atirador",
      "ativo",
      "atoleiro",
      "atracar",
      "atrevido",
      "atriz",
      "atual",
      "atum",
      "auditor",
      "aumentar",
      "aura",
      "aurora",
      "autismo",
      "autoria",
      "autuar",
      "avaliar",
      "avante",
      "avaria",
      "avental",
      "avesso",
      "aviador",
      "avisar",
      "avulso",
      "axila",
      "azarar",
      "azedo",
      "azeite",
      "azulejo",
      "babar",
      "babosa",
      "bacalhau",
      "bacharel",
      "bacia",
      "bagagem",
      "baiano",
      "bailar",
      "baioneta",
      "bairro",
      "baixista",
      "bajular",
      "baleia",
      "baliza",
      "balsa",
      "banal",
      "bandeira",
      "banho",
      "banir",
      "banquete",
      "barato",
      "barbado",
      "baronesa",
      "barraca",
      "barulho",
      "baseado",
      "bastante",
      "batata",
      "batedor",
      "batida",
      "batom",
      "batucar",
      "baunilha",
      "beber",
      "beijo",
      "beirada",
      "beisebol",
      "beldade",
      "beleza",
      "belga",
      "beliscar",
      "bendito",
      "bengala",
      "benzer",
      "berimbau",
      "berlinda",
      "berro",
      "besouro",
      "bexiga",
      "bezerro",
      "bico",
      "bicudo",
      "bienal",
      "bifocal",
      "bifurcar",
      "bigorna",
      "bilhete",
      "bimestre",
      "bimotor",
      "biologia",
      "biombo",
      "biosfera",
      "bipolar",
      "birrento",
      "biscoito",
      "bisneto",
      "bispo",
      "bissexto",
      "bitola",
      "bizarro",
      "blindado",
      "bloco",
      "bloquear",
      "boato",
      "bobagem",
      "bocado",
      "bocejo",
      "bochecha",
      "boicotar",
      "bolada",
      "boletim",
      "bolha",
      "bolo",
      "bombeiro",
      "bonde",
      "boneco",
      "bonita",
      "borbulha",
      "borda",
      "boreal",
      "borracha",
      "bovino",
      "boxeador",
      "branco",
      "brasa",
      "braveza",
      "breu",
      "briga",
      "brilho",
      "brincar",
      "broa",
      "brochura",
      "bronzear",
      "broto",
      "bruxo",
      "bucha",
      "budismo",
      "bufar",
      "bule",
      "buraco",
      "busca",
      "busto",
      "buzina",
      "cabana",
      "cabelo",
      "cabide",
      "cabo",
      "cabrito",
      "cacau",
      "cacetada",
      "cachorro",
      "cacique",
      "cadastro",
      "cadeado",
      "cafezal",
      "caiaque",
      "caipira",
      "caixote",
      "cajado",
      "caju",
      "calafrio",
      "calcular",
      "caldeira",
      "calibrar",
      "calmante",
      "calota",
      "camada",
      "cambista",
      "camisa",
      "camomila",
      "campanha",
      "camuflar",
      "canavial",
      "cancelar",
      "caneta",
      "canguru",
      "canhoto",
      "canivete",
      "canoa",
      "cansado",
      "cantar",
      "canudo",
      "capacho",
      "capela",
      "capinar",
      "capotar",
      "capricho",
      "captador",
      "capuz",
      "caracol",
      "carbono",
      "cardeal",
      "careca",
      "carimbar",
      "carneiro",
      "carpete",
      "carreira",
      "cartaz",
      "carvalho",
      "casaco",
      "casca",
      "casebre",
      "castelo",
      "casulo",
      "catarata",
      "cativar",
      "caule",
      "causador",
      "cautelar",
      "cavalo",
      "caverna",
      "cebola",
      "cedilha",
      "cegonha",
      "celebrar",
      "celular",
      "cenoura",
      "censo",
      "centeio",
      "cercar",
      "cerrado",
      "certeiro",
      "cerveja",
      "cetim",
      "cevada",
      "chacota",
      "chaleira",
      "chamado",
      "chapada",
      "charme",
      "chatice",
      "chave",
      "chefe",
      "chegada",
      "cheiro",
      "cheque",
      "chicote",
      "chifre",
      "chinelo",
      "chocalho",
      "chover",
      "chumbo",
      "chutar",
      "chuva",
      "cicatriz",
      "ciclone",
      "cidade",
      "cidreira",
      "ciente",
      "cigana",
      "cimento",
      "cinto",
      "cinza",
      "ciranda",
      "circuito",
      "cirurgia",
      "citar",
      "clareza",
      "clero",
      "clicar",
      "clone",
      "clube",
      "coado",
      "coagir",
      "cobaia",
      "cobertor",
      "cobrar",
      "cocada",
      "coelho",
      "coentro",
      "coeso",
      "cogumelo",
      "coibir",
      "coifa",
      "coiote",
      "colar",
      "coleira",
      "colher",
      "colidir",
      "colmeia",
      "colono",
      "coluna",
      "comando",
      "combinar",
      "comentar",
      "comitiva",
      "comover",
      "complexo",
      "comum",
      "concha",
      "condor",
      "conectar",
      "confuso",
      "congelar",
      "conhecer",
      "conjugar",
      "consumir",
      "contrato",
      "convite",
      "cooperar",
      "copeiro",
      "copiador",
      "copo",
      "coquetel",
      "coragem",
      "cordial",
      "corneta",
      "coronha",
      "corporal",
      "correio",
      "cortejo",
      "coruja",
      "corvo",
      "cosseno",
      "costela",
      "cotonete",
      "couro",
      "couve",
      "covil",
      "cozinha",
      "cratera",
      "cravo",
      "creche",
      "credor",
      "creme",
      "crer",
      "crespo",
      "criada",
      "criminal",
      "crioulo",
      "crise",
      "criticar",
      "crosta",
      "crua",
      "cruzeiro",
      "cubano",
      "cueca",
      "cuidado",
      "cujo",
      "culatra",
      "culminar",
      "culpar",
      "cultura",
      "cumprir",
      "cunhado",
      "cupido",
      "curativo",
      "curral",
      "cursar",
      "curto",
      "cuspir",
      "custear",
      "cutelo",
      "damasco",
      "datar",
      "debater",
      "debitar",
      "deboche",
      "debulhar",
      "decalque",
      "decimal",
      "declive",
      "decote",
      "decretar",
      "dedal",
      "dedicado",
      "deduzir",
      "defesa",
      "defumar",
      "degelo",
      "degrau",
      "degustar",
      "deitado",
      "deixar",
      "delator",
      "delegado",
      "delinear",
      "delonga",
      "demanda",
      "demitir",
      "demolido",
      "dentista",
      "depenado",
      "depilar",
      "depois",
      "depressa",
      "depurar",
      "deriva",
      "derramar",
      "desafio",
      "desbotar",
      "descanso",
      "desenho",
      "desfiado",
      "desgaste",
      "desigual",
      "deslize",
      "desmamar",
      "desova",
      "despesa",
      "destaque",
      "desviar",
      "detalhar",
      "detentor",
      "detonar",
      "detrito",
      "deusa",
      "dever",
      "devido",
      "devotado",
      "dezena",
      "diagrama",
      "dialeto",
      "didata",
      "difuso",
      "digitar",
      "dilatado",
      "diluente",
      "diminuir",
      "dinastia",
      "dinheiro",
      "diocese",
      "direto",
      "discreta",
      "disfarce",
      "disparo",
      "disquete",
      "dissipar",
      "distante",
      "ditador",
      "diurno",
      "diverso",
      "divisor",
      "divulgar",
      "dizer",
      "dobrador",
      "dolorido",
      "domador",
      "dominado",
      "donativo",
      "donzela",
      "dormente",
      "dorsal",
      "dosagem",
      "dourado",
      "doutor",
      "drenagem",
      "drible",
      "drogaria",
      "duelar",
      "duende",
      "dueto",
      "duplo",
      "duquesa",
      "durante",
      "duvidoso",
      "eclodir",
      "ecoar",
      "ecologia",
      "edificar",
      "edital",
      "educado",
      "efeito",
      "efetivar",
      "ejetar",
      "elaborar",
      "eleger",
      "eleitor",
      "elenco",
      "elevador",
      "eliminar",
      "elogiar",
      "embargo",
      "embolado",
      "embrulho",
      "embutido",
      "emenda",
      "emergir",
      "emissor",
      "empatia",
      "empenho",
      "empinado",
      "empolgar",
      "emprego",
      "empurrar",
      "emulador",
      "encaixe",
      "encenado",
      "enchente",
      "encontro",
      "endeusar",
      "endossar",
      "enfaixar",
      "enfeite",
      "enfim",
      "engajado",
      "engenho",
      "englobar",
      "engomado",
      "engraxar",
      "enguia",
      "enjoar",
      "enlatar",
      "enquanto",
      "enraizar",
      "enrolado",
      "enrugar",
      "ensaio",
      "enseada",
      "ensino",
      "ensopado",
      "entanto",
      "enteado",
      "entidade",
      "entortar",
      "entrada",
      "entulho",
      "envergar",
      "enviado",
      "envolver",
      "enxame",
      "enxerto",
      "enxofre",
      "enxuto",
      "epiderme",
      "equipar",
      "ereto",
      "erguido",
      "errata",
      "erva",
      "ervilha",
      "esbanjar",
      "esbelto",
      "escama",
      "escola",
      "escrita",
      "escuta",
      "esfinge",
      "esfolar",
      "esfregar",
      "esfumado",
      "esgrima",
      "esmalte",
      "espanto",
      "espelho",
      "espiga",
      "esponja",
      "espreita",
      "espumar",
      "esquerda",
      "estaca",
      "esteira",
      "esticar",
      "estofado",
      "estrela",
      "estudo",
      "esvaziar",
      "etanol",
      "etiqueta",
      "euforia",
      "europeu",
      "evacuar",
      "evaporar",
      "evasivo",
      "eventual",
      "evidente",
      "evoluir",
      "exagero",
      "exalar",
      "examinar",
      "exato",
      "exausto",
      "excesso",
      "excitar",
      "exclamar",
      "executar",
      "exemplo",
      "exibir",
      "exigente",
      "exonerar",
      "expandir",
      "expelir",
      "expirar",
      "explanar",
      "exposto",
      "expresso",
      "expulsar",
      "externo",
      "extinto",
      "extrato",
      "fabricar",
      "fabuloso",
      "faceta",
      "facial",
      "fada",
      "fadiga",
      "faixa",
      "falar",
      "falta",
      "familiar",
      "fandango",
      "fanfarra",
      "fantoche",
      "fardado",
      "farelo",
      "farinha",
      "farofa",
      "farpa",
      "fartura",
      "fatia",
      "fator",
      "favorita",
      "faxina",
      "fazenda",
      "fechado",
      "feijoada",
      "feirante",
      "felino",
      "feminino",
      "fenda",
      "feno",
      "fera",
      "feriado",
      "ferrugem",
      "ferver",
      "festejar",
      "fetal",
      "feudal",
      "fiapo",
      "fibrose",
      "ficar",
      "ficheiro",
      "figurado",
      "fileira",
      "filho",
      "filme",
      "filtrar",
      "firmeza",
      "fisgada",
      "fissura",
      "fita",
      "fivela",
      "fixador",
      "fixo",
      "flacidez",
      "flamingo",
      "flanela",
      "flechada",
      "flora",
      "flutuar",
      "fluxo",
      "focal",
      "focinho",
      "fofocar",
      "fogo",
      "foguete",
      "foice",
      "folgado",
      "folheto",
      "forjar",
      "formiga",
      "forno",
      "forte",
      "fosco",
      "fossa",
      "fragata",
      "fralda",
      "frango",
      "frasco",
      "fraterno",
      "freira",
      "frente",
      "fretar",
      "frieza",
      "friso",
      "fritura",
      "fronha",
      "frustrar",
      "fruteira",
      "fugir",
      "fulano",
      "fuligem",
      "fundar",
      "fungo",
      "funil",
      "furador",
      "furioso",
      "futebol",
      "gabarito",
      "gabinete",
      "gado",
      "gaiato",
      "gaiola",
      "gaivota",
      "galega",
      "galho",
      "galinha",
      "galocha",
      "ganhar",
      "garagem",
      "garfo",
      "gargalo",
      "garimpo",
      "garoupa",
      "garrafa",
      "gasoduto",
      "gasto",
      "gata",
      "gatilho",
      "gaveta",
      "gazela",
      "gelado",
      "geleia",
      "gelo",
      "gemada",
      "gemer",
      "gemido",
      "generoso",
      "gengiva",
      "genial",
      "genoma",
      "genro",
      "geologia",
      "gerador",
      "germinar",
      "gesso",
      "gestor",
      "ginasta",
      "gincana",
      "gingado",
      "girafa",
      "girino",
      "glacial",
      "glicose",
      "global",
      "glorioso",
      "goela",
      "goiaba",
      "golfe",
      "golpear",
      "gordura",
      "gorjeta",
      "gorro",
      "gostoso",
      "goteira",
      "governar",
      "gracejo",
      "gradual",
      "grafite",
      "gralha",
      "grampo",
      "granada",
      "gratuito",
      "graveto",
      "graxa",
      "grego",
      "grelhar",
      "greve",
      "grilo",
      "grisalho",
      "gritaria",
      "grosso",
      "grotesco",
      "grudado",
      "grunhido",
      "gruta",
      "guache",
      "guarani",
      "guaxinim",
      "guerrear",
      "guiar",
      "guincho",
      "guisado",
      "gula",
      "guloso",
      "guru",
      "habitar",
      "harmonia",
      "haste",
      "haver",
      "hectare",
      "herdar",
      "heresia",
      "hesitar",
      "hiato",
      "hibernar",
      "hidratar",
      "hiena",
      "hino",
      "hipismo",
      "hipnose",
      "hipoteca",
      "hoje",
      "holofote",
      "homem",
      "honesto",
      "honrado",
      "hormonal",
      "hospedar",
      "humorado",
      "iate",
      "ideia",
      "idoso",
      "ignorado",
      "igreja",
      "iguana",
      "ileso",
      "ilha",
      "iludido",
      "iluminar",
      "ilustrar",
      "imagem",
      "imediato",
      "imenso",
      "imersivo",
      "iminente",
      "imitador",
      "imortal",
      "impacto",
      "impedir",
      "implante",
      "impor",
      "imprensa",
      "impune",
      "imunizar",
      "inalador",
      "inapto",
      "inativo",
      "incenso",
      "inchar",
      "incidir",
      "incluir",
      "incolor",
      "indeciso",
      "indireto",
      "indutor",
      "ineficaz",
      "inerente",
      "infantil",
      "infestar",
      "infinito",
      "inflamar",
      "informal",
      "infrator",
      "ingerir",
      "inibido",
      "inicial",
      "inimigo",
      "injetar",
      "inocente",
      "inodoro",
      "inovador",
      "inox",
      "inquieto",
      "inscrito",
      "inseto",
      "insistir",
      "inspetor",
      "instalar",
      "insulto",
      "intacto",
      "integral",
      "intimar",
      "intocado",
      "intriga",
      "invasor",
      "inverno",
      "invicto",
      "invocar",
      "iogurte",
      "iraniano",
      "ironizar",
      "irreal",
      "irritado",
      "isca",
      "isento",
      "isolado",
      "isqueiro",
      "italiano",
      "janeiro",
      "jangada",
      "janta",
      "jararaca",
      "jardim",
      "jarro",
      "jasmim",
      "jato",
      "javali",
      "jazida",
      "jejum",
      "joaninha",
      "joelhada",
      "jogador",
      "joia",
      "jornal",
      "jorrar",
      "jovem",
      "juba",
      "judeu",
      "judoca",
      "juiz",
      "julgador",
      "julho",
      "jurado",
      "jurista",
      "juro",
      "justa",
      "labareda",
      "laboral",
      "lacre",
      "lactante",
      "ladrilho",
      "lagarta",
      "lagoa",
      "laje",
      "lamber",
      "lamentar",
      "laminar",
      "lampejo",
      "lanche",
      "lapidar",
      "lapso",
      "laranja",
      "lareira",
      "largura",
      "lasanha",
      "lastro",
      "lateral",
      "latido",
      "lavanda",
      "lavoura",
      "lavrador",
      "laxante",
      "lazer",
      "lealdade",
      "lebre",
      "legado",
      "legendar",
      "legista",
      "leigo",
      "leiloar",
      "leitura",
      "lembrete",
      "leme",
      "lenhador",
      "lentilha",
      "leoa",
      "lesma",
      "leste",
      "letivo",
      "letreiro",
      "levar",
      "leveza",
      "levitar",
      "liberal",
      "libido",
      "liderar",
      "ligar",
      "ligeiro",
      "limitar",
      "limoeiro",
      "limpador",
      "linda",
      "linear",
      "linhagem",
      "liquidez",
      "listagem",
      "lisura",
      "litoral",
      "livro",
      "lixa",
      "lixeira",
      "locador",
      "locutor",
      "lojista",
      "lombo",
      "lona",
      "longe",
      "lontra",
      "lorde",
      "lotado",
      "loteria",
      "loucura",
      "lousa",
      "louvar",
      "luar",
      "lucidez",
      "lucro",
      "luneta",
      "lustre",
      "lutador",
      "luva",
      "macaco",
      "macete",
      "machado",
      "macio",
      "madeira",
      "madrinha",
      "magnata",
      "magreza",
      "maior",
      "mais",
      "malandro",
      "malha",
      "malote",
      "maluco",
      "mamilo",
      "mamoeiro",
      "mamute",
      "manada",
      "mancha",
      "mandato",
      "manequim",
      "manhoso",
      "manivela",
      "manobrar",
      "mansa",
      "manter",
      "manusear",
      "mapeado",
      "maquinar",
      "marcador",
      "maresia",
      "marfim",
      "margem",
      "marinho",
      "marmita",
      "maroto",
      "marquise",
      "marreco",
      "martelo",
      "marujo",
      "mascote",
      "masmorra",
      "massagem",
      "mastigar",
      "matagal",
      "materno",
      "matinal",
      "matutar",
      "maxilar",
      "medalha",
      "medida",
      "medusa",
      "megafone",
      "meiga",
      "melancia",
      "melhor",
      "membro",
      "memorial",
      "menino",
      "menos",
      "mensagem",
      "mental",
      "merecer",
      "mergulho",
      "mesada",
      "mesclar",
      "mesmo",
      "mesquita",
      "mestre",
      "metade",
      "meteoro",
      "metragem",
      "mexer",
      "mexicano",
      "micro",
      "migalha",
      "migrar",
      "milagre",
      "milenar",
      "milhar",
      "mimado",
      "minerar",
      "minhoca",
      "ministro",
      "minoria",
      "miolo",
      "mirante",
      "mirtilo",
      "misturar",
      "mocidade",
      "moderno",
      "modular",
      "moeda",
      "moer",
      "moinho",
      "moita",
      "moldura",
      "moleza",
      "molho",
      "molinete",
      "molusco",
      "montanha",
      "moqueca",
      "morango",
      "morcego",
      "mordomo",
      "morena",
      "mosaico",
      "mosquete",
      "mostarda",
      "motel",
      "motim",
      "moto",
      "motriz",
      "muda",
      "muito",
      "mulata",
      "mulher",
      "multar",
      "mundial",
      "munido",
      "muralha",
      "murcho",
      "muscular",
      "museu",
      "musical",
      "nacional",
      "nadador",
      "naja",
      "namoro",
      "narina",
      "narrado",
      "nascer",
      "nativa",
      "natureza",
      "navalha",
      "navegar",
      "navio",
      "neblina",
      "nebuloso",
      "negativa",
      "negociar",
      "negrito",
      "nervoso",
      "neta",
      "neural",
      "nevasca",
      "nevoeiro",
      "ninar",
      "ninho",
      "nitidez",
      "nivelar",
      "nobreza",
      "noite",
      "noiva",
      "nomear",
      "nominal",
      "nordeste",
      "nortear",
      "notar",
      "noticiar",
      "noturno",
      "novelo",
      "novilho",
      "novo",
      "nublado",
      "nudez",
      "numeral",
      "nupcial",
      "nutrir",
      "nuvem",
      "obcecado",
      "obedecer",
      "objetivo",
      "obrigado",
      "obscuro",
      "obstetra",
      "obter",
      "obturar",
      "ocidente",
      "ocioso",
      "ocorrer",
      "oculista",
      "ocupado",
      "ofegante",
      "ofensiva",
      "oferenda",
      "oficina",
      "ofuscado",
      "ogiva",
      "olaria",
      "oleoso",
      "olhar",
      "oliveira",
      "ombro",
      "omelete",
      "omisso",
      "omitir",
      "ondulado",
      "oneroso",
      "ontem",
      "opcional",
      "operador",
      "oponente",
      "oportuno",
      "oposto",
      "orar",
      "orbitar",
      "ordem",
      "ordinal",
      "orfanato",
      "orgasmo",
      "orgulho",
      "oriental",
      "origem",
      "oriundo",
      "orla",
      "ortodoxo",
      "orvalho",
      "oscilar",
      "ossada",
      "osso",
      "ostentar",
      "otimismo",
      "ousadia",
      "outono",
      "outubro",
      "ouvido",
      "ovelha",
      "ovular",
      "oxidar",
      "oxigenar",
      "pacato",
      "paciente",
      "pacote",
      "pactuar",
      "padaria",
      "padrinho",
      "pagar",
      "pagode",
      "painel",
      "pairar",
      "paisagem",
      "palavra",
      "palestra",
      "palheta",
      "palito",
      "palmada",
      "palpitar",
      "pancada",
      "panela",
      "panfleto",
      "panqueca",
      "pantanal",
      "papagaio",
      "papelada",
      "papiro",
      "parafina",
      "parcial",
      "pardal",
      "parede",
      "partida",
      "pasmo",
      "passado",
      "pastel",
      "patamar",
      "patente",
      "patinar",
      "patrono",
      "paulada",
      "pausar",
      "peculiar",
      "pedalar",
      "pedestre",
      "pediatra",
      "pedra",
      "pegada",
      "peitoral",
      "peixe",
      "pele",
      "pelicano",
      "penca",
      "pendurar",
      "peneira",
      "penhasco",
      "pensador",
      "pente",
      "perceber",
      "perfeito",
      "pergunta",
      "perito",
      "permitir",
      "perna",
      "perplexo",
      "persiana",
      "pertence",
      "peruca",
      "pescado",
      "pesquisa",
      "pessoa",
      "petiscar",
      "piada",
      "picado",
      "piedade",
      "pigmento",
      "pilastra",
      "pilhado",
      "pilotar",
      "pimenta",
      "pincel",
      "pinguim",
      "pinha",
      "pinote",
      "pintar",
      "pioneiro",
      "pipoca",
      "piquete",
      "piranha",
      "pires",
      "pirueta",
      "piscar",
      "pistola",
      "pitanga",
      "pivete",
      "planta",
      "plaqueta",
      "platina",
      "plebeu",
      "plumagem",
      "pluvial",
      "pneu",
      "poda",
      "poeira",
      "poetisa",
      "polegada",
      "policiar",
      "poluente",
      "polvilho",
      "pomar",
      "pomba",
      "ponderar",
      "pontaria",
      "populoso",
      "porta",
      "possuir",
      "postal",
      "pote",
      "poupar",
      "pouso",
      "povoar",
      "praia",
      "prancha",
      "prato",
      "praxe",
      "prece",
      "predador",
      "prefeito",
      "premiar",
      "prensar",
      "preparar",
      "presilha",
      "pretexto",
      "prevenir",
      "prezar",
      "primata",
      "princesa",
      "prisma",
      "privado",
      "processo",
      "produto",
      "profeta",
      "proibido",
      "projeto",
      "prometer",
      "propagar",
      "prosa",
      "protetor",
      "provador",
      "publicar",
      "pudim",
      "pular",
      "pulmonar",
      "pulseira",
      "punhal",
      "punir",
      "pupilo",
      "pureza",
      "puxador",
      "quadra",
      "quantia",
      "quarto",
      "quase",
      "quebrar",
      "queda",
      "queijo",
      "quente",
      "querido",
      "quimono",
      "quina",
      "quiosque",
      "rabanada",
      "rabisco",
      "rachar",
      "racionar",
      "radial",
      "raiar",
      "rainha",
      "raio",
      "raiva",
      "rajada",
      "ralado",
      "ramal",
      "ranger",
      "ranhura",
      "rapadura",
      "rapel",
      "rapidez",
      "raposa",
      "raquete",
      "raridade",
      "rasante",
      "rascunho",
      "rasgar",
      "raspador",
      "rasteira",
      "rasurar",
      "ratazana",
      "ratoeira",
      "realeza",
      "reanimar",
      "reaver",
      "rebaixar",
      "rebelde",
      "rebolar",
      "recado",
      "recente",
      "recheio",
      "recibo",
      "recordar",
      "recrutar",
      "recuar",
      "rede",
      "redimir",
      "redonda",
      "reduzida",
      "reenvio",
      "refinar",
      "refletir",
      "refogar",
      "refresco",
      "refugiar",
      "regalia",
      "regime",
      "regra",
      "reinado",
      "reitor",
      "rejeitar",
      "relativo",
      "remador",
      "remendo",
      "remorso",
      "renovado",
      "reparo",
      "repelir",
      "repleto",
      "repolho",
      "represa",
      "repudiar",
      "requerer",
      "resenha",
      "resfriar",
      "resgatar",
      "residir",
      "resolver",
      "respeito",
      "ressaca",
      "restante",
      "resumir",
      "retalho",
      "reter",
      "retirar",
      "retomada",
      "retratar",
      "revelar",
      "revisor",
      "revolta",
      "riacho",
      "rica",
      "rigidez",
      "rigoroso",
      "rimar",
      "ringue",
      "risada",
      "risco",
      "risonho",
      "robalo",
      "rochedo",
      "rodada",
      "rodeio",
      "rodovia",
      "roedor",
      "roleta",
      "romano",
      "roncar",
      "rosado",
      "roseira",
      "rosto",
      "rota",
      "roteiro",
      "rotina",
      "rotular",
      "rouco",
      "roupa",
      "roxo",
      "rubro",
      "rugido",
      "rugoso",
      "ruivo",
      "rumo",
      "rupestre",
      "russo",
      "sabor",
      "saciar",
      "sacola",
      "sacudir",
      "sadio",
      "safira",
      "saga",
      "sagrada",
      "saibro",
      "salada",
      "saleiro",
      "salgado",
      "saliva",
      "salpicar",
      "salsicha",
      "saltar",
      "salvador",
      "sambar",
      "samurai",
      "sanar",
      "sanfona",
      "sangue",
      "sanidade",
      "sapato",
      "sarda",
      "sargento",
      "sarjeta",
      "saturar",
      "saudade",
      "saxofone",
      "sazonal",
      "secar",
      "secular",
      "seda",
      "sedento",
      "sediado",
      "sedoso",
      "sedutor",
      "segmento",
      "segredo",
      "segundo",
      "seiva",
      "seleto",
      "selvagem",
      "semanal",
      "semente",
      "senador",
      "senhor",
      "sensual",
      "sentado",
      "separado",
      "sereia",
      "seringa",
      "serra",
      "servo",
      "setembro",
      "setor",
      "sigilo",
      "silhueta",
      "silicone",
      "simetria",
      "simpatia",
      "simular",
      "sinal",
      "sincero",
      "singular",
      "sinopse",
      "sintonia",
      "sirene",
      "siri",
      "situado",
      "soberano",
      "sobra",
      "socorro",
      "sogro",
      "soja",
      "solda",
      "soletrar",
      "solteiro",
      "sombrio",
      "sonata",
      "sondar",
      "sonegar",
      "sonhador",
      "sono",
      "soprano",
      "soquete",
      "sorrir",
      "sorteio",
      "sossego",
      "sotaque",
      "soterrar",
      "sovado",
      "sozinho",
      "suavizar",
      "subida",
      "submerso",
      "subsolo",
      "subtrair",
      "sucata",
      "sucesso",
      "suco",
      "sudeste",
      "sufixo",
      "sugador",
      "sugerir",
      "sujeito",
      "sulfato",
      "sumir",
      "suor",
      "superior",
      "suplicar",
      "suposto",
      "suprimir",
      "surdina",
      "surfista",
      "surpresa",
      "surreal",
      "surtir",
      "suspiro",
      "sustento",
      "tabela",
      "tablete",
      "tabuada",
      "tacho",
      "tagarela",
      "talher",
      "talo",
      "talvez",
      "tamanho",
      "tamborim",
      "tampa",
      "tangente",
      "tanto",
      "tapar",
      "tapioca",
      "tardio",
      "tarefa",
      "tarja",
      "tarraxa",
      "tatuagem",
      "taurino",
      "taxativo",
      "taxista",
      "teatral",
      "tecer",
      "tecido",
      "teclado",
      "tedioso",
      "teia",
      "teimar",
      "telefone",
      "telhado",
      "tempero",
      "tenente",
      "tensor",
      "tentar",
      "termal",
      "terno",
      "terreno",
      "tese",
      "tesoura",
      "testado",
      "teto",
      "textura",
      "texugo",
      "tiara",
      "tigela",
      "tijolo",
      "timbrar",
      "timidez",
      "tingido",
      "tinteiro",
      "tiragem",
      "titular",
      "toalha",
      "tocha",
      "tolerar",
      "tolice",
      "tomada",
      "tomilho",
      "tonel",
      "tontura",
      "topete",
      "tora",
      "torcido",
      "torneio",
      "torque",
      "torrada",
      "torto",
      "tostar",
      "touca",
      "toupeira",
      "toxina",
      "trabalho",
      "tracejar",
      "tradutor",
      "trafegar",
      "trajeto",
      "trama",
      "trancar",
      "trapo",
      "traseiro",
      "tratador",
      "travar",
      "treino",
      "tremer",
      "trepidar",
      "trevo",
      "triagem",
      "tribo",
      "triciclo",
      "tridente",
      "trilogia",
      "trindade",
      "triplo",
      "triturar",
      "triunfal",
      "trocar",
      "trombeta",
      "trova",
      "trunfo",
      "truque",
      "tubular",
      "tucano",
      "tudo",
      "tulipa",
      "tupi",
      "turbo",
      "turma",
      "turquesa",
      "tutelar",
      "tutorial",
      "uivar",
      "umbigo",
      "unha",
      "unidade",
      "uniforme",
      "urologia",
      "urso",
      "urtiga",
      "urubu",
      "usado",
      "usina",
      "usufruir",
      "vacina",
      "vadiar",
      "vagaroso",
      "vaidoso",
      "vala",
      "valente",
      "validade",
      "valores",
      "vantagem",
      "vaqueiro",
      "varanda",
      "vareta",
      "varrer",
      "vascular",
      "vasilha",
      "vassoura",
      "vazar",
      "vazio",
      "veado",
      "vedar",
      "vegetar",
      "veicular",
      "veleiro",
      "velhice",
      "veludo",
      "vencedor",
      "vendaval",
      "venerar",
      "ventre",
      "verbal",
      "verdade",
      "vereador",
      "vergonha",
      "vermelho",
      "verniz",
      "versar",
      "vertente",
      "vespa",
      "vestido",
      "vetorial",
      "viaduto",
      "viagem",
      "viajar",
      "viatura",
      "vibrador",
      "videira",
      "vidraria",
      "viela",
      "viga",
      "vigente",
      "vigiar",
      "vigorar",
      "vilarejo",
      "vinco",
      "vinheta",
      "vinil",
      "violeta",
      "virada",
      "virtude",
      "visitar",
      "visto",
      "vitral",
      "viveiro",
      "vizinho",
      "voador",
      "voar",
      "vogal",
      "volante",
      "voleibol",
      "voltagem",
      "volumoso",
      "vontade",
      "vulto",
      "vuvuzela",
      "xadrez",
      "xarope",
      "xeque",
      "xeretar",
      "xerife",
      "xingar",
      "zangado",
      "zarpar",
      "zebu",
      "zelador",
      "zombar",
      "zoologia",
      "zumbido"
    ];
  }
});

// ../../node_modules/bip39/src/wordlists/english.json
var require_english = __commonJS({
  "../../node_modules/bip39/src/wordlists/english.json"(exports2, module2) {
    module2.exports = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
  }
});

// ../../node_modules/bip39/src/_wordlists.js
var require_wordlists = __commonJS({
  "../../node_modules/bip39/src/_wordlists.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var wordlists = {};
    exports2.wordlists = wordlists;
    var _default;
    exports2._default = _default;
    try {
      exports2._default = _default = require_czech();
      wordlists.czech = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_chinese_simplified();
      wordlists.chinese_simplified = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_chinese_traditional();
      wordlists.chinese_traditional = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_korean();
      wordlists.korean = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_french();
      wordlists.french = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_italian();
      wordlists.italian = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_spanish();
      wordlists.spanish = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_japanese();
      wordlists.japanese = _default;
      wordlists.JA = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_portuguese();
      wordlists.portuguese = _default;
    } catch (err) {
    }
    try {
      exports2._default = _default = require_english();
      wordlists.english = _default;
      wordlists.EN = _default;
    } catch (err) {
    }
  }
});

// ../../node_modules/bip39/src/index.js
var require_src = __commonJS({
  "../../node_modules/bip39/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var pbkdf2_1 = require_pbkdf2();
    var utils_1 = require_utils();
    var _wordlists_1 = require_wordlists();
    var DEFAULT_WORDLIST = _wordlists_1._default;
    var INVALID_MNEMONIC = "Invalid mnemonic";
    var INVALID_ENTROPY = "Invalid entropy";
    var INVALID_CHECKSUM = "Invalid mnemonic checksum";
    var WORDLIST_REQUIRED = "A wordlist is required but a default could not be found.\nPlease pass a 2048 word array explicitly.";
    function normalize(str) {
      return (str || "").normalize("NFKD");
    }
    function lpad(str, padString2, length2) {
      while (str.length < length2) {
        str = padString2 + str;
      }
      return str;
    }
    function binaryToByte(bin) {
      return parseInt(bin, 2);
    }
    function bytesToBinary(bytes) {
      return bytes.map((x3) => lpad(x3.toString(2), "0", 8)).join("");
    }
    function deriveChecksumBits(entropyBuffer) {
      const ENT = entropyBuffer.length * 8;
      const CS = ENT / 32;
      const hash3 = sha256_1.sha256(Uint8Array.from(entropyBuffer));
      return bytesToBinary(Array.from(hash3)).slice(0, CS);
    }
    function salt(password) {
      return "mnemonic" + (password || "");
    }
    function mnemonicToSeedSync(mnemonic, password) {
      const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), "utf8"));
      const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
      const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64
      });
      return Buffer.from(res);
    }
    exports2.mnemonicToSeedSync = mnemonicToSeedSync;
    function mnemonicToSeed2(mnemonic, password) {
      const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), "utf8"));
      const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
      return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64
      }).then((res) => Buffer.from(res));
    }
    exports2.mnemonicToSeed = mnemonicToSeed2;
    function mnemonicToEntropy(mnemonic, wordlist) {
      wordlist = wordlist || DEFAULT_WORDLIST;
      if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
      }
      const words = normalize(mnemonic).split(" ");
      if (words.length % 3 !== 0) {
        throw new Error(INVALID_MNEMONIC);
      }
      const bits = words.map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
          throw new Error(INVALID_MNEMONIC);
        }
        return lpad(index.toString(2), "0", 11);
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
      if (entropyBytes.length < 16) {
        throw new Error(INVALID_ENTROPY);
      }
      if (entropyBytes.length > 32) {
        throw new Error(INVALID_ENTROPY);
      }
      if (entropyBytes.length % 4 !== 0) {
        throw new Error(INVALID_ENTROPY);
      }
      const entropy = Buffer.from(entropyBytes);
      const newChecksum = deriveChecksumBits(entropy);
      if (newChecksum !== checksumBits) {
        throw new Error(INVALID_CHECKSUM);
      }
      return entropy.toString("hex");
    }
    exports2.mnemonicToEntropy = mnemonicToEntropy;
    function entropyToMnemonic(entropy, wordlist) {
      if (!Buffer.isBuffer(entropy)) {
        entropy = Buffer.from(entropy, "hex");
      }
      wordlist = wordlist || DEFAULT_WORDLIST;
      if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
      }
      if (entropy.length < 16) {
        throw new TypeError(INVALID_ENTROPY);
      }
      if (entropy.length > 32) {
        throw new TypeError(INVALID_ENTROPY);
      }
      if (entropy.length % 4 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
      }
      const entropyBits = bytesToBinary(Array.from(entropy));
      const checksumBits = deriveChecksumBits(entropy);
      const bits = entropyBits + checksumBits;
      const chunks = bits.match(/(.{1,11})/g);
      const words = chunks.map((binary) => {
        const index = binaryToByte(binary);
        return wordlist[index];
      });
      return wordlist[0] === "あいこくしん" ? words.join("　") : words.join(" ");
    }
    exports2.entropyToMnemonic = entropyToMnemonic;
    function generateMnemonic3(strength, rng, wordlist) {
      strength = strength || 128;
      if (strength % 32 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
      }
      rng = rng || ((size) => Buffer.from(utils_1.randomBytes(size)));
      return entropyToMnemonic(rng(strength / 8), wordlist);
    }
    exports2.generateMnemonic = generateMnemonic3;
    function validateMnemonic(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
      } catch (e2) {
        return false;
      }
      return true;
    }
    exports2.validateMnemonic = validateMnemonic;
    function setDefaultWordlist(language) {
      const result = _wordlists_1.wordlists[language];
      if (result) {
        DEFAULT_WORDLIST = result;
      } else {
        throw new Error('Could not find wordlist for language "' + language + '"');
      }
    }
    exports2.setDefaultWordlist = setDefaultWordlist;
    function getDefaultWordlist() {
      if (!DEFAULT_WORDLIST) {
        throw new Error("No Default Wordlist set");
      }
      return Object.keys(_wordlists_1.wordlists).filter((lang) => {
        if (lang === "JA" || lang === "EN") {
          return false;
        }
        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
      })[0];
    }
    exports2.getDefaultWordlist = getDefaultWordlist;
    var _wordlists_2 = require_wordlists();
    exports2.wordlists = _wordlists_2.wordlists;
  }
});

// ../../node_modules/lodash.isplainobject/index.js
var require_lodash = __commonJS({
  "../../node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e2) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject3(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject3;
  }
});

// ../../node_modules/deep-for-each/es/index.js
function forEachObject(obj, fn2, path) {
  for (const key in obj) {
    const deepPath = path ? `${path}.${key}` : key;
    fn2.call(obj, obj[key], key, obj, deepPath);
    forEach2(obj[key], fn2, deepPath);
  }
}
function forEachArray(array, fn2, path) {
  array.forEach((value, index, arr) => {
    const deepPath = `${path}[${index}]`;
    fn2.call(arr, value, index, arr, deepPath);
    forEach2(arr[index], fn2, deepPath);
  });
}
function forEach2(value, fn2, path) {
  path = path || "";
  if (Array.isArray(value)) {
    forEachArray(value, fn2, path);
  } else if ((0, import_lodash.default)(value)) {
    forEachObject(value, fn2, path);
  }
}
var import_lodash, es_default;
var init_es = __esm({
  "../../node_modules/deep-for-each/es/index.js"() {
    import_lodash = __toESM(require_lodash());
    es_default = forEach2;
  }
});

// ../../node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "../../node_modules/kind-of/index.js"(exports2, module2) {
    var toString5 = Object.prototype.toString;
    module2.exports = function kindOf2(val) {
      if (val === void 0) return "undefined";
      if (val === null) return "null";
      var type = typeof val;
      if (type === "boolean") return "boolean";
      if (type === "string") return "string";
      if (type === "number") return "number";
      if (type === "symbol") return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray2(val)) return "array";
      if (isBuffer2(val)) return "buffer";
      if (isArguments(val)) return "arguments";
      if (isDate2(val)) return "date";
      if (isError(val)) return "error";
      if (isRegexp(val)) return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString5.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray2(val) {
      if (Array.isArray) return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate2(val) {
      if (val instanceof Date) return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp) return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name2, val) {
      return ctorName(name2) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer2(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// ../../node_modules/shallow-clone/index.js
var require_shallow_clone = __commonJS({
  "../../node_modules/shallow-clone/index.js"(exports2, module2) {
    "use strict";
    var valueOf = Symbol.prototype.valueOf;
    var typeOf = require_kind_of();
    function clone(val, deep) {
      switch (typeOf(val)) {
        case "array":
          return val.slice();
        case "object":
          return Object.assign({}, val);
        case "date":
          return new val.constructor(Number(val));
        case "map":
          return new Map(val);
        case "set":
          return new Set(val);
        case "buffer":
          return cloneBuffer(val);
        case "symbol":
          return cloneSymbol(val);
        case "arraybuffer":
          return cloneArrayBuffer(val);
        case "float32array":
        case "float64array":
        case "int16array":
        case "int32array":
        case "int8array":
        case "uint16array":
        case "uint32array":
        case "uint8clampedarray":
        case "uint8array":
          return cloneTypedArray(val);
        case "regexp":
          return cloneRegExp(val);
        case "error":
          return Object.create(val);
        default: {
          return val;
        }
      }
    }
    function cloneRegExp(val) {
      const flags = val.flags !== void 0 ? val.flags : /\w+$/.exec(val) || void 0;
      const re = new val.constructor(val.source, flags);
      re.lastIndex = val.lastIndex;
      return re;
    }
    function cloneArrayBuffer(val) {
      const res = new val.constructor(val.byteLength);
      new Uint8Array(res).set(new Uint8Array(val));
      return res;
    }
    function cloneTypedArray(val, deep) {
      return new val.constructor(val.buffer, val.byteOffset, val.length);
    }
    function cloneBuffer(val) {
      const len = val.length;
      const buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);
      val.copy(buf);
      return buf;
    }
    function cloneSymbol(val) {
      return valueOf ? Object(valueOf.call(val)) : {};
    }
    module2.exports = clone;
  }
});

// ../../node_modules/isobject/index.js
var require_isobject = __commonJS({
  "../../node_modules/isobject/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function isObject2(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    };
  }
});

// ../../node_modules/is-plain-object/index.js
var require_is_plain_object = __commonJS({
  "../../node_modules/is-plain-object/index.js"(exports2, module2) {
    "use strict";
    var isObject2 = require_isobject();
    function isObjectObject(o2) {
      return isObject2(o2) === true && Object.prototype.toString.call(o2) === "[object Object]";
    }
    module2.exports = function isPlainObject3(o2) {
      var ctor, prot;
      if (isObjectObject(o2) === false) return false;
      ctor = o2.constructor;
      if (typeof ctor !== "function") return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false) return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/clone-deep/index.js
var require_clone_deep = __commonJS({
  "../../node_modules/clone-deep/index.js"(exports2, module2) {
    "use strict";
    var clone = require_shallow_clone();
    var typeOf = require_kind_of();
    var isPlainObject3 = require_is_plain_object();
    function cloneDeep2(val, instanceClone) {
      switch (typeOf(val)) {
        case "object":
          return cloneObjectDeep(val, instanceClone);
        case "array":
          return cloneArrayDeep(val, instanceClone);
        default: {
          return clone(val);
        }
      }
    }
    function cloneObjectDeep(val, instanceClone) {
      if (typeof instanceClone === "function") {
        return instanceClone(val);
      }
      if (instanceClone || isPlainObject3(val)) {
        const res = new val.constructor();
        for (let key in val) {
          res[key] = cloneDeep2(val[key], instanceClone);
        }
        return res;
      }
      return val;
    }
    function cloneArrayDeep(val, instanceClone) {
      const res = new val.constructor(val.length);
      for (let i2 = 0; i2 < val.length; i2++) {
        res[i2] = cloneDeep2(val[i2], instanceClone);
      }
      return res;
    }
    module2.exports = cloneDeep2;
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "../../node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base3, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base3 === "le" || base3 === "be") {
            endian = base3;
            base3 = 10;
          }
          this._init(number || 0, base3 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer().Buffer;
        }
      } catch (e2) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base3, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base3, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base3, endian);
        }
        if (base3 === "hex") {
          base3 = 16;
        }
        assert(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base3 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base3, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base3, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base3, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base3, endian);
      };
      BN.prototype._initArray = function _initArray(number, base3, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j2, w3;
        var off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
            w3 = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
            this.words[j2] |= w3 << off & 67108863;
            this.words[j2 + 1] = w3 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j2 = 0; i2 < number.length; i2 += 3) {
            w3 = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
            this.words[j2] |= w3 << off & 67108863;
            this.words[j2 + 1] = w3 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string2, index) {
        var c2 = string2.charCodeAt(index);
        if (c2 >= 65 && c2 <= 70) {
          return c2 - 55;
        } else if (c2 >= 97 && c2 <= 102) {
          return c2 - 87;
        } else {
          return c2 - 48 & 15;
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r2 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r2;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var off = 0;
        var j2 = 0;
        var w3;
        if (endian === "be") {
          for (i2 = number.length - 1; i2 >= start; i2 -= 2) {
            w3 = parseHexByte(number, start, i2) << off;
            this.words[j2] |= w3 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w3 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number.length; i2 += 2) {
            w3 = parseHexByte(number, start, i2) << off;
            this.words[j2] |= w3 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w3 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r2 = 0;
        var len = Math.min(str.length, end);
        for (var i2 = start; i2 < len; i2++) {
          var c2 = str.charCodeAt(i2) - 48;
          r2 *= mul;
          if (c2 >= 49) {
            r2 += c2 - 49 + 10;
          } else if (c2 >= 17) {
            r2 += c2 - 17 + 10;
          } else {
            r2 += c2;
          }
        }
        return r2;
      }
      BN.prototype._parseBase = function _parseBase(number, base3, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base3 | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number, i2, i2 + limbLen, base3);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i2, number.length, base3);
          for (i2 = 0; i2 < mod2; i2++) {
            pow *= base3;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r2 = new BN(null);
        this.copy(r2);
        return r2;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString5(base3, padding) {
        base3 = base3 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base3 === 16 || base3 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w3 = this.words[i2];
            var word = ((w3 << off | carry) & 16777215).toString(16);
            carry = w3 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
          var groupSize = groupSizes[base3];
          var groupBase = groupBases[base3];
          out = "";
          var c2 = this.clone();
          c2.negative = 0;
          while (!c2.isZero()) {
            var r2 = c2.modn(groupBase).toString(base3);
            c2 = c2.idivn(groupBase);
            if (!c2.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON2() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer2(endian, length2) {
        assert(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length2);
      };
      BN.prototype.toArray = function toArray2(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
        var byteLength = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b2, i2;
        var q2 = this.clone();
        if (!littleEndian) {
          for (i2 = 0; i2 < reqLength - byteLength; i2++) {
            res[i2] = 0;
          }
          for (i2 = 0; !q2.isZero(); i2++) {
            b2 = q2.andln(255);
            q2.iushrn(8);
            res[reqLength - i2 - 1] = b2;
          }
        } else {
          for (i2 = 0; !q2.isZero(); i2++) {
            b2 = q2.andln(255);
            q2.iushrn(8);
            res[i2] = b2;
          }
          for (; i2 < reqLength; i2++) {
            res[i2] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w3) {
          return 32 - Math.clz32(w3);
        };
      } else {
        BN.prototype._countBits = function _countBits(w3) {
          var t2 = w3;
          var r2 = 0;
          if (t2 >= 4096) {
            r2 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r2 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r2 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r2 += 2;
            t2 >>>= 2;
          }
          return r2 + t2;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w3) {
        if (w3 === 0) return 26;
        var t2 = w3;
        var r2 = 0;
        if ((t2 & 8191) === 0) {
          r2 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r2 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r2 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r2 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN.prototype.bitLength = function bitLength() {
        var w3 = this.words[this.length - 1];
        var hi2 = this._countBits(w3);
        return (this.length - 1) * 26 + hi2;
      };
      function toBitArray(num) {
        var w3 = new Array(num.bitLength());
        for (var bit = 0; bit < w3.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w3[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w3;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r2 = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b2 = this._zeroBits(this.words[i2]);
          r2 += b2;
          if (b2 !== 26) break;
        }
        return r2;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or3(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i2 = 0; i2 < b2.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b2.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a2;
        var b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        for (var i2 = 0; i2 < b2.length; i2++) {
          this.words[i2] = a2.words[i2] ^ b2.words[i2];
        }
        if (this !== a2) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = a2.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a2, b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b2.length; i2++) {
          r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r2 = (a2.words[i2] | 0) + carry;
          this.words[i2] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a2.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a2, b2;
        if (cmp > 0) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b2.length; i2++) {
          r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r2 = (a2.words[i2] | 0) + carry;
          carry = r2 >> 26;
          this.words[i2] = r2 & 67108863;
        }
        if (carry === 0 && i2 < a2.length && a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a2 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a2 = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r2 = a2 * b2;
        var lo2 = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i2 = k2 - j2 | 0;
            a2 = self2.words[i2] | 0;
            b2 = num.words[j2] | 0;
            r2 = a2 * b2 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a2 = self2.words;
        var b2 = num.words;
        var o2 = out.words;
        var c2 = 0;
        var lo2;
        var mid;
        var hi2;
        var a02 = a2[0] | 0;
        var al0 = a02 & 8191;
        var ah0 = a02 >>> 13;
        var a12 = a2[1] | 0;
        var al1 = a12 & 8191;
        var ah1 = a12 >>> 13;
        var a22 = a2[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a3 = a2[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a2[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a2[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a2[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a2[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a2[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a2[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b02 = b2[0] | 0;
        var bl0 = b02 & 8191;
        var bh0 = b02 >>> 13;
        var b12 = b2[1] | 0;
        var bl1 = b12 & 8191;
        var bh1 = b12 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi2 = Math.imul(ah0, bh0);
        var w02 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
        w02 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi2 = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi2 = hi2 + Math.imul(ah0, bh1) | 0;
        var w12 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi2 = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi2 = hi2 + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi2 = hi2 + Math.imul(ah0, bh2) | 0;
        var w22 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi2 = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi2 = hi2 + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi2 = hi2 + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi2 = hi2 + Math.imul(ah0, bh3) | 0;
        var w3 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi2 = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi2 = hi2 + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi2 = hi2 + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi2 = hi2 + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi2 = hi2 + Math.imul(ah0, bh4) | 0;
        var w4 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi2 = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi2 = hi2 + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi2 = hi2 + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi2 = hi2 + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi2 = hi2 + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi2 = hi2 + Math.imul(ah0, bh5) | 0;
        var w5 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi2 = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi2 = hi2 + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi2 = hi2 + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi2 = hi2 + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi2 = hi2 + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi2 = hi2 + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi2 = hi2 + Math.imul(ah0, bh6) | 0;
        var w6 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi2 = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi2 = hi2 + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi2 = hi2 + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi2 = hi2 + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi2 = hi2 + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi2 = hi2 + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi2 = hi2 + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi2 = hi2 + Math.imul(ah0, bh7) | 0;
        var w7 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi2 = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi2 = hi2 + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi2 = hi2 + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi2 = hi2 + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi2 = hi2 + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi2 = hi2 + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi2 = hi2 + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi2 = hi2 + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi2 = hi2 + Math.imul(ah0, bh8) | 0;
        var w8 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi2 = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi2 = hi2 + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi2 = hi2 + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi2 = hi2 + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi2 = hi2 + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi2 = hi2 + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi2 = hi2 + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi2 = hi2 + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi2 = hi2 + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi2 = hi2 + Math.imul(ah0, bh9) | 0;
        var w9 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi2 = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi2 = hi2 + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi2 = hi2 + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi2 = hi2 + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi2 = hi2 + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi2 = hi2 + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi2 = hi2 + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi2 = hi2 + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi2 = hi2 + Math.imul(ah1, bh9) | 0;
        var w10 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi2 = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi2 = hi2 + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi2 = hi2 + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi2 = hi2 + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi2 = hi2 + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi2 = hi2 + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi2 = hi2 + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi2 = hi2 + Math.imul(ah2, bh9) | 0;
        var w11 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi2 = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi2 = hi2 + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi2 = hi2 + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi2 = hi2 + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi2 = hi2 + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi2 = hi2 + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi2 = hi2 + Math.imul(ah3, bh9) | 0;
        var w122 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
        w122 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi2 = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi2 = hi2 + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi2 = hi2 + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi2 = hi2 + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi2 = hi2 + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi2 = hi2 + Math.imul(ah4, bh9) | 0;
        var w13 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi2 = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi2 = hi2 + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi2 = hi2 + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi2 = hi2 + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi2 = hi2 + Math.imul(ah5, bh9) | 0;
        var w14 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi2 = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi2 = hi2 + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi2 = hi2 + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi2 = hi2 + Math.imul(ah6, bh9) | 0;
        var w15 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi2 = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi2 = hi2 + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi2 = hi2 + Math.imul(ah7, bh9) | 0;
        var w16 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi2 = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi2 = hi2 + Math.imul(ah8, bh9) | 0;
        var w17 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi2 = Math.imul(ah9, bh9);
        var w18 = (c2 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o2[0] = w02;
        o2[1] = w12;
        o2[2] = w22;
        o2[3] = w3;
        o2[4] = w4;
        o2[5] = w5;
        o2[6] = w6;
        o2[7] = w7;
        o2[8] = w8;
        o2[9] = w9;
        o2[10] = w10;
        o2[11] = w11;
        o2[12] = w122;
        o2[13] = w13;
        o2[14] = w14;
        o2[15] = w15;
        o2[16] = w16;
        o2[17] = w17;
        o2[18] = w18;
        if (c2 !== 0) {
          o2[19] = c2;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i2 = k2 - j2;
            var a2 = self2.words[i2] | 0;
            var b2 = num.words[j2] | 0;
            var r2 = a2 * b2;
            var lo2 = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x3, y2) {
        this.x = x3;
        this.y = y2;
      }
      FFTM.prototype.makeRBT = function makeRBT(N11) {
        var t2 = new Array(N11);
        var l2 = BN.prototype._countBits(N11) - 1;
        for (var i2 = 0; i2 < N11; i2++) {
          t2[i2] = this.revBin(i2, l2, N11);
        }
        return t2;
      };
      FFTM.prototype.revBin = function revBin(x3, l2, N11) {
        if (x3 === 0 || x3 === N11 - 1) return x3;
        var rb = 0;
        for (var i2 = 0; i2 < l2; i2++) {
          rb |= (x3 & 1) << l2 - i2 - 1;
          x3 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N11) {
        for (var i2 = 0; i2 < N11; i2++) {
          rtws[i2] = rws[rbt[i2]];
          itws[i2] = iws[rbt[i2]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N11, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N11);
        for (var s2 = 1; s2 < N11; s2 <<= 1) {
          var l2 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p2 = 0; p2 < N11; p2 += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j2 = 0; j2 < s2; j2++) {
              var re = rtws[p2 + j2];
              var ie = itws[p2 + j2];
              var ro2 = rtws[p2 + j2 + s2];
              var io2 = itws[p2 + j2 + s2];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p2 + j2] = re + ro2;
              itws[p2 + j2] = ie + io2;
              rtws[p2 + j2 + s2] = re - ro2;
              itws[p2 + j2 + s2] = ie - io2;
              if (j2 !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m2) {
        var N11 = Math.max(m2, n2) | 1;
        var odd = N11 & 1;
        var i2 = 0;
        for (N11 = N11 / 2 | 0; N11; N11 = N11 >>> 1) {
          i2++;
        }
        return 1 << i2 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N11) {
        if (N11 <= 1) return;
        for (var i2 = 0; i2 < N11 / 2; i2++) {
          var t2 = rws[i2];
          rws[i2] = rws[N11 - i2 - 1];
          rws[N11 - i2 - 1] = t2;
          t2 = iws[i2];
          iws[i2] = -iws[N11 - i2 - 1];
          iws[N11 - i2 - 1] = -t2;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N11) {
        var carry = 0;
        for (var i2 = 0; i2 < N11 / 2; i2++) {
          var w3 = Math.round(ws2[2 * i2 + 1] / N11) * 8192 + Math.round(ws2[2 * i2] / N11) + carry;
          ws2[i2] = w3 & 67108863;
          if (w3 < 67108864) {
            carry = 0;
          } else {
            carry = w3 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N11) {
        var carry = 0;
        for (var i2 = 0; i2 < len; i2++) {
          carry = carry + (ws2[i2] | 0);
          rws[2 * i2] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i2 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i2 = 2 * len; i2 < N11; ++i2) {
          rws[i2] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N11) {
        var ph2 = new Array(N11);
        for (var i2 = 0; i2 < N11; i2++) {
          ph2[i2] = 0;
        }
        return ph2;
      };
      FFTM.prototype.mulp = function mulp(x3, y2, out) {
        var N11 = 2 * this.guessLen13b(x3.length, y2.length);
        var rbt = this.makeRBT(N11);
        var _3 = this.stub(N11);
        var rws = new Array(N11);
        var rwst = new Array(N11);
        var iwst = new Array(N11);
        var nrws = new Array(N11);
        var nrwst = new Array(N11);
        var niwst = new Array(N11);
        var rmws = out.words;
        rmws.length = N11;
        this.convert13b(x3.words, x3.length, rws, N11);
        this.convert13b(y2.words, y2.length, nrws, N11);
        this.transform(rws, _3, rwst, iwst, N11, rbt);
        this.transform(nrws, _3, nrwst, niwst, N11, rbt);
        for (var i2 = 0; i2 < N11; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
          rwst[i2] = rx;
        }
        this.conjugate(rwst, iwst, N11);
        this.transform(rwst, iwst, rmws, _3, N11, rbt);
        this.conjugate(rmws, _3, N11);
        this.normalize13b(rmws, N11);
        out.negative = x3.negative ^ y2.negative;
        out.length = x3.length + y2.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w3 = (this.words[i2] | 0) * num;
          var lo2 = (w3 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w3 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i2] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w3 = toBitArray(num);
        if (w3.length === 0) return new BN(1);
        var res = this;
        for (var i2 = 0; i2 < w3.length; i2++, res = res.sqr()) {
          if (w3[i2] !== 0) break;
        }
        if (++i2 < w3.length) {
          for (var q2 = res.sqr(); i2 < w3.length; i2++, q2 = q2.sqr()) {
            if (w3[i2] === 0) continue;
            res = res.mul(q2);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i2;
        if (r2 !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c2 = (this.words[i2] | 0) - newCarry << r2;
            this.words[i2] = c2 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s2] = this.words[i2];
          }
          for (i2 = 0; i2 < s2; i2++) {
            this.words[i2] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h2;
        if (hint) {
          h2 = (hint - hint % 26) / 26;
        } else {
          h2 = 0;
        }
        var r2 = bits % 26;
        var s2 = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h2 -= s2;
        h2 = Math.max(0, h2);
        if (maskedWords) {
          for (var i2 = 0; i2 < s2; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s2) return false;
        var w3 = this.words[s2];
        return !!(w3 & q2);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r2 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i2;
        this._expand(len);
        var w3;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w3 = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w3 -= right & 67108863;
          carry = (w3 >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w3 & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w3 = (this.words[i2 + shift] | 0) + carry;
          carry = w3 >> 26;
          this.words[i2 + shift] = w3 & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w3 = -(this.words[i2] | 0) + carry;
          carry = w3 >> 26;
          this.words[i2] = w3 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a2 = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a2.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m2 = a2.length - b2.length;
        var q2;
        if (mode !== "mod") {
          q2 = new BN(null);
          q2.length = m2 + 1;
          q2.words = new Array(q2.length);
          for (var i2 = 0; i2 < q2.length; i2++) {
            q2.words[i2] = 0;
          }
        }
        var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
        if (diff.negative === 0) {
          a2 = diff;
          if (q2) {
            q2.words[m2] = 1;
          }
        }
        for (var j2 = m2 - 1; j2 >= 0; j2--) {
          var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a2._ishlnsubmul(b2, qj, j2);
          while (a2.negative !== 0) {
            qj--;
            a2.negative = 0;
            a2._ishlnsubmul(b2, 1, j2);
            if (!a2.isZero()) {
              a2.negative ^= 1;
            }
          }
          if (q2) {
            q2.words[j2] = qj;
          }
        }
        if (q2) {
          q2.strip();
        }
        a2.strip();
        if (mode !== "div" && shift !== 0) {
          a2.iushrn(shift);
        }
        return {
          div: q2 || null,
          mod: a2
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm2 = this.divmod(num);
        if (dm2.mod.isZero()) return dm2.div;
        var mod2 = dm2.div.negative !== 0 ? dm2.mod.isub(num) : dm2.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm2.div;
        return dm2.div.negative !== 0 ? dm2.div.isubn(1) : dm2.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p2 = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w3 = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w3 / num | 0;
          carry = w3 % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p2) {
        assert(p2.negative === 0);
        assert(!p2.isZero());
        var x3 = this;
        var y2 = p2.clone();
        if (x3.negative !== 0) {
          x3 = x3.umod(p2);
        } else {
          x3 = x3.clone();
        }
        var A2 = new BN(1);
        var B3 = new BN(0);
        var C3 = new BN(0);
        var D2 = new BN(1);
        var g2 = 0;
        while (x3.isEven() && y2.isEven()) {
          x3.iushrn(1);
          y2.iushrn(1);
          ++g2;
        }
        var yp2 = y2.clone();
        var xp2 = x3.clone();
        while (!x3.isZero()) {
          for (var i2 = 0, im2 = 1; (x3.words[0] & im2) === 0 && i2 < 26; ++i2, im2 <<= 1) ;
          if (i2 > 0) {
            x3.iushrn(i2);
            while (i2-- > 0) {
              if (A2.isOdd() || B3.isOdd()) {
                A2.iadd(yp2);
                B3.isub(xp2);
              }
              A2.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j2 = 0, jm2 = 1; (y2.words[0] & jm2) === 0 && j2 < 26; ++j2, jm2 <<= 1) ;
          if (j2 > 0) {
            y2.iushrn(j2);
            while (j2-- > 0) {
              if (C3.isOdd() || D2.isOdd()) {
                C3.iadd(yp2);
                D2.isub(xp2);
              }
              C3.iushrn(1);
              D2.iushrn(1);
            }
          }
          if (x3.cmp(y2) >= 0) {
            x3.isub(y2);
            A2.isub(C3);
            B3.isub(D2);
          } else {
            y2.isub(x3);
            C3.isub(A2);
            D2.isub(B3);
          }
        }
        return {
          a: C3,
          b: D2,
          gcd: y2.iushln(g2)
        };
      };
      BN.prototype._invmp = function _invmp(p2) {
        assert(p2.negative === 0);
        assert(!p2.isZero());
        var a2 = this;
        var b2 = p2.clone();
        if (a2.negative !== 0) {
          a2 = a2.umod(p2);
        } else {
          a2 = a2.clone();
        }
        var x12 = new BN(1);
        var x22 = new BN(0);
        var delta = b2.clone();
        while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i2 = 0, im2 = 1; (a2.words[0] & im2) === 0 && i2 < 26; ++i2, im2 <<= 1) ;
          if (i2 > 0) {
            a2.iushrn(i2);
            while (i2-- > 0) {
              if (x12.isOdd()) {
                x12.iadd(delta);
              }
              x12.iushrn(1);
            }
          }
          for (var j2 = 0, jm2 = 1; (b2.words[0] & jm2) === 0 && j2 < 26; ++j2, jm2 <<= 1) ;
          if (j2 > 0) {
            b2.iushrn(j2);
            while (j2-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a2.cmp(b2) >= 0) {
            a2.isub(b2);
            x12.isub(x22);
          } else {
            b2.isub(a2);
            x22.isub(x12);
          }
        }
        var res;
        if (a2.cmpn(1) === 0) {
          res = x12;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p2);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a2 = this.clone();
        var b2 = num.clone();
        a2.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
          a2.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a2.isEven()) {
            a2.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r2 = a2.cmp(b2);
          if (r2 < 0) {
            var t2 = a2;
            a2 = b2;
            b2 = t2;
          } else if (r2 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a2.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q2 = 1 << r2;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q2;
          return this;
        }
        var carry = q2;
        for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
          var w3 = this.words[i2] | 0;
          w3 += carry;
          carry = w3 >>> 26;
          w3 &= 67108863;
          this.words[i2] = w3;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w3 = this.words[0] | 0;
          res = w3 === num ? 0 : w3 < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a2 = this.words[i2] | 0;
          var b2 = num.words[i2] | 0;
          if (a2 === b2) continue;
          if (a2 < b2) {
            res = -1;
          } else if (a2 > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt2(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt2(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p2) {
        this.name = name2;
        this.p = new BN(p2, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output.words[i2] = input.words[i2];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10; i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i2 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w3 = num.words[i2] | 0;
          lo2 += w3 * 977;
          num.words[i2] = lo2 & 67108863;
          lo2 = w3 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi2 = (num.words[i2] | 0) * 19 + carry;
          var lo2 = hi2 & 67108863;
          hi2 >>>= 26;
          num.words[i2] = lo2;
          carry = hi2;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name2) {
        if (primes[name2]) return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN._prime(m2);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m2.gtn(1), "modulus must be greater than 1");
          this.m = m2;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a2) {
        assert(a2.negative === 0, "red works only with positives");
        assert(a2.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a2, b2) {
        assert((a2.negative | b2.negative) === 0, "red works only with positives");
        assert(
          a2.red && a2.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a2) {
        if (this.prime) return this.prime.ireduce(a2)._forceRed(this);
        return a2.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a2) {
        if (a2.isZero()) {
          return a2.clone();
        }
        return this.m.sub(a2)._forceRed(this);
      };
      Red.prototype.add = function add(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a2, num) {
        this._verify1(a2);
        return this.imod(a2.ushln(num));
      };
      Red.prototype.imul = function imul(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.imul(b2));
      };
      Red.prototype.mul = function mul(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.mul(b2));
      };
      Red.prototype.isqr = function isqr(a2) {
        return this.imul(a2, a2.clone());
      };
      Red.prototype.sqr = function sqr(a2) {
        return this.mul(a2, a2);
      };
      Red.prototype.sqrt = function sqrt(a2) {
        if (a2.isZero()) return a2.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a2, pow);
        }
        var q2 = this.m.subn(1);
        var s2 = 0;
        while (!q2.isZero() && q2.andln(1) === 0) {
          s2++;
          q2.iushrn(1);
        }
        assert(!q2.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z3 = this.m.bitLength();
        z3 = new BN(2 * z3 * z3).toRed(this);
        while (this.pow(z3, lpow).cmp(nOne) !== 0) {
          z3.redIAdd(nOne);
        }
        var c2 = this.pow(z3, q2);
        var r2 = this.pow(a2, q2.addn(1).iushrn(1));
        var t2 = this.pow(a2, q2);
        var m2 = s2;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert(i2 < m2);
          var b2 = this.pow(c2, new BN(1).iushln(m2 - i2 - 1));
          r2 = r2.redMul(b2);
          c2 = b2.redSqr();
          t2 = t2.redMul(c2);
          m2 = i2;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a2) {
        var inv = a2._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a2, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a2.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a2;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a2);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j2 = start - 1; j2 >= 0; j2--) {
            var bit = word >> j2 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        Red.call(this, m2);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a2, b2) {
        if (a2.isZero() || b2.isZero()) {
          a2.words[0] = 0;
          a2.length = 1;
          return a2;
        }
        var t2 = a2.imul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a2, b2) {
        if (a2.isZero() || b2.isZero()) return new BN(0)._forceRed(this);
        var t2 = a2.mul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a2) {
        var res = this.imod(a2._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// ../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e2, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s2 = buffer[offset + i2];
      i2 += d2;
      e2 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
      }
      m2 = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e2, m2, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m2 = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e2)) < 1) {
          e2--;
          c2 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e2++;
          c2 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m2 = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m2 = (value * c2 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
      }
      buffer[offset + i2 - d2] |= s2 * 128;
    };
  }
});

// ../../node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "../../node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer4;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e2) {
        return false;
      }
    }
    Object.defineProperty(Buffer4.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer4.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer4.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer4.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer2(length2) {
      if (length2 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length2);
      Object.setPrototypeOf(buf, Buffer4.prototype);
      return buf;
    }
    function Buffer4(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe2(arg);
      }
      return from3(arg, encodingOrOffset, length2);
    }
    Buffer4.poolSize = 8192;
    function from3(value, encodingOrOffset, length2) {
      if (typeof value === "string") {
        return fromString3(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer4.from(valueOf, encodingOrOffset, length2);
      }
      const b2 = fromObject(value);
      if (b2) return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer4.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer4.from = function(value, encodingOrOffset, length2) {
      return from3(value, encodingOrOffset, length2);
    };
    Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer4, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer2(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer2(size).fill(fill, encoding) : createBuffer2(size).fill(fill);
      }
      return createBuffer2(size);
    }
    Buffer4.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe2(size) {
      assertSize(size);
      return createBuffer2(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer4.allocUnsafe = function(size) {
      return allocUnsafe2(size);
    };
    Buffer4.allocUnsafeSlow = function(size) {
      return allocUnsafe2(size);
    };
    function fromString3(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer4.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length2 = byteLength(string2, encoding) | 0;
      let buf = createBuffer2(length2);
      const actual = buf.write(string2, encoding);
      if (actual !== length2) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer2(length2);
      for (let i2 = 0; i2 < length2; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length2) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length2 === void 0) {
        buf = new Uint8Array(array);
      } else if (length2 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length2);
      }
      Object.setPrototypeOf(buf, Buffer4.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer4.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer2(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer2(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length2) {
      if (length2 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length2 | 0;
    }
    function SlowBuffer(length2) {
      if (+length2 != length2) {
        length2 = 0;
      }
      return Buffer4.alloc(+length2);
    }
    Buffer4.isBuffer = function isBuffer2(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer4.prototype;
    };
    Buffer4.compare = function compare(a2, b2) {
      if (isInstance(a2, Uint8Array)) a2 = Buffer4.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b2, Uint8Array)) b2 = Buffer4.from(b2, b2.offset, b2.byteLength);
      if (!Buffer4.isBuffer(a2) || !Buffer4.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b2) return 0;
      let x3 = a2.length;
      let y2 = b2.length;
      for (let i2 = 0, len = Math.min(x3, y2); i2 < len; ++i2) {
        if (a2[i2] !== b2[i2]) {
          x3 = a2[i2];
          y2 = b2[i2];
          break;
        }
      }
      if (x3 < y2) return -1;
      if (y2 < x3) return 1;
      return 0;
    };
    Buffer4.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer4.concat = function concat2(list, length2) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer4.alloc(0);
      }
      let i2;
      if (length2 === void 0) {
        length2 = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length2 += list[i2].length;
        }
      }
      const buffer = Buffer4.allocUnsafe(length2);
      let pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        let buf = list[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer4.isBuffer(buf)) buf = Buffer4.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer4.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string2, encoding) {
      if (Buffer4.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      const len = string2.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer4.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer4.prototype._isBuffer = true;
    function swap(b2, n2, m2) {
      const i2 = b2[n2];
      b2[n2] = b2[m2];
      b2[m2] = i2;
    }
    Buffer4.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer4.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer4.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer4.prototype.toString = function toString5() {
      const length2 = this.length;
      if (length2 === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length2);
      return slowToString.apply(this, arguments);
    };
    Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
    Buffer4.prototype.equals = function equals4(b2) {
      if (!Buffer4.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
      if (this === b2) return true;
      return Buffer4.compare(this, b2) === 0;
    };
    Buffer4.prototype.inspect = function inspect() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;
    }
    Buffer4.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer4.from(target, target.offset, target.byteLength);
      }
      if (!Buffer4.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x3 = thisEnd - thisStart;
      let y2 = end - start;
      const len = Math.min(x3, y2);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x3 = thisCopy[i2];
          y2 = targetCopy[i2];
          break;
        }
      }
      if (x3 < y2) return -1;
      if (y2 < x3) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer4.from(val, encoding);
      }
      if (Buffer4.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      let i2;
      if (dir) {
        let foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          let found = true;
          for (let j2 = 0; j2 < valLength; j2++) {
            if (read2(arr, i2 + j2) !== read2(val, j2)) {
              found = false;
              break;
            }
          }
          if (found) return i2;
        }
      }
      return -1;
    }
    Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string2, offset, length2) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length2) {
        length2 = remaining;
      } else {
        length2 = Number(length2);
        if (length2 > remaining) {
          length2 = remaining;
        }
      }
      const strLen = string2.length;
      if (length2 > strLen / 2) {
        length2 = strLen / 2;
      }
      let i2;
      for (i2 = 0; i2 < length2; ++i2) {
        const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string2, offset, length2) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length2);
    }
    function asciiWrite(buf, string2, offset, length2) {
      return blitBuffer(asciiToBytes(string2), buf, offset, length2);
    }
    function base64Write(buf, string2, offset, length2) {
      return blitBuffer(base64ToBytes(string2), buf, offset, length2);
    }
    function ucs2Write(buf, string2, offset, length2) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length2);
    }
    Buffer4.prototype.write = function write(string2, offset, length2, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length2 = this.length;
        offset = 0;
      } else if (length2 === void 0 && typeof offset === "string") {
        encoding = offset;
        length2 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length2)) {
          length2 = length2 >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length2;
          length2 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length2 === void 0 || length2 > remaining) length2 = remaining;
      if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length2);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length2);
          case "base64":
            return base64Write(this, string2, offset, length2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length2);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer4.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base642.fromByteArray(buf);
      } else {
        return base642.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i2 = start;
      while (i2 < end) {
        const firstByte = buf[i2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    Buffer4.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer4.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length2) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length2) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    };
    Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer4.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo2 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo2) + (BigInt(hi2) << BigInt(32));
    });
    Buffer4.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi2) << BigInt(32)) + BigInt(lo2);
    });
    Buffer4.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer4.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i2 = byteLength2;
      let mul = 1;
      let val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer4.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer4.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer4.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer4.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer4.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer4.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer4.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer4.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer4.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer4.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer4.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer4.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo2 = Number(value & BigInt(4294967295));
      buf[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf[offset++] = lo2;
      lo2 = lo2 >> 8;
      buf[offset++] = lo2;
      let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo2 = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo2;
      lo2 = lo2 >> 8;
      buf[offset + 6] = lo2;
      lo2 = lo2 >> 8;
      buf[offset + 5] = lo2;
      lo2 = lo2 >> 8;
      buf[offset + 4] = lo2;
      let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi2;
      hi2 = hi2 >> 8;
      buf[offset + 2] = hi2;
      hi2 = hi2 >> 8;
      buf[offset + 1] = hi2;
      hi2 = hi2 >> 8;
      buf[offset] = hi2;
      return offset + 8;
    }
    Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer4.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer4.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer4.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer4.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer4.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer4.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        const bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    };
    var errors = {};
    function E3(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E3(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name2) {
        if (name2) {
          return `${name2} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E3(
      "ERR_INVALID_ARG_TYPE",
      function(name2, actual) {
        return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E3(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n2 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n2} and < 2${n2} ** ${(byteLength2 + 1) * 8}${n2}`;
          } else {
            range = `>= -(2${n2} ** ${(byteLength2 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n2}`;
          }
        } else {
          range = `>= ${min}${n2} and <= ${max}${n2}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length2, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length2 < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length2}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string2, units) {
      units = units || Infinity;
      let codePoint;
      const length2 = string2.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i2 = 0; i2 < length2; ++i2) {
        codePoint = string2.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length2) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c2, hi2, lo2;
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0) break;
        c2 = str.charCodeAt(i2);
        hi2 = c2 >> 8;
        lo2 = c2 % 256;
        byteArray.push(lo2);
        byteArray.push(hi2);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length2) {
      let i2;
      for (i2 = 0; i2 < length2; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src2.length) break;
        dst[i2 + offset] = src2[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet2 = "0123456789abcdef";
      const table = new Array(256);
      for (let i2 = 0; i2 < 16; ++i2) {
        const i16 = i2 * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet2[i2] + alphabet2[j2];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn2) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1/base/reporter.js
var require_reporter = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1/base/reporter.js"(exports2) {
    "use strict";
    var inherits2 = require_inherits_browser();
    function Reporter(options) {
      this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
      };
    }
    exports2.Reporter = Reporter;
    Reporter.prototype.isError = function isError(obj) {
      return obj instanceof ReporterError;
    };
    Reporter.prototype.save = function save() {
      const state = this._reporterState;
      return { obj: state.obj, pathLen: state.path.length };
    };
    Reporter.prototype.restore = function restore2(data) {
      const state = this._reporterState;
      state.obj = data.obj;
      state.path = state.path.slice(0, data.pathLen);
    };
    Reporter.prototype.enterKey = function enterKey(key) {
      return this._reporterState.path.push(key);
    };
    Reporter.prototype.exitKey = function exitKey(index) {
      const state = this._reporterState;
      state.path = state.path.slice(0, index - 1);
    };
    Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
      const state = this._reporterState;
      this.exitKey(index);
      if (state.obj !== null)
        state.obj[key] = value;
    };
    Reporter.prototype.path = function path() {
      return this._reporterState.path.join("/");
    };
    Reporter.prototype.enterObject = function enterObject() {
      const state = this._reporterState;
      const prev = state.obj;
      state.obj = {};
      return prev;
    };
    Reporter.prototype.leaveObject = function leaveObject(prev) {
      const state = this._reporterState;
      const now = state.obj;
      state.obj = prev;
      return now;
    };
    Reporter.prototype.error = function error(msg) {
      let err;
      const state = this._reporterState;
      const inherited = msg instanceof ReporterError;
      if (inherited) {
        err = msg;
      } else {
        err = new ReporterError(state.path.map(function(elem) {
          return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
      }
      if (!state.options.partial)
        throw err;
      if (!inherited)
        state.errors.push(err);
      return err;
    };
    Reporter.prototype.wrapResult = function wrapResult(result) {
      const state = this._reporterState;
      if (!state.options.partial)
        return result;
      return {
        result: this.isError(result) ? null : result,
        errors: state.errors
      };
    };
    function ReporterError(path, msg) {
      this.path = path;
      this.rethrow(msg);
    }
    inherits2(ReporterError, Error);
    ReporterError.prototype.rethrow = function rethrow(msg) {
      this.message = msg + " at: " + (this.path || "(shallow)");
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ReporterError);
      if (!this.stack) {
        try {
          throw new Error(this.message);
        } catch (e2) {
          this.stack = e2.stack;
        }
      }
      return this;
    };
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1/base/buffer.js
var require_buffer3 = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1/base/buffer.js"(exports2) {
    "use strict";
    var inherits2 = require_inherits_browser();
    var Reporter = require_reporter().Reporter;
    var Buffer4 = require_buffer2().Buffer;
    function DecoderBuffer(base3, options) {
      Reporter.call(this, options);
      if (!Buffer4.isBuffer(base3)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = base3;
      this.offset = 0;
      this.length = base3.length;
    }
    inherits2(DecoderBuffer, Reporter);
    exports2.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.prototype.save = function save() {
      return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
    };
    DecoderBuffer.prototype.restore = function restore2(save) {
      const res = new DecoderBuffer(this.base);
      res.offset = save.offset;
      res.length = this.offset;
      this.offset = save.offset;
      Reporter.prototype.restore.call(this, save.reporter);
      return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
      if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
      else
        return this.error(fail || "DecoderBuffer overrun");
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
      if (!(this.offset + bytes <= this.length))
        return this.error(fail || "DecoderBuffer overrun");
      const res = new DecoderBuffer(this.base);
      res._reporterState = this._reporterState;
      res.offset = this.offset;
      res.length = this.offset + bytes;
      this.offset += bytes;
      return res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter) {
      if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
          if (!(item instanceof EncoderBuffer))
            item = new EncoderBuffer(item, reporter);
          this.length += item.length;
          return item;
        }, this);
      } else if (typeof value === "number") {
        if (!(0 <= value && value <= 255))
          return reporter.error("non-byte EncoderBuffer value");
        this.value = value;
        this.length = 1;
      } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer4.byteLength(value);
      } else if (Buffer4.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
      } else {
        return reporter.error("Unsupported type: " + typeof value);
      }
    }
    exports2.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.prototype.join = function join(out, offset) {
      if (!out)
        out = new Buffer4(this.length);
      if (!offset)
        offset = 0;
      if (this.length === 0)
        return out;
      if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
          item.join(out, offset);
          offset += item.length;
        });
      } else {
        if (typeof this.value === "number")
          out[offset] = this.value;
        else if (typeof this.value === "string")
          out.write(this.value, offset);
        else if (Buffer4.isBuffer(this.value))
          this.value.copy(out, offset);
        offset += this.length;
      }
      return out;
    };
  }
});

// ../../node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "../../node_modules/minimalistic-assert/index.js"(exports2, module2) {
    module2.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l2, r2, msg) {
      if (l2 != r2)
        throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
    };
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1/base/node.js
var require_node = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1/base/node.js"(exports2, module2) {
    "use strict";
    var Reporter = require_reporter().Reporter;
    var EncoderBuffer = require_buffer3().EncoderBuffer;
    var DecoderBuffer = require_buffer3().DecoderBuffer;
    var assert = require_minimalistic_assert();
    var tags = [
      "seq",
      "seqof",
      "set",
      "setof",
      "objid",
      "bool",
      "gentime",
      "utctime",
      "null_",
      "enum",
      "int",
      "objDesc",
      "bitstr",
      "bmpstr",
      "charstr",
      "genstr",
      "graphstr",
      "ia5str",
      "iso646str",
      "numstr",
      "octstr",
      "printstr",
      "t61str",
      "unistr",
      "utf8str",
      "videostr"
    ];
    var methods = [
      "key",
      "obj",
      "use",
      "optional",
      "explicit",
      "implicit",
      "def",
      "choice",
      "any",
      "contains"
    ].concat(tags);
    var overrided = [
      "_peekTag",
      "_decodeTag",
      "_use",
      "_decodeStr",
      "_decodeObjid",
      "_decodeTime",
      "_decodeNull",
      "_decodeInt",
      "_decodeBool",
      "_decodeList",
      "_encodeComposite",
      "_encodeStr",
      "_encodeObjid",
      "_encodeTime",
      "_encodeNull",
      "_encodeInt",
      "_encodeBool"
    ];
    function Node(enc, parent) {
      const state = {};
      this._baseState = state;
      state.enc = enc;
      state.parent = parent || null;
      state.children = null;
      state.tag = null;
      state.args = null;
      state.reverseArgs = null;
      state.choice = null;
      state.optional = false;
      state.any = false;
      state.obj = false;
      state.use = null;
      state.useDecoder = null;
      state.key = null;
      state["default"] = null;
      state.explicit = null;
      state.implicit = null;
      state.contains = null;
      if (!state.parent) {
        state.children = [];
        this._wrap();
      }
    }
    module2.exports = Node;
    var stateProps = [
      "enc",
      "parent",
      "children",
      "tag",
      "args",
      "reverseArgs",
      "choice",
      "optional",
      "any",
      "obj",
      "use",
      "alteredUse",
      "key",
      "default",
      "explicit",
      "implicit",
      "contains"
    ];
    Node.prototype.clone = function clone() {
      const state = this._baseState;
      const cstate = {};
      stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
      });
      const res = new this.constructor(cstate.parent);
      res._baseState = cstate;
      return res;
    };
    Node.prototype._wrap = function wrap() {
      const state = this._baseState;
      methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
          const clone = new this.constructor(this);
          state.children.push(clone);
          return clone[method].apply(clone, arguments);
        };
      }, this);
    };
    Node.prototype._init = function init(body) {
      const state = this._baseState;
      assert(state.parent === null);
      body.call(this);
      state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
      }, this);
      assert.equal(state.children.length, 1, "Root node can have only one child");
    };
    Node.prototype._useArgs = function useArgs(args) {
      const state = this._baseState;
      const children = args.filter(function(arg) {
        return arg instanceof this.constructor;
      }, this);
      args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
      }, this);
      if (children.length !== 0) {
        assert(state.children === null);
        state.children = children;
        children.forEach(function(child) {
          child._baseState.parent = this;
        }, this);
      }
      if (args.length !== 0) {
        assert(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function(arg) {
          if (typeof arg !== "object" || arg.constructor !== Object)
            return arg;
          const res = {};
          Object.keys(arg).forEach(function(key) {
            if (key == (key | 0))
              key |= 0;
            const value = arg[key];
            res[value] = key;
          });
          return res;
        });
      }
    };
    overrided.forEach(function(method) {
      Node.prototype[method] = function _overrided() {
        const state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
      };
    });
    tags.forEach(function(tag) {
      Node.prototype[tag] = function _tagMethod() {
        const state = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert(state.tag === null);
        state.tag = tag;
        this._useArgs(args);
        return this;
      };
    });
    Node.prototype.use = function use(item) {
      assert(item);
      const state = this._baseState;
      assert(state.use === null);
      state.use = item;
      return this;
    };
    Node.prototype.optional = function optional() {
      const state = this._baseState;
      state.optional = true;
      return this;
    };
    Node.prototype.def = function def(val) {
      const state = this._baseState;
      assert(state["default"] === null);
      state["default"] = val;
      state.optional = true;
      return this;
    };
    Node.prototype.explicit = function explicit(num) {
      const state = this._baseState;
      assert(state.explicit === null && state.implicit === null);
      state.explicit = num;
      return this;
    };
    Node.prototype.implicit = function implicit(num) {
      const state = this._baseState;
      assert(state.explicit === null && state.implicit === null);
      state.implicit = num;
      return this;
    };
    Node.prototype.obj = function obj() {
      const state = this._baseState;
      const args = Array.prototype.slice.call(arguments);
      state.obj = true;
      if (args.length !== 0)
        this._useArgs(args);
      return this;
    };
    Node.prototype.key = function key(newKey) {
      const state = this._baseState;
      assert(state.key === null);
      state.key = newKey;
      return this;
    };
    Node.prototype.any = function any() {
      const state = this._baseState;
      state.any = true;
      return this;
    };
    Node.prototype.choice = function choice(obj) {
      const state = this._baseState;
      assert(state.choice === null);
      state.choice = obj;
      this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
      }));
      return this;
    };
    Node.prototype.contains = function contains(item) {
      const state = this._baseState;
      assert(state.use === null);
      state.contains = item;
      return this;
    };
    Node.prototype._decode = function decode8(input, options) {
      const state = this._baseState;
      if (state.parent === null)
        return input.wrapResult(state.children[0]._decode(input, options));
      let result = state["default"];
      let present = true;
      let prevKey = null;
      if (state.key !== null)
        prevKey = input.enterKey(state.key);
      if (state.optional) {
        let tag = null;
        if (state.explicit !== null)
          tag = state.explicit;
        else if (state.implicit !== null)
          tag = state.implicit;
        else if (state.tag !== null)
          tag = state.tag;
        if (tag === null && !state.any) {
          const save = input.save();
          try {
            if (state.choice === null)
              this._decodeGeneric(state.tag, input, options);
            else
              this._decodeChoice(input, options);
            present = true;
          } catch (e2) {
            present = false;
          }
          input.restore(save);
        } else {
          present = this._peekTag(input, tag, state.any);
          if (input.isError(present))
            return present;
        }
      }
      let prevObj;
      if (state.obj && present)
        prevObj = input.enterObject();
      if (present) {
        if (state.explicit !== null) {
          const explicit = this._decodeTag(input, state.explicit);
          if (input.isError(explicit))
            return explicit;
          input = explicit;
        }
        const start = input.offset;
        if (state.use === null && state.choice === null) {
          let save;
          if (state.any)
            save = input.save();
          const body = this._decodeTag(
            input,
            state.implicit !== null ? state.implicit : state.tag,
            state.any
          );
          if (input.isError(body))
            return body;
          if (state.any)
            result = input.raw(save);
          else
            input = body;
        }
        if (options && options.track && state.tag !== null)
          options.track(input.path(), start, input.length, "tagged");
        if (options && options.track && state.tag !== null)
          options.track(input.path(), input.offset, input.length, "content");
        if (state.any) {
        } else if (state.choice === null) {
          result = this._decodeGeneric(state.tag, input, options);
        } else {
          result = this._decodeChoice(input, options);
        }
        if (input.isError(result))
          return result;
        if (!state.any && state.choice === null && state.children !== null) {
          state.children.forEach(function decodeChildren(child) {
            child._decode(input, options);
          });
        }
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
          const data = new DecoderBuffer(result);
          result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
      }
      if (state.obj && present)
        result = input.leaveObject(prevObj);
      if (state.key !== null && (result !== null || present === true))
        input.leaveKey(prevKey, state.key, result);
      else if (prevKey !== null)
        input.exitKey(prevKey);
      return result;
    };
    Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
      const state = this._baseState;
      if (tag === "seq" || tag === "set")
        return null;
      if (tag === "seqof" || tag === "setof")
        return this._decodeList(input, tag, state.args[0], options);
      else if (/str$/.test(tag))
        return this._decodeStr(input, tag, options);
      else if (tag === "objid" && state.args)
        return this._decodeObjid(input, state.args[0], state.args[1], options);
      else if (tag === "objid")
        return this._decodeObjid(input, null, null, options);
      else if (tag === "gentime" || tag === "utctime")
        return this._decodeTime(input, tag, options);
      else if (tag === "null_")
        return this._decodeNull(input, options);
      else if (tag === "bool")
        return this._decodeBool(input, options);
      else if (tag === "objDesc")
        return this._decodeStr(input, tag, options);
      else if (tag === "int" || tag === "enum")
        return this._decodeInt(input, state.args && state.args[0], options);
      if (state.use !== null) {
        return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
      } else {
        return input.error("unknown tag: " + tag);
      }
    };
    Node.prototype._getUse = function _getUse(entity, obj) {
      const state = this._baseState;
      state.useDecoder = this._use(entity, obj);
      assert(state.useDecoder._baseState.parent === null);
      state.useDecoder = state.useDecoder._baseState.children[0];
      if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
      }
      return state.useDecoder;
    };
    Node.prototype._decodeChoice = function decodeChoice(input, options) {
      const state = this._baseState;
      let result = null;
      let match = false;
      Object.keys(state.choice).some(function(key) {
        const save = input.save();
        const node = state.choice[key];
        try {
          const value = node._decode(input, options);
          if (input.isError(value))
            return false;
          result = { type: key, value };
          match = true;
        } catch (e2) {
          input.restore(save);
          return false;
        }
        return true;
      }, this);
      if (!match)
        return input.error("Choice not matched");
      return result;
    };
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
      return new EncoderBuffer(data, this.reporter);
    };
    Node.prototype._encode = function encode9(data, reporter, parent) {
      const state = this._baseState;
      if (state["default"] !== null && state["default"] === data)
        return;
      const result = this._encodeValue(data, reporter, parent);
      if (result === void 0)
        return;
      if (this._skipDefault(result, reporter, parent))
        return;
      return result;
    };
    Node.prototype._encodeValue = function encode9(data, reporter, parent) {
      const state = this._baseState;
      if (state.parent === null)
        return state.children[0]._encode(data, reporter || new Reporter());
      let result = null;
      this.reporter = reporter;
      if (state.optional && data === void 0) {
        if (state["default"] !== null)
          data = state["default"];
        else
          return;
      }
      let content = null;
      let primitive = false;
      if (state.any) {
        result = this._createEncoderBuffer(data);
      } else if (state.choice) {
        result = this._encodeChoice(data, reporter);
      } else if (state.contains) {
        content = this._getUse(state.contains, parent)._encode(data, reporter);
        primitive = true;
      } else if (state.children) {
        content = state.children.map(function(child) {
          if (child._baseState.tag === "null_")
            return child._encode(null, reporter, data);
          if (child._baseState.key === null)
            return reporter.error("Child should have a key");
          const prevKey = reporter.enterKey(child._baseState.key);
          if (typeof data !== "object")
            return reporter.error("Child expected, but input is not object");
          const res = child._encode(data[child._baseState.key], reporter, data);
          reporter.leaveKey(prevKey);
          return res;
        }, this).filter(function(child) {
          return child;
        });
        content = this._createEncoderBuffer(content);
      } else {
        if (state.tag === "seqof" || state.tag === "setof") {
          if (!(state.args && state.args.length === 1))
            return reporter.error("Too many args for : " + state.tag);
          if (!Array.isArray(data))
            return reporter.error("seqof/setof, but data is not Array");
          const child = this.clone();
          child._baseState.implicit = null;
          content = this._createEncoderBuffer(data.map(function(item) {
            const state2 = this._baseState;
            return this._getUse(state2.args[0], data)._encode(item, reporter);
          }, child));
        } else if (state.use !== null) {
          result = this._getUse(state.use, parent)._encode(data, reporter);
        } else {
          content = this._encodePrimitive(state.tag, data);
          primitive = true;
        }
      }
      if (!state.any && state.choice === null) {
        const tag = state.implicit !== null ? state.implicit : state.tag;
        const cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
          if (state.use === null)
            reporter.error("Tag could be omitted only for .use()");
        } else {
          if (state.use === null)
            result = this._encodeComposite(tag, primitive, cls, content);
        }
      }
      if (state.explicit !== null)
        result = this._encodeComposite(state.explicit, false, "context", result);
      return result;
    };
    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
      const state = this._baseState;
      const node = state.choice[data.type];
      if (!node) {
        assert(
          false,
          data.type + " not found in " + JSON.stringify(Object.keys(state.choice))
        );
      }
      return node._encode(data.value, reporter);
    };
    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
      const state = this._baseState;
      if (/str$/.test(tag))
        return this._encodeStr(data, tag);
      else if (tag === "objid" && state.args)
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
      else if (tag === "objid")
        return this._encodeObjid(data, null, null);
      else if (tag === "gentime" || tag === "utctime")
        return this._encodeTime(data, tag);
      else if (tag === "null_")
        return this._encodeNull();
      else if (tag === "int" || tag === "enum")
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
      else if (tag === "bool")
        return this._encodeBool(data);
      else if (tag === "objDesc")
        return this._encodeStr(data, tag);
      else
        throw new Error("Unsupported tag: " + tag);
    };
    Node.prototype._isNumstr = function isNumstr(str) {
      return /^[0-9 ]*$/.test(str);
    };
    Node.prototype._isPrintstr = function isPrintstr(str) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
    };
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1/constants/der.js
var require_der = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1/constants/der.js"(exports2) {
    "use strict";
    function reverse(map) {
      const res = {};
      Object.keys(map).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        const value = map[key];
        res[value] = key;
      });
      return res;
    }
    exports2.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    };
    exports2.tagClassByName = reverse(exports2.tagClass);
    exports2.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    };
    exports2.tagByName = reverse(exports2.tag);
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1/encoders/der.js
var require_der2 = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1/encoders/der.js"(exports2, module2) {
    "use strict";
    var inherits2 = require_inherits_browser();
    var Buffer4 = require_buffer2().Buffer;
    var Node = require_node();
    var der = require_der();
    function DEREncoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module2.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode9(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
      Node.call(this, "der", parent);
    }
    inherits2(DERNode, Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
      const encodedTag = encodeTag(tag, primitive, cls, this.reporter);
      if (content.length < 128) {
        const header2 = new Buffer4(2);
        header2[0] = encodedTag;
        header2[1] = content.length;
        return this._createEncoderBuffer([header2, content]);
      }
      let lenOctets = 1;
      for (let i2 = content.length; i2 >= 256; i2 >>= 8)
        lenOctets++;
      const header = new Buffer4(1 + 1 + lenOctets);
      header[0] = encodedTag;
      header[1] = 128 | lenOctets;
      for (let i2 = 1 + lenOctets, j2 = content.length; j2 > 0; i2--, j2 >>= 8)
        header[i2] = j2 & 255;
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === "bitstr") {
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      } else if (tag === "bmpstr") {
        const buf = new Buffer4(str.length * 2);
        for (let i2 = 0; i2 < str.length; i2++) {
          buf.writeUInt16BE(str.charCodeAt(i2), i2 * 2);
        }
        return this._createEncoderBuffer(buf);
      } else if (tag === "numstr") {
        if (!this._isNumstr(str)) {
          return this.reporter.error("Encoding of string type: numstr supports only digits and space");
        }
        return this._createEncoderBuffer(str);
      } else if (tag === "printstr") {
        if (!this._isPrintstr(str)) {
          return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
        }
        return this._createEncoderBuffer(str);
      } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
      } else if (tag === "objDesc") {
        return this._createEncoderBuffer(str);
      } else {
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id2, values, relative) {
      if (typeof id2 === "string") {
        if (!values)
          return this.reporter.error("string objid given, but no values map found");
        if (!values.hasOwnProperty(id2))
          return this.reporter.error("objid not found in values map");
        id2 = values[id2].split(/[\s.]+/g);
        for (let i2 = 0; i2 < id2.length; i2++)
          id2[i2] |= 0;
      } else if (Array.isArray(id2)) {
        id2 = id2.slice();
        for (let i2 = 0; i2 < id2.length; i2++)
          id2[i2] |= 0;
      }
      if (!Array.isArray(id2)) {
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id2));
      }
      if (!relative) {
        if (id2[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        id2.splice(0, 2, id2[0] * 40 + id2[1]);
      }
      let size = 0;
      for (let i2 = 0; i2 < id2.length; i2++) {
        let ident = id2[i2];
        for (size++; ident >= 128; ident >>= 7)
          size++;
      }
      const objid = new Buffer4(size);
      let offset = objid.length - 1;
      for (let i2 = id2.length - 1; i2 >= 0; i2--) {
        let ident = id2[i2];
        objid[offset--] = ident & 127;
        while ((ident >>= 7) > 0)
          objid[offset--] = 128 | ident & 127;
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num) {
      if (num < 10)
        return "0" + num;
      else
        return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      let str;
      const date = new Date(time);
      if (tag === "gentime") {
        str = [
          two(date.getUTCFullYear()),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else if (tag === "utctime") {
        str = [
          two(date.getUTCFullYear() % 100),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else {
        this.reporter.error("Encoding " + tag + " time is not supported yet");
      }
      return this._encodeStr(str, "octstr");
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer("");
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === "string") {
        if (!values)
          return this.reporter.error("String int or enum given, but no values map");
        if (!values.hasOwnProperty(num)) {
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        }
        num = values[num];
      }
      if (typeof num !== "number" && !Buffer4.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 128) {
          numArray.unshift(0);
        }
        num = new Buffer4(numArray);
      }
      if (Buffer4.isBuffer(num)) {
        let size2 = num.length;
        if (num.length === 0)
          size2++;
        const out2 = new Buffer4(size2);
        num.copy(out2);
        if (num.length === 0)
          out2[0] = 0;
        return this._createEncoderBuffer(out2);
      }
      if (num < 128)
        return this._createEncoderBuffer(num);
      if (num < 256)
        return this._createEncoderBuffer([0, num]);
      let size = 1;
      for (let i2 = num; i2 >= 256; i2 >>= 8)
        size++;
      const out = new Array(size);
      for (let i2 = out.length - 1; i2 >= 0; i2--) {
        out[i2] = num & 255;
        num >>= 8;
      }
      if (out[0] & 128) {
        out.unshift(0);
      }
      return this._createEncoderBuffer(new Buffer4(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
      return this._createEncoderBuffer(value ? 255 : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getEncoder("der").tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
      const state = this._baseState;
      let i2;
      if (state["default"] === null)
        return false;
      const data = dataBuffer.join();
      if (state.defaultBuffer === void 0)
        state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
      if (data.length !== state.defaultBuffer.length)
        return false;
      for (i2 = 0; i2 < data.length; i2++)
        if (data[i2] !== state.defaultBuffer[i2])
          return false;
      return true;
    };
    function encodeTag(tag, primitive, cls, reporter) {
      let res;
      if (tag === "seqof")
        tag = "seq";
      else if (tag === "setof")
        tag = "set";
      if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
      else if (typeof tag === "number" && (tag | 0) === tag)
        res = tag;
      else
        return reporter.error("Unknown tag: " + tag);
      if (res >= 31)
        return reporter.error("Multi-octet tag encoding unsupported");
      if (!primitive)
        res |= 32;
      res |= der.tagClassByName[cls || "universal"] << 6;
      return res;
    }
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1/encoders/pem.js
var require_pem = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1/encoders/pem.js"(exports2, module2) {
    "use strict";
    var inherits2 = require_inherits_browser();
    var DEREncoder = require_der2();
    function PEMEncoder(entity) {
      DEREncoder.call(this, entity);
      this.enc = "pem";
    }
    inherits2(PEMEncoder, DEREncoder);
    module2.exports = PEMEncoder;
    PEMEncoder.prototype.encode = function encode9(data, options) {
      const buf = DEREncoder.prototype.encode.call(this, data);
      const p2 = buf.toString("base64");
      const out = ["-----BEGIN " + options.label + "-----"];
      for (let i2 = 0; i2 < p2.length; i2 += 64)
        out.push(p2.slice(i2, i2 + 64));
      out.push("-----END " + options.label + "-----");
      return out.join("\n");
    };
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1/encoders/index.js
var require_encoders = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1/encoders/index.js"(exports2) {
    "use strict";
    var encoders = exports2;
    encoders.der = require_der2();
    encoders.pem = require_pem();
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1/decoders/der.js
var require_der3 = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1/decoders/der.js"(exports2, module2) {
    "use strict";
    var inherits2 = require_inherits_browser();
    var bignum = require_bn();
    var DecoderBuffer = require_buffer3().DecoderBuffer;
    var Node = require_node();
    var der = require_der();
    function DERDecoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module2.exports = DERDecoder;
    DERDecoder.prototype.decode = function decode8(data, options) {
      if (!(data instanceof DecoderBuffer))
        data = new DecoderBuffer(data, options);
      return this.tree._decode(data, options);
    };
    function DERNode(parent) {
      Node.call(this, "der", parent);
    }
    inherits2(DERNode, Node);
    DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
      if (buffer.isEmpty())
        return false;
      const state = buffer.save();
      const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
      if (buffer.isError(decodedTag))
        return decodedTag;
      buffer.restore(state);
      return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
    };
    DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
      const decodedTag = derDecodeTag(
        buffer,
        'Failed to decode tag of "' + tag + '"'
      );
      if (buffer.isError(decodedTag))
        return decodedTag;
      let len = derDecodeLen(
        buffer,
        decodedTag.primitive,
        'Failed to get length of "' + tag + '"'
      );
      if (buffer.isError(len))
        return len;
      if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
        return buffer.error('Failed to match tag: "' + tag + '"');
      }
      if (decodedTag.primitive || len !== null)
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
      const state = buffer.save();
      const res = this._skipUntilEnd(
        buffer,
        'Failed to skip indefinite length body: "' + this.tag + '"'
      );
      if (buffer.isError(res))
        return res;
      len = buffer.offset - state.offset;
      buffer.restore(state);
      return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    };
    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
      for (; ; ) {
        const tag = derDecodeTag(buffer, fail);
        if (buffer.isError(tag))
          return tag;
        const len = derDecodeLen(buffer, tag.primitive, fail);
        if (buffer.isError(len))
          return len;
        let res;
        if (tag.primitive || len !== null)
          res = buffer.skip(len);
        else
          res = this._skipUntilEnd(buffer, fail);
        if (buffer.isError(res))
          return res;
        if (tag.tagStr === "end")
          break;
      }
    };
    DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
      const result = [];
      while (!buffer.isEmpty()) {
        const possibleEnd = this._peekTag(buffer, "end");
        if (buffer.isError(possibleEnd))
          return possibleEnd;
        const res = decoder.decode(buffer, "der", options);
        if (buffer.isError(res) && possibleEnd)
          break;
        result.push(res);
      }
      return result;
    };
    DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
      if (tag === "bitstr") {
        const unused = buffer.readUInt8();
        if (buffer.isError(unused))
          return unused;
        return { unused, data: buffer.raw() };
      } else if (tag === "bmpstr") {
        const raw = buffer.raw();
        if (raw.length % 2 === 1)
          return buffer.error("Decoding of string type: bmpstr length mismatch");
        let str = "";
        for (let i2 = 0; i2 < raw.length / 2; i2++) {
          str += String.fromCharCode(raw.readUInt16BE(i2 * 2));
        }
        return str;
      } else if (tag === "numstr") {
        const numstr = buffer.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
          return buffer.error("Decoding of string type: numstr unsupported characters");
        }
        return numstr;
      } else if (tag === "octstr") {
        return buffer.raw();
      } else if (tag === "objDesc") {
        return buffer.raw();
      } else if (tag === "printstr") {
        const printstr = buffer.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
          return buffer.error("Decoding of string type: printstr unsupported characters");
        }
        return printstr;
      } else if (/str$/.test(tag)) {
        return buffer.raw().toString();
      } else {
        return buffer.error("Decoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
      let result;
      const identifiers = [];
      let ident = 0;
      let subident = 0;
      while (!buffer.isEmpty()) {
        subident = buffer.readUInt8();
        ident <<= 7;
        ident |= subident & 127;
        if ((subident & 128) === 0) {
          identifiers.push(ident);
          ident = 0;
        }
      }
      if (subident & 128)
        identifiers.push(ident);
      const first = identifiers[0] / 40 | 0;
      const second = identifiers[0] % 40;
      if (relative)
        result = identifiers;
      else
        result = [first, second].concat(identifiers.slice(1));
      if (values) {
        let tmp = values[result.join(" ")];
        if (tmp === void 0)
          tmp = values[result.join(".")];
        if (tmp !== void 0)
          result = tmp;
      }
      return result;
    };
    DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
      const str = buffer.raw().toString();
      let year;
      let mon;
      let day;
      let hour;
      let min;
      let sec;
      if (tag === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
      } else if (tag === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70)
          year = 2e3 + year;
        else
          year = 1900 + year;
      } else {
        return buffer.error("Decoding " + tag + " time is not supported yet");
      }
      return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    };
    DERNode.prototype._decodeNull = function decodeNull() {
      return null;
    };
    DERNode.prototype._decodeBool = function decodeBool(buffer) {
      const res = buffer.readUInt8();
      if (buffer.isError(res))
        return res;
      else
        return res !== 0;
    };
    DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
      const raw = buffer.raw();
      let res = new bignum(raw);
      if (values)
        res = values[res.toString(10)] || res;
      return res;
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getDecoder("der").tree;
    };
    function derDecodeTag(buf, fail) {
      let tag = buf.readUInt8(fail);
      if (buf.isError(tag))
        return tag;
      const cls = der.tagClass[tag >> 6];
      const primitive = (tag & 32) === 0;
      if ((tag & 31) === 31) {
        let oct = tag;
        tag = 0;
        while ((oct & 128) === 128) {
          oct = buf.readUInt8(fail);
          if (buf.isError(oct))
            return oct;
          tag <<= 7;
          tag |= oct & 127;
        }
      } else {
        tag &= 31;
      }
      const tagStr = der.tag[tag];
      return {
        cls,
        primitive,
        tag,
        tagStr
      };
    }
    function derDecodeLen(buf, primitive, fail) {
      let len = buf.readUInt8(fail);
      if (buf.isError(len))
        return len;
      if (!primitive && len === 128)
        return null;
      if ((len & 128) === 0) {
        return len;
      }
      const num = len & 127;
      if (num > 4)
        return buf.error("length octect is too long");
      len = 0;
      for (let i2 = 0; i2 < num; i2++) {
        len <<= 8;
        const j2 = buf.readUInt8(fail);
        if (buf.isError(j2))
          return j2;
        len |= j2;
      }
      return len;
    }
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1/decoders/pem.js
var require_pem2 = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1/decoders/pem.js"(exports2, module2) {
    "use strict";
    var inherits2 = require_inherits_browser();
    var Buffer4 = require_buffer2().Buffer;
    var DERDecoder = require_der3();
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity);
      this.enc = "pem";
    }
    inherits2(PEMDecoder, DERDecoder);
    module2.exports = PEMDecoder;
    PEMDecoder.prototype.decode = function decode8(data, options) {
      const lines = data.toString().split(/[\r\n]+/g);
      const label = options.label.toUpperCase();
      const re = /^-----(BEGIN|END) ([^-]+)-----$/;
      let start = -1;
      let end = -1;
      for (let i2 = 0; i2 < lines.length; i2++) {
        const match = lines[i2].match(re);
        if (match === null)
          continue;
        if (match[2] !== label)
          continue;
        if (start === -1) {
          if (match[1] !== "BEGIN")
            break;
          start = i2;
        } else {
          if (match[1] !== "END")
            break;
          end = i2;
          break;
        }
      }
      if (start === -1 || end === -1)
        throw new Error("PEM section not found for: " + label);
      const base642 = lines.slice(start + 1, end).join("");
      base642.replace(/[^a-z0-9+/=]+/gi, "");
      const input = new Buffer4(base642, "base64");
      return DERDecoder.prototype.decode.call(this, input, options);
    };
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1/decoders/index.js
var require_decoders = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1/decoders/index.js"(exports2) {
    "use strict";
    var decoders = exports2;
    decoders.der = require_der3();
    decoders.pem = require_pem2();
  }
});

// browser-external:vm
var require_vm = __commonJS({
  "browser-external:vm"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "vm" has been externalized for browser compatibility. Cannot access "vm.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1/api.js
var require_api = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1/api.js"(exports2) {
    "use strict";
    var encoders = require_encoders();
    var decoders = require_decoders();
    var inherits2 = require_inherits_browser();
    var api = exports2;
    api.define = function define3(name2, body) {
      return new Entity(name2, body);
    };
    function Entity(name2, body) {
      this.name = name2;
      this.body = body;
      this.decoders = {};
      this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(base3) {
      let named;
      try {
        named = require_vm().runInThisContext(
          "(function " + this.name + "(entity) {\n  this._initNamed(entity);\n})"
        );
      } catch (e2) {
        named = function(entity) {
          this._initNamed(entity);
        };
      }
      inherits2(named, base3);
      named.prototype._initNamed = function initnamed(entity) {
        base3.call(this, entity);
      };
      return new named(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
      enc = enc || "der";
      if (!this.decoders.hasOwnProperty(enc))
        this.decoders[enc] = this._createNamed(decoders[enc]);
      return this.decoders[enc];
    };
    Entity.prototype.decode = function decode8(data, enc, options) {
      return this._getDecoder(enc).decode(data, options);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
      enc = enc || "der";
      if (!this.encoders.hasOwnProperty(enc))
        this.encoders[enc] = this._createNamed(encoders[enc]);
      return this.encoders[enc];
    };
    Entity.prototype.encode = function encode9(data, enc, reporter) {
      return this._getEncoder(enc).encode(data, reporter);
    };
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1/base/index.js
var require_base = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1/base/index.js"(exports2) {
    "use strict";
    var base3 = exports2;
    base3.Reporter = require_reporter().Reporter;
    base3.DecoderBuffer = require_buffer3().DecoderBuffer;
    base3.EncoderBuffer = require_buffer3().EncoderBuffer;
    base3.Node = require_node();
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1/constants/index.js
var require_constants = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1/constants/index.js"(exports2) {
    "use strict";
    var constants = exports2;
    constants._reverse = function reverse(map) {
      const res = {};
      Object.keys(map).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        const value = map[key];
        res[value] = key;
      });
      return res;
    };
    constants.der = require_der();
  }
});

// ../../node_modules/@lordvlad/asn1.js/lib/asn1.js
var require_asn1 = __commonJS({
  "../../node_modules/@lordvlad/asn1.js/lib/asn1.js"(exports2) {
    "use strict";
    var asn12 = exports2;
    asn12.bignum = require_bn();
    asn12.define = require_api().define;
    asn12.base = require_base();
    asn12.constants = require_constants();
    asn12.decoders = require_decoders();
    asn12.encoders = require_encoders();
  }
});

// ../../node_modules/crypto-key-composer/node_modules/buffer/index.js
var require_buffer4 = __commonJS({
  "../../node_modules/crypto-key-composer/node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer4;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e2) {
        return false;
      }
    }
    Object.defineProperty(Buffer4.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer4.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer4.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer4.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer2(length2) {
      if (length2 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length2);
      Object.setPrototypeOf(buf, Buffer4.prototype);
      return buf;
    }
    function Buffer4(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe2(arg);
      }
      return from3(arg, encodingOrOffset, length2);
    }
    Buffer4.poolSize = 8192;
    function from3(value, encodingOrOffset, length2) {
      if (typeof value === "string") {
        return fromString3(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer4.from(valueOf, encodingOrOffset, length2);
      }
      var b2 = fromObject(value);
      if (b2) return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer4.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length2
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer4.from = function(value, encodingOrOffset, length2) {
      return from3(value, encodingOrOffset, length2);
    };
    Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer4, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer2(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer2(size).fill(fill, encoding) : createBuffer2(size).fill(fill);
      }
      return createBuffer2(size);
    }
    Buffer4.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe2(size) {
      assertSize(size);
      return createBuffer2(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer4.allocUnsafe = function(size) {
      return allocUnsafe2(size);
    };
    Buffer4.allocUnsafeSlow = function(size) {
      return allocUnsafe2(size);
    };
    function fromString3(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer4.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length2 = byteLength(string2, encoding) | 0;
      var buf = createBuffer2(length2);
      var actual = buf.write(string2, encoding);
      if (actual !== length2) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer2(length2);
      for (var i2 = 0; i2 < length2; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length2) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length2 === void 0) {
        buf = new Uint8Array(array);
      } else if (length2 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length2);
      }
      Object.setPrototypeOf(buf, Buffer4.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer4.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer2(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer2(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length2) {
      if (length2 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length2 | 0;
    }
    function SlowBuffer(length2) {
      if (+length2 != length2) {
        length2 = 0;
      }
      return Buffer4.alloc(+length2);
    }
    Buffer4.isBuffer = function isBuffer2(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer4.prototype;
    };
    Buffer4.compare = function compare(a2, b2) {
      if (isInstance(a2, Uint8Array)) a2 = Buffer4.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b2, Uint8Array)) b2 = Buffer4.from(b2, b2.offset, b2.byteLength);
      if (!Buffer4.isBuffer(a2) || !Buffer4.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b2) return 0;
      var x3 = a2.length;
      var y2 = b2.length;
      for (var i2 = 0, len = Math.min(x3, y2); i2 < len; ++i2) {
        if (a2[i2] !== b2[i2]) {
          x3 = a2[i2];
          y2 = b2[i2];
          break;
        }
      }
      if (x3 < y2) return -1;
      if (y2 < x3) return 1;
      return 0;
    };
    Buffer4.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer4.concat = function concat2(list, length2) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer4.alloc(0);
      }
      var i2;
      if (length2 === void 0) {
        length2 = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length2 += list[i2].length;
        }
      }
      var buffer = Buffer4.allocUnsafe(length2);
      var pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        var buf = list[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer4.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer4.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string2, encoding) {
      if (Buffer4.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      var len = string2.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer4.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer4.prototype._isBuffer = true;
    function swap(b2, n2, m2) {
      var i2 = b2[n2];
      b2[n2] = b2[m2];
      b2[m2] = i2;
    }
    Buffer4.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer4.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer4.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i2 = 0; i2 < len; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer4.prototype.toString = function toString5() {
      var length2 = this.length;
      if (length2 === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length2);
      return slowToString.apply(this, arguments);
    };
    Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
    Buffer4.prototype.equals = function equals4(b2) {
      if (!Buffer4.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
      if (this === b2) return true;
      return Buffer4.compare(this, b2) === 0;
    };
    Buffer4.prototype.inspect = function inspect() {
      var str = "";
      var max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;
    }
    Buffer4.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer4.from(target, target.offset, target.byteLength);
      }
      if (!Buffer4.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x3 = thisEnd - thisStart;
      var y2 = end - start;
      var len = Math.min(x3, y2);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x3 = thisCopy[i2];
          y2 = targetCopy[i2];
          break;
        }
      }
      if (x3 < y2) return -1;
      if (y2 < x3) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer4.from(val, encoding);
      }
      if (Buffer4.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      var i2;
      if (dir) {
        var foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          var found = true;
          for (var j2 = 0; j2 < valLength; j2++) {
            if (read2(arr, i2 + j2) !== read2(val, j2)) {
              found = false;
              break;
            }
          }
          if (found) return i2;
        }
      }
      return -1;
    }
    Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string2, offset, length2) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length2) {
        length2 = remaining;
      } else {
        length2 = Number(length2);
        if (length2 > remaining) {
          length2 = remaining;
        }
      }
      var strLen = string2.length;
      if (length2 > strLen / 2) {
        length2 = strLen / 2;
      }
      for (var i2 = 0; i2 < length2; ++i2) {
        var parsed = parseInt(string2.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string2, offset, length2) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length2);
    }
    function asciiWrite(buf, string2, offset, length2) {
      return blitBuffer(asciiToBytes(string2), buf, offset, length2);
    }
    function base64Write(buf, string2, offset, length2) {
      return blitBuffer(base64ToBytes(string2), buf, offset, length2);
    }
    function ucs2Write(buf, string2, offset, length2) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length2);
    }
    Buffer4.prototype.write = function write(string2, offset, length2, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length2 = this.length;
        offset = 0;
      } else if (length2 === void 0 && typeof offset === "string") {
        encoding = offset;
        length2 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length2)) {
          length2 = length2 >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length2;
          length2 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length2 === void 0 || length2 > remaining) length2 = remaining;
      if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length2);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length2);
          case "base64":
            return base64Write(this, string2, offset, length2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length2);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer4.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base642.fromByteArray(buf);
      } else {
        return base642.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i2 = start;
      while (i2 < end) {
        var firstByte = buf[i2];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = "";
      for (var i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    Buffer4.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer4.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length2) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length2) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    };
    Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer4.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer4.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var i2 = byteLength2;
      var mul = 1;
      var val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer4.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer4.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer4.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer4.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer4.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer4.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer4.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer4.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer4.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer4.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i2 = byteLength2 - 1;
      var mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer4.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i2 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i2 = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer4.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer4.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer4.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      var i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        var bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string2, units) {
      units = units || Infinity;
      var codePoint;
      var length2 = string2.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i2 = 0; i2 < length2; ++i2) {
        codePoint = string2.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length2) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c2, hi2, lo2;
      var byteArray = [];
      for (var i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0) break;
        c2 = str.charCodeAt(i2);
        hi2 = c2 >> 8;
        lo2 = c2 % 256;
        byteArray.push(lo2);
        byteArray.push(hi2);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length2) {
      for (var i2 = 0; i2 < length2; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src2.length) break;
        dst[i2 + offset] = src2[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet2 = "0123456789abcdef";
      var table = new Array(256);
      for (var i2 = 0; i2 < 16; ++i2) {
        var i16 = i2 * 16;
        for (var j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet2[i2] + alphabet2[j2];
        }
      }
      return table;
    }();
  }
});

// ../../node_modules/crypto-key-composer/es/util/binary.js
var binaryStringToUint8Array, uint8ArrayToBinaryString, hexStringToUint8Array, uint8ArrayToHexString, typedArrayToUint8Array, bnToUint8Array, uint8ArrayToInteger;
var init_binary = __esm({
  "../../node_modules/crypto-key-composer/es/util/binary.js"() {
    binaryStringToUint8Array = (str) => {
      const len = str.length;
      const uint8Array = new Uint8Array(len);
      for (let i2 = 0; i2 < len; i2 += 1) {
        uint8Array[i2] = str.charCodeAt(i2);
      }
      return uint8Array;
    };
    uint8ArrayToBinaryString = (uint8Array) => String.fromCharCode.apply(null, uint8Array);
    hexStringToUint8Array = (str) => new Uint8Array(str.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
    uint8ArrayToHexString = (uint8Array) => Array.prototype.map.call(uint8Array, (x3) => `00${x3.toString(16)}`.slice(-2)).join("");
    typedArrayToUint8Array = (typedArray) => new Uint8Array(typedArray.buffer.slice(typedArray.byteOffset, typedArray.byteOffset + typedArray.byteLength));
    bnToUint8Array = (bn2) => {
      const numArray = bn2.toArray();
      if (!bn2.negative && numArray[0] & 128) {
        numArray.unshift(0);
      }
      return Uint8Array.from(numArray);
    };
    uint8ArrayToInteger = (uint8Array) => {
      if (uint8Array.byteLength > 32) {
        throw new Error("Only 32 byte integers is supported");
      }
      let integer = 0;
      let byteCount = 0;
      do {
        integer = (integer << 8) + uint8Array[byteCount];
        byteCount += 1;
      } while (uint8Array.byteLength > byteCount);
      return integer;
    };
  }
});

// ../../node_modules/es6-error/es6/index.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    cls.apply(this, arguments);
  }
  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }
  return ExtendableBuiltin;
}
var ExtendableError, es6_default;
var init_es6 = __esm({
  "../../node_modules/es6-error/es6/index.js"() {
    ExtendableError = function(_extendableBuiltin2) {
      _inherits(ExtendableError2, _extendableBuiltin2);
      function ExtendableError2() {
        var message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        _classCallCheck(this, ExtendableError2);
        var _this = _possibleConstructorReturn(this, (ExtendableError2.__proto__ || Object.getPrototypeOf(ExtendableError2)).call(this, message));
        Object.defineProperty(_this, "message", {
          configurable: true,
          enumerable: false,
          value: message,
          writable: true
        });
        Object.defineProperty(_this, "name", {
          configurable: true,
          enumerable: false,
          value: _this.constructor.name,
          writable: true
        });
        if (Error.hasOwnProperty("captureStackTrace")) {
          Error.captureStackTrace(_this, _this.constructor);
          return _possibleConstructorReturn(_this);
        }
        Object.defineProperty(_this, "stack", {
          configurable: true,
          enumerable: false,
          value: new Error(message).stack,
          writable: true
        });
        return _this;
      }
      return ExtendableError2;
    }(_extendableBuiltin(Error));
    es6_default = ExtendableError;
  }
});

// ../../node_modules/crypto-key-composer/es/util/errors.js
var BaseError, UnexpectedTypeError, AggregatedError, UnsupportedFormatError, UnsupportedAlgorithmError, MissingPasswordError, DecryptionFailedError, DecodeAsn1FailedError, EncodeAsn1FailedError, DecodePemFailedError, EncodePemFailedError;
var init_errors = __esm({
  "../../node_modules/crypto-key-composer/es/util/errors.js"() {
    init_es6();
    BaseError = class extends es6_default {
      constructor(message, name2, code2, props) {
        super(message);
        this.name = name2 || "BaseError";
        if (code2) {
          this.code = code2;
        }
        Object.assign(this, props);
      }
    };
    UnexpectedTypeError = class extends BaseError {
      constructor(message, props) {
        super(message, "UnexpectedTypeError", "UNEXPECTED_TYPE", props);
      }
    };
    AggregatedError = class extends BaseError {
      constructor(message, errors, props) {
        super(message, "AggregatedError", "AGGREGATED_ERROR", {
          ...props,
          errors
        });
      }
    };
    UnsupportedFormatError = class extends BaseError {
      constructor(format, props) {
        super(`Unsupported format '${format}'`, "UnsupportedFormatError", "UNSUPPORTED_FORMAT", props);
      }
    };
    UnsupportedAlgorithmError = class extends BaseError {
      constructor(message, props) {
        super(message, "UnsupportedAlgorithmError", "UNSUPPORTED_ALGORITHM", props);
      }
    };
    MissingPasswordError = class extends BaseError {
      constructor(message, props) {
        super(message, "MissingPasswordError", "MISSING_PASSWORD", props);
      }
    };
    DecryptionFailedError = class extends BaseError {
      constructor(message, props) {
        super(message, "DecryptionFailedError", "DECRYPTION_FAILED", props);
      }
    };
    DecodeAsn1FailedError = class extends BaseError {
      constructor(message, modelName, props) {
        super(message, "DecodeAsn1FailedError", "DECODE_ASN1_FAILED", {
          ...props,
          modelName
        });
      }
    };
    EncodeAsn1FailedError = class extends BaseError {
      constructor(message, modelName, props) {
        super(message, "EncodeAsn1FailedError", "ENCODE_ASN1_FAILED", {
          ...props,
          modelName
        });
      }
    };
    DecodePemFailedError = class extends BaseError {
      constructor(message, props) {
        super(message, "DecodePemFailedError", "DECODE_PEM_FAILED", props);
      }
    };
    EncodePemFailedError = class extends BaseError {
      constructor(message, props) {
        super(message, "EncodePemFailedError", "ENCODE_PEM_FAILED", props);
      }
    };
  }
});

// ../../node_modules/crypto-key-composer/es/util/asn1-encoder.js
var import_clone_deep, import_asn1, import_buffer, objidValues, define2, decodeAsn1, encodeAsn1;
var init_asn1_encoder = __esm({
  "../../node_modules/crypto-key-composer/es/util/asn1-encoder.js"() {
    init_es();
    import_clone_deep = __toESM(require_clone_deep());
    import_asn1 = __toESM(require_asn1());
    import_buffer = __toESM(require_buffer4());
    init_binary();
    init_errors();
    objidValues = new Proxy({}, {
      get: (obj, key) => {
        if (key === "hasOwnProperty") {
          return (key2) => key2.indexOf(".") > 0;
        }
        return key.indexOf(".") > 0 ? key : void 0;
      }
    });
    define2 = (name2, fn2) => import_asn1.default.define(name2, function() {
      fn2(this);
    });
    decodeAsn1 = (encodedEntity, Model) => {
      let decodedEntity;
      try {
        decodedEntity = Model.decode(import_buffer.Buffer.from(encodedEntity), "der");
      } catch (err) {
        throw new DecodeAsn1FailedError(`Failed to decode ${Model.name}`, Model.name, {
          originalError: err
        });
      }
      const mapValue = (value) => {
        if (ArrayBuffer.isView(value)) {
          return typedArrayToUint8Array(value);
        }
        if (value && value.toArrayLike) {
          return bnToUint8Array(value);
        }
        return value;
      };
      es_default(decodedEntity, (value, key, subject) => {
        subject[key] = mapValue(value);
      });
      return mapValue(decodedEntity);
    };
    encodeAsn1 = (decodedEntity, Model) => {
      const mapValue = (value) => {
        if (value instanceof Uint8Array) {
          return import_buffer.Buffer.from(value);
        }
        return value;
      };
      decodedEntity = (0, import_clone_deep.default)(decodedEntity);
      decodedEntity = mapValue(decodedEntity);
      es_default(decodedEntity, (value, key, subject) => {
        subject[key] = mapValue(value);
      });
      let encodedEntity;
      try {
        encodedEntity = Model.encode(decodedEntity, "der");
      } catch (err) {
        throw new EncodeAsn1FailedError(`Failed to encode ${Model.name}`, Model.name, {
          originalError: err
        });
      }
      return typedArrayToUint8Array(encodedEntity);
    };
  }
});

// ../../node_modules/lodash/constant.js
var require_constant = __commonJS({
  "../../node_modules/lodash/constant.js"(exports2, module2) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module2.exports = constant;
  }
});

// ../../node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "../../node_modules/lodash/_createBaseFor.js"(exports2, module2) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
        while (length2--) {
          var key = props[fromRight ? length2 : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module2.exports = createBaseFor;
  }
});

// ../../node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "../../node_modules/lodash/_baseFor.js"(exports2, module2) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// ../../node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../../node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// ../../node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// ../../node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// ../../node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// ../../node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// ../../node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// ../../node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// ../../node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../../node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// ../../node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// ../../node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../../node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray2 = Array.isArray;
    module2.exports = isArray2;
  }
});

// ../../node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../../node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// ../../node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../../node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer4 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer4 ? Buffer4.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer2;
  }
});

// ../../node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../../node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length2) {
      var type = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    module2.exports = isIndex;
  }
});

// ../../node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../../node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// ../../node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../../node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// ../../node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../../node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// ../../node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../../node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// ../../node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../../node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray2;
  }
});

// ../../node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../../node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray2 = require_isArray();
    var isBuffer2 = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray2 = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// ../../node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../../node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// ../../node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../../node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// ../../node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "../../node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// ../../node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "../../node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// ../../node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject2;
  }
});

// ../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject2 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction2(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction2;
  }
});

// ../../node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction2 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    module2.exports = isArrayLike;
  }
});

// ../../node_modules/lodash/keys.js
var require_keys = __commonJS({
  "../../node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// ../../node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "../../node_modules/lodash/_baseForOwn.js"(exports2, module2) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module2.exports = baseForOwn;
  }
});

// ../../node_modules/lodash/_baseInverter.js
var require_baseInverter = __commonJS({
  "../../node_modules/lodash/_baseInverter.js"(exports2, module2) {
    var baseForOwn = require_baseForOwn();
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object2) {
        setter(accumulator, iteratee(value), key, object2);
      });
      return accumulator;
    }
    module2.exports = baseInverter;
  }
});

// ../../node_modules/lodash/_createInverter.js
var require_createInverter = __commonJS({
  "../../node_modules/lodash/_createInverter.js"(exports2, module2) {
    var baseInverter = require_baseInverter();
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }
    module2.exports = createInverter;
  }
});

// ../../node_modules/lodash/identity.js
var require_identity = __commonJS({
  "../../node_modules/lodash/identity.js"(exports2, module2) {
    function identity3(value) {
      return value;
    }
    module2.exports = identity3;
  }
});

// ../../node_modules/lodash/invert.js
var require_invert = __commonJS({
  "../../node_modules/lodash/invert.js"(exports2, module2) {
    var constant = require_constant();
    var createInverter = require_createInverter();
    var identity3 = require_identity();
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    var invert = createInverter(function(result, value, key) {
      if (value != null && typeof value.toString != "function") {
        value = nativeObjectToString.call(value);
      }
      result[value] = key;
    }, constant(identity3));
    module2.exports = invert;
  }
});

// ../../node_modules/crypto-key-composer/es/util/oids.js
var import_invert, OIDS, FLIPPED_OIDS;
var init_oids = __esm({
  "../../node_modules/crypto-key-composer/es/util/oids.js"() {
    import_invert = __toESM(require_invert());
    OIDS = {
      // RSA
      "1.2.840.113549.1.1.1": "rsa-encryption",
      "1.2.840.113549.1.1.2": "md2-with-rsa-encryption",
      "1.2.840.113549.1.1.3": "md4-with-rsa-encryption",
      "1.2.840.113549.1.1.4": "md5-with-rsa-encryption",
      "1.2.840.113549.1.1.5": "sha1-with-rsa-encryption",
      "1.2.840.113549.1.1.14": "sha224-with-rsa-encryption",
      "1.2.840.113549.1.1.11": "sha256-with-rsa-encryption",
      "1.2.840.113549.1.1.12": "sha384-with-rsa-encryption",
      "1.2.840.113549.1.1.13": "sha512-with-rsa-encryption",
      "1.2.840.113549.1.1.15": "sha512-224-with-rsa-encryption",
      "1.2.840.113549.1.1.16": "sha512-256-with-rsa-encryption",
      "1.2.840.113549.1.1.7": "rsaes-oaep",
      "1.2.840.113549.1.1.10": "rsassa-pss",
      // Ed25519
      "1.3.101.112": "ed25519",
      // EC & its curves
      "1.2.840.10045.2.1": "ec-public-key",
      "1.3.132.1.12": "ec-dh",
      "1.3.132.1.13": "ec-mqv",
      "1.3.132.0.1": "sect163k1",
      "1.3.132.0.2": "sect163r1",
      "1.3.132.0.3": "sect239k1",
      "1.3.132.0.4": "sect113r1",
      "1.3.132.0.5": "sect113r2",
      "1.3.132.0.6": "secp112r1",
      "1.3.132.0.7": "secp112r2",
      "1.3.132.0.8": "secp160r1",
      "1.3.132.0.9": "secp160k1",
      "1.3.132.0.10": "secp256k1",
      "1.3.132.0.15": "sect163r2",
      "1.3.132.0.16": "sect283k1",
      "1.3.132.0.17": "sect283r1",
      "1.3.132.0.22": "sect131r1",
      "1.3.132.0.23": "sect131r2",
      "1.3.132.0.24": "sect193r1",
      "1.3.132.0.25": "sect193r2",
      "1.3.132.0.26": "sect233k1",
      "1.3.132.0.27": "sect233r1",
      "1.3.132.0.28": "secp128r1",
      "1.3.132.0.29": "secp128r2",
      "1.3.132.0.30": "secp160r2",
      "1.3.132.0.31": "secp192k1",
      "1.3.132.0.32": "secp224k1",
      "1.3.132.0.33": "secp224r1",
      "1.3.132.0.34": "secp384r1",
      "1.3.132.0.35": "secp521r1",
      "1.3.132.0.36": "sect409k1",
      "1.3.132.0.37": "sect409r1",
      "1.3.132.0.38": "sect571k1",
      "1.3.132.0.39": "sect571r1",
      "1.2.840.10045.3.1.1": "secp192r1",
      "1.2.840.10045.3.1.7": "secp256r1",
      // PBE related
      "2.16.840.1.101.3.4.1.2": "aes128-cbc",
      "2.16.840.1.101.3.4.1.22": "aes192-cbc",
      "2.16.840.1.101.3.4.1.42": "aes256-cbc",
      "1.2.840.113549.3.2": "rc2-cbc",
      "1.3.14.3.2.7": "des-cbc",
      "1.2.840.113549.3.7": "des-ede3-cbc",
      "1.2.840.113549.1.5.13": "pbes2",
      "1.2.840.113549.1.5.12": "pbkdf2",
      "1.2.840.113549.2.7": "hmac-with-sha1",
      "1.2.840.113549.2.8": "hmac-with-sha224",
      "1.2.840.113549.2.9": "hmac-with-sha256",
      "1.2.840.113549.2.10": "hmac-with-sha384",
      "1.2.840.113549.2.11": "hmac-with-sha512"
    };
    FLIPPED_OIDS = (0, import_invert.default)(OIDS);
  }
});

// ../../node_modules/crypto-key-composer/es/util/asn1-entities.js
var import_buffer2, OtherPrimeInfo, RsaPrivateKey, RsaPublicKey, EcPrivateKey, EcParameters, AlgorithmIdentifier, PrivateKeyInfo, EncryptedPrivateKeyInfo, Pbes2Algorithms, Pbes2EsParams, Pbkdf2Params, Rc2CbcParameter, CurvePrivateKey, SubjectPublicKeyInfo;
var init_asn1_entities = __esm({
  "../../node_modules/crypto-key-composer/es/util/asn1-entities.js"() {
    import_buffer2 = __toESM(require_buffer4());
    init_asn1_encoder();
    init_oids();
    OtherPrimeInfo = define2("OtherPrimeInfo", (asn12) => {
      asn12.seq().obj(asn12.key("prime").int(), asn12.key("exponent").int(), asn12.key("coefficient").int());
    });
    RsaPrivateKey = define2("RSAPrivateKey", (asn12) => {
      asn12.seq().obj(asn12.key("version").int(), asn12.key("modulus").int(), asn12.key("publicExponent").int(), asn12.key("privateExponent").int(), asn12.key("prime1").int(), asn12.key("prime2").int(), asn12.key("exponent1").int(), asn12.key("exponent2").int(), asn12.key("coefficient").int(), asn12.key("otherPrimeInfos").seqof(OtherPrimeInfo).optional());
    });
    RsaPublicKey = define2("RSAPublicKey", (asn12) => {
      asn12.seq().obj(asn12.key("modulus").int(), asn12.key("publicExponent").int());
    });
    EcPrivateKey = define2("ECPrivateKey", (asn12) => {
      asn12.seq().obj(asn12.key("version").int(), asn12.key("privateKey").octstr(), asn12.key("parameters").explicit(0).optional().use(EcParameters), asn12.key("publicKey").explicit(1).optional().bitstr());
    });
    EcParameters = define2("ECParameters", (asn12) => {
      asn12.choice({
        namedCurve: asn12.objid(objidValues)
      });
    });
    AlgorithmIdentifier = define2("AlgorithmIdentifier", (asn12) => {
      asn12.seq().obj(asn12.key("id").objid(objidValues), asn12.key("parameters").optional().any());
    });
    PrivateKeyInfo = define2("PrivateKeyInfo", (asn12) => {
      asn12.seq().obj(asn12.key("version").int(), asn12.key("privateKeyAlgorithm").use(AlgorithmIdentifier), asn12.key("privateKey").octstr(), asn12.key("attributes").implicit(0).optional().any(), asn12.key("publicKey").implicit(1).optional().bitstr());
    });
    EncryptedPrivateKeyInfo = define2("EncryptedPrivateKeyInfo", (asn12) => {
      asn12.seq().obj(asn12.key("encryptionAlgorithm").use(AlgorithmIdentifier), asn12.key("encryptedData").octstr());
    });
    Pbes2Algorithms = define2("PBES2Algorithms", (asn12) => {
      asn12.seq().obj(asn12.key("keyDerivationFunc").use(AlgorithmIdentifier), asn12.key("encryptionScheme").use(AlgorithmIdentifier));
    });
    Pbes2EsParams = {
      "des-cbc": define2("desCBC", (asn12) => asn12.octstr()),
      "des-ede3-cbc": define2("des-EDE3-CBC", (asn12) => asn12.octstr()),
      "aes128-cbc": define2("aes128-CBC", (asn12) => asn12.octstr()),
      "aes192-cbc": define2("aes192-CBC", (asn12) => asn12.octstr()),
      "aes256-cbc": define2("aes256-CBC", (asn12) => asn12.octstr())
    };
    Pbkdf2Params = define2("PBKDF2-params", (asn12) => {
      asn12.seq().obj(asn12.key("salt").choice({
        specified: asn12.octstr(),
        otherSource: asn12.use(AlgorithmIdentifier)
      }), asn12.key("iterationCount").int(), asn12.key("keyLength").int().optional(), asn12.key("prf").use(AlgorithmIdentifier).def({
        id: FLIPPED_OIDS["hmac-with-sha1"],
        parameters: import_buffer2.Buffer.from([5, 0])
      }));
    });
    Rc2CbcParameter = define2("RC2-CBC-Parameter", (asn12) => {
      asn12.seq().obj(asn12.key("rc2ParameterVersion").int().optional(), asn12.key("iv").octstr());
    });
    CurvePrivateKey = define2("CurvePrivateKey", (asn12) => {
      asn12.octstr();
    });
    SubjectPublicKeyInfo = define2("SubjectPublicKeyInfo", (asn12) => {
      asn12.seq().obj(asn12.key("algorithm").use(AlgorithmIdentifier), asn12.key("publicKey").bitstr());
    });
  }
});

// ../../node_modules/crypto-key-composer/es/util/ec.js
var getEcFieldSize, decodeEcPoint, encodeEcPoint, validateEcD;
var init_ec = __esm({
  "../../node_modules/crypto-key-composer/es/util/ec.js"() {
    init_errors();
    getEcFieldSize = (namedCurve) => (
      // Get the the curve's field size in bytes by extracting the number of bits from it and converting it to bytes
      // Note that the number of bits may not be multiples of 8
      Math.floor((Number(namedCurve.match(/\d+/)[0]) + 7) / 8)
    );
    decodeEcPoint = (namedCurve, publicKey) => {
      const fieldSizeBytes = getEcFieldSize(namedCurve);
      if (publicKey[0] !== 4) {
        throw new UnsupportedAlgorithmError("Only uncompressed EC points are supported");
      }
      if (publicKey.length !== fieldSizeBytes * 2 + 1) {
        throw new UnsupportedAlgorithmError(`Expecting EC public key to have length ${fieldSizeBytes * 2 - 1}`);
      }
      return {
        x: publicKey.slice(1, fieldSizeBytes + 1),
        y: publicKey.slice(fieldSizeBytes + 1)
      };
    };
    encodeEcPoint = (namedCurve, x3, y2) => {
      const fieldSizeBytes = getEcFieldSize(namedCurve);
      if (!y2) {
        throw new UnsupportedAlgorithmError("Only uncompressed EC points are supported (y must be specified)");
      }
      if (!x3 || x3.length !== fieldSizeBytes || !y2 || y2.length !== fieldSizeBytes) {
        throw new UnsupportedAlgorithmError(`Expecting x & y points to have length ${fieldSizeBytes} bytes`);
      }
      return new Uint8Array([4, ...x3, ...y2]);
    };
    validateEcD = (namedCurve, d2) => {
      const fieldSizeBytes = getEcFieldSize(namedCurve);
      if (!d2 || d2.length < fieldSizeBytes) {
        throw new UnsupportedAlgorithmError(`Expecting d length to be >= ${fieldSizeBytes} bytes`);
      }
      return d2;
    };
  }
});

// ../../node_modules/crypto-key-composer/es/util/key-types.js
var KEY_TYPES, KEY_ALIASES;
var init_key_types = __esm({
  "../../node_modules/crypto-key-composer/es/util/key-types.js"() {
    KEY_TYPES = {
      // RSA key types
      "rsa-encryption": "rsa",
      "md2-with-rsa-encryption": "rsa",
      "md4-with-rsa-encryption": "rsa",
      "md5-with-rsa-encryption": "rsa",
      "sha1-with-rsa-encryption": "rsa",
      "sha224-with-rsa-encryption": "rsa",
      "sha256-with-rsa-encryption": "rsa",
      "sha384-with-rsa-encryption": "rsa",
      "sha512-with-rsa-encryption": "rsa",
      "sha512-224-with-rsa-encryption": "rsa",
      "sha512-256-with-rsa-encryption": "rsa",
      "rsaes-oaep": "rsa",
      "rsassa-pss": "rsa",
      // EC key types
      "ec-public-key": "ec",
      "ec-dh": "ec",
      "ec-mqv": "ec",
      // ED25519 key types
      ed25519: "ed25519"
    };
    KEY_ALIASES = {
      rsa: {
        id: "rsa-encryption"
      },
      ec: {
        id: "ec-public-key"
      }
    };
  }
});

// ../../node_modules/crypto-key-composer/es/formats/raw/keys.js
var SUPPORTED_KEY_TYPES, decomposeRsaPrivateKey, composeRsaPrivateKey, decomposeRsaPublicKey, composeRsaPublicKey, decomposeEcPrivateKey, composeEcPrivateKey, decomposeRawPrivateKey, composeRawPrivateKey, decomposeRawPublicKey, composeRawPublicKey;
var init_keys = __esm({
  "../../node_modules/crypto-key-composer/es/formats/raw/keys.js"() {
    init_asn1_encoder();
    init_asn1_entities();
    init_ec();
    init_errors();
    init_oids();
    init_key_types();
    SUPPORTED_KEY_TYPES = {
      private: ["rsa", "ec"],
      public: ["rsa"]
    };
    decomposeRsaPrivateKey = (rsaPrivateKeyAsn1) => {
      const {
        version: version2,
        ...keyData
      } = decodeAsn1(rsaPrivateKeyAsn1, RsaPrivateKey);
      return {
        keyAlgorithm: {
          id: "rsa-encryption"
        },
        keyData
      };
    };
    composeRsaPrivateKey = (keyAlgorithm, keyData) => {
      const otherPrimeInfos = keyData.otherPrimeInfos;
      const hasMultiplePrimes = otherPrimeInfos && otherPrimeInfos.length > 0;
      const rsaPrivateKey = {
        ...keyData,
        version: hasMultiplePrimes ? 1 : 0,
        otherPrimeInfos: hasMultiplePrimes ? otherPrimeInfos : void 0
      };
      return encodeAsn1(rsaPrivateKey, RsaPrivateKey);
    };
    decomposeRsaPublicKey = (rsaPublicKeyAsn1) => {
      const {
        version: version2,
        ...keyData
      } = decodeAsn1(rsaPublicKeyAsn1, RsaPublicKey);
      return {
        keyAlgorithm: {
          id: "rsa-encryption"
        },
        keyData
      };
    };
    composeRsaPublicKey = (keyAlgorithm, keyData) => encodeAsn1(keyData, RsaPublicKey);
    decomposeEcPrivateKey = (ecPrivateKeyAsn1) => {
      const ecPrivateKey = decodeAsn1(ecPrivateKeyAsn1, EcPrivateKey);
      if (!ecPrivateKey.parameters) {
        throw new UnsupportedAlgorithmError("Missing parameters from ECPrivateKey");
      }
      if (ecPrivateKey.parameters.type !== "namedCurve") {
        throw new UnsupportedAlgorithmError("Only EC named curves are supported");
      }
      if (!ecPrivateKey.publicKey) {
        throw new UnsupportedAlgorithmError("Missing publicKey from ECPrivateKey");
      }
      const namedCurve = OIDS[ecPrivateKey.parameters.value];
      if (!namedCurve) {
        throw new UnsupportedAlgorithmError(`Unsupported named curve OID '${ecPrivateKey.parameters.value}'`);
      }
      const {
        x: x3,
        y: y2
      } = decodeEcPoint(namedCurve, ecPrivateKey.publicKey.data);
      return {
        keyAlgorithm: {
          id: "ec-public-key",
          namedCurve
        },
        keyData: {
          d: ecPrivateKey.privateKey,
          x: x3,
          y: y2
        }
      };
    };
    composeEcPrivateKey = (keyAlgorithm, keyData) => {
      const namedCurveOid = FLIPPED_OIDS[keyAlgorithm.namedCurve];
      if (!namedCurveOid) {
        throw new UnsupportedAlgorithmError(`Unsupported named curve '${keyAlgorithm.namedCurve}'`);
      }
      const privateKey = validateEcD(keyAlgorithm.namedCurve, keyData.d);
      const publicKey = encodeEcPoint(keyAlgorithm.namedCurve, keyData.x, keyData.y);
      const ecPrivateKey = {
        version: 1,
        privateKey,
        parameters: {
          type: "namedCurve",
          value: namedCurveOid
        },
        publicKey: {
          unused: 0,
          data: publicKey
        }
      };
      return encodeAsn1(ecPrivateKey, EcPrivateKey);
    };
    decomposeRawPrivateKey = (keyType, privateKeyAsn1) => {
      switch (keyType) {
        case "rsa":
          return decomposeRsaPrivateKey(privateKeyAsn1);
        case "ec":
          return decomposeEcPrivateKey(privateKeyAsn1);
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key type '${keyType}'`);
      }
    };
    composeRawPrivateKey = (keyAlgorithm, keyData) => {
      const keyType = KEY_TYPES[keyAlgorithm.id];
      switch (keyType) {
        case "rsa":
          return composeRsaPrivateKey(keyAlgorithm, keyData);
        case "ec":
          return composeEcPrivateKey(keyAlgorithm, keyData);
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key algorithm id '${keyAlgorithm.id}'`);
      }
    };
    decomposeRawPublicKey = (keyType, publicKeyAsn1) => {
      switch (keyType) {
        case "rsa":
          return decomposeRsaPublicKey(publicKeyAsn1);
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key type '${keyType}'`);
      }
    };
    composeRawPublicKey = (keyAlgorithm, keyData) => {
      const keyType = KEY_TYPES[keyAlgorithm.id];
      switch (keyType) {
        case "rsa":
          return composeRsaPublicKey(keyAlgorithm, keyData);
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key algorithm id '${keyAlgorithm.id}'`);
      }
    };
  }
});

// ../../node_modules/crypto-key-composer/es/formats/pkcs1/pkcs1-der.js
var pkcs1_der_exports = {};
__export(pkcs1_der_exports, {
  composePrivateKey: () => composePrivateKey,
  decomposePrivateKey: () => decomposePrivateKey
});
var decomposePrivateKey, composePrivateKey;
var init_pkcs1_der = __esm({
  "../../node_modules/crypto-key-composer/es/formats/pkcs1/pkcs1-der.js"() {
    init_keys();
    init_errors();
    init_key_types();
    decomposePrivateKey = (rsaPrivateKeyAsn1) => {
      let decomposedRsaKey;
      try {
        decomposedRsaKey = decomposeRsaPrivateKey(rsaPrivateKeyAsn1);
      } catch (err) {
        err.invalidInputKey = err instanceof DecodeAsn1FailedError;
        throw err;
      }
      const {
        keyAlgorithm,
        keyData
      } = decomposedRsaKey;
      return {
        format: "pkcs1-der",
        encryptionAlgorithm: null,
        keyAlgorithm,
        keyData
      };
    };
    composePrivateKey = ({
      keyAlgorithm,
      keyData,
      encryptionAlgorithm
    }) => {
      const keyType = KEY_TYPES[keyAlgorithm.id];
      if (keyType !== "rsa") {
        throw new UnsupportedAlgorithmError("The key algorithm id for PKCS1 must be one of RSA's");
      }
      if (encryptionAlgorithm) {
        throw new UnsupportedAlgorithmError("The PKCS1 DER format does not support encryption");
      }
      return composeRsaPrivateKey(keyAlgorithm, keyData);
    };
  }
});

// ../../node_modules/node-forge/lib/forge.js
var require_forge = __commonJS({
  "../../node_modules/node-forge/lib/forge.js"(exports2, module2) {
    module2.exports = {
      // default options
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// ../../node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS({
  "../../node_modules/node-forge/lib/baseN.js"(exports2, module2) {
    var api = {};
    module2.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet2, maxline) {
      if (typeof alphabet2 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet2);
      } else {
        var i2 = 0;
        var base3 = alphabet2.length;
        var first = alphabet2.charAt(0);
        var digits = [0];
        for (i2 = 0; i2 < input.length; ++i2) {
          for (var j2 = 0, carry = input[i2]; j2 < digits.length; ++j2) {
            carry += digits[j2] << 8;
            digits[j2] = carry % base3;
            carry = carry / base3 | 0;
          }
          while (carry > 0) {
            digits.push(carry % base3);
            carry = carry / base3 | 0;
          }
        }
        for (i2 = 0; input[i2] === 0 && i2 < input.length - 1; ++i2) {
          output += first;
        }
        for (i2 = digits.length - 1; i2 >= 0; --i2) {
          output += alphabet2[digits[i2]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet2) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet2 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table = _reverseAlphabets[alphabet2];
      if (!table) {
        table = _reverseAlphabets[alphabet2] = [];
        for (var i2 = 0; i2 < alphabet2.length; ++i2) {
          table[alphabet2.charCodeAt(i2)] = i2;
        }
      }
      input = input.replace(/\s/g, "");
      var base3 = alphabet2.length;
      var first = alphabet2.charAt(0);
      var bytes = [0];
      for (var i2 = 0; i2 < input.length; i2++) {
        var value = table[input.charCodeAt(i2)];
        if (value === void 0) {
          return;
        }
        for (var j2 = 0, carry = value; j2 < bytes.length; ++j2) {
          carry += bytes[j2] * base3;
          bytes[j2] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k2 = 0; input[k2] === first && k2 < input.length - 1; ++k2) {
        bytes.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes.reverse());
      }
      return new Uint8Array(bytes.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet2) {
      var i2 = 0;
      var base3 = alphabet2.length;
      var first = alphabet2.charAt(0);
      var digits = [0];
      for (i2 = 0; i2 < input.length(); ++i2) {
        for (var j2 = 0, carry = input.at(i2); j2 < digits.length; ++j2) {
          carry += digits[j2] << 8;
          digits[j2] = carry % base3;
          carry = carry / base3 | 0;
        }
        while (carry > 0) {
          digits.push(carry % base3);
          carry = carry / base3 | 0;
        }
      }
      var output = "";
      for (i2 = 0; input.at(i2) === 0 && i2 < input.length() - 1; ++i2) {
        output += first;
      }
      for (i2 = digits.length - 1; i2 >= 0; --i2) {
        output += alphabet2[digits[i2]];
      }
      return output;
    }
  }
});

// ../../node_modules/node-forge/lib/util.js
var require_util = __commonJS({
  "../../node_modules/node-forge/lib/util.js"(exports2, module2) {
    var forge = require_forge();
    var baseN = require_baseN();
    var util2 = module2.exports = forge.util = forge.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util2.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util2.setImmediate = setImmediate;
        } else {
          util2.setImmediate = util2.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util2.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util2.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util2.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        var msg = "forge.setImmediate";
        var callbacks = [];
        util2.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util2.setImmediate;
        util2.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util2.nextTick = util2.setImmediate;
    })();
    util2.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util2.globalScope = function() {
      if (util2.isNodejs) {
        return global;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util2.isArray = Array.isArray || function(x3) {
      return Object.prototype.toString.call(x3) === "[object Array]";
    };
    util2.isArrayBuffer = function(x3) {
      return typeof ArrayBuffer !== "undefined" && x3 instanceof ArrayBuffer;
    };
    util2.isArrayBufferView = function(x3) {
      return x3 && util2.isArrayBuffer(x3.buffer) && x3.byteLength !== void 0;
    };
    function _checkBitsParam(n2) {
      if (!(n2 === 8 || n2 === 16 || n2 === 24 || n2 === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n2);
      }
    }
    util2.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b2) {
      this.data = "";
      this.read = 0;
      if (typeof b2 === "string") {
        this.data = b2;
      } else if (util2.isArrayBuffer(b2) || util2.isArrayBufferView(b2)) {
        if (typeof Buffer !== "undefined" && b2 instanceof Buffer) {
          this.data = b2.toString("binary");
        } else {
          var arr = new Uint8Array(b2);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e2) {
            for (var i2 = 0; i2 < arr.length; ++i2) {
              this.putByte(arr[i2]);
            }
          }
        }
      } else if (b2 instanceof ByteStringBuffer || typeof b2 === "object" && typeof b2.data === "string" && typeof b2.read === "number") {
        this.data = b2.data;
        this.read = b2.read;
      }
      this._constructedStringLength = 0;
    }
    util2.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util2.ByteStringBuffer.prototype._optimizeConstructedString = function(x3) {
      this._constructedStringLength += x3;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util2.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util2.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util2.ByteStringBuffer.prototype.putByte = function(b2) {
      return this.putBytes(String.fromCharCode(b2));
    };
    util2.ByteStringBuffer.prototype.fillWithByte = function(b2, n2) {
      b2 = String.fromCharCode(b2);
      var d2 = this.data;
      while (n2 > 0) {
        if (n2 & 1) {
          d2 += b2;
        }
        n2 >>>= 1;
        if (n2 > 0) {
          b2 += b2;
        }
      }
      this.data = d2;
      this._optimizeConstructedString(n2);
      return this;
    };
    util2.ByteStringBuffer.prototype.putBytes = function(bytes) {
      this.data += bytes;
      this._optimizeConstructedString(bytes.length);
      return this;
    };
    util2.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util2.encodeUtf8(str));
    };
    util2.ByteStringBuffer.prototype.putInt16 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt24 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt32 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt16Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt24Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt32Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 24 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt = function(i2, n2) {
      _checkBitsParam(n2);
      var bytes = "";
      do {
        n2 -= 8;
        bytes += String.fromCharCode(i2 >> n2 & 255);
      } while (n2 > 0);
      return this.putBytes(bytes);
    };
    util2.ByteStringBuffer.prototype.putSignedInt = function(i2, n2) {
      if (i2 < 0) {
        i2 += 2 << n2 - 1;
      }
      return this.putInt(i2, n2);
    };
    util2.ByteStringBuffer.prototype.putBuffer = function(buffer) {
      return this.putBytes(buffer.getBytes());
    };
    util2.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util2.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt = function(n2) {
      _checkBitsParam(n2);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n2 -= 8;
      } while (n2 > 0);
      return rval;
    };
    util2.ByteStringBuffer.prototype.getSignedInt = function(n2) {
      var x3 = this.getInt(n2);
      var max = 2 << n2 - 2;
      if (x3 >= max) {
        x3 -= max << 1;
      }
      return x3;
    };
    util2.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util2.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util2.ByteStringBuffer.prototype.at = function(i2) {
      return this.data.charCodeAt(this.read + i2);
    };
    util2.ByteStringBuffer.prototype.setAt = function(i2, b2) {
      this.data = this.data.substr(0, this.read + i2) + String.fromCharCode(b2) + this.data.substr(this.read + i2 + 1);
      return this;
    };
    util2.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util2.ByteStringBuffer.prototype.copy = function() {
      var c2 = util2.createBuffer(this.data);
      c2.read = this.read;
      return c2;
    };
    util2.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util2.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util2.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util2.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.length; ++i2) {
        var b2 = this.data.charCodeAt(i2);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util2.ByteStringBuffer.prototype.toString = function() {
      return util2.decodeUtf8(this.bytes());
    };
    function DataBuffer(b2, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer2 = util2.isArrayBuffer(b2);
      var isArrayBufferView2 = util2.isArrayBufferView(b2);
      if (isArrayBuffer2 || isArrayBufferView2) {
        if (isArrayBuffer2) {
          this.data = new DataView(b2);
        } else {
          this.data = new DataView(b2.buffer, b2.byteOffset, b2.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b2 !== null && b2 !== void 0) {
        this.putBytes(b2);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    util2.DataBuffer = DataBuffer;
    util2.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util2.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util2.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src2 = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src2);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util2.DataBuffer.prototype.putByte = function(b2) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b2);
      return this;
    };
    util2.DataBuffer.prototype.fillWithByte = function(b2, n2) {
      this.accommodate(n2);
      for (var i2 = 0; i2 < n2; ++i2) {
        this.data.setUint8(b2);
      }
      return this;
    };
    util2.DataBuffer.prototype.putBytes = function(bytes, encoding) {
      if (util2.isArrayBufferView(bytes)) {
        var src2 = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        var len = src2.byteLength - src2.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src2);
        this.write += len;
        return this;
      }
      if (util2.isArrayBuffer(bytes)) {
        var src2 = new Uint8Array(bytes);
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src2, this.write);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes instanceof util2.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util2.isArrayBufferView(bytes.data)) {
        var src2 = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(bytes.data.byteLength, this.write);
        dst.set(src2);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes instanceof util2.ByteStringBuffer) {
        bytes = bytes.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.hex.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.base64.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes = util2.encodeUtf8(bytes);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util2.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes);
    };
    util2.DataBuffer.prototype.putBuffer = function(buffer) {
      this.putBytes(buffer);
      buffer.clear();
      return this;
    };
    util2.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util2.DataBuffer.prototype.putInt16 = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2);
      this.write += 2;
      return this;
    };
    util2.DataBuffer.prototype.putInt24 = function(i2) {
      this.accommodate(3);
      this.data.setInt16(this.write, i2 >> 8 & 65535);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.write += 3;
      return this;
    };
    util2.DataBuffer.prototype.putInt32 = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2);
      this.write += 4;
      return this;
    };
    util2.DataBuffer.prototype.putInt16Le = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2, true);
      this.write += 2;
      return this;
    };
    util2.DataBuffer.prototype.putInt24Le = function(i2) {
      this.accommodate(3);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.data.setInt16(this.write, i2 >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util2.DataBuffer.prototype.putInt32Le = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2, true);
      this.write += 4;
      return this;
    };
    util2.DataBuffer.prototype.putInt = function(i2, n2) {
      _checkBitsParam(n2);
      this.accommodate(n2 / 8);
      do {
        n2 -= 8;
        this.data.setInt8(this.write++, i2 >> n2 & 255);
      } while (n2 > 0);
      return this;
    };
    util2.DataBuffer.prototype.putSignedInt = function(i2, n2) {
      _checkBitsParam(n2);
      this.accommodate(n2 / 8);
      if (i2 < 0) {
        i2 += 2 << n2 - 1;
      }
      return this.putInt(i2, n2);
    };
    util2.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util2.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util2.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util2.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util2.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util2.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util2.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util2.DataBuffer.prototype.getInt = function(n2) {
      _checkBitsParam(n2);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n2 -= 8;
      } while (n2 > 0);
      return rval;
    };
    util2.DataBuffer.prototype.getSignedInt = function(n2) {
      var x3 = this.getInt(n2);
      var max = 2 << n2 - 2;
      if (x3 >= max) {
        x3 -= max << 1;
      }
      return x3;
    };
    util2.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util2.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util2.DataBuffer.prototype.at = function(i2) {
      return this.data.getUint8(this.read + i2);
    };
    util2.DataBuffer.prototype.setAt = function(i2, b2) {
      this.data.setUint8(i2, b2);
      return this;
    };
    util2.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util2.DataBuffer.prototype.copy = function() {
      return new util2.DataBuffer(this);
    };
    util2.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src2 = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src2.byteLength);
        dst.set(src2);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util2.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util2.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util2.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.byteLength; ++i2) {
        var b2 = this.data.getUint8(i2);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util2.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util2.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util2.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util2.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util2.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util2.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util2.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util2.encodeUtf8(input);
      }
      return new util2.ByteBuffer(input);
    };
    util2.fillString = function(c2, n2) {
      var s2 = "";
      while (n2 > 0) {
        if (n2 & 1) {
          s2 += c2;
        }
        n2 >>>= 1;
        if (n2 > 0) {
          c2 += c2;
        }
      }
      return s2;
    };
    util2.xorBytes = function(s12, s2, n2) {
      var s3 = "";
      var b2 = "";
      var t2 = "";
      var i2 = 0;
      var c2 = 0;
      for (; n2 > 0; --n2, ++i2) {
        b2 = s12.charCodeAt(i2) ^ s2.charCodeAt(i2);
        if (c2 >= 10) {
          s3 += t2;
          t2 = "";
          c2 = 0;
        }
        t2 += String.fromCharCode(b2);
        ++c2;
      }
      s3 += t2;
      return s3;
    };
    util2.hexToBytes = function(hex) {
      var rval = "";
      var i2 = 0;
      if (hex.length & true) {
        i2 = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i2 < hex.length; i2 += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i2, 2), 16));
      }
      return rval;
    };
    util2.bytesToHex = function(bytes) {
      return util2.createBuffer(bytes).toHex();
    };
    util2.int32ToBytes = function(i2) {
      return String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      /*43 -43 = 0*/
      /*'+',  1,  2,  3,'/' */
      62,
      -1,
      -1,
      -1,
      63,
      /*'0','1','2','3','4','5','6','7','8','9' */
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      /*15, 16, 17,'=', 19, 20, 21 */
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      /*65 - 43 = 22*/
      /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      /*91 - 43 = 48 */
      /*48, 49, 50, 51, 52, 53 */
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      /*97 - 43 = 54*/
      /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util2.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.length) {
        chr1 = input.charCodeAt(i2++);
        chr2 = input.charCodeAt(i2++);
        chr3 = input.charCodeAt(i2++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util2.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i2 = 0;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util2.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util2.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util2.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util2.binary.raw.encode = function(bytes) {
      return String.fromCharCode.apply(null, bytes);
    };
    util2.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j2 = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j2++] = str.charCodeAt(i2);
      }
      return output ? j2 - offset : out;
    };
    util2.binary.hex.encode = util2.bytesToHex;
    util2.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i2 = 0, j2 = offset;
      if (hex.length & 1) {
        i2 = 1;
        out[j2++] = parseInt(hex[0], 16);
      }
      for (; i2 < hex.length; i2 += 2) {
        out[j2++] = parseInt(hex.substr(i2, 2), 16);
      }
      return output ? j2 - offset : out;
    };
    util2.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.byteLength) {
        chr1 = input[i2++];
        chr2 = input[i2++];
        chr3 = input[i2++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util2.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i2 = 0, j2 = offset;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        out[j2++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j2++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j2++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j2 - offset : out.subarray(0, j2);
    };
    util2.binary.base58.encode = function(input, maxline) {
      return util2.binary.baseN.encode(input, _base58, maxline);
    };
    util2.binary.base58.decode = function(input, maxline) {
      return util2.binary.baseN.decode(input, _base58, maxline);
    };
    util2.text = {
      utf8: {},
      utf16: {}
    };
    util2.text.utf8.encode = function(str, output, offset) {
      str = util2.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j2 = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j2++] = str.charCodeAt(i2);
      }
      return output ? j2 - offset : out;
    };
    util2.text.utf8.decode = function(bytes) {
      return util2.decodeUtf8(String.fromCharCode.apply(null, bytes));
    };
    util2.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j2 = offset;
      var k2 = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        view[k2++] = str.charCodeAt(i2);
        j2 += 2;
      }
      return output ? j2 - offset : out;
    };
    util2.text.utf16.decode = function(bytes) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
    };
    util2.deflate = function(api, bytes, raw) {
      bytes = util2.decode64(api.deflate(util2.encode64(bytes)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes = bytes.substring(start, bytes.length - 4);
      }
      return bytes;
    };
    util2.inflate = function(api, bytes, raw) {
      var rval = api.inflate(util2.encode64(bytes)).rval;
      return rval === null ? null : util2.decode64(rval);
    };
    var _setStorageObject = function(api, id2, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id2);
      } else {
        obj = util2.encode64(JSON.stringify(obj));
        rval = api.setItem(id2, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id2) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id2);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util2.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id2, key, data) {
      var obj = _getStorageObject(api, id2);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id2, obj);
    };
    var _getItem = function(api, id2, key) {
      var rval = _getStorageObject(api, id2);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id2, key) {
      var obj = _getStorageObject(api, id2);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty2 = true;
        for (var prop in obj) {
          empty2 = false;
          break;
        }
        if (empty2) {
          obj = null;
        }
        _setStorageObject(api, id2, obj);
      }
    };
    var _clearItems = function(api, id2) {
      _setStorageObject(api, id2, null);
    };
    var _callStorageFunction = function(func, args, location2) {
      var rval = null;
      if (typeof location2 === "undefined") {
        location2 = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location2) {
        type = location2[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util2.setItem = function(api, id2, key, data, location2) {
      _callStorageFunction(_setItem, arguments, location2);
    };
    util2.getItem = function(api, id2, key, location2) {
      return _callStorageFunction(_getItem, arguments, location2);
    };
    util2.removeItem = function(api, id2, key, location2) {
      _callStorageFunction(_removeItem, arguments, location2);
    };
    util2.clearItems = function(api, id2, location2) {
      _callStorageFunction(_clearItems, arguments, location2);
    };
    util2.parseUrl = function(str) {
      var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
      regex.lastIndex = 0;
      var m2 = regex.exec(str);
      var url = m2 === null ? null : {
        full: str,
        scheme: m2[1],
        host: m2[2],
        port: m2[3],
        path: m2[4]
      };
      if (url) {
        url.fullHost = url.host;
        if (url.port) {
          if (url.port !== 80 && url.scheme === "http") {
            url.fullHost += ":" + url.port;
          } else if (url.port !== 443 && url.scheme === "https") {
            url.fullHost += ":" + url.port;
          }
        } else if (url.scheme === "http") {
          url.port = 80;
        } else if (url.scheme === "https") {
          url.port = 443;
        }
        url.full = url.scheme + "://" + url.fullHost;
      }
      return url;
    };
    var _queryVariables = null;
    util2.getQueryVariables = function(query) {
      var parse = function(q2) {
        var rval2 = {};
        var kvpairs = q2.split("&");
        for (var i2 = 0; i2 < kvpairs.length; i2++) {
          var pos = kvpairs[i2].indexOf("=");
          var key;
          var val;
          if (pos > 0) {
            key = kvpairs[i2].substring(0, pos);
            val = kvpairs[i2].substring(pos + 1);
          } else {
            key = kvpairs[i2];
            val = null;
          }
          if (!(key in rval2)) {
            rval2[key] = [];
          }
          if (!(key in Object.prototype) && val !== null) {
            rval2[key].push(unescape(val));
          }
        }
        return rval2;
      };
      var rval;
      if (typeof query === "undefined") {
        if (_queryVariables === null) {
          if (typeof window !== "undefined" && window.location && window.location.search) {
            _queryVariables = parse(window.location.search.substring(1));
          } else {
            _queryVariables = {};
          }
        }
        rval = _queryVariables;
      } else {
        rval = parse(query);
      }
      return rval;
    };
    util2.parseFragment = function(fragment) {
      var fp2 = fragment;
      var fq = "";
      var pos = fragment.indexOf("?");
      if (pos > 0) {
        fp2 = fragment.substring(0, pos);
        fq = fragment.substring(pos + 1);
      }
      var path = fp2.split("/");
      if (path.length > 0 && path[0] === "") {
        path.shift();
      }
      var query = fq === "" ? {} : util2.getQueryVariables(fq);
      return {
        pathString: fp2,
        queryString: fq,
        path,
        query
      };
    };
    util2.makeRequest = function(reqString) {
      var frag = util2.parseFragment(reqString);
      var req = {
        // full path string
        path: frag.pathString,
        // full query string
        query: frag.queryString,
        /**
         * Get path or element in path.
         *
         * @param i optional path index.
         *
         * @return path or part of path if i provided.
         */
        getPath: function(i2) {
          return typeof i2 === "undefined" ? frag.path : frag.path[i2];
        },
        /**
         * Get query, values for a key, or value for a key index.
         *
         * @param k optional query key.
         * @param i optional query key index.
         *
         * @return query, values for a key, or value for a key index.
         */
        getQuery: function(k2, i2) {
          var rval;
          if (typeof k2 === "undefined") {
            rval = frag.query;
          } else {
            rval = frag.query[k2];
            if (rval && typeof i2 !== "undefined") {
              rval = rval[i2];
            }
          }
          return rval;
        },
        getQueryLast: function(k2, _default) {
          var rval;
          var vals = req.getQuery(k2);
          if (vals) {
            rval = vals[vals.length - 1];
          } else {
            rval = _default;
          }
          return rval;
        }
      };
      return req;
    };
    util2.makeLink = function(path, query, fragment) {
      path = jQuery.isArray(path) ? path.join("/") : path;
      var qstr = jQuery.param(query || {});
      fragment = fragment || "";
      return path + (qstr.length > 0 ? "?" + qstr : "") + (fragment.length > 0 ? "#" + fragment : "");
    };
    util2.setPath = function(object, keys, value) {
      if (typeof object === "object" && object !== null) {
        var i2 = 0;
        var len = keys.length;
        while (i2 < len) {
          var next = keys[i2++];
          if (i2 == len) {
            object[next] = value;
          } else {
            var hasNext = next in object;
            if (!hasNext || hasNext && typeof object[next] !== "object" || hasNext && object[next] === null) {
              object[next] = {};
            }
            object = object[next];
          }
        }
      }
    };
    util2.getPath = function(object, keys, _default) {
      var i2 = 0;
      var len = keys.length;
      var hasNext = true;
      while (hasNext && i2 < len && typeof object === "object" && object !== null) {
        var next = keys[i2++];
        hasNext = next in object;
        if (hasNext) {
          object = object[next];
        }
      }
      return hasNext ? object : _default;
    };
    util2.deletePath = function(object, keys) {
      if (typeof object === "object" && object !== null) {
        var i2 = 0;
        var len = keys.length;
        while (i2 < len) {
          var next = keys[i2++];
          if (i2 == len) {
            delete object[next];
          } else {
            if (!(next in object) || typeof object[next] !== "object" || object[next] === null) {
              break;
            }
            object = object[next];
          }
        }
      }
    };
    util2.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util2.format = function(format) {
      var re = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while (match = re.exec(format)) {
        part = format.substring(last, re.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re.lastIndex;
        var code2 = match[0][1];
        switch (code2) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code2 + "?>");
        }
      }
      parts.push(format.substring(last));
      return parts.join("");
    };
    util2.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n2 = number, c2 = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d2 = dec_point === void 0 ? "," : dec_point;
      var t2 = thousands_sep === void 0 ? "." : thousands_sep, s2 = n2 < 0 ? "-" : "";
      var i2 = parseInt(n2 = Math.abs(+n2 || 0).toFixed(c2), 10) + "";
      var j2 = i2.length > 3 ? i2.length % 3 : 0;
      return s2 + (j2 ? i2.substr(0, j2) + t2 : "") + i2.substr(j2).replace(/(\d{3})(?=\d)/g, "$1" + t2) + (c2 ? d2 + Math.abs(n2 - i2).toFixed(c2).slice(2) : "");
    };
    util2.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util2.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util2.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util2.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util2.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util2.bytesFromIP = function(ip2) {
      if (ip2.indexOf(".") !== -1) {
        return util2.bytesFromIPv4(ip2);
      }
      if (ip2.indexOf(":") !== -1) {
        return util2.bytesFromIPv6(ip2);
      }
      return null;
    };
    util2.bytesFromIPv4 = function(ip2) {
      ip2 = ip2.split(".");
      if (ip2.length !== 4) {
        return null;
      }
      var b2 = util2.createBuffer();
      for (var i2 = 0; i2 < ip2.length; ++i2) {
        var num = parseInt(ip2[i2], 10);
        if (isNaN(num)) {
          return null;
        }
        b2.putByte(num);
      }
      return b2.getBytes();
    };
    util2.bytesFromIPv6 = function(ip2) {
      var blanks = 0;
      ip2 = ip2.split(":").filter(function(e2) {
        if (e2.length === 0) ++blanks;
        return true;
      });
      var zeros = (8 - ip2.length + blanks) * 2;
      var b2 = util2.createBuffer();
      for (var i2 = 0; i2 < 8; ++i2) {
        if (!ip2[i2] || ip2[i2].length === 0) {
          b2.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes = util2.hexToBytes(ip2[i2]);
        if (bytes.length < 2) {
          b2.putByte(0);
        }
        b2.putBytes(bytes);
      }
      return b2.getBytes();
    };
    util2.bytesToIP = function(bytes) {
      if (bytes.length === 4) {
        return util2.bytesToIPv4(bytes);
      }
      if (bytes.length === 16) {
        return util2.bytesToIPv6(bytes);
      }
      return null;
    };
    util2.bytesToIPv4 = function(bytes) {
      if (bytes.length !== 4) {
        return null;
      }
      var ip2 = [];
      for (var i2 = 0; i2 < bytes.length; ++i2) {
        ip2.push(bytes.charCodeAt(i2));
      }
      return ip2.join(".");
    };
    util2.bytesToIPv6 = function(bytes) {
      if (bytes.length !== 16) {
        return null;
      }
      var ip2 = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i2 = 0; i2 < bytes.length; i2 += 2) {
        var hex = util2.bytesToHex(bytes[i2] + bytes[i2 + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip2.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last.end = idx;
            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip2.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip2.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip2.unshift("");
          }
          if (group.end === 7) {
            ip2.push("");
          }
        }
      }
      return ip2.join(":");
    };
    util2.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util2 && !options.update) {
        return callback(null, util2.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util2.cores = navigator.hardwareConcurrency;
        return callback(null, util2.cores);
      }
      if (typeof Worker === "undefined") {
        util2.cores = 1;
        return callback(null, util2.cores);
      }
      if (typeof Blob === "undefined") {
        util2.cores = 2;
        return callback(null, util2.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        (function() {
          self.addEventListener("message", function(e2) {
            var st2 = Date.now();
            var et = st2 + 4;
            while (Date.now() < et) ;
            self.postMessage({ st: st2, et });
          });
        }).toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x3) {
            return avg2 + x3;
          }, 0) / max.length);
          util2.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util2.cores);
        }
        map(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e2) {
            results.push(e2.data);
            if (results.length === numWorkers) {
              for (var i3 = 0; i3 < numWorkers; ++i3) {
                workers[i3].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          workers[i2].postMessage(i2);
        }
      }
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n2 = 0; n2 < numWorkers; ++n2) {
          var r12 = results[n2];
          var overlap = overlaps[n2] = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            if (n2 === i2) {
              continue;
            }
            var r2 = results[i2];
            if (r12.st > r2.st && r12.st < r2.et || r2.st > r12.st && r2.st < r12.et) {
              overlap.push(i2);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
  }
});

// ../../node_modules/node-forge/lib/md.js
var require_md2 = __commonJS({
  "../../node_modules/node-forge/lib/md.js"(exports2, module2) {
    var forge = require_forge();
    module2.exports = forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
  }
});

// ../../node_modules/node-forge/lib/sha1.js
var require_sha1 = __commonJS({
  "../../node_modules/node-forge/lib/sha1.js"(exports2, module2) {
    var forge = require_forge();
    require_md2();
    require_util();
    var sha12 = module2.exports = forge.sha1 = forge.sha1 || {};
    forge.md.sha1 = forge.md.algorithms.sha1 = sha12;
    sha12.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w2 = new Array(80);
      var md2 = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength64 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w2, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var next, carry;
        var bits = md2.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md2.fullMessageLength.length - 1; ++i2) {
          next = md2.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w2, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s2, w3, bytes) {
      var t2, a2, b2, c2, d2, e2, f2, i2;
      var len = bytes.length();
      while (len >= 64) {
        a2 = s2.h0;
        b2 = s2.h1;
        c2 = s2.h2;
        d2 = s2.h3;
        e2 = s2.h4;
        for (i2 = 0; i2 < 16; ++i2) {
          t2 = bytes.getInt32();
          w3[i2] = t2;
          f2 = d2 ^ b2 & (c2 ^ d2);
          t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 20; ++i2) {
          t2 = w3[i2 - 3] ^ w3[i2 - 8] ^ w3[i2 - 14] ^ w3[i2 - 16];
          t2 = t2 << 1 | t2 >>> 31;
          w3[i2] = t2;
          f2 = d2 ^ b2 & (c2 ^ d2);
          t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 32; ++i2) {
          t2 = w3[i2 - 3] ^ w3[i2 - 8] ^ w3[i2 - 14] ^ w3[i2 - 16];
          t2 = t2 << 1 | t2 >>> 31;
          w3[i2] = t2;
          f2 = b2 ^ c2 ^ d2;
          t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 40; ++i2) {
          t2 = w3[i2 - 6] ^ w3[i2 - 16] ^ w3[i2 - 28] ^ w3[i2 - 32];
          t2 = t2 << 2 | t2 >>> 30;
          w3[i2] = t2;
          f2 = b2 ^ c2 ^ d2;
          t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 60; ++i2) {
          t2 = w3[i2 - 6] ^ w3[i2 - 16] ^ w3[i2 - 28] ^ w3[i2 - 32];
          t2 = t2 << 2 | t2 >>> 30;
          w3[i2] = t2;
          f2 = b2 & c2 | d2 & (b2 ^ c2);
          t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 2400959708 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 80; ++i2) {
          t2 = w3[i2 - 6] ^ w3[i2 - 16] ^ w3[i2 - 28] ^ w3[i2 - 32];
          t2 = t2 << 2 | t2 >>> 30;
          w3[i2] = t2;
          f2 = b2 ^ c2 ^ d2;
          t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 3395469782 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        s2.h0 = s2.h0 + a2 | 0;
        s2.h1 = s2.h1 + b2 | 0;
        s2.h2 = s2.h2 + c2 | 0;
        s2.h3 = s2.h3 + d2 | 0;
        s2.h4 = s2.h4 + e2 | 0;
        len -= 64;
      }
    }
  }
});

// ../../node_modules/node-forge/lib/sha256.js
var require_sha2562 = __commonJS({
  "../../node_modules/node-forge/lib/sha256.js"(exports2, module2) {
    var forge = require_forge();
    require_md2();
    require_util();
    var sha2563 = module2.exports = forge.sha256 = forge.sha256 || {};
    forge.md.sha256 = forge.md.algorithms.sha256 = sha2563;
    sha2563.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w2 = new Array(64);
      var md2 = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength64 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w2, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var next, carry;
        var bits = md2.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md2.fullMessageLength.length - 1; ++i2) {
          next = md2.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w2, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    function _update(s2, w3, bytes) {
      var t12, t2, s02, s12, ch2, maj, i2, a2, b2, c2, d2, e2, f2, g2, h2;
      var len = bytes.length();
      while (len >= 64) {
        for (i2 = 0; i2 < 16; ++i2) {
          w3[i2] = bytes.getInt32();
        }
        for (; i2 < 64; ++i2) {
          t12 = w3[i2 - 2];
          t12 = (t12 >>> 17 | t12 << 15) ^ (t12 >>> 19 | t12 << 13) ^ t12 >>> 10;
          t2 = w3[i2 - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w3[i2] = t12 + w3[i2 - 7] + t2 + w3[i2 - 16] | 0;
        }
        a2 = s2.h0;
        b2 = s2.h1;
        c2 = s2.h2;
        d2 = s2.h3;
        e2 = s2.h4;
        f2 = s2.h5;
        g2 = s2.h6;
        h2 = s2.h7;
        for (i2 = 0; i2 < 64; ++i2) {
          s12 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
          ch2 = g2 ^ e2 & (f2 ^ g2);
          s02 = (a2 >>> 2 | a2 << 30) ^ (a2 >>> 13 | a2 << 19) ^ (a2 >>> 22 | a2 << 10);
          maj = a2 & b2 | c2 & (a2 ^ b2);
          t12 = h2 + s12 + ch2 + _k[i2] + w3[i2];
          t2 = s02 + maj;
          h2 = g2;
          g2 = f2;
          f2 = e2;
          e2 = d2 + t12 >>> 0;
          d2 = c2;
          c2 = b2;
          b2 = a2;
          a2 = t12 + t2 >>> 0;
        }
        s2.h0 = s2.h0 + a2 | 0;
        s2.h1 = s2.h1 + b2 | 0;
        s2.h2 = s2.h2 + c2 | 0;
        s2.h3 = s2.h3 + d2 | 0;
        s2.h4 = s2.h4 + e2 | 0;
        s2.h5 = s2.h5 + f2 | 0;
        s2.h6 = s2.h6 + g2 | 0;
        s2.h7 = s2.h7 + h2 | 0;
        len -= 64;
      }
    }
  }
});

// ../../node_modules/node-forge/lib/sha512.js
var require_sha5122 = __commonJS({
  "../../node_modules/node-forge/lib/sha512.js"(exports2, module2) {
    var forge = require_forge();
    require_md2();
    require_util();
    var sha5123 = module2.exports = forge.sha512 = forge.sha512 || {};
    forge.md.sha512 = forge.md.algorithms.sha512 = sha5123;
    var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
    sha384.create = function() {
      return sha5123.create("SHA-384");
    };
    forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
    forge.sha512.sha256 = forge.sha512.sha256 || {
      create: function() {
        return sha5123.create("SHA-512/256");
      }
    };
    forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
    forge.sha512.sha224 = forge.sha512.sha224 || {
      create: function() {
        return sha5123.create("SHA-512/224");
      }
    };
    forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
    sha5123.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h2 = null;
      var _input = forge.util.createBuffer();
      var _w2 = new Array(80);
      for (var wi2 = 0; wi2 < 80; ++wi2) {
        _w2[wi2] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md2 = {
        // SHA-512 => sha512
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 16
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength128 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _h2 = new Array(_state.length);
        for (var i2 = 0; i2 < _state.length; ++i2) {
          _h2[i2] = _state[i2].slice(0);
        }
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h2, _w2, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var next, carry;
        var bits = md2.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md2.fullMessageLength.length - 1; ++i2) {
          next = md2.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var h2 = new Array(_h2.length);
        for (var i2 = 0; i2 < _h2.length; ++i2) {
          h2[i2] = _h2[i2].slice(0);
        }
        _update(h2, _w2, finalBlock);
        var rval = forge.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h2.length;
        } else if (algorithm === "SHA-384") {
          hlen = h2.length - 2;
        } else {
          hlen = h2.length - 4;
        }
        for (var i2 = 0; i2 < hlen; ++i2) {
          rval.putInt32(h2[i2][0]);
          if (i2 !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h2[i2][1]);
          }
        }
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s2, w3, bytes) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i2, hi2, lo2, w22, w7, w15, w16;
      var len = bytes.length();
      while (len >= 128) {
        for (i2 = 0; i2 < 16; ++i2) {
          w3[i2][0] = bytes.getInt32() >>> 0;
          w3[i2][1] = bytes.getInt32() >>> 0;
        }
        for (; i2 < 80; ++i2) {
          w22 = w3[i2 - 2];
          hi2 = w22[0];
          lo2 = w22[1];
          t1_hi = ((hi2 >>> 19 | lo2 << 13) ^ // ROTR 19
          (lo2 >>> 29 | hi2 << 3) ^ // ROTR 61/(swap + ROTR 29)
          hi2 >>> 6) >>> 0;
          t1_lo = ((hi2 << 13 | lo2 >>> 19) ^ // ROTR 19
          (lo2 << 3 | hi2 >>> 29) ^ // ROTR 61/(swap + ROTR 29)
          (hi2 << 26 | lo2 >>> 6)) >>> 0;
          w15 = w3[i2 - 15];
          hi2 = w15[0];
          lo2 = w15[1];
          t2_hi = ((hi2 >>> 1 | lo2 << 31) ^ // ROTR 1
          (hi2 >>> 8 | lo2 << 24) ^ // ROTR 8
          hi2 >>> 7) >>> 0;
          t2_lo = ((hi2 << 31 | lo2 >>> 1) ^ // ROTR 1
          (hi2 << 24 | lo2 >>> 8) ^ // ROTR 8
          (hi2 << 25 | lo2 >>> 7)) >>> 0;
          w7 = w3[i2 - 7];
          w16 = w3[i2 - 16];
          lo2 = t1_lo + w7[1] + t2_lo + w16[1];
          w3[i2][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo2 / 4294967296 >>> 0) >>> 0;
          w3[i2][1] = lo2 >>> 0;
        }
        a_hi = s2[0][0];
        a_lo = s2[0][1];
        b_hi = s2[1][0];
        b_lo = s2[1][1];
        c_hi = s2[2][0];
        c_lo = s2[2][1];
        d_hi = s2[3][0];
        d_lo = s2[3][1];
        e_hi = s2[4][0];
        e_lo = s2[4][1];
        f_hi = s2[5][0];
        f_lo = s2[5][1];
        g_hi = s2[6][0];
        g_lo = s2[6][1];
        h_hi = s2[7][0];
        h_lo = s2[7][1];
        for (i2 = 0; i2 < 80; ++i2) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
          (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
          (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
          (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
          (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
          (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
          (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo2 = h_lo + s1_lo + ch_lo + _k[i2][1] + w3[i2][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i2][0] + w3[i2][0] + (lo2 / 4294967296 >>> 0) >>> 0;
          t1_lo = lo2 >>> 0;
          lo2 = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo2 / 4294967296 >>> 0) >>> 0;
          t2_lo = lo2 >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo2 = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo2 / 4294967296 >>> 0) >>> 0;
          e_lo = lo2 >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo2 = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo2 / 4294967296 >>> 0) >>> 0;
          a_lo = lo2 >>> 0;
        }
        lo2 = s2[0][1] + a_lo;
        s2[0][0] = s2[0][0] + a_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[0][1] = lo2 >>> 0;
        lo2 = s2[1][1] + b_lo;
        s2[1][0] = s2[1][0] + b_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[1][1] = lo2 >>> 0;
        lo2 = s2[2][1] + c_lo;
        s2[2][0] = s2[2][0] + c_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[2][1] = lo2 >>> 0;
        lo2 = s2[3][1] + d_lo;
        s2[3][0] = s2[3][0] + d_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[3][1] = lo2 >>> 0;
        lo2 = s2[4][1] + e_lo;
        s2[4][0] = s2[4][0] + e_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[4][1] = lo2 >>> 0;
        lo2 = s2[5][1] + f_lo;
        s2[5][0] = s2[5][0] + f_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[5][1] = lo2 >>> 0;
        lo2 = s2[6][1] + g_lo;
        s2[6][0] = s2[6][0] + g_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[6][1] = lo2 >>> 0;
        lo2 = s2[7][1] + h_lo;
        s2[7][0] = s2[7][0] + h_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[7][1] = lo2 >>> 0;
        len -= 128;
      }
    }
  }
});

// ../../node_modules/node-forge/lib/md5.js
var require_md5 = __commonJS({
  "../../node_modules/node-forge/lib/md5.js"(exports2, module2) {
    var forge = require_forge();
    require_md2();
    require_util();
    var md52 = module2.exports = forge.md5 = forge.md5 || {};
    forge.md.md5 = forge.md.algorithms.md5 = md52;
    md52.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w2 = new Array(16);
      var md2 = {
        algorithm: "md5",
        blockLength: 64,
        digestLength: 16,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength64 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878
        };
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w2, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var bits, carry = 0;
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          bits = md2.fullMessageLength[i2] * 8 + carry;
          carry = bits / 4294967296 >>> 0;
          finalBlock.putInt32Le(bits >>> 0);
        }
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3
        };
        _update(s2, _w2, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32Le(s2.h0);
        rval.putInt32Le(s2.h1);
        rval.putInt32Le(s2.h2);
        rval.putInt32Le(s2.h3);
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _g2 = null;
    var _r2 = null;
    var _k = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _g2 = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        1,
        6,
        11,
        0,
        5,
        10,
        15,
        4,
        9,
        14,
        3,
        8,
        13,
        2,
        7,
        12,
        5,
        8,
        11,
        14,
        1,
        4,
        7,
        10,
        13,
        0,
        3,
        6,
        9,
        12,
        15,
        2,
        0,
        7,
        14,
        5,
        12,
        3,
        10,
        1,
        8,
        15,
        6,
        13,
        4,
        11,
        2,
        9
      ];
      _r2 = [
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21
      ];
      _k = new Array(64);
      for (var i2 = 0; i2 < 64; ++i2) {
        _k[i2] = Math.floor(Math.abs(Math.sin(i2 + 1)) * 4294967296);
      }
      _initialized = true;
    }
    function _update(s2, w3, bytes) {
      var t2, a2, b2, c2, d2, f2, r2, i2;
      var len = bytes.length();
      while (len >= 64) {
        a2 = s2.h0;
        b2 = s2.h1;
        c2 = s2.h2;
        d2 = s2.h3;
        for (i2 = 0; i2 < 16; ++i2) {
          w3[i2] = bytes.getInt32Le();
          f2 = d2 ^ b2 & (c2 ^ d2);
          t2 = a2 + f2 + _k[i2] + w3[i2];
          r2 = _r2[i2];
          a2 = d2;
          d2 = c2;
          c2 = b2;
          b2 += t2 << r2 | t2 >>> 32 - r2;
        }
        for (; i2 < 32; ++i2) {
          f2 = c2 ^ d2 & (b2 ^ c2);
          t2 = a2 + f2 + _k[i2] + w3[_g2[i2]];
          r2 = _r2[i2];
          a2 = d2;
          d2 = c2;
          c2 = b2;
          b2 += t2 << r2 | t2 >>> 32 - r2;
        }
        for (; i2 < 48; ++i2) {
          f2 = b2 ^ c2 ^ d2;
          t2 = a2 + f2 + _k[i2] + w3[_g2[i2]];
          r2 = _r2[i2];
          a2 = d2;
          d2 = c2;
          c2 = b2;
          b2 += t2 << r2 | t2 >>> 32 - r2;
        }
        for (; i2 < 64; ++i2) {
          f2 = c2 ^ (b2 | ~d2);
          t2 = a2 + f2 + _k[i2] + w3[_g2[i2]];
          r2 = _r2[i2];
          a2 = d2;
          d2 = c2;
          c2 = b2;
          b2 += t2 << r2 | t2 >>> 32 - r2;
        }
        s2.h0 = s2.h0 + a2 | 0;
        s2.h1 = s2.h1 + b2 | 0;
        s2.h2 = s2.h2 + c2 | 0;
        s2.h3 = s2.h3 + d2 | 0;
        len -= 64;
      }
    }
  }
});

// ../../node_modules/node-forge/lib/hmac.js
var require_hmac2 = __commonJS({
  "../../node_modules/node-forge/lib/hmac.js"(exports2, module2) {
    var forge = require_forge();
    require_md2();
    require_util();
    var hmac = module2.exports = forge.hmac = forge.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md2, key) {
        if (md2 !== null) {
          if (typeof md2 === "string") {
            md2 = md2.toLowerCase();
            if (md2 in forge.md.algorithms) {
              _md = forge.md.algorithms[md2].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md2 + '"');
            }
          } else {
            _md = md2;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge.util.createBuffer(key);
          } else if (forge.util.isArray(key)) {
            var tmp = key;
            key = forge.util.createBuffer();
            for (var i2 = 0; i2 < tmp.length; ++i2) {
              key.putByte(tmp[i2]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge.util.createBuffer();
          _opadding = forge.util.createBuffer();
          keylen = key.length();
          for (var i2 = 0; i2 < keylen; ++i2) {
            var tmp = key.at(i2);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i2 = 0; i2 < tmp; ++i2) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes) {
        _md.update(bytes);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// browser-external:crypto
var require_crypto2 = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf22 = __commonJS({
  "../../node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
    var forge = require_forge();
    require_hmac2();
    require_md2();
    require_util();
    var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
    var crypto2;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript) {
      crypto2 = require_crypto2();
    }
    module2.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p2, s2, c2, dkLen, md2, callback) {
      if (typeof md2 === "function") {
        callback = md2;
        md2 = null;
      }
      if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto2.pbkdf2 && (md2 === null || typeof md2 !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md2 || md2 === "sha1"))) {
        if (typeof md2 !== "string") {
          md2 = "sha1";
        }
        p2 = Buffer.from(p2, "binary");
        s2 = Buffer.from(s2, "binary");
        if (!callback) {
          if (crypto2.pbkdf2Sync.length === 4) {
            return crypto2.pbkdf2Sync(p2, s2, c2, dkLen).toString("binary");
          }
          return crypto2.pbkdf2Sync(p2, s2, c2, dkLen, md2).toString("binary");
        }
        if (crypto2.pbkdf2Sync.length === 4) {
          return crypto2.pbkdf2(p2, s2, c2, dkLen, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto2.pbkdf2(p2, s2, c2, dkLen, md2, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md2 === "undefined" || md2 === null) {
        md2 = "sha1";
      }
      if (typeof md2 === "string") {
        if (!(md2 in forge.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md2);
        }
        md2 = forge.md[md2].create();
      }
      var hLen = md2.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r2 = dkLen - (len - 1) * hLen;
      var prf = forge.hmac.create();
      prf.start(md2, p2);
      var dk = "";
      var xor, u_c, u_c1;
      if (!callback) {
        for (var i2 = 1; i2 <= len; ++i2) {
          prf.start(null, null);
          prf.update(s2);
          prf.update(forge.util.int32ToBytes(i2));
          xor = u_c1 = prf.digest().getBytes();
          for (var j2 = 2; j2 <= c2; ++j2) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i2 < len ? xor : xor.substr(0, r2);
        }
        return dk;
      }
      var i2 = 1, j2;
      function outer() {
        if (i2 > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s2);
        prf.update(forge.util.int32ToBytes(i2));
        xor = u_c1 = prf.digest().getBytes();
        j2 = 2;
        inner();
      }
      function inner() {
        if (j2 <= c2) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
          ++j2;
          return forge.util.setImmediate(inner);
        }
        dk += i2 < len ? xor : xor.substr(0, r2);
        ++i2;
        outer();
      }
      outer();
    };
  }
});

// ../../node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS({
  "../../node_modules/node-forge/lib/cipher.js"(exports2, module2) {
    var forge = require_forge();
    require_util();
    module2.exports = forge.cipher = forge.cipher || {};
    forge.cipher.algorithms = forge.cipher.algorithms || {};
    forge.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge.cipher.registerAlgorithm = function(name2, algorithm) {
      name2 = name2.toUpperCase();
      forge.cipher.algorithms[name2] = algorithm;
    };
    forge.cipher.getAlgorithm = function(name2) {
      name2 = name2.toUpperCase();
      if (name2 in forge.cipher.algorithms) {
        return forge.cipher.algorithms[name2];
      }
      return null;
    };
    var BlockCipher = forge.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge.util.createBuffer();
      this.output = options.output || forge.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS({
  "../../node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
    var forge = require_forge();
    require_util();
    forge.cipher = forge.cipher || {};
    var modes = module2.exports = forge.cipher.modes = forge.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = this._prev[i2] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._prev[i2] ^ this._outBlock[i2]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32() ^ this._outBlock[i2];
          output.putInt32(this._inBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32() ^ this._outBlock[i2];
        this._partialOutput.putInt32(this._partialBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32();
          output.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
          this._inBlock[i2] = this._outBlock[i2];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._outBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv2 = forge.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv2.length();
      if (ivLength === 12) {
        this._j0 = [iv2.getInt32(), iv2.getInt32(), iv2.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv2.length() > 0) {
          this._j0 = this.ghash(
            this._hashSubkey,
            this._j0,
            [iv2.getInt32(), iv2.getInt32(), iv2.getInt32(), iv2.getInt32()]
          );
        }
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [0, 0].concat(from64To32(ivLength * 8))
        );
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(this._outBlock[i2] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._outBlock[i2] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this.tag.putInt32(this._s[i2] ^ tag[i2]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x3, y2) {
      var z_i = [0, 0, 0, 0];
      var v_i = y2.slice(0);
      for (var i2 = 0; i2 < 128; ++i2) {
        var x_i = x3[i2 / 32 | 0] & 1 << 31 - i2 % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x3, out) {
      var lsb = x3[3] & 1;
      for (var i2 = 3; i2 > 0; --i2) {
        out[i2] = x3[i2] >>> 1 | (x3[i2 - 1] & 1) << 31;
      }
      out[0] = x3[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x3) {
      var z3 = [0, 0, 0, 0];
      for (var i2 = 0; i2 < 32; ++i2) {
        var idx = i2 / 8 | 0;
        var x_i = x3[idx] >>> (7 - i2 % 8) * 4 & 15;
        var ah2 = this._m[i2][x_i];
        z3[0] ^= ah2[0];
        z3[1] ^= ah2[1];
        z3[2] ^= ah2[2];
        z3[3] ^= ah2[3];
      }
      return z3;
    };
    modes.gcm.prototype.ghash = function(h2, y2, x3) {
      y2[0] ^= x3[0];
      y2[1] ^= x3[1];
      y2[2] ^= x3[2];
      y2[3] ^= x3[3];
      return this.tableMultiply(y2);
    };
    modes.gcm.prototype.generateHashTable = function(h2, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m2 = new Array(size);
      for (var i2 = 0; i2 < size; ++i2) {
        var tmp = [0, 0, 0, 0];
        var idx = i2 / perInt | 0;
        var shft = (perInt - 1 - i2 % perInt) * bits;
        tmp[idx] = 1 << bits - 1 << shft;
        m2[i2] = this.generateSubHashTable(this.multiply(tmp, h2), bits);
      }
      return m2;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size = 1 << bits;
      var half = size >>> 1;
      var m2 = new Array(size);
      m2[half] = mid.slice(0);
      var i2 = half >>> 1;
      while (i2 > 0) {
        this.pow(m2[2 * i2], m2[i2] = []);
        i2 >>= 1;
      }
      i2 = 2;
      while (i2 < half) {
        for (var j2 = 1; j2 < i2; ++j2) {
          var m_i = m2[i2];
          var m_j = m2[j2];
          m2[i2 + j2] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i2 *= 2;
      }
      m2[0] = [0, 0, 0, 0];
      for (i2 = half + 1; i2 < size; ++i2) {
        var c2 = m2[i2 ^ half];
        m2[i2] = [mid[0] ^ c2[0], mid[1] ^ c2[1], mid[2] ^ c2[2], mid[3] ^ c2[3]];
      }
      return m2;
    };
    function transformIV(iv2) {
      if (typeof iv2 === "string") {
        iv2 = forge.util.createBuffer(iv2);
      }
      if (forge.util.isArray(iv2) && iv2.length > 4) {
        var tmp = iv2;
        iv2 = forge.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          iv2.putByte(tmp[i2]);
        }
      }
      if (!forge.util.isArray(iv2)) {
        iv2 = [iv2.getInt32(), iv2.getInt32(), iv2.getInt32(), iv2.getInt32()];
      }
      return iv2;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
  }
});

// ../../node_modules/node-forge/lib/aes.js
var require_aes = __commonJS({
  "../../node_modules/node-forge/lib/aes.js"(exports2, module2) {
    var forge = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge.aes = forge.aes || {};
    forge.aes.startEncrypting = function(key, iv2, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode
      });
      cipher.start(iv2);
      return cipher;
    };
    forge.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.aes.startDecrypting = function(key, iv2, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode
      });
      cipher.start(iv2);
      return cipher;
    };
    forge.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.aes.Algorithm = function(name2, mode) {
      if (!init) {
        initialize();
      }
      var self2 = this;
      self2.name = name2;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge.util.createBuffer(key);
      } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          key.putByte(tmp[i2]);
        }
      }
      if (!forge.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i2 = 0; i2 < len; ++i2) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge.aes._expandKey = function(key, decrypt2) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt2);
    };
    forge.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
    function registerAlgorithm(name2, mode) {
      var factory = function() {
        return new forge.aes.Algorithm(name2, mode);
      };
      forge.cipher.registerAlgorithm(name2, factory);
    }
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i2 = 0; i2 < 128; ++i2) {
        xtime[i2] = i2 << 1;
        xtime[i2 + 128] = i2 + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i2 = 0; i2 < 4; ++i2) {
        mix[i2] = new Array(256);
        imix[i2] = new Array(256);
      }
      var e2 = 0, ei2 = 0, e22, e4, e8, sx, sx2, me, ime;
      for (var i2 = 0; i2 < 256; ++i2) {
        sx = ei2 ^ ei2 << 1 ^ ei2 << 2 ^ ei2 << 3 ^ ei2 << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e2] = sx;
        isbox[sx] = e2;
        sx2 = xtime[sx];
        e22 = xtime[e2];
        e4 = xtime[e22];
        e8 = xtime[e4];
        me = sx2 << 24 ^ // 2
        sx << 16 ^ // 1
        sx << 8 ^ // 1
        (sx ^ sx2);
        ime = (e22 ^ e4 ^ e8) << 24 ^ // E (14)
        (e2 ^ e8) << 16 ^ // 9
        (e2 ^ e4 ^ e8) << 8 ^ // D (13)
        (e2 ^ e22 ^ e8);
        for (var n2 = 0; n2 < 4; ++n2) {
          mix[n2][e2] = me;
          imix[n2][sx] = ime;
          me = me << 24 | me >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e2 === 0) {
          e2 = ei2 = 1;
        } else {
          e2 = e22 ^ xtime[xtime[xtime[e22 ^ e8]]];
          ei2 ^= xtime[xtime[ei2]];
        }
      }
    }
    function _expandKey(key, decrypt2) {
      var w3 = key.slice(0);
      var temp, iNk = 1;
      var Nk = w3.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i2 = Nk; i2 < end; ++i2) {
        temp = w3[i2 - 1];
        if (i2 % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i2 % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w3[i2] = w3[i2 - Nk] ^ temp;
      }
      if (decrypt2) {
        var tmp;
        var m02 = imix[0];
        var m12 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w3.slice(0);
        end = w3.length;
        for (var i2 = 0, wi2 = end - Nb; i2 < end; i2 += Nb, wi2 -= Nb) {
          if (i2 === 0 || i2 === end - Nb) {
            wnew[i2] = w3[wi2];
            wnew[i2 + 1] = w3[wi2 + 3];
            wnew[i2 + 2] = w3[wi2 + 2];
            wnew[i2 + 3] = w3[wi2 + 1];
          } else {
            for (var n2 = 0; n2 < Nb; ++n2) {
              tmp = w3[wi2 + n2];
              wnew[i2 + (3 & -n2)] = m02[sbox[tmp >>> 24]] ^ m12[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w3 = wnew;
      }
      return w3;
    }
    function _updateBlock(w3, input, output, decrypt2) {
      var Nr2 = w3.length / 4 - 1;
      var m02, m12, m2, m3, sub;
      if (decrypt2) {
        m02 = imix[0];
        m12 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m02 = mix[0];
        m12 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a2, b2, c2, d2, a22, b22, c22;
      a2 = input[0] ^ w3[0];
      b2 = input[decrypt2 ? 3 : 1] ^ w3[1];
      c2 = input[2] ^ w3[2];
      d2 = input[decrypt2 ? 1 : 3] ^ w3[3];
      var i2 = 3;
      for (var round = 1; round < Nr2; ++round) {
        a22 = m02[a2 >>> 24] ^ m12[b2 >>> 16 & 255] ^ m2[c2 >>> 8 & 255] ^ m3[d2 & 255] ^ w3[++i2];
        b22 = m02[b2 >>> 24] ^ m12[c2 >>> 16 & 255] ^ m2[d2 >>> 8 & 255] ^ m3[a2 & 255] ^ w3[++i2];
        c22 = m02[c2 >>> 24] ^ m12[d2 >>> 16 & 255] ^ m2[a2 >>> 8 & 255] ^ m3[b2 & 255] ^ w3[++i2];
        d2 = m02[d2 >>> 24] ^ m12[a2 >>> 16 & 255] ^ m2[b2 >>> 8 & 255] ^ m3[c2 & 255] ^ w3[++i2];
        a2 = a22;
        b2 = b22;
        c2 = c22;
      }
      output[0] = sub[a2 >>> 24] << 24 ^ sub[b2 >>> 16 & 255] << 16 ^ sub[c2 >>> 8 & 255] << 8 ^ sub[d2 & 255] ^ w3[++i2];
      output[decrypt2 ? 3 : 1] = sub[b2 >>> 24] << 24 ^ sub[c2 >>> 16 & 255] << 16 ^ sub[d2 >>> 8 & 255] << 8 ^ sub[a2 & 255] ^ w3[++i2];
      output[2] = sub[c2 >>> 24] << 24 ^ sub[d2 >>> 16 & 255] << 16 ^ sub[a2 >>> 8 & 255] << 8 ^ sub[b2 & 255] ^ w3[++i2];
      output[decrypt2 ? 1 : 3] = sub[d2 >>> 24] << 24 ^ sub[a2 >>> 16 & 255] << 16 ^ sub[b2 >>> 8 & 255] << 8 ^ sub[c2 & 255] ^ w3[++i2];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv2, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv2;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// ../../node_modules/node-forge/lib/des.js
var require_des = __commonJS({
  "../../node_modules/node-forge/lib/des.js"(exports2, module2) {
    var forge = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge.des = forge.des || {};
    forge.des.startEncrypting = function(key, iv2, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode: mode || (iv2 === null ? "ECB" : "CBC")
      });
      cipher.start(iv2);
      return cipher;
    };
    forge.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.des.startDecrypting = function(key, iv2, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode: mode || (iv2 === null ? "ECB" : "CBC")
      });
      cipher.start(iv2);
      return cipher;
    };
    forge.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.des.Algorithm = function(name2, mode) {
      var self2 = this;
      self2.name = name2;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
    function registerAlgorithm(name2, mode) {
      var factory = function() {
        return new forge.des.Algorithm(name2, mode);
      };
      forge.cipher.registerAlgorithm(name2, factory);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n2 = 0, tmp;
      for (var j2 = 0; j2 < iterations; j2++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i2 = 0; i2 < shifts.length; ++i2) {
          if (shifts[i2]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n2++] = lefttmp ^ tmp;
          keys[n2++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt2) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt2 ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt2 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j2 = 0; j2 < iterations; j2 += 3) {
        var endloop = looping[j2 + 1];
        var loopinc = looping[j2 + 2];
        for (var i2 = looping[j2]; i2 != endloop; i2 += loopinc) {
          var right1 = right ^ keys[i2];
          var right2 = (right >>> 4 | right << 28) ^ keys[i2 + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv2, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv2;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// ../../node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS({
  "../../node_modules/node-forge/lib/rc2.js"(exports2, module2) {
    var forge = require_forge();
    require_util();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s2 = [1, 2, 3, 5];
    var rol = function(word, bits) {
      return word << bits & 65535 | (word & 65535) >> 16 - bits;
    };
    var ror = function(word, bits) {
      return (word & 65535) >> bits | word << 16 - bits & 65535;
    };
    module2.exports = forge.rc2 = forge.rc2 || {};
    forge.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L2 = key;
      var T3 = key.length();
      var T12 = effKeyBits;
      var T8 = Math.ceil(T12 / 8);
      var TM = 255 >> (T12 & 7);
      var i2;
      for (i2 = T3; i2 < 128; i2++) {
        L2.putByte(piTable[L2.at(i2 - 1) + L2.at(i2 - T3) & 255]);
      }
      L2.setAt(128 - T8, piTable[L2.at(128 - T8) & TM]);
      for (i2 = 127 - T8; i2 >= 0; i2--) {
        L2.setAt(i2, piTable[L2.at(i2 + 1) ^ L2.at(i2 + T8)]);
      }
      return L2;
    };
    var createCipher = function(key, bits, encrypt2) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i2, j2, K2 = [];
      key = forge.rc2.expandKey(key, bits);
      for (i2 = 0; i2 < 64; i2++) {
        K2.push(key.getInt16Le());
      }
      if (encrypt2) {
        mixRound = function(R2) {
          for (i2 = 0; i2 < 4; i2++) {
            R2[i2] += K2[j2] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
            R2[i2] = rol(R2[i2], s2[i2]);
            j2++;
          }
        };
        mashRound = function(R2) {
          for (i2 = 0; i2 < 4; i2++) {
            R2[i2] += K2[R2[(i2 + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R2) {
          for (i2 = 3; i2 >= 0; i2--) {
            R2[i2] = ror(R2[i2], s2[i2]);
            R2[i2] -= K2[j2] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
            j2--;
          }
        };
        mashRound = function(R2) {
          for (i2 = 3; i2 >= 0; i2--) {
            R2[i2] -= K2[R2[(i2 + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R2 = [];
        for (i2 = 0; i2 < 4; i2++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt2) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R2.push(val & 65535);
        }
        j2 = encrypt2 ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R2);
          }
        }
        for (i2 = 0; i2 < 4; i2++) {
          if (_iv !== null) {
            if (encrypt2) {
              _iv.putInt16Le(R2[i2]);
            } else {
              R2[i2] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R2[i2]);
        }
      };
      var cipher = null;
      cipher = {
        /**
         * Starts or restarts the encryption or decryption process, whichever
         * was previously configured.
         *
         * To use the cipher in CBC mode, iv may be given either as a string
         * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
         *
         * @param iv the initialization vector to use, null for ECB mode.
         * @param output the output the buffer to write to, null to create one.
         */
        start: function(iv2, output) {
          if (iv2) {
            if (typeof iv2 === "string") {
              iv2 = forge.util.createBuffer(iv2);
            }
          }
          _finish = false;
          _input = forge.util.createBuffer();
          _output = output || new forge.util.createBuffer();
          _iv = iv2;
          cipher.output = _output;
        },
        /**
         * Updates the next block.
         *
         * @param input the buffer to read from.
         */
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        /**
         * Finishes encrypting or decrypting.
         *
         * @param pad a padding function to use, null for PKCS#7 padding,
         *           signature(blockSize, buffer, decrypt).
         *
         * @return true if successful, false on error.
         */
        finish: function(pad) {
          var rval = true;
          if (encrypt2) {
            if (pad) {
              rval = pad(8, _input, !encrypt2);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt2) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt2);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge.rc2.startEncrypting = function(key, iv2, output) {
      var cipher = forge.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv2, output);
      return cipher;
    };
    forge.rc2.createEncryptionCipher = function(key, bits) {
      return createCipher(key, bits, true);
    };
    forge.rc2.startDecrypting = function(key, iv2, output) {
      var cipher = forge.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv2, output);
      return cipher;
    };
    forge.rc2.createDecryptionCipher = function(key, bits) {
      return createCipher(key, bits, false);
    };
  }
});

// ../../node_modules/node-forge/lib/prng.js
var require_prng = __commonJS({
  "../../node_modules/node-forge/lib/prng.js"(exports2, module2) {
    var forge = require_forge();
    require_util();
    var _crypto = null;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require_crypto2();
    }
    var prng = module2.exports = forge.prng = forge.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        // number of reseeds so far
        reseeds: 0,
        // amount of data generated so far
        generated: 0,
        // no initial key bytes
        keyBytes: ""
      };
      var md2 = plugin.md;
      var pools = new Array(32);
      for (var i2 = 0; i2 < 32; ++i2) {
        pools[i2] = md2.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b2 = forge.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err) {
          if (err) {
            return callback(err);
          }
          if (b2.length() >= count) {
            return callback(null, b2.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge.util.setImmediate(generate);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b2 = forge.util.createBuffer();
        while (b2.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b2.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md3 = ctx.plugin.md.create();
        md3.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k2 = 0; k2 < 32; ++k2) {
          if (ctx.reseeds % _2powK === 0) {
            md3.update(ctx.pools[k2].digest().getBytes());
            ctx.pools[k2].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md3.digest().getBytes();
        md3.start();
        md3.update(ctx.keyBytes);
        var seedBytes = md3.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b2 = forge.util.createBuffer();
        if (getRandomValues) {
          while (b2.length() < needed) {
            var count = Math.max(1, Math.min(needed - b2.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i3 = 0; i3 < entropy.length; ++i3) {
                b2.putInt32(entropy[i3]);
              }
            } catch (e2) {
              if (!(typeof QuotaExceededError !== "undefined" && e2 instanceof QuotaExceededError)) {
                throw e2;
              }
            }
          }
        }
        if (b2.length() < needed) {
          var hi2, lo2, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b2.length() < needed) {
            lo2 = 16807 * (seed & 65535);
            hi2 = 16807 * (seed >> 16);
            lo2 += (hi2 & 32767) << 16;
            lo2 += hi2 >> 15;
            lo2 = (lo2 & 2147483647) + (lo2 >> 31);
            seed = lo2 & 4294967295;
            for (var i3 = 0; i3 < 3; ++i3) {
              next = seed >>> (i3 << 3);
              next ^= Math.floor(Math.random() * 256);
              b2.putByte(String.fromCharCode(next & 255));
            }
          }
        }
        return b2.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e2) {
            callback(e2);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes) {
        var count = bytes.length;
        for (var i3 = 0; i3 < count; ++i3) {
          ctx.pools[ctx.pool].update(bytes.substr(i3, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i3, n2) {
        var bytes = "";
        for (var x3 = 0; x3 < n2; x3 += 8) {
          bytes += String.fromCharCode(i3 >> x3 & 255);
        }
        ctx.collect(bytes);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e2) {
              var data = e2.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = function(e2) {
            var data = e2.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
                worker.postMessage({ forge: { prng: { err, bytes } } });
              });
            }
          };
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// ../../node_modules/node-forge/lib/random.js
var require_random = __commonJS({
  "../../node_modules/node-forge/lib/random.js"(exports2, module2) {
    var forge = require_forge();
    require_aes();
    require_sha2562();
    require_prng();
    require_util();
    (function() {
      if (forge.random && forge.random.getBytes) {
        module2.exports = forge.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key2, seed) {
          forge.aes._updateBlock(key2, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge.md.sha256;
        function spawnPrng() {
          var ctx = forge.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
        if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e2) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e2) {
              _ctx.collectInt(e2.clientX, 16);
              _ctx.collectInt(e2.clientY, 16);
            });
            jQuery2().keypress(function(e2) {
              _ctx.collectInt(e2.charCode, 8);
            });
          }
        }
        if (!forge.random) {
          forge.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge.random[key] = _ctx[key];
          }
        }
        forge.random.createInstance = spawnPrng;
        module2.exports = forge.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// ../../node_modules/crypto-key-composer/es/util/random.js
var import_random, randomBytes, random_default;
var init_random = __esm({
  "../../node_modules/crypto-key-composer/es/util/random.js"() {
    import_random = __toESM(require_random());
    init_binary();
    randomBytes = (size) => binaryStringToUint8Array(import_random.default.getBytesSync(size));
    random_default = randomBytes;
  }
});

// ../../node_modules/crypto-key-composer/es/util/pbe.js
var import_util, import_sha1, import_sha256, import_sha512, import_md5, import_pbkdf2, import_aes, import_des, import_rc2, deriveKeyWithPbkdf2, deriveKeyWithOpensslDeriveBytes, decryptWithAes, encryptWithAes, decryptWithDes, encryptWithDes, decryptWithRc2, encryptWithRc2, getRc2KeyLength, decryptWithPassword, encryptWithPassword;
var init_pbe = __esm({
  "../../node_modules/crypto-key-composer/es/util/pbe.js"() {
    import_util = __toESM(require_util());
    import_sha1 = __toESM(require_sha1());
    import_sha256 = __toESM(require_sha2562());
    import_sha512 = __toESM(require_sha5122());
    import_md5 = __toESM(require_md5());
    import_pbkdf2 = __toESM(require_pbkdf22());
    import_aes = __toESM(require_aes());
    import_des = __toESM(require_des());
    import_rc2 = __toESM(require_rc2());
    init_random();
    init_binary();
    init_errors();
    deriveKeyWithPbkdf2 = (password, params) => {
      const {
        salt,
        iterationCount,
        keyLength,
        prf
      } = params;
      const saltStr = uint8ArrayToBinaryString(salt);
      let prfMd;
      switch (prf) {
        case "hmac-with-sha1":
          prfMd = import_sha1.default.create();
          break;
        case "hmac-with-sha256":
          prfMd = import_sha256.default.create();
          break;
        case "hmac-with-sha384":
          prfMd = import_sha512.default.sha384.create();
          break;
        case "hmac-with-sha512":
          prfMd = import_sha512.default.create();
          break;
        default:
          throw new UnsupportedAlgorithmError(`Unsupported PBKDF2 prf id '${prf}'`);
      }
      const keyStr = (0, import_pbkdf2.default)(password, saltStr, iterationCount, keyLength, prfMd);
      return binaryStringToUint8Array(keyStr);
    };
    deriveKeyWithOpensslDeriveBytes = (password, params) => {
      const {
        salt,
        keyLength
      } = params;
      const saltStr = uint8ArrayToBinaryString(salt);
      const md2 = import_md5.default.create();
      const hash3 = (bytes) => md2.start().update(bytes).digest().getBytes();
      const digests = [hash3(password + saltStr)];
      for (let length2 = 16, i2 = 1; length2 < keyLength; i2 += 1, length2 += 16) {
        digests.push(hash3(digests[i2 - 1] + password + saltStr));
      }
      const digestStr = digests.join("").substr(0, keyLength);
      return binaryStringToUint8Array(digestStr);
    };
    decryptWithAes = (key, encryptedData, params) => {
      const {
        iv: iv2,
        mode
      } = params;
      const ivStr = uint8ArrayToBinaryString(iv2);
      const keyStr = uint8ArrayToBinaryString(key);
      const cipher = import_aes.default.createDecryptionCipher(keyStr, mode);
      cipher.start(ivStr);
      cipher.update((0, import_util.createBuffer)(uint8ArrayToBinaryString(encryptedData)));
      if (!cipher.finish()) {
        throw new DecryptionFailedError("Decryption failed, mostly likely the password is wrong");
      }
      return binaryStringToUint8Array(cipher.output.getBytes());
    };
    encryptWithAes = (key, data, params) => {
      const {
        iv: iv2,
        mode
      } = params;
      const ivStr = uint8ArrayToBinaryString(iv2);
      const keyStr = uint8ArrayToBinaryString(key);
      const cipher = import_aes.default.createEncryptionCipher(keyStr, mode);
      cipher.start(ivStr);
      cipher.update((0, import_util.createBuffer)(uint8ArrayToBinaryString(data)));
      cipher.finish();
      return binaryStringToUint8Array(cipher.output.getBytes());
    };
    decryptWithDes = (key, encryptedData, params) => {
      const {
        iv: iv2,
        mode
      } = params;
      const ivStr = uint8ArrayToBinaryString(iv2);
      const keyStr = uint8ArrayToBinaryString(key);
      const cipher = import_des.default.createDecryptionCipher(keyStr, mode);
      cipher.start(ivStr);
      cipher.update((0, import_util.createBuffer)(uint8ArrayToBinaryString(encryptedData)));
      if (!cipher.finish()) {
        throw new DecryptionFailedError("Decryption failed, mostly likely the password is wrong");
      }
      return binaryStringToUint8Array(cipher.output.getBytes());
    };
    encryptWithDes = (key, data, params) => {
      const {
        iv: iv2,
        mode
      } = params;
      const ivStr = uint8ArrayToBinaryString(iv2);
      const keyStr = uint8ArrayToBinaryString(key);
      const cipher = import_des.default.createEncryptionCipher(keyStr, mode);
      cipher.start(ivStr);
      cipher.update((0, import_util.createBuffer)(uint8ArrayToBinaryString(data)));
      cipher.finish();
      return binaryStringToUint8Array(cipher.output.getBytes());
    };
    decryptWithRc2 = (key, encryptedData, params) => {
      const {
        iv: iv2,
        bits
      } = params;
      const ivStr = uint8ArrayToBinaryString(iv2);
      const keyStr = uint8ArrayToBinaryString(key);
      const cipher = import_rc2.default.createDecryptionCipher(keyStr, bits);
      cipher.start(ivStr);
      cipher.update((0, import_util.createBuffer)(uint8ArrayToBinaryString(encryptedData)));
      if (!cipher.finish()) {
        throw new DecryptionFailedError("Decryption failed, mostly likely the password is wrong");
      }
      return binaryStringToUint8Array(cipher.output.getBytes());
    };
    encryptWithRc2 = (key, data, params) => {
      const {
        iv: iv2,
        bits
      } = params;
      const ivStr = uint8ArrayToBinaryString(iv2);
      const keyStr = uint8ArrayToBinaryString(key);
      const cipher = import_rc2.default.createEncryptionCipher(keyStr, bits);
      cipher.start(ivStr);
      cipher.update((0, import_util.createBuffer)(uint8ArrayToBinaryString(data)));
      cipher.finish();
      return binaryStringToUint8Array(cipher.output.getBytes());
    };
    getRc2KeyLength = (bits) => {
      switch (bits) {
        case 40:
          return 5;
        case 64:
          return 8;
        case 128:
          return 16;
        default:
          throw new UnsupportedAlgorithmError(`Unsupported RC2 bits parameter with value '${bits}'`);
      }
    };
    decryptWithPassword = (encryptedData, encryptionAlgorithm, password) => {
      const {
        keyDerivationFunc,
        encryptionScheme
      } = encryptionAlgorithm;
      let deriveKeyFn;
      let derivedKeyLength;
      let decryptFn;
      switch (encryptionScheme.id) {
        case "aes128-cbc":
        case "aes192-cbc":
        case "aes256-cbc":
          decryptFn = (key) => decryptWithAes(key, encryptedData, {
            ...encryptionScheme,
            mode: "CBC"
          });
          derivedKeyLength = Number(encryptionScheme.id.match(/^aes(\d+)-/)[1]) / 8;
          break;
        case "rc2-cbc":
          decryptFn = (key) => decryptWithRc2(key, encryptedData, encryptionScheme);
          derivedKeyLength = getRc2KeyLength(encryptionScheme.bits);
          break;
        case "des-ede3-cbc":
          decryptFn = (key) => decryptWithDes(key, encryptedData, {
            ...encryptionScheme,
            mode: "CBC"
          });
          derivedKeyLength = 24;
          break;
        case "des-cbc":
          decryptFn = (key) => decryptWithDes(key, encryptedData, {
            ...encryptionScheme,
            mode: "CBC"
          });
          derivedKeyLength = 8;
          break;
        default:
          throw new UnsupportedAlgorithmError(`Unsupported encryption scheme id '${encryptionScheme.id}'`);
      }
      switch (keyDerivationFunc.id) {
        case "pbkdf2":
          deriveKeyFn = () => deriveKeyWithPbkdf2(password, {
            ...keyDerivationFunc,
            keyLength: keyDerivationFunc.keyLength || derivedKeyLength
          });
          break;
        case "openssl-derive-bytes":
          deriveKeyFn = () => deriveKeyWithOpensslDeriveBytes(password, {
            keyLength: derivedKeyLength,
            salt: encryptionScheme.iv.slice(0, 8)
          });
          break;
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key derivation function id '${keyDerivationFunc.id}'`);
      }
      const derivedKey = deriveKeyFn();
      const decryptedData = decryptFn(derivedKey);
      return decryptedData;
    };
    encryptWithPassword = (data, encryptionAlgorithm, password) => {
      const keyDerivationFunc = {
        ...encryptionAlgorithm.keyDerivationFunc
      };
      const encryptionScheme = {
        ...encryptionAlgorithm.encryptionScheme
      };
      let deriveKeyFn;
      let derivedKeyLength;
      let encryptFn;
      switch (encryptionScheme.id) {
        case "aes128-cbc":
        case "aes192-cbc":
        case "aes256-cbc":
          encryptionScheme.iv = encryptionScheme.iv || random_default(16);
          encryptFn = (key) => encryptWithAes(key, data, {
            ...encryptionScheme,
            mode: "CBC"
          });
          derivedKeyLength = Number(encryptionScheme.id.match(/^aes(\d+)-/)[1]) / 8;
          break;
        case "rc2-cbc":
          encryptionScheme.bits = encryptionScheme.bits || 128;
          encryptionScheme.iv = encryptionScheme.iv || random_default(16);
          encryptFn = (key) => encryptWithRc2(key, data, encryptionScheme);
          derivedKeyLength = getRc2KeyLength(encryptionScheme.bits);
          break;
        case "des-ede3-cbc":
          encryptionScheme.iv = encryptionScheme.iv || random_default(8);
          encryptFn = (key) => encryptWithDes(key, data, {
            ...encryptionScheme,
            mode: "CBC"
          });
          derivedKeyLength = 24;
          break;
        case "des-cbc":
          encryptionScheme.iv = encryptionScheme.iv || random_default(8);
          encryptFn = (key) => encryptWithDes(key, data, {
            ...encryptionScheme,
            mode: "CBC"
          });
          derivedKeyLength = 8;
          break;
        default:
          throw new UnsupportedAlgorithmError(`Unsupported encryption scheme id '${encryptionScheme.id}'`);
      }
      switch (keyDerivationFunc.id) {
        case "pbkdf2":
          if (keyDerivationFunc.keyLength != null && derivedKeyLength !== keyDerivationFunc.keyLength) {
            throw new UnsupportedAlgorithmError(`The specified key length must be equal to ${derivedKeyLength} (or omitted)`);
          }
          keyDerivationFunc.salt = keyDerivationFunc.salt || random_default(16);
          keyDerivationFunc.iterationCount = keyDerivationFunc.iterationCount || 1e4;
          keyDerivationFunc.keyLength = keyDerivationFunc.keyLength || derivedKeyLength;
          keyDerivationFunc.prf = keyDerivationFunc.prf || "hmac-with-sha512";
          deriveKeyFn = () => deriveKeyWithPbkdf2(password, keyDerivationFunc);
          break;
        case "openssl-derive-bytes":
          keyDerivationFunc.keyLength = derivedKeyLength;
          keyDerivationFunc.salt = encryptionScheme.iv.slice(0, 8);
          deriveKeyFn = () => deriveKeyWithOpensslDeriveBytes(password, keyDerivationFunc);
          break;
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key derivation function id '${keyDerivationFunc.id}'`);
      }
      const derivedKey = deriveKeyFn();
      const encryptedData = encryptFn(derivedKey);
      return {
        effectiveEncryptionAlgorithm: {
          keyDerivationFunc,
          encryptionScheme
        },
        encryptedData
      };
    };
  }
});

// ../../node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "../../node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// ../../node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "../../node_modules/lodash/isPlainObject.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject3(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject3;
  }
});

// ../../node_modules/crypto-key-composer/es/util/validator.js
var import_isPlainObject, validateFormat, validateAlgorithmIdentifier, validateDecomposedKey, validateEncryptionAlgorithm;
var init_validator = __esm({
  "../../node_modules/crypto-key-composer/es/util/validator.js"() {
    import_isPlainObject = __toESM(require_isPlainObject());
    init_binary();
    init_key_types();
    init_errors();
    validateFormat = (format, supportedFormats) => {
      if (typeof format !== "string") {
        throw new UnexpectedTypeError("Expecting format to be a string");
      }
      if (!supportedFormats[format]) {
        throw new UnsupportedFormatError(format);
      }
      return format;
    };
    validateAlgorithmIdentifier = (algorithmIdentifier, errorContext) => {
      if (typeof algorithmIdentifier === "string") {
        algorithmIdentifier = {
          id: algorithmIdentifier
        };
      }
      if (!(0, import_isPlainObject.default)(algorithmIdentifier)) {
        throw new UnexpectedTypeError(`Expecting ${errorContext} to be an object`);
      }
      if (typeof algorithmIdentifier.id !== "string") {
        throw new UnexpectedTypeError(`Expecting ${errorContext} id to be a string`);
      }
      return algorithmIdentifier;
    };
    validateDecomposedKey = (decomposedKey, supportedFormats) => {
      if (!decomposedKey || !(0, import_isPlainObject.default)(decomposedKey)) {
        throw new UnexpectedTypeError("Expecting decomposed key to be an object");
      }
      decomposedKey = {
        ...decomposedKey
      };
      decomposedKey.format = validateFormat(decomposedKey.format, supportedFormats);
      decomposedKey.keyAlgorithm = validateAlgorithmIdentifier(decomposedKey.keyAlgorithm, "key algorithm");
      const aliasedKeyAlgorithm = KEY_ALIASES[decomposedKey.keyAlgorithm.id];
      if (aliasedKeyAlgorithm) {
        decomposedKey.keyAlgorithm = {
          ...aliasedKeyAlgorithm,
          ...decomposedKey.keyAlgorithm,
          id: aliasedKeyAlgorithm.id
        };
      }
      if (!(0, import_isPlainObject.default)(decomposedKey.keyData)) {
        throw new UnexpectedTypeError("Expecting key data to be an object");
      }
      if (decomposedKey.encryptionAlgorithm && !(0, import_isPlainObject.default)(decomposedKey.encryptionAlgorithm)) {
        throw new UnexpectedTypeError("Expecting encryption algorithm to be an object");
      }
      return decomposedKey;
    };
    validateEncryptionAlgorithm = (encryptionAlgorithm, defaultKeyDerivationFunc, defaultEncryptionScheme) => {
      encryptionAlgorithm = encryptionAlgorithm || {};
      return {
        keyDerivationFunc: validateAlgorithmIdentifier(encryptionAlgorithm.keyDerivationFunc || defaultKeyDerivationFunc, "key derivation func"),
        encryptionScheme: validateAlgorithmIdentifier(encryptionAlgorithm.encryptionScheme || defaultEncryptionScheme, "encryption scheme")
      };
    };
  }
});

// ../../node_modules/crypto-key-composer/es/formats/raw/encryption.js
var decryptPemBody, encryptPemBody, maybeDecryptPemBody, maybeEncryptPemBody;
var init_encryption = __esm({
  "../../node_modules/crypto-key-composer/es/formats/raw/encryption.js"() {
    init_pbe();
    init_binary();
    init_validator();
    init_errors();
    decryptPemBody = (pem, password) => {
      const keyDerivationFunc = {
        id: "openssl-derive-bytes"
      };
      const encryptionScheme = {
        iv: hexStringToUint8Array(pem.dekInfo.parameters)
      };
      const dekInfoAlgorithm = pem.dekInfo.algorithm;
      switch (dekInfoAlgorithm) {
        case "AES-128-CBC":
        case "AES-192-CBC":
        case "AES-256-CBC":
          encryptionScheme.id = dekInfoAlgorithm.replace("-", "").toLowerCase();
          break;
        case "RC2-40-CBC":
        case "RC2-64-CBC":
        case "RC2-128-CBC":
        case "RC2-CBC":
          encryptionScheme.id = "rc2-cbc";
          encryptionScheme.bits = Number((dekInfoAlgorithm.match(/-(\d+)-/) || [])[1]) || 128;
          break;
        case "DES-CBC":
        case "DES-EDE3-CBC":
          encryptionScheme.id = dekInfoAlgorithm.toLowerCase();
          break;
        default:
          throw new UnsupportedAlgorithmError(`Unsupported DEK-INFO algorithm '${dekInfoAlgorithm}'`);
      }
      const encryptionAlgorithm = {
        keyDerivationFunc,
        encryptionScheme
      };
      const decryptedPemBody = decryptWithPassword(binaryStringToUint8Array(pem.body), encryptionAlgorithm, password);
      return {
        encryptionAlgorithm,
        pemBody: decryptedPemBody
      };
    };
    encryptPemBody = (pemBody, encryptionAlgorithm, password) => {
      encryptionAlgorithm = validateEncryptionAlgorithm(encryptionAlgorithm, "openssl-derive-bytes", "aes256-cbc");
      const {
        keyDerivationFunc,
        encryptionScheme
      } = encryptionAlgorithm;
      if (keyDerivationFunc.id !== "openssl-derive-bytes") {
        throw new UnsupportedAlgorithmError("PKCS1 PEM keys only support 'openssl-derive-bytes' as the key derivation func");
      }
      let dekInfoAlgorithm;
      switch (encryptionScheme.id) {
        case "aes128-cbc":
        case "aes192-cbc":
        case "aes256-cbc":
          dekInfoAlgorithm = encryptionScheme.id.replace("aes", "aes-").toUpperCase();
          break;
        case "rc2-cbc":
          encryptionScheme.bits = encryptionScheme.bits || 128;
          switch (encryptionScheme.bits) {
            case 40:
              dekInfoAlgorithm = "RC2-40-CBC";
              break;
            case 64:
              dekInfoAlgorithm = "RC2-64-CBC";
              break;
            case 128:
              dekInfoAlgorithm = "RC2-CBC";
              break;
            default:
              throw new UnsupportedAlgorithmError(`Unsupported RC2 bits parameter with value '${encryptionScheme.bits}'`);
          }
          break;
        case "des-cbc":
        case "des-ede3-cbc":
          dekInfoAlgorithm = encryptionScheme.id.toUpperCase();
          break;
        default:
          throw new UnsupportedAlgorithmError(`Unsupported encryption scheme id '${encryptionScheme.id}'`);
      }
      const {
        encryptedData,
        effectiveEncryptionAlgorithm
      } = encryptWithPassword(pemBody, encryptionAlgorithm, password);
      return {
        pemHeaders: {
          procType: {
            version: "4",
            type: "ENCRYPTED"
          },
          dekInfo: {
            algorithm: dekInfoAlgorithm,
            parameters: uint8ArrayToHexString(effectiveEncryptionAlgorithm.encryptionScheme.iv).toUpperCase()
          }
        },
        pemBody: encryptedData
      };
    };
    maybeDecryptPemBody = (pem, password) => {
      const encrypted = pem.procType && pem.procType.type === "ENCRYPTED" && pem.dekInfo && pem.dekInfo.algorithm;
      if (!encrypted) {
        return {
          pemBody: binaryStringToUint8Array(pem.body),
          encryptionAlgorithm: null
        };
      }
      if (!password) {
        throw new MissingPasswordError("Please specify the password to decrypt the key");
      }
      return decryptPemBody(pem, password);
    };
    maybeEncryptPemBody = (pemBody, encryptionAlgorithm, password) => {
      if (!password && !encryptionAlgorithm) {
        return {
          pemHeaders: null,
          pemBody
        };
      }
      if (!password && encryptionAlgorithm) {
        throw new MissingPasswordError("An encryption algorithm was specified but no password was set");
      }
      return encryptPemBody(pemBody, encryptionAlgorithm, password);
    };
  }
});

// ../../node_modules/matcher/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "../../node_modules/matcher/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module2.exports = (string2) => {
      if (typeof string2 !== "string") {
        throw new TypeError("Expected a string");
      }
      return string2.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// ../../node_modules/matcher/index.js
var require_matcher = __commonJS({
  "../../node_modules/matcher/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var regexpCache = /* @__PURE__ */ new Map();
    function makeRegexp(pattern, options) {
      options = {
        caseSensitive: false,
        ...options
      };
      const cacheKey = pattern + JSON.stringify(options);
      if (regexpCache.has(cacheKey)) {
        return regexpCache.get(cacheKey);
      }
      const negated = pattern[0] === "!";
      if (negated) {
        pattern = pattern.slice(1);
      }
      pattern = escapeStringRegexp(pattern).replace(/\\\*/g, ".*");
      const regexp = new RegExp(`^${pattern}$`, options.caseSensitive ? "" : "i");
      regexp.negated = negated;
      regexpCache.set(cacheKey, regexp);
      return regexp;
    }
    module2.exports = (inputs, patterns, options) => {
      if (!(Array.isArray(inputs) && Array.isArray(patterns))) {
        throw new TypeError(`Expected two arrays, got ${typeof inputs} ${typeof patterns}`);
      }
      if (patterns.length === 0) {
        return inputs;
      }
      const firstNegated = patterns[0][0] === "!";
      patterns = patterns.map((pattern) => makeRegexp(pattern, options));
      const result = [];
      for (const input of inputs) {
        let matches = firstNegated;
        for (const pattern of patterns) {
          if (pattern.test(input)) {
            matches = !pattern.negated;
          }
        }
        if (matches) {
          result.push(input);
        }
      }
      return result;
    };
    module2.exports.isMatch = (input, pattern, options) => {
      const inputArray = Array.isArray(input) ? input : [input];
      const patternArray = Array.isArray(pattern) ? pattern : [pattern];
      return inputArray.some((input2) => {
        return patternArray.every((pattern2) => {
          const regexp = makeRegexp(pattern2, options);
          const matches = regexp.test(input2);
          return regexp.negated ? !matches : matches;
        });
      });
    };
  }
});

// ../../node_modules/node-forge/lib/pem.js
var require_pem3 = __commonJS({
  "../../node_modules/node-forge/lib/pem.js"(exports2, module2) {
    var forge = require_forge();
    require_util();
    var pem = module2.exports = forge.pem = forge.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i2 = 0; i2 < msg.headers.length; ++i2) {
          rval += foldHeader(msg.headers[i2]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var msg = {
          type: match[1],
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li2 = 0;
        while (match && li2 < lines.length) {
          var line = lines[li2].replace(/\s+$/, "");
          for (var nl2 = li2 + 1; nl2 < lines.length; ++nl2) {
            var next = lines[nl2];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li2 = nl2;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values = match[2].split(",");
            for (var vi2 = 0; vi2 < values.length; ++vi2) {
              header.values.push(ltrim(values[vi2]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li2;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = function(match, $1) {
        return " " + $1;
      };
      for (var i2 = 0; i2 < header.values.length; ++i2) {
        values.push(header.values[i2].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length2 = 0;
      var candidate = -1;
      for (var i2 = 0; i2 < rval.length; ++i2, ++length2) {
        if (length2 > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length2 = i2 - candidate - 1;
          candidate = -1;
          ++i2;
        } else if (rval[i2] === " " || rval[i2] === "	" || rval[i2] === ",") {
          candidate = i2;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});

// ../../node_modules/crypto-key-composer/es/util/pem-encoder.js
var import_matcher, import_pem, decodePem, encodePem;
var init_pem_encoder = __esm({
  "../../node_modules/crypto-key-composer/es/util/pem-encoder.js"() {
    import_matcher = __toESM(require_matcher());
    import_pem = __toESM(require_pem3());
    init_errors();
    init_binary();
    decodePem = (pem, patterns) => {
      if (pem instanceof Uint8Array) {
        pem = uint8ArrayToBinaryString(pem);
      }
      let decodedPem;
      try {
        decodedPem = (0, import_pem.decode)(pem);
      } catch (err) {
        throw new DecodePemFailedError("Failed to decode PEM", {
          originalError: err
        });
      }
      if (!patterns) {
        return decodedPem[0];
      }
      patterns = Array.isArray(patterns) ? patterns : [patterns];
      const pemMessage = decodedPem.find((msg) => (0, import_matcher.default)([msg.type], patterns, {
        caseSensitive: true
      }).length > 0);
      if (!pemMessage) {
        throw new DecodePemFailedError(`Could not find pem message matching patterns: '${patterns.join("', '")}'`);
      }
      return pemMessage;
    };
    encodePem = (decodedPem) => {
      let pem;
      try {
        pem = (0, import_pem.encode)(decodedPem);
      } catch (err) {
        throw new EncodePemFailedError("Failed to encode PEM", {
          originalError: err
        });
      }
      pem = pem.replace(/\r/g, "");
      return pem;
    };
  }
});

// ../../node_modules/crypto-key-composer/es/formats/pkcs1/pkcs1-pem.js
var pkcs1_pem_exports = {};
__export(pkcs1_pem_exports, {
  composePrivateKey: () => composePrivateKey2,
  decomposePrivateKey: () => decomposePrivateKey2
});
var decomposePrivateKey2, composePrivateKey2;
var init_pkcs1_pem = __esm({
  "../../node_modules/crypto-key-composer/es/formats/pkcs1/pkcs1-pem.js"() {
    init_encryption();
    init_pkcs1_der();
    init_pem_encoder();
    init_binary();
    init_errors();
    decomposePrivateKey2 = (pem, options) => {
      let decodedPem;
      try {
        decodedPem = decodePem(pem, "RSA PRIVATE KEY");
      } catch (err) {
        err.invalidInputKey = err instanceof DecodePemFailedError;
        throw err;
      }
      const {
        pemBody: pkcs1Key,
        encryptionAlgorithm
      } = maybeDecryptPemBody(decodedPem, options.password);
      const decomposedKey = decomposePrivateKey(pkcs1Key, options);
      decomposedKey.encryptionAlgorithm = encryptionAlgorithm;
      decomposedKey.format = "pkcs1-pem";
      return decomposedKey;
    };
    composePrivateKey2 = ({
      encryptionAlgorithm,
      ...decomposedKey
    }, options) => {
      const pkcs1Key = composePrivateKey(decomposedKey, options);
      const {
        pemBody,
        pemHeaders
      } = maybeEncryptPemBody(pkcs1Key, encryptionAlgorithm, options.password);
      return encodePem({
        type: "RSA PRIVATE KEY",
        body: uint8ArrayToBinaryString(pemBody),
        ...pemHeaders
      });
    };
  }
});

// ../../node_modules/crypto-key-composer/es/formats/pkcs8/keys.js
var decomposeRsaPrivateKeyInfo, composeRsaPrivateKeyInfo, decomposeEcPrivateKeyInfo, composeEcPrivateKeyInfo, decomposeEd25519PrivateKeyInfo, composeEd25519PrivateKeyInfo, decomposePrivateKeyInfo, composePrivateKeyInfo;
var init_keys2 = __esm({
  "../../node_modules/crypto-key-composer/es/formats/pkcs8/keys.js"() {
    init_keys();
    init_asn1_encoder();
    init_asn1_entities();
    init_ec();
    init_binary();
    init_errors();
    init_oids();
    init_key_types();
    decomposeRsaPrivateKeyInfo = (privateKeyInfo) => {
      const {
        privateKeyAlgorithm,
        privateKey: privateKeyAsn1
      } = privateKeyInfo;
      const keyAlgorithm = {
        id: OIDS[privateKeyAlgorithm.id]
      };
      switch (keyAlgorithm.id) {
        case "rsa-encryption":
        case "md2-with-rsa-encryption":
        case "md4-with-rsa-encryption":
        case "md5-with-rsa-encryption":
        case "sha1-with-rsa-encryption":
        case "sha224-with-rsa-encryption":
        case "sha256-with-rsa-encryption":
        case "sha384-with-rsa-encryption":
        case "sha512-with-rsa-encryption":
        case "sha512-224-with-rsa-encryption":
        case "sha512-256-with-rsa-encryption":
          break;
        case "rsaes-oaep":
          throw new UnsupportedAlgorithmError("RSA-OAEP keys are not yet supported");
        case "rsassa-pss":
          throw new UnsupportedAlgorithmError("RSA-PSS keys are not yet supported");
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key algorithm OID '${privateKeyAlgorithm.id}'`);
      }
      const {
        keyData
      } = decomposeRsaPrivateKey(privateKeyAsn1);
      return {
        keyAlgorithm: {
          id: OIDS[privateKeyAlgorithm.id]
        },
        keyData
      };
    };
    composeRsaPrivateKeyInfo = (keyAlgorithm, keyData) => {
      const rsaPrivateKeyAsn1 = composeRsaPrivateKey(keyAlgorithm, keyData);
      return {
        version: 0,
        privateKeyAlgorithm: {
          id: FLIPPED_OIDS[keyAlgorithm.id],
          parameters: hexStringToUint8Array("0500")
        },
        privateKey: rsaPrivateKeyAsn1
      };
    };
    decomposeEcPrivateKeyInfo = (privateKeyInfo) => {
      const {
        privateKeyAlgorithm,
        privateKey: privateKeyAsn1
      } = privateKeyInfo;
      const ecParameters = decodeAsn1(privateKeyAlgorithm.parameters, EcParameters);
      const ecPrivateKey = decodeAsn1(privateKeyAsn1, EcPrivateKey);
      if (ecParameters.type !== "namedCurve") {
        throw new UnsupportedAlgorithmError("Only EC named curves are supported");
      }
      if (!ecPrivateKey.publicKey) {
        throw new UnsupportedAlgorithmError("Missing publicKey from ECPrivateKey");
      }
      const namedCurve = OIDS[ecParameters.value];
      if (!namedCurve) {
        throw new UnsupportedAlgorithmError(`Unsupported named curve OID '${ecParameters.value}'`);
      }
      const {
        x: x3,
        y: y2
      } = decodeEcPoint(namedCurve, ecPrivateKey.publicKey.data);
      return {
        keyAlgorithm: {
          id: "ec-public-key",
          namedCurve
        },
        keyData: {
          d: ecPrivateKey.privateKey,
          x: x3,
          y: y2
        }
      };
    };
    composeEcPrivateKeyInfo = (keyAlgorithm, keyData) => {
      const namedCurveOid = FLIPPED_OIDS[keyAlgorithm.namedCurve];
      if (!namedCurveOid) {
        throw new UnsupportedAlgorithmError(`Unsupported named curve '${keyAlgorithm.namedCurve}'`);
      }
      const privateKey = validateEcD(keyAlgorithm.namedCurve, keyData.d);
      const publicKey = encodeEcPoint(keyAlgorithm.namedCurve, keyData.x, keyData.y);
      const ecPrivateKey = {
        version: 1,
        privateKey,
        publicKey: {
          unused: 0,
          data: publicKey
        }
      };
      const ecPrivateKeyAsn1 = encodeAsn1(ecPrivateKey, EcPrivateKey);
      const ecParametersAsn1 = encodeAsn1({
        type: "namedCurve",
        value: namedCurveOid
      }, EcParameters);
      return {
        version: 0,
        privateKeyAlgorithm: {
          id: FLIPPED_OIDS[keyAlgorithm.id],
          parameters: ecParametersAsn1
        },
        privateKey: ecPrivateKeyAsn1
      };
    };
    decomposeEd25519PrivateKeyInfo = (privateKeyInfo) => {
      const {
        privateKeyAlgorithm,
        privateKey
      } = privateKeyInfo;
      const seed = decodeAsn1(privateKey, CurvePrivateKey);
      return {
        keyAlgorithm: {
          id: OIDS[privateKeyAlgorithm.id]
        },
        keyData: {
          seed
        }
      };
    };
    composeEd25519PrivateKeyInfo = (keyAlgorithm, keyData) => ({
      version: 0,
      privateKeyAlgorithm: {
        id: FLIPPED_OIDS[keyAlgorithm.id]
      },
      privateKey: encodeAsn1(keyData.seed, CurvePrivateKey)
    });
    decomposePrivateKeyInfo = (privateKeyInfo) => {
      const keyType = KEY_TYPES[OIDS[privateKeyInfo.privateKeyAlgorithm.id]];
      switch (keyType) {
        case "rsa":
          return decomposeRsaPrivateKeyInfo(privateKeyInfo);
        case "ec":
          return decomposeEcPrivateKeyInfo(privateKeyInfo);
        case "ed25519":
          return decomposeEd25519PrivateKeyInfo(privateKeyInfo);
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key algorithm OID '${privateKeyInfo.privateKeyAlgorithm.id}'`);
      }
    };
    composePrivateKeyInfo = (keyAlgorithm, keyData) => {
      const keyType = KEY_TYPES[keyAlgorithm.id];
      switch (keyType) {
        case "rsa":
          return composeRsaPrivateKeyInfo(keyAlgorithm, keyData);
        case "ec":
          return composeEcPrivateKeyInfo(keyAlgorithm, keyData);
        case "ed25519":
          return composeEd25519PrivateKeyInfo(keyAlgorithm, keyData);
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key algorithm id '${keyAlgorithm.id}'`);
      }
    };
  }
});

// ../../node_modules/crypto-key-composer/es/formats/pkcs8/encryption.js
var decryptWithPBES2, encryptWithPBES2, maybeDecryptPrivateKeyInfo, maybeEncryptPrivateKeyInfo;
var init_encryption2 = __esm({
  "../../node_modules/crypto-key-composer/es/formats/pkcs8/encryption.js"() {
    init_asn1_encoder();
    init_asn1_entities();
    init_pbe();
    init_binary();
    init_errors();
    init_validator();
    init_oids();
    decryptWithPBES2 = (encryptedData, encryptionAlgorithmParamsAsn1, password) => {
      const {
        keyDerivationFunc,
        encryptionScheme
      } = decodeAsn1(encryptionAlgorithmParamsAsn1, Pbes2Algorithms);
      const keyDerivationFuncId = OIDS[keyDerivationFunc.id];
      const encryptionSchemeId = OIDS[encryptionScheme.id];
      const effectiveKeyDerivationFunc = {
        id: keyDerivationFuncId
      };
      const effectiveEncryptionScheme = {
        id: encryptionSchemeId
      };
      switch (encryptionSchemeId) {
        case "aes128-cbc":
        case "aes192-cbc":
        case "aes256-cbc":
        case "des-ede3-cbc":
        case "des-cbc":
          effectiveEncryptionScheme.iv = decodeAsn1(encryptionScheme.parameters, Pbes2EsParams[encryptionSchemeId]);
          break;
        case "rc2-cbc": {
          const rc2CBCParameter = decodeAsn1(encryptionScheme.parameters, Rc2CbcParameter);
          const rc2ParameterVersion = uint8ArrayToInteger(rc2CBCParameter.rc2ParameterVersion);
          effectiveEncryptionScheme.iv = rc2CBCParameter.iv;
          switch (rc2ParameterVersion) {
            case 160:
              effectiveEncryptionScheme.bits = 40;
              break;
            case 120:
              effectiveEncryptionScheme.bits = 64;
              break;
            case 58:
              effectiveEncryptionScheme.bits = 128;
              break;
            default:
              throw new UnsupportedAlgorithmError(`Unsupported RC2 version parameter with value '${rc2ParameterVersion}'`);
          }
          break;
        }
        default:
          throw new UnsupportedAlgorithmError(`Unsupported encryption scheme algorithm OID '${encryptionScheme.id}'`);
      }
      switch (keyDerivationFuncId) {
        case "pbkdf2": {
          const pbkdf2Params = decodeAsn1(keyDerivationFunc.parameters, Pbkdf2Params);
          const prfId = OIDS[pbkdf2Params.prf.id];
          if (pbkdf2Params.salt.type !== "specified") {
            throw new UnsupportedAlgorithmError("Only 'specified' salts are supported in PBKDF2");
          }
          if (!prfId) {
            throw new UnsupportedAlgorithmError(`Unsupported prf algorithm OID '${pbkdf2Params.prf.id}'`);
          }
          effectiveKeyDerivationFunc.salt = pbkdf2Params.salt.value;
          effectiveKeyDerivationFunc.iterationCount = uint8ArrayToInteger(pbkdf2Params.iterationCount);
          effectiveKeyDerivationFunc.prf = prfId;
          if (pbkdf2Params.keyLength) {
            effectiveKeyDerivationFunc.keyLength = uint8ArrayToInteger(pbkdf2Params.keyLength);
          }
          break;
        }
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key derivation function algorithm OID '${keyDerivationFunc.id}'`);
      }
      const encryptionAlgorithm = {
        keyDerivationFunc: effectiveKeyDerivationFunc,
        encryptionScheme: effectiveEncryptionScheme
      };
      const decryptedData = decryptWithPassword(encryptedData, encryptionAlgorithm, password);
      return {
        encryptionAlgorithm,
        decryptedData
      };
    };
    encryptWithPBES2 = (data, encryptionAlgorithm, password) => {
      encryptionAlgorithm = validateEncryptionAlgorithm(encryptionAlgorithm, "pbkdf2", "aes256-cbc");
      const {
        keyDerivationFunc,
        encryptionScheme
      } = encryptionAlgorithm;
      let encodeEncryptionSchemeAsn1ParamsFn;
      let encodeKeyDerivationFuncAsn1ParamsFn;
      switch (encryptionScheme.id) {
        case "aes128-cbc":
        case "aes192-cbc":
        case "aes256-cbc":
        case "des-ede3-cbc":
        case "des-cbc":
          encodeEncryptionSchemeAsn1ParamsFn = ({
            iv: iv2
          }) => encodeAsn1(iv2, Pbes2EsParams[encryptionScheme.id]);
          break;
        case "rc2-cbc":
          encodeEncryptionSchemeAsn1ParamsFn = ({
            iv: iv2,
            bits
          }) => {
            let rc2ParameterVersion;
            switch (bits) {
              case 40:
                rc2ParameterVersion = 160;
                break;
              case 64:
                rc2ParameterVersion = 120;
                break;
              case 128:
                rc2ParameterVersion = 58;
                break;
              default:
                throw new UnsupportedAlgorithmError(`Unsupported RC2 bits parameter with value '${rc2ParameterVersion}'`);
            }
            return encodeAsn1({
              iv: iv2,
              rc2ParameterVersion
            }, Rc2CbcParameter);
          };
          break;
        default:
          throw new UnsupportedAlgorithmError(`Unsupported encryption scheme id '${encryptionScheme.id}'`);
      }
      switch (keyDerivationFunc.id) {
        case "pbkdf2":
          encodeKeyDerivationFuncAsn1ParamsFn = ({
            salt,
            iterationCount,
            prf
          }) => encodeAsn1({
            salt: {
              type: "specified",
              value: salt
            },
            iterationCount,
            keyLength: keyDerivationFunc.keyLength,
            prf: {
              id: FLIPPED_OIDS[prf],
              parameters: hexStringToUint8Array("0500")
            }
          }, Pbkdf2Params);
          break;
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key derivation function id '${keyDerivationFunc.id}'`);
      }
      const {
        encryptedData,
        effectiveEncryptionAlgorithm
      } = encryptWithPassword(data, encryptionAlgorithm, password);
      const encryptionAlgorithmParamsAsn1 = encodeAsn1({
        keyDerivationFunc: {
          id: FLIPPED_OIDS[keyDerivationFunc.id],
          parameters: encodeKeyDerivationFuncAsn1ParamsFn(effectiveEncryptionAlgorithm.keyDerivationFunc)
        },
        encryptionScheme: {
          id: FLIPPED_OIDS[encryptionScheme.id],
          parameters: encodeEncryptionSchemeAsn1ParamsFn(effectiveEncryptionAlgorithm.encryptionScheme)
        }
      }, Pbes2Algorithms);
      return {
        encryptionAlgorithmParamsAsn1,
        encryptedData
      };
    };
    maybeDecryptPrivateKeyInfo = (encryptedPrivateKeyInfoAsn1, password) => {
      let encryptedPrivateKeyInfo;
      try {
        encryptedPrivateKeyInfo = decodeAsn1(encryptedPrivateKeyInfoAsn1, EncryptedPrivateKeyInfo);
      } catch (err) {
        if (err instanceof DecodeAsn1FailedError) {
          return {
            encryptionAlgorithm: null,
            privateKeyInfoAsn1: encryptedPrivateKeyInfoAsn1
          };
        }
        throw err;
      }
      if (!password) {
        throw new MissingPasswordError("Please specify the password to decrypt the key");
      }
      const {
        encryptionAlgorithm,
        encryptedData
      } = encryptedPrivateKeyInfo;
      const encryptionAlgorithmId = OIDS[encryptionAlgorithm.id];
      const encryptionAlgorithmParamsAsn1 = encryptionAlgorithm.parameters;
      let decryptionResult;
      switch (encryptionAlgorithmId) {
        case "pbes2":
          decryptionResult = decryptWithPBES2(encryptedData, encryptionAlgorithmParamsAsn1, password);
          break;
        default:
          throw new UnsupportedAlgorithmError(`Unsupported encryption algorithm OID '${encryptionAlgorithm.id}'`);
      }
      return {
        encryptionAlgorithm: decryptionResult.encryptionAlgorithm,
        privateKeyInfoAsn1: decryptionResult.decryptedData
      };
    };
    maybeEncryptPrivateKeyInfo = (privateKeyInfoAsn1, encryptionAlgorithm, password) => {
      if (!password && !encryptionAlgorithm) {
        return privateKeyInfoAsn1;
      }
      if (!password && encryptionAlgorithm) {
        throw new MissingPasswordError("An encryption algorithm was specified but no password was set");
      }
      const {
        encryptedData,
        encryptionAlgorithmParamsAsn1
      } = encryptWithPBES2(privateKeyInfoAsn1, encryptionAlgorithm, password);
      const encryptedPrivateKeyInfoAsn1 = encodeAsn1({
        encryptionAlgorithm: {
          id: FLIPPED_OIDS.pbes2,
          parameters: encryptionAlgorithmParamsAsn1
        },
        encryptedData
      }, EncryptedPrivateKeyInfo);
      return encryptedPrivateKeyInfoAsn1;
    };
  }
});

// ../../node_modules/crypto-key-composer/es/formats/pkcs8/pkcs8-der.js
var pkcs8_der_exports = {};
__export(pkcs8_der_exports, {
  composePrivateKey: () => composePrivateKey3,
  decomposePrivateKey: () => decomposePrivateKey3
});
var decomposePrivateKey3, composePrivateKey3;
var init_pkcs8_der = __esm({
  "../../node_modules/crypto-key-composer/es/formats/pkcs8/pkcs8-der.js"() {
    init_keys2();
    init_encryption2();
    init_asn1_encoder();
    init_asn1_entities();
    init_errors();
    decomposePrivateKey3 = (encryptedPrivateKeyInfoAsn1, options) => {
      const {
        privateKeyInfoAsn1,
        encryptionAlgorithm
      } = maybeDecryptPrivateKeyInfo(encryptedPrivateKeyInfoAsn1, options.password);
      let privateKeyInfo;
      try {
        privateKeyInfo = decodeAsn1(privateKeyInfoAsn1, PrivateKeyInfo);
      } catch (err) {
        err.invalidInputKey = err instanceof DecodeAsn1FailedError;
        throw err;
      }
      const {
        keyAlgorithm,
        keyData
      } = decomposePrivateKeyInfo(privateKeyInfo);
      return {
        format: "pkcs8-der",
        keyAlgorithm,
        keyData,
        encryptionAlgorithm
      };
    };
    composePrivateKey3 = ({
      keyAlgorithm,
      keyData,
      encryptionAlgorithm
    }, options) => {
      const privateKeyInfo = composePrivateKeyInfo(keyAlgorithm, keyData);
      const privateKeyInfoAsn1 = encodeAsn1(privateKeyInfo, PrivateKeyInfo);
      const encryptedPrivateKeyInfoAsn1 = maybeEncryptPrivateKeyInfo(privateKeyInfoAsn1, encryptionAlgorithm, options.password);
      return encryptedPrivateKeyInfoAsn1;
    };
  }
});

// ../../node_modules/crypto-key-composer/es/formats/pkcs8/pkcs8-pem.js
var pkcs8_pem_exports = {};
__export(pkcs8_pem_exports, {
  composePrivateKey: () => composePrivateKey4,
  decomposePrivateKey: () => decomposePrivateKey4
});
var decomposePrivateKey4, composePrivateKey4;
var init_pkcs8_pem = __esm({
  "../../node_modules/crypto-key-composer/es/formats/pkcs8/pkcs8-pem.js"() {
    init_pkcs8_der();
    init_binary();
    init_pem_encoder();
    init_errors();
    decomposePrivateKey4 = (pem, options) => {
      let decodedPem;
      try {
        decodedPem = decodePem(pem, ["PRIVATE KEY", "ENCRYPTED PRIVATE KEY"]);
      } catch (err) {
        err.invalidInputKey = err instanceof DecodePemFailedError;
        throw err;
      }
      const pkcs8Key = binaryStringToUint8Array(decodedPem.body);
      const decomposedKey = decomposePrivateKey3(pkcs8Key, options);
      decomposedKey.format = "pkcs8-pem";
      return decomposedKey;
    };
    composePrivateKey4 = (decomposedKey, options) => {
      const pkcs8Key = composePrivateKey3(decomposedKey, options);
      return encodePem({
        type: options.password ? "ENCRYPTED PRIVATE KEY" : "PRIVATE KEY",
        body: uint8ArrayToBinaryString(pkcs8Key)
      });
    };
  }
});

// ../../node_modules/crypto-key-composer/es/formats/raw/raw-der.js
var raw_der_exports = {};
__export(raw_der_exports, {
  composePrivateKey: () => composePrivateKey5,
  composePublicKey: () => composePublicKey,
  decomposePrivateKey: () => decomposePrivateKey5,
  decomposePublicKey: () => decomposePublicKey
});
var decomposePrivateKey5, composePrivateKey5, decomposePublicKey, composePublicKey;
var init_raw_der = __esm({
  "../../node_modules/crypto-key-composer/es/formats/raw/raw-der.js"() {
    init_keys();
    init_errors();
    decomposePrivateKey5 = (privateKeyAsn1) => {
      let decomposedKey;
      const errors = {};
      for (const keyType of SUPPORTED_KEY_TYPES.private) {
        try {
          decomposedKey = decomposeRawPrivateKey(keyType, privateKeyAsn1);
          break;
        } catch (err) {
          if (err instanceof DecodeAsn1FailedError) {
            errors[keyType] = err;
          } else {
            throw err;
          }
        }
      }
      if (!decomposedKey) {
        throw new AggregatedError(`The input key is not one of: ${SUPPORTED_KEY_TYPES.private.join(", ")}`, errors, {
          invalidInputKey: true
        });
      }
      const {
        keyAlgorithm,
        keyData
      } = decomposedKey;
      return {
        format: "raw-der",
        encryptionAlgorithm: null,
        keyAlgorithm,
        keyData
      };
    };
    composePrivateKey5 = ({
      keyAlgorithm,
      keyData,
      encryptionAlgorithm
    }) => {
      if (encryptionAlgorithm) {
        throw new UnsupportedAlgorithmError("The RAW DER format does not support encryption");
      }
      return composeRawPrivateKey(keyAlgorithm, keyData);
    };
    decomposePublicKey = (publicKeyAsn1) => {
      let decomposedKey;
      const errors = {};
      for (const keyType of SUPPORTED_KEY_TYPES.public) {
        try {
          decomposedKey = decomposeRawPublicKey(keyType, publicKeyAsn1);
          break;
        } catch (err) {
          if (err instanceof DecodeAsn1FailedError) {
            errors[keyType] = err;
          } else {
            throw err;
          }
        }
      }
      if (!decomposedKey) {
        throw new AggregatedError(`The input key is not one of: ${SUPPORTED_KEY_TYPES.public.join(", ")}`, errors, {
          invalidInputKey: true
        });
      }
      const {
        keyAlgorithm,
        keyData
      } = decomposedKey;
      return {
        format: "raw-der",
        keyAlgorithm,
        keyData
      };
    };
    composePublicKey = ({
      keyAlgorithm,
      keyData
    }) => composeRawPublicKey(keyAlgorithm, keyData);
  }
});

// ../../node_modules/crypto-key-composer/es/formats/raw/raw-pem.js
var raw_pem_exports = {};
__export(raw_pem_exports, {
  composePrivateKey: () => composePrivateKey6,
  composePublicKey: () => composePublicKey2,
  decomposePrivateKey: () => decomposePrivateKey6,
  decomposePublicKey: () => decomposePublicKey2
});
var getKeyType, getPemType, decomposePrivateKey6, composePrivateKey6, decomposePublicKey2, composePublicKey2;
var init_raw_pem = __esm({
  "../../node_modules/crypto-key-composer/es/formats/raw/raw-pem.js"() {
    init_encryption();
    init_keys();
    init_binary();
    init_pem_encoder();
    init_errors();
    init_key_types();
    getKeyType = (pemType) => {
      const match = /^(\S+?) (PUBLIC|PRIVATE) KEY$/.exec(pemType);
      return match && match[1].toLocaleLowerCase();
    };
    getPemType = (keyAlgorithm) => {
      const keyType = KEY_TYPES[keyAlgorithm.id];
      return keyType && keyType.toUpperCase();
    };
    decomposePrivateKey6 = (pem, options) => {
      let decodedPem;
      try {
        decodedPem = decodePem(pem, "* PRIVATE KEY");
      } catch (err) {
        err.invalidInputKey = err instanceof DecodePemFailedError;
        throw err;
      }
      const {
        pemBody,
        encryptionAlgorithm
      } = maybeDecryptPemBody(decodedPem, options.password);
      const keyType = getKeyType(decodedPem.type);
      if (!keyType) {
        throw new DecodePemFailedError("Unable to extract key type from PEM", {
          invalidInputKey: true
        });
      }
      const {
        keyAlgorithm,
        keyData
      } = decomposeRawPrivateKey(keyType, pemBody);
      return {
        format: "raw-pem",
        keyAlgorithm,
        keyData,
        encryptionAlgorithm
      };
    };
    composePrivateKey6 = ({
      keyAlgorithm,
      keyData,
      encryptionAlgorithm
    }, options) => {
      const rawKey = composeRawPrivateKey(keyAlgorithm, keyData);
      const pemKeyType = getPemType(keyAlgorithm);
      if (!pemKeyType) {
        throw new UnsupportedAlgorithmError("Unable to extract pem type from key algorithm");
      }
      const {
        pemBody,
        pemHeaders
      } = maybeEncryptPemBody(rawKey, encryptionAlgorithm, options.password);
      return encodePem({
        type: `${pemKeyType} PRIVATE KEY`,
        body: uint8ArrayToBinaryString(pemBody),
        ...pemHeaders
      });
    };
    decomposePublicKey2 = (pem) => {
      let decodedPem;
      try {
        decodedPem = decodePem(pem);
      } catch (err) {
        err.invalidInputKey = err instanceof DecodePemFailedError;
        throw err;
      }
      const keyType = getKeyType(decodedPem.type);
      if (!keyType) {
        throw new DecodePemFailedError("Unable to extract key type from PEM", {
          invalidInputKey: true
        });
      }
      const pemBody = binaryStringToUint8Array(decodedPem.body);
      const {
        keyAlgorithm,
        keyData
      } = decomposeRawPublicKey(keyType, pemBody);
      return {
        format: "raw-pem",
        keyAlgorithm,
        keyData
      };
    };
    composePublicKey2 = ({
      keyAlgorithm,
      keyData
    }) => {
      const rawKey = composeRawPublicKey(keyAlgorithm, keyData);
      const pemKeyType = getPemType(keyAlgorithm);
      if (!pemKeyType) {
        throw new UnsupportedAlgorithmError("Unable to extract pem type from key algorithm");
      }
      return encodePem({
        type: `${pemKeyType} PUBLIC KEY`,
        body: uint8ArrayToBinaryString(rawKey)
      });
    };
  }
});

// ../../node_modules/crypto-key-composer/es/formats/spki/keys.js
var decomposeRsaSubjectPublicKeyInfo, composeRsaSubjectPublicKeyInfo, decomposeEcSubjectPublicKeyInfo, composeEcSubjectPublicKeyInfo, decomposeEd25519SubjectPublicKeyInfo, composeEd25519SubjectPublicKeyInfo, decomposeSubjectPublicKeyInfo, composeSubjectPublicKeyInfo;
var init_keys3 = __esm({
  "../../node_modules/crypto-key-composer/es/formats/spki/keys.js"() {
    init_keys();
    init_asn1_encoder();
    init_asn1_entities();
    init_ec();
    init_binary();
    init_errors();
    init_oids();
    init_key_types();
    decomposeRsaSubjectPublicKeyInfo = (subjectPublicKeyInfo) => {
      const {
        algorithm,
        publicKey: publicKeyAsn1
      } = subjectPublicKeyInfo;
      const keyAlgorithm = {
        id: OIDS[algorithm.id]
      };
      switch (keyAlgorithm.id) {
        case "rsa-encryption":
        case "md2-with-rsa-encryption":
        case "md4-with-rsa-encryption":
        case "md5-with-rsa-encryption":
        case "sha1-with-rsa-encryption":
        case "sha224-with-rsa-encryption":
        case "sha256-with-rsa-encryption":
        case "sha384-with-rsa-encryption":
        case "sha512-with-rsa-encryption":
        case "sha512-224-with-rsa-encryption":
        case "sha512-256-with-rsa-encryption":
          break;
        case "rsaes-oaep":
          throw new UnsupportedAlgorithmError("RSA-OAEP keys are not yet supported");
        case "rsassa-pss":
          throw new UnsupportedAlgorithmError("RSA-PSS keys are not yet supported");
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key algorithm OID '${algorithm.id}'`);
      }
      const {
        keyData
      } = decomposeRsaPublicKey(publicKeyAsn1.data);
      return {
        keyAlgorithm: {
          id: OIDS[algorithm.id]
        },
        keyData
      };
    };
    composeRsaSubjectPublicKeyInfo = (keyAlgorithm, keyData) => {
      const rsaPublicKeyAsn1 = composeRsaPublicKey(keyAlgorithm, keyData);
      return {
        algorithm: {
          id: FLIPPED_OIDS[keyAlgorithm.id],
          parameters: hexStringToUint8Array("0500")
        },
        publicKey: {
          unused: 0,
          data: rsaPublicKeyAsn1
        }
      };
    };
    decomposeEcSubjectPublicKeyInfo = (subjectPublicKeyInfo) => {
      const {
        algorithm,
        publicKey
      } = subjectPublicKeyInfo;
      const ecParameters = decodeAsn1(algorithm.parameters, EcParameters);
      if (ecParameters.type !== "namedCurve") {
        throw new UnsupportedAlgorithmError("Only EC named curves are supported");
      }
      const namedCurve = OIDS[ecParameters.value];
      if (!namedCurve) {
        throw new UnsupportedAlgorithmError(`Unsupported named curve OID '${ecParameters.value}'`);
      }
      const {
        x: x3,
        y: y2
      } = decodeEcPoint(namedCurve, publicKey.data);
      return {
        keyAlgorithm: {
          id: "ec-public-key",
          namedCurve
        },
        keyData: {
          x: x3,
          y: y2
        }
      };
    };
    composeEcSubjectPublicKeyInfo = (keyAlgorithm, keyData) => {
      const namedCurveOid = FLIPPED_OIDS[keyAlgorithm.namedCurve];
      if (!namedCurveOid) {
        throw new UnsupportedAlgorithmError(`Unsupported named curve '${keyAlgorithm.namedCurve}'`);
      }
      const encodedPoint = encodeEcPoint(keyAlgorithm.namedCurve, keyData.x, keyData.y);
      const ecParametersAsn1 = encodeAsn1({
        type: "namedCurve",
        value: namedCurveOid
      }, EcParameters);
      return {
        algorithm: {
          id: FLIPPED_OIDS[keyAlgorithm.id],
          parameters: ecParametersAsn1
        },
        publicKey: {
          unused: 0,
          data: encodedPoint
        }
      };
    };
    decomposeEd25519SubjectPublicKeyInfo = (subjectPublicKeyInfo) => {
      const {
        algorithm,
        publicKey
      } = subjectPublicKeyInfo;
      return {
        keyAlgorithm: {
          id: OIDS[algorithm.id]
        },
        keyData: {
          bytes: publicKey.data
        }
      };
    };
    composeEd25519SubjectPublicKeyInfo = (keyAlgorithm, keyData) => ({
      algorithm: {
        id: FLIPPED_OIDS[keyAlgorithm.id]
      },
      publicKey: {
        unused: 0,
        data: keyData.bytes
      }
    });
    decomposeSubjectPublicKeyInfo = (subjectPublicKeyInfo) => {
      const keyType = KEY_TYPES[OIDS[subjectPublicKeyInfo.algorithm.id]];
      switch (keyType) {
        case "rsa":
          return decomposeRsaSubjectPublicKeyInfo(subjectPublicKeyInfo);
        case "ec":
          return decomposeEcSubjectPublicKeyInfo(subjectPublicKeyInfo);
        case "ed25519":
          return decomposeEd25519SubjectPublicKeyInfo(subjectPublicKeyInfo);
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key algorithm OID '${subjectPublicKeyInfo.algorithm.id}'`);
      }
    };
    composeSubjectPublicKeyInfo = (keyAlgorithm, keyData) => {
      const keyType = KEY_TYPES[keyAlgorithm.id];
      switch (keyType) {
        case "rsa":
          return composeRsaSubjectPublicKeyInfo(keyAlgorithm, keyData);
        case "ec":
          return composeEcSubjectPublicKeyInfo(keyAlgorithm, keyData);
        case "ed25519":
          return composeEd25519SubjectPublicKeyInfo(keyAlgorithm, keyData);
        default:
          throw new UnsupportedAlgorithmError(`Unsupported key algorithm id '${keyAlgorithm.id}'`);
      }
    };
  }
});

// ../../node_modules/crypto-key-composer/es/formats/spki/spki-der.js
var spki_der_exports = {};
__export(spki_der_exports, {
  composePublicKey: () => composePublicKey3,
  decomposePublicKey: () => decomposePublicKey3
});
var decomposePublicKey3, composePublicKey3;
var init_spki_der = __esm({
  "../../node_modules/crypto-key-composer/es/formats/spki/spki-der.js"() {
    init_keys3();
    init_asn1_encoder();
    init_asn1_entities();
    init_errors();
    decomposePublicKey3 = (subjectPublicKeyInfoAsn1) => {
      let subjectPublicKeyInfo;
      try {
        subjectPublicKeyInfo = decodeAsn1(subjectPublicKeyInfoAsn1, SubjectPublicKeyInfo);
      } catch (err) {
        err.invalidInputKey = err instanceof DecodeAsn1FailedError;
        throw err;
      }
      const {
        keyAlgorithm,
        keyData
      } = decomposeSubjectPublicKeyInfo(subjectPublicKeyInfo);
      return {
        format: "spki-der",
        keyAlgorithm,
        keyData
      };
    };
    composePublicKey3 = ({
      keyAlgorithm,
      keyData
    }) => {
      const subjectPublicKeyInfo = composeSubjectPublicKeyInfo(keyAlgorithm, keyData);
      const subjectPublicKeyInfoAsn1 = encodeAsn1(subjectPublicKeyInfo, SubjectPublicKeyInfo);
      return subjectPublicKeyInfoAsn1;
    };
  }
});

// ../../node_modules/crypto-key-composer/es/formats/spki/spki-pem.js
var spki_pem_exports = {};
__export(spki_pem_exports, {
  composePublicKey: () => composePublicKey4,
  decomposePublicKey: () => decomposePublicKey4
});
var decomposePublicKey4, composePublicKey4;
var init_spki_pem = __esm({
  "../../node_modules/crypto-key-composer/es/formats/spki/spki-pem.js"() {
    init_spki_der();
    init_binary();
    init_pem_encoder();
    init_errors();
    decomposePublicKey4 = (pem, options) => {
      let decodedPem;
      try {
        decodedPem = decodePem(pem, "PUBLIC KEY");
      } catch (err) {
        err.invalidInputKey = err instanceof DecodePemFailedError;
        throw err;
      }
      const spkiKey = binaryStringToUint8Array(decodedPem.body);
      const decomposedKey = decomposePublicKey3(spkiKey, options);
      decomposedKey.format = "spki-pem";
      return decomposedKey;
    };
    composePublicKey4 = (decomposedKey) => {
      const spkiKey = composePublicKey3(decomposedKey);
      return encodePem({
        type: "PUBLIC KEY",
        body: uint8ArrayToBinaryString(spkiKey)
      });
    };
  }
});

// ../../node_modules/crypto-key-composer/es/formats/index.js
var mapPrivate, mapPublic, PRIVATE_FORMATS, PUBLIC_FORMATS;
var init_formats = __esm({
  "../../node_modules/crypto-key-composer/es/formats/index.js"() {
    init_pkcs1_der();
    init_pkcs1_pem();
    init_pkcs8_der();
    init_pkcs8_pem();
    init_raw_der();
    init_raw_pem();
    init_spki_der();
    init_spki_pem();
    mapPrivate = (format) => ({
      decomposeKey: format.decomposePrivateKey,
      composeKey: format.composePrivateKey
    });
    mapPublic = (format) => ({
      decomposeKey: format.decomposePublicKey,
      composeKey: format.composePublicKey
    });
    PRIVATE_FORMATS = {
      "pkcs1-der": mapPrivate(pkcs1_der_exports),
      "pkcs1-pem": mapPrivate(pkcs1_pem_exports),
      "pkcs8-der": mapPrivate(pkcs8_der_exports),
      "pkcs8-pem": mapPrivate(pkcs8_pem_exports),
      "raw-der": mapPrivate(raw_der_exports),
      "raw-pem": mapPrivate(raw_pem_exports)
    };
    PUBLIC_FORMATS = {
      "raw-der": mapPublic(raw_der_exports),
      "raw-pem": mapPublic(raw_pem_exports),
      "spki-der": mapPublic(spki_der_exports),
      "spki-pem": mapPublic(spki_pem_exports)
    };
  }
});

// ../../node_modules/crypto-key-composer/es/index.js
var composeKey, composePrivateKey7, composePublicKey5, getKeyTypeFromAlgorithm;
var init_es2 = __esm({
  "../../node_modules/crypto-key-composer/es/index.js"() {
    init_formats();
    init_validator();
    init_errors();
    init_key_types();
    composeKey = (supportedFormats, decomposedKey, options) => {
      decomposedKey = validateDecomposedKey(decomposedKey, supportedFormats);
      return supportedFormats[decomposedKey.format].composeKey(decomposedKey, options);
    };
    composePrivateKey7 = (decomposedKey, options) => composeKey(PRIVATE_FORMATS, decomposedKey, {
      password: null,
      ...options
    });
    composePublicKey5 = (decomposedKey) => composeKey(PUBLIC_FORMATS, decomposedKey, {});
    getKeyTypeFromAlgorithm = (keyAlgorithm) => {
      const keyAlgorithmId = typeof keyAlgorithm === "string" ? keyAlgorithm : keyAlgorithm && keyAlgorithm.id;
      return KEY_TYPES[keyAlgorithmId];
    };
  }
});

// ../../node_modules/node-forge/lib/oids.js
var require_oids = __commonJS({
  "../../node_modules/node-forge/lib/oids.js"(exports2, module2) {
    var forge = require_forge();
    forge.pki = forge.pki || {};
    var oids = module2.exports = forge.pki.oids = forge.oids = forge.oids || {};
    function _IN(id2, name2) {
      oids[id2] = name2;
      oids[name2] = id2;
    }
    function _I_(id2, name2) {
      oids[id2] = name2;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.5", "serialName");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.13", "description");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// ../../node_modules/node-forge/lib/asn1.js
var require_asn12 = __commonJS({
  "../../node_modules/node-forge/lib/asn1.js"(exports2, module2) {
    var forge = require_forge();
    require_util();
    require_oids();
    var asn12 = module2.exports = forge.asn1 = forge.asn1 || {};
    asn12.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn12.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn12.create = function(tagClass, type, constructed, value, options) {
      if (forge.util.isArray(value)) {
        var tmp = [];
        for (var i2 = 0; i2 < value.length; ++i2) {
          if (value[i2] !== void 0) {
            tmp.push(value[i2]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge.util.isArray(value),
        value
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn12.copy(obj);
      }
      return obj;
    };
    asn12.copy = function(obj, options) {
      var copy;
      if (forge.util.isArray(obj)) {
        copy = [];
        for (var i2 = 0; i2 < obj.length; ++i2) {
          copy.push(asn12.copy(obj[i2], options));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn12.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn12.equals = function(obj1, obj2, options) {
      if (forge.util.isArray(obj1)) {
        if (!forge.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i2 = 0; i2 < obj1.length; ++i2) {
          if (!asn12.equals(obj1[i2], obj2[i2])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn12.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn12.getBerValueLength = function(b2) {
      var b22 = b2.getByte();
      if (b22 === 128) {
        return void 0;
      }
      var length2;
      var longForm = b22 & 128;
      if (!longForm) {
        length2 = b22;
      } else {
        length2 = b2.getInt((b22 & 127) << 3);
      }
      return length2;
    };
    function _checkBufferLength(bytes, remaining, n2) {
      if (n2 > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes.length();
        error.remaining = remaining;
        error.requested = n2;
        throw error;
      }
    }
    var _getValueLength = function(bytes, remaining) {
      var b2 = bytes.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length2;
      var longForm = b2 & 128;
      if (!longForm) {
        length2 = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes, remaining, longFormBytes);
        length2 = bytes.getInt(longFormBytes << 3);
      }
      if (length2 < 0) {
        throw new Error("Negative length: " + length2);
      }
      return length2;
    };
    asn12.fromDer = function(bytes, options) {
      if (options === void 0) {
        options = {
          strict: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      return _fromDer(bytes, bytes.length(), 0, options);
    };
    function _fromDer(bytes, remaining, depth, options) {
      var start;
      _checkBufferLength(bytes, remaining, 2);
      var b12 = bytes.getByte();
      remaining--;
      var tagClass = b12 & 192;
      var type = b12 & 31;
      start = bytes.length();
      var length2 = _getValueLength(bytes, remaining);
      remaining -= start - bytes.length();
      if (length2 !== void 0 && length2 > remaining) {
        if (options.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes.length();
          error.remaining = remaining;
          error.requested = length2;
          throw error;
        }
        length2 = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b12 & 32) === 32;
      if (constructed) {
        value = [];
        if (length2 === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes, remaining, 2);
            if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
              bytes.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes.length();
            value.push(_fromDer(bytes, remaining, depth + 1, options));
            remaining -= start - bytes.length();
          }
        } else {
          while (length2 > 0) {
            start = bytes.length();
            value.push(_fromDer(bytes, length2, depth + 1, options));
            remaining -= start - bytes.length();
            length2 -= start - bytes.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn12.Class.UNIVERSAL && type === asn12.Type.BITSTRING) {
        bitStringContents = bytes.bytes(length2);
      }
      if (value === void 0 && options.decodeBitStrings && tagClass === asn12.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
      // .. other parts of forge expect to decode OCTET STRINGs manually
      type === asn12.Type.BITSTRING && length2 > 1) {
        var savedRead = bytes.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn12.Type.BITSTRING) {
          _checkBufferLength(bytes, remaining, 1);
          unused = bytes.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes.length();
            var subOptions = {
              // enforce strict mode to avoid parsing ASN.1 from plain data
              verbose: options.verbose,
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
            var used = start - bytes.length();
            remaining -= used;
            if (type == asn12.Type.BITSTRING) {
              used++;
            }
            var tc2 = composed.tagClass;
            if (used === length2 && (tc2 === asn12.Class.UNIVERSAL || tc2 === asn12.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length2 === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length2 = remaining;
        }
        if (type === asn12.Type.BMPSTRING) {
          value = "";
          for (; length2 > 0; length2 -= 2) {
            _checkBufferLength(bytes, remaining, 2);
            value += String.fromCharCode(bytes.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes.getBytes(length2);
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn12.create(tagClass, type, constructed, value, asn1Options);
    }
    asn12.toDer = function(obj) {
      var bytes = forge.util.createBuffer();
      var b12 = obj.tagClass | obj.type;
      var value = forge.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn12.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b12 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            value.putBuffer(asn12.toDer(obj.value[i2]));
          }
        }
      } else {
        if (obj.type === asn12.Type.BMPSTRING) {
          for (var i2 = 0; i2 < obj.value.length; ++i2) {
            value.putInt16(obj.value.charCodeAt(i2));
          }
        } else {
          if (obj.type === asn12.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
          (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes.putByte(b12);
      if (value.length() <= 127) {
        bytes.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes.putByte(lenBytes.length | 128);
        for (var i2 = lenBytes.length - 1; i2 >= 0; --i2) {
          bytes.putByte(lenBytes.charCodeAt(i2));
        }
      }
      bytes.putBuffer(value);
      return bytes;
    };
    asn12.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes = forge.util.createBuffer();
      bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last, valueBytes, value, b2;
      for (var i2 = 2; i2 < values.length; ++i2) {
        last = true;
        valueBytes = [];
        value = parseInt(values[i2], 10);
        do {
          b2 = value & 127;
          value = value >>> 7;
          if (!last) {
            b2 |= 128;
          }
          valueBytes.push(b2);
          last = false;
        } while (value > 0);
        for (var n2 = valueBytes.length - 1; n2 >= 0; --n2) {
          bytes.putByte(valueBytes[n2]);
        }
      }
      return bytes;
    };
    asn12.derToOid = function(bytes) {
      var oid;
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      var b2 = bytes.getByte();
      oid = Math.floor(b2 / 40) + "." + b2 % 40;
      var value = 0;
      while (bytes.length() > 0) {
        b2 = bytes.getByte();
        value = value << 7;
        if (b2 & 128) {
          value += b2 & 127;
        } else {
          oid += "." + (value + b2);
          value = 0;
        }
      }
      return oid;
    };
    asn12.utcTimeToDate = function(utc) {
      var date = /* @__PURE__ */ new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh2 = parseInt(utc.substr(6, 2), 10);
      var mm2 = parseInt(utc.substr(8, 2), 10);
      var ss2 = 0;
      if (utc.length > 11) {
        var c2 = utc.charAt(10);
        var end = 10;
        if (c2 !== "+" && c2 !== "-") {
          ss2 = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh2, mm2, ss2, 0);
      if (end) {
        c2 = utc.charAt(end);
        if (c2 === "+" || c2 === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c2 === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn12.generalizedTimeToDate = function(gentime) {
      var date = /* @__PURE__ */ new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh2 = parseInt(gentime.substr(8, 2), 10);
      var mm2 = parseInt(gentime.substr(10, 2), 10);
      var ss2 = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c2 = gentime.charAt(end);
      if (c2 === "+" || c2 === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c2 === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh2, mm2, ss2, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh2, mm2, ss2, fff);
      }
      return date;
    };
    asn12.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push(("" + date.getUTCFullYear()).substr(2));
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format.length; ++i2) {
        if (format[i2].length < 2) {
          rval += "0";
        }
        rval += format[i2];
      }
      rval += "Z";
      return rval;
    };
    asn12.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push("" + date.getUTCFullYear());
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format.length; ++i2) {
        if (format[i2].length < 2) {
          rval += "0";
        }
        rval += format[i2];
      }
      rval += "Z";
      return rval;
    };
    asn12.integerToDer = function(x3) {
      var rval = forge.util.createBuffer();
      if (x3 >= -128 && x3 < 128) {
        return rval.putSignedInt(x3, 8);
      }
      if (x3 >= -32768 && x3 < 32768) {
        return rval.putSignedInt(x3, 16);
      }
      if (x3 >= -8388608 && x3 < 8388608) {
        return rval.putSignedInt(x3, 24);
      }
      if (x3 >= -2147483648 && x3 < 2147483648) {
        return rval.putSignedInt(x3, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x3;
      throw error;
    };
    asn12.derToInteger = function(bytes) {
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      var n2 = bytes.length() * 8;
      if (n2 > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes.getSignedInt(n2);
    };
    asn12.validate = function(obj, v3, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v3.tagClass || typeof v3.tagClass === "undefined") && (obj.type === v3.type || typeof v3.type === "undefined")) {
        if (obj.constructed === v3.constructed || typeof v3.constructed === "undefined") {
          rval = true;
          if (v3.value && forge.util.isArray(v3.value)) {
            var j2 = 0;
            for (var i2 = 0; rval && i2 < v3.value.length; ++i2) {
              rval = v3.value[i2].optional || false;
              if (obj.value[j2]) {
                rval = asn12.validate(obj.value[j2], v3.value[i2], capture, errors);
                if (rval) {
                  ++j2;
                } else if (v3.value[i2].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push(
                  "[" + v3.name + '] Tag class "' + v3.tagClass + '", type "' + v3.type + '" expected value length "' + v3.value.length + '", got "' + obj.value.length + '"'
                );
              }
            }
          }
          if (rval && capture) {
            if (v3.capture) {
              capture[v3.capture] = obj.value;
            }
            if (v3.captureAsn1) {
              capture[v3.captureAsn1] = obj;
            }
            if (v3.captureBitStringContents && "bitStringContents" in obj) {
              capture[v3.captureBitStringContents] = obj.bitStringContents;
            }
            if (v3.captureBitStringValue && "bitStringContents" in obj) {
              var value;
              if (obj.bitStringContents.length < 2) {
                capture[v3.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error(
                    "captureBitStringValue only supported for zero unused bits"
                  );
                }
                capture[v3.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors) {
          errors.push(
            "[" + v3.name + '] Expected constructed "' + v3.constructed + '", got "' + obj.constructed + '"'
          );
        }
      } else if (errors) {
        if (obj.tagClass !== v3.tagClass) {
          errors.push(
            "[" + v3.name + '] Expected tag class "' + v3.tagClass + '", got "' + obj.tagClass + '"'
          );
        }
        if (obj.type !== v3.type) {
          errors.push(
            "[" + v3.name + '] Expected type "' + v3.type + '", got "' + obj.type + '"'
          );
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn12.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i2 = 0; i2 < level * indentation; ++i2) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn12.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn12.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn12.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn12.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn12.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn12.Type.NONE:
            rval += " (None)";
            break;
          case asn12.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn12.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn12.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn12.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn12.Type.NULL:
            rval += " (Null)";
            break;
          case asn12.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn12.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn12.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn12.Type.REAL:
            rval += " (Real)";
            break;
          case asn12.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn12.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn12.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn12.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn12.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn12.Type.SET:
            rval += " (Set)";
            break;
          case asn12.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn12.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn12.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn12.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn12.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            subvalues += 1;
            sub += asn12.prettyPrint(obj.value[i2], level + 1, indentation);
            if (i2 + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn12.Type.OID) {
          var oid = asn12.derToOid(obj.value);
          rval += oid;
          if (forge.pki && forge.pki.oids) {
            if (oid in forge.pki.oids) {
              rval += " (" + forge.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn12.Type.INTEGER) {
          try {
            rval += asn12.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn12.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn12.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.type === asn12.Type.UTF8) {
          rval += forge.util.decodeUtf8(obj.value);
        } else if (obj.type === asn12.Type.PRINTABLESTRING || obj.type === asn12.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// ../../node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS({
  "../../node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
    var forge = require_forge();
    module2.exports = forge.jsbn = forge.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a2, b2, c2) {
      this.data = [];
      if (a2 != null)
        if ("number" == typeof a2) this.fromNumber(a2, b2, c2);
        else if (b2 == null && "string" != typeof a2) this.fromString(a2, 256);
        else this.fromString(a2, b2);
    }
    forge.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i2, x3, w3, j2, c2, n2) {
      while (--n2 >= 0) {
        var v3 = x3 * this.data[i2++] + w3.data[j2] + c2;
        c2 = Math.floor(v3 / 67108864);
        w3.data[j2++] = v3 & 67108863;
      }
      return c2;
    }
    function am2(i2, x3, w3, j2, c2, n2) {
      var xl2 = x3 & 32767, xh2 = x3 >> 15;
      while (--n2 >= 0) {
        var l2 = this.data[i2] & 32767;
        var h2 = this.data[i2++] >> 15;
        var m2 = xh2 * l2 + h2 * xl2;
        l2 = xl2 * l2 + ((m2 & 32767) << 15) + w3.data[j2] + (c2 & 1073741823);
        c2 = (l2 >>> 30) + (m2 >>> 15) + xh2 * h2 + (c2 >>> 30);
        w3.data[j2++] = l2 & 1073741823;
      }
      return c2;
    }
    function am3(i2, x3, w3, j2, c2, n2) {
      var xl2 = x3 & 16383, xh2 = x3 >> 14;
      while (--n2 >= 0) {
        var l2 = this.data[i2] & 16383;
        var h2 = this.data[i2++] >> 14;
        var m2 = xh2 * l2 + h2 * xl2;
        l2 = xl2 * l2 + ((m2 & 16383) << 14) + w3.data[j2] + c2;
        c2 = (l2 >> 28) + (m2 >> 14) + xh2 * h2;
        w3.data[j2++] = l2 & 268435455;
      }
      return c2;
    }
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr2;
    var vv2;
    rr2 = "0".charCodeAt(0);
    for (vv2 = 0; vv2 <= 9; ++vv2) BI_RC[rr2++] = vv2;
    rr2 = "a".charCodeAt(0);
    for (vv2 = 10; vv2 < 36; ++vv2) BI_RC[rr2++] = vv2;
    rr2 = "A".charCodeAt(0);
    for (vv2 = 10; vv2 < 36; ++vv2) BI_RC[rr2++] = vv2;
    function int2char(n2) {
      return BI_RM.charAt(n2);
    }
    function intAt(s2, i2) {
      var c2 = BI_RC[s2.charCodeAt(i2)];
      return c2 == null ? -1 : c2;
    }
    function bnpCopyTo(r2) {
      for (var i2 = this.t - 1; i2 >= 0; --i2) r2.data[i2] = this.data[i2];
      r2.t = this.t;
      r2.s = this.s;
    }
    function bnpFromInt(x3) {
      this.t = 1;
      this.s = x3 < 0 ? -1 : 0;
      if (x3 > 0) this.data[0] = x3;
      else if (x3 < -1) this.data[0] = x3 + this.DV;
      else this.t = 0;
    }
    function nbv(i2) {
      var r2 = nbi();
      r2.fromInt(i2);
      return r2;
    }
    function bnpFromString(s2, b2) {
      var k2;
      if (b2 == 16) k2 = 4;
      else if (b2 == 8) k2 = 3;
      else if (b2 == 256) k2 = 8;
      else if (b2 == 2) k2 = 1;
      else if (b2 == 32) k2 = 5;
      else if (b2 == 4) k2 = 2;
      else {
        this.fromRadix(s2, b2);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i2 = s2.length, mi2 = false, sh2 = 0;
      while (--i2 >= 0) {
        var x3 = k2 == 8 ? s2[i2] & 255 : intAt(s2, i2);
        if (x3 < 0) {
          if (s2.charAt(i2) == "-") mi2 = true;
          continue;
        }
        mi2 = false;
        if (sh2 == 0)
          this.data[this.t++] = x3;
        else if (sh2 + k2 > this.DB) {
          this.data[this.t - 1] |= (x3 & (1 << this.DB - sh2) - 1) << sh2;
          this.data[this.t++] = x3 >> this.DB - sh2;
        } else
          this.data[this.t - 1] |= x3 << sh2;
        sh2 += k2;
        if (sh2 >= this.DB) sh2 -= this.DB;
      }
      if (k2 == 8 && (s2[0] & 128) != 0) {
        this.s = -1;
        if (sh2 > 0) this.data[this.t - 1] |= (1 << this.DB - sh2) - 1 << sh2;
      }
      this.clamp();
      if (mi2) BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c2 = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c2) --this.t;
    }
    function bnToString(b2) {
      if (this.s < 0) return "-" + this.negate().toString(b2);
      var k2;
      if (b2 == 16) k2 = 4;
      else if (b2 == 8) k2 = 3;
      else if (b2 == 2) k2 = 1;
      else if (b2 == 32) k2 = 5;
      else if (b2 == 4) k2 = 2;
      else return this.toRadix(b2);
      var km2 = (1 << k2) - 1, d2, m2 = false, r2 = "", i2 = this.t;
      var p2 = this.DB - i2 * this.DB % k2;
      if (i2-- > 0) {
        if (p2 < this.DB && (d2 = this.data[i2] >> p2) > 0) {
          m2 = true;
          r2 = int2char(d2);
        }
        while (i2 >= 0) {
          if (p2 < k2) {
            d2 = (this.data[i2] & (1 << p2) - 1) << k2 - p2;
            d2 |= this.data[--i2] >> (p2 += this.DB - k2);
          } else {
            d2 = this.data[i2] >> (p2 -= k2) & km2;
            if (p2 <= 0) {
              p2 += this.DB;
              --i2;
            }
          }
          if (d2 > 0) m2 = true;
          if (m2) r2 += int2char(d2);
        }
      }
      return m2 ? r2 : "0";
    }
    function bnNegate() {
      var r2 = nbi();
      BigInteger.ZERO.subTo(this, r2);
      return r2;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a2) {
      var r2 = this.s - a2.s;
      if (r2 != 0) return r2;
      var i2 = this.t;
      r2 = i2 - a2.t;
      if (r2 != 0) return this.s < 0 ? -r2 : r2;
      while (--i2 >= 0) if ((r2 = this.data[i2] - a2.data[i2]) != 0) return r2;
      return 0;
    }
    function nbits(x3) {
      var r2 = 1, t2;
      if ((t2 = x3 >>> 16) != 0) {
        x3 = t2;
        r2 += 16;
      }
      if ((t2 = x3 >> 8) != 0) {
        x3 = t2;
        r2 += 8;
      }
      if ((t2 = x3 >> 4) != 0) {
        x3 = t2;
        r2 += 4;
      }
      if ((t2 = x3 >> 2) != 0) {
        x3 = t2;
        r2 += 2;
      }
      if ((t2 = x3 >> 1) != 0) {
        x3 = t2;
        r2 += 1;
      }
      return r2;
    }
    function bnBitLength() {
      if (this.t <= 0) return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n2, r2) {
      var i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) r2.data[i2 + n2] = this.data[i2];
      for (i2 = n2 - 1; i2 >= 0; --i2) r2.data[i2] = 0;
      r2.t = this.t + n2;
      r2.s = this.s;
    }
    function bnpDRShiftTo(n2, r2) {
      for (var i2 = n2; i2 < this.t; ++i2) r2.data[i2 - n2] = this.data[i2];
      r2.t = Math.max(this.t - n2, 0);
      r2.s = this.s;
    }
    function bnpLShiftTo(n2, r2) {
      var bs2 = n2 % this.DB;
      var cbs = this.DB - bs2;
      var bm2 = (1 << cbs) - 1;
      var ds2 = Math.floor(n2 / this.DB), c2 = this.s << bs2 & this.DM, i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) {
        r2.data[i2 + ds2 + 1] = this.data[i2] >> cbs | c2;
        c2 = (this.data[i2] & bm2) << bs2;
      }
      for (i2 = ds2 - 1; i2 >= 0; --i2) r2.data[i2] = 0;
      r2.data[ds2] = c2;
      r2.t = this.t + ds2 + 1;
      r2.s = this.s;
      r2.clamp();
    }
    function bnpRShiftTo(n2, r2) {
      r2.s = this.s;
      var ds2 = Math.floor(n2 / this.DB);
      if (ds2 >= this.t) {
        r2.t = 0;
        return;
      }
      var bs2 = n2 % this.DB;
      var cbs = this.DB - bs2;
      var bm2 = (1 << bs2) - 1;
      r2.data[0] = this.data[ds2] >> bs2;
      for (var i2 = ds2 + 1; i2 < this.t; ++i2) {
        r2.data[i2 - ds2 - 1] |= (this.data[i2] & bm2) << cbs;
        r2.data[i2 - ds2] = this.data[i2] >> bs2;
      }
      if (bs2 > 0) r2.data[this.t - ds2 - 1] |= (this.s & bm2) << cbs;
      r2.t = this.t - ds2;
      r2.clamp();
    }
    function bnpSubTo(a2, r2) {
      var i2 = 0, c2 = 0, m2 = Math.min(a2.t, this.t);
      while (i2 < m2) {
        c2 += this.data[i2] - a2.data[i2];
        r2.data[i2++] = c2 & this.DM;
        c2 >>= this.DB;
      }
      if (a2.t < this.t) {
        c2 -= a2.s;
        while (i2 < this.t) {
          c2 += this.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += this.s;
      } else {
        c2 += this.s;
        while (i2 < a2.t) {
          c2 -= a2.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 -= a2.s;
      }
      r2.s = c2 < 0 ? -1 : 0;
      if (c2 < -1) r2.data[i2++] = this.DV + c2;
      else if (c2 > 0) r2.data[i2++] = c2;
      r2.t = i2;
      r2.clamp();
    }
    function bnpMultiplyTo(a2, r2) {
      var x3 = this.abs(), y2 = a2.abs();
      var i2 = x3.t;
      r2.t = i2 + y2.t;
      while (--i2 >= 0) r2.data[i2] = 0;
      for (i2 = 0; i2 < y2.t; ++i2) r2.data[i2 + x3.t] = x3.am(0, y2.data[i2], r2, i2, 0, x3.t);
      r2.s = 0;
      r2.clamp();
      if (this.s != a2.s) BigInteger.ZERO.subTo(r2, r2);
    }
    function bnpSquareTo(r2) {
      var x3 = this.abs();
      var i2 = r2.t = 2 * x3.t;
      while (--i2 >= 0) r2.data[i2] = 0;
      for (i2 = 0; i2 < x3.t - 1; ++i2) {
        var c2 = x3.am(i2, x3.data[i2], r2, 2 * i2, 0, 1);
        if ((r2.data[i2 + x3.t] += x3.am(i2 + 1, 2 * x3.data[i2], r2, 2 * i2 + 1, c2, x3.t - i2 - 1)) >= x3.DV) {
          r2.data[i2 + x3.t] -= x3.DV;
          r2.data[i2 + x3.t + 1] = 1;
        }
      }
      if (r2.t > 0) r2.data[r2.t - 1] += x3.am(i2, x3.data[i2], r2, 2 * i2, 0, 1);
      r2.s = 0;
      r2.clamp();
    }
    function bnpDivRemTo(m2, q2, r2) {
      var pm2 = m2.abs();
      if (pm2.t <= 0) return;
      var pt3 = this.abs();
      if (pt3.t < pm2.t) {
        if (q2 != null) q2.fromInt(0);
        if (r2 != null) this.copyTo(r2);
        return;
      }
      if (r2 == null) r2 = nbi();
      var y2 = nbi(), ts2 = this.s, ms2 = m2.s;
      var nsh = this.DB - nbits(pm2.data[pm2.t - 1]);
      if (nsh > 0) {
        pm2.lShiftTo(nsh, y2);
        pt3.lShiftTo(nsh, r2);
      } else {
        pm2.copyTo(y2);
        pt3.copyTo(r2);
      }
      var ys2 = y2.t;
      var y02 = y2.data[ys2 - 1];
      if (y02 == 0) return;
      var yt2 = y02 * (1 << this.F1) + (ys2 > 1 ? y2.data[ys2 - 2] >> this.F2 : 0);
      var d12 = this.FV / yt2, d2 = (1 << this.F1) / yt2, e2 = 1 << this.F2;
      var i2 = r2.t, j2 = i2 - ys2, t2 = q2 == null ? nbi() : q2;
      y2.dlShiftTo(j2, t2);
      if (r2.compareTo(t2) >= 0) {
        r2.data[r2.t++] = 1;
        r2.subTo(t2, r2);
      }
      BigInteger.ONE.dlShiftTo(ys2, t2);
      t2.subTo(y2, y2);
      while (y2.t < ys2) y2.data[y2.t++] = 0;
      while (--j2 >= 0) {
        var qd2 = r2.data[--i2] == y02 ? this.DM : Math.floor(r2.data[i2] * d12 + (r2.data[i2 - 1] + e2) * d2);
        if ((r2.data[i2] += y2.am(0, qd2, r2, j2, 0, ys2)) < qd2) {
          y2.dlShiftTo(j2, t2);
          r2.subTo(t2, r2);
          while (r2.data[i2] < --qd2) r2.subTo(t2, r2);
        }
      }
      if (q2 != null) {
        r2.drShiftTo(ys2, q2);
        if (ts2 != ms2) BigInteger.ZERO.subTo(q2, q2);
      }
      r2.t = ys2;
      r2.clamp();
      if (nsh > 0) r2.rShiftTo(nsh, r2);
      if (ts2 < 0) BigInteger.ZERO.subTo(r2, r2);
    }
    function bnMod(a2) {
      var r2 = nbi();
      this.abs().divRemTo(a2, null, r2);
      if (this.s < 0 && r2.compareTo(BigInteger.ZERO) > 0) a2.subTo(r2, r2);
      return r2;
    }
    function Classic(m2) {
      this.m = m2;
    }
    function cConvert(x3) {
      if (x3.s < 0 || x3.compareTo(this.m) >= 0) return x3.mod(this.m);
      else return x3;
    }
    function cRevert(x3) {
      return x3;
    }
    function cReduce(x3) {
      x3.divRemTo(this.m, null, x3);
    }
    function cMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    function cSqrTo(x3, r2) {
      x3.squareTo(r2);
      this.reduce(r2);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1) return 0;
      var x3 = this.data[0];
      if ((x3 & 1) == 0) return 0;
      var y2 = x3 & 3;
      y2 = y2 * (2 - (x3 & 15) * y2) & 15;
      y2 = y2 * (2 - (x3 & 255) * y2) & 255;
      y2 = y2 * (2 - ((x3 & 65535) * y2 & 65535)) & 65535;
      y2 = y2 * (2 - x3 * y2 % this.DV) % this.DV;
      return y2 > 0 ? this.DV - y2 : -y2;
    }
    function Montgomery(m2) {
      this.m = m2;
      this.mp = m2.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m2.DB - 15) - 1;
      this.mt2 = 2 * m2.t;
    }
    function montConvert(x3) {
      var r2 = nbi();
      x3.abs().dlShiftTo(this.m.t, r2);
      r2.divRemTo(this.m, null, r2);
      if (x3.s < 0 && r2.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r2, r2);
      return r2;
    }
    function montRevert(x3) {
      var r2 = nbi();
      x3.copyTo(r2);
      this.reduce(r2);
      return r2;
    }
    function montReduce(x3) {
      while (x3.t <= this.mt2)
        x3.data[x3.t++] = 0;
      for (var i2 = 0; i2 < this.m.t; ++i2) {
        var j2 = x3.data[i2] & 32767;
        var u02 = j2 * this.mpl + ((j2 * this.mph + (x3.data[i2] >> 15) * this.mpl & this.um) << 15) & x3.DM;
        j2 = i2 + this.m.t;
        x3.data[j2] += this.m.am(0, u02, x3, i2, 0, this.m.t);
        while (x3.data[j2] >= x3.DV) {
          x3.data[j2] -= x3.DV;
          x3.data[++j2]++;
        }
      }
      x3.clamp();
      x3.drShiftTo(this.m.t, x3);
      if (x3.compareTo(this.m) >= 0) x3.subTo(this.m, x3);
    }
    function montSqrTo(x3, r2) {
      x3.squareTo(r2);
      this.reduce(r2);
    }
    function montMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e2, z3) {
      if (e2 > 4294967295 || e2 < 1) return BigInteger.ONE;
      var r2 = nbi(), r22 = nbi(), g2 = z3.convert(this), i2 = nbits(e2) - 1;
      g2.copyTo(r2);
      while (--i2 >= 0) {
        z3.sqrTo(r2, r22);
        if ((e2 & 1 << i2) > 0) z3.mulTo(r22, g2, r2);
        else {
          var t2 = r2;
          r2 = r22;
          r22 = t2;
        }
      }
      return z3.revert(r2);
    }
    function bnModPowInt(e2, m2) {
      var z3;
      if (e2 < 256 || m2.isEven()) z3 = new Classic(m2);
      else z3 = new Montgomery(m2);
      return this.exp(e2, z3);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r2 = nbi();
      this.copyTo(r2);
      return r2;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1) return this.data[0] - this.DV;
        else if (this.t == 0) return -1;
      } else if (this.t == 1) return this.data[0];
      else if (this.t == 0) return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r2) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r2));
    }
    function bnSigNum() {
      if (this.s < 0) return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;
      else return 1;
    }
    function bnpToRadix(b2) {
      if (b2 == null) b2 = 10;
      if (this.signum() == 0 || b2 < 2 || b2 > 36) return "0";
      var cs2 = this.chunkSize(b2);
      var a2 = Math.pow(b2, cs2);
      var d2 = nbv(a2), y2 = nbi(), z3 = nbi(), r2 = "";
      this.divRemTo(d2, y2, z3);
      while (y2.signum() > 0) {
        r2 = (a2 + z3.intValue()).toString(b2).substr(1) + r2;
        y2.divRemTo(d2, y2, z3);
      }
      return z3.intValue().toString(b2) + r2;
    }
    function bnpFromRadix(s2, b2) {
      this.fromInt(0);
      if (b2 == null) b2 = 10;
      var cs2 = this.chunkSize(b2);
      var d2 = Math.pow(b2, cs2), mi2 = false, j2 = 0, w3 = 0;
      for (var i2 = 0; i2 < s2.length; ++i2) {
        var x3 = intAt(s2, i2);
        if (x3 < 0) {
          if (s2.charAt(i2) == "-" && this.signum() == 0) mi2 = true;
          continue;
        }
        w3 = b2 * w3 + x3;
        if (++j2 >= cs2) {
          this.dMultiply(d2);
          this.dAddOffset(w3, 0);
          j2 = 0;
          w3 = 0;
        }
      }
      if (j2 > 0) {
        this.dMultiply(Math.pow(b2, j2));
        this.dAddOffset(w3, 0);
      }
      if (mi2) BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a2, b2, c2) {
      if ("number" == typeof b2) {
        if (a2 < 2) this.fromInt(1);
        else {
          this.fromNumber(a2, c2);
          if (!this.testBit(a2 - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a2 - 1), op_or, this);
          if (this.isEven()) this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b2)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a2) this.subTo(BigInteger.ONE.shiftLeft(a2 - 1), this);
          }
        }
      } else {
        var x3 = new Array(), t2 = a2 & 7;
        x3.length = (a2 >> 3) + 1;
        b2.nextBytes(x3);
        if (t2 > 0) x3[0] &= (1 << t2) - 1;
        else x3[0] = 0;
        this.fromString(x3, 256);
      }
    }
    function bnToByteArray() {
      var i2 = this.t, r2 = new Array();
      r2[0] = this.s;
      var p2 = this.DB - i2 * this.DB % 8, d2, k2 = 0;
      if (i2-- > 0) {
        if (p2 < this.DB && (d2 = this.data[i2] >> p2) != (this.s & this.DM) >> p2)
          r2[k2++] = d2 | this.s << this.DB - p2;
        while (i2 >= 0) {
          if (p2 < 8) {
            d2 = (this.data[i2] & (1 << p2) - 1) << 8 - p2;
            d2 |= this.data[--i2] >> (p2 += this.DB - 8);
          } else {
            d2 = this.data[i2] >> (p2 -= 8) & 255;
            if (p2 <= 0) {
              p2 += this.DB;
              --i2;
            }
          }
          if ((d2 & 128) != 0) d2 |= -256;
          if (k2 == 0 && (this.s & 128) != (d2 & 128)) ++k2;
          if (k2 > 0 || d2 != this.s) r2[k2++] = d2;
        }
      }
      return r2;
    }
    function bnEquals(a2) {
      return this.compareTo(a2) == 0;
    }
    function bnMin(a2) {
      return this.compareTo(a2) < 0 ? this : a2;
    }
    function bnMax(a2) {
      return this.compareTo(a2) > 0 ? this : a2;
    }
    function bnpBitwiseTo(a2, op2, r2) {
      var i2, f2, m2 = Math.min(a2.t, this.t);
      for (i2 = 0; i2 < m2; ++i2) r2.data[i2] = op2(this.data[i2], a2.data[i2]);
      if (a2.t < this.t) {
        f2 = a2.s & this.DM;
        for (i2 = m2; i2 < this.t; ++i2) r2.data[i2] = op2(this.data[i2], f2);
        r2.t = this.t;
      } else {
        f2 = this.s & this.DM;
        for (i2 = m2; i2 < a2.t; ++i2) r2.data[i2] = op2(f2, a2.data[i2]);
        r2.t = a2.t;
      }
      r2.s = op2(this.s, a2.s);
      r2.clamp();
    }
    function op_and(x3, y2) {
      return x3 & y2;
    }
    function bnAnd(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_and, r2);
      return r2;
    }
    function op_or(x3, y2) {
      return x3 | y2;
    }
    function bnOr(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_or, r2);
      return r2;
    }
    function op_xor(x3, y2) {
      return x3 ^ y2;
    }
    function bnXor(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_xor, r2);
      return r2;
    }
    function op_andnot(x3, y2) {
      return x3 & ~y2;
    }
    function bnAndNot(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_andnot, r2);
      return r2;
    }
    function bnNot() {
      var r2 = nbi();
      for (var i2 = 0; i2 < this.t; ++i2) r2.data[i2] = this.DM & ~this.data[i2];
      r2.t = this.t;
      r2.s = ~this.s;
      return r2;
    }
    function bnShiftLeft(n2) {
      var r2 = nbi();
      if (n2 < 0) this.rShiftTo(-n2, r2);
      else this.lShiftTo(n2, r2);
      return r2;
    }
    function bnShiftRight(n2) {
      var r2 = nbi();
      if (n2 < 0) this.lShiftTo(-n2, r2);
      else this.rShiftTo(n2, r2);
      return r2;
    }
    function lbit(x3) {
      if (x3 == 0) return -1;
      var r2 = 0;
      if ((x3 & 65535) == 0) {
        x3 >>= 16;
        r2 += 16;
      }
      if ((x3 & 255) == 0) {
        x3 >>= 8;
        r2 += 8;
      }
      if ((x3 & 15) == 0) {
        x3 >>= 4;
        r2 += 4;
      }
      if ((x3 & 3) == 0) {
        x3 >>= 2;
        r2 += 2;
      }
      if ((x3 & 1) == 0) ++r2;
      return r2;
    }
    function bnGetLowestSetBit() {
      for (var i2 = 0; i2 < this.t; ++i2)
        if (this.data[i2] != 0) return i2 * this.DB + lbit(this.data[i2]);
      if (this.s < 0) return this.t * this.DB;
      return -1;
    }
    function cbit(x3) {
      var r2 = 0;
      while (x3 != 0) {
        x3 &= x3 - 1;
        ++r2;
      }
      return r2;
    }
    function bnBitCount() {
      var r2 = 0, x3 = this.s & this.DM;
      for (var i2 = 0; i2 < this.t; ++i2) r2 += cbit(this.data[i2] ^ x3);
      return r2;
    }
    function bnTestBit(n2) {
      var j2 = Math.floor(n2 / this.DB);
      if (j2 >= this.t) return this.s != 0;
      return (this.data[j2] & 1 << n2 % this.DB) != 0;
    }
    function bnpChangeBit(n2, op2) {
      var r2 = BigInteger.ONE.shiftLeft(n2);
      this.bitwiseTo(r2, op2, r2);
      return r2;
    }
    function bnSetBit(n2) {
      return this.changeBit(n2, op_or);
    }
    function bnClearBit(n2) {
      return this.changeBit(n2, op_andnot);
    }
    function bnFlipBit(n2) {
      return this.changeBit(n2, op_xor);
    }
    function bnpAddTo(a2, r2) {
      var i2 = 0, c2 = 0, m2 = Math.min(a2.t, this.t);
      while (i2 < m2) {
        c2 += this.data[i2] + a2.data[i2];
        r2.data[i2++] = c2 & this.DM;
        c2 >>= this.DB;
      }
      if (a2.t < this.t) {
        c2 += a2.s;
        while (i2 < this.t) {
          c2 += this.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += this.s;
      } else {
        c2 += this.s;
        while (i2 < a2.t) {
          c2 += a2.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += a2.s;
      }
      r2.s = c2 < 0 ? -1 : 0;
      if (c2 > 0) r2.data[i2++] = c2;
      else if (c2 < -1) r2.data[i2++] = this.DV + c2;
      r2.t = i2;
      r2.clamp();
    }
    function bnAdd(a2) {
      var r2 = nbi();
      this.addTo(a2, r2);
      return r2;
    }
    function bnSubtract(a2) {
      var r2 = nbi();
      this.subTo(a2, r2);
      return r2;
    }
    function bnMultiply(a2) {
      var r2 = nbi();
      this.multiplyTo(a2, r2);
      return r2;
    }
    function bnDivide(a2) {
      var r2 = nbi();
      this.divRemTo(a2, r2, null);
      return r2;
    }
    function bnRemainder(a2) {
      var r2 = nbi();
      this.divRemTo(a2, null, r2);
      return r2;
    }
    function bnDivideAndRemainder(a2) {
      var q2 = nbi(), r2 = nbi();
      this.divRemTo(a2, q2, r2);
      return new Array(q2, r2);
    }
    function bnpDMultiply(n2) {
      this.data[this.t] = this.am(0, n2 - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n2, w3) {
      if (n2 == 0) return;
      while (this.t <= w3) this.data[this.t++] = 0;
      this.data[w3] += n2;
      while (this.data[w3] >= this.DV) {
        this.data[w3] -= this.DV;
        if (++w3 >= this.t) this.data[this.t++] = 0;
        ++this.data[w3];
      }
    }
    function NullExp() {
    }
    function nNop(x3) {
      return x3;
    }
    function nMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
    }
    function nSqrTo(x3, r2) {
      x3.squareTo(r2);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e2) {
      return this.exp(e2, new NullExp());
    }
    function bnpMultiplyLowerTo(a2, n2, r2) {
      var i2 = Math.min(this.t + a2.t, n2);
      r2.s = 0;
      r2.t = i2;
      while (i2 > 0) r2.data[--i2] = 0;
      var j2;
      for (j2 = r2.t - this.t; i2 < j2; ++i2) r2.data[i2 + this.t] = this.am(0, a2.data[i2], r2, i2, 0, this.t);
      for (j2 = Math.min(a2.t, n2); i2 < j2; ++i2) this.am(0, a2.data[i2], r2, i2, 0, n2 - i2);
      r2.clamp();
    }
    function bnpMultiplyUpperTo(a2, n2, r2) {
      --n2;
      var i2 = r2.t = this.t + a2.t - n2;
      r2.s = 0;
      while (--i2 >= 0) r2.data[i2] = 0;
      for (i2 = Math.max(n2 - this.t, 0); i2 < a2.t; ++i2)
        r2.data[this.t + i2 - n2] = this.am(n2 - i2, a2.data[i2], r2, 0, 0, this.t + i2 - n2);
      r2.clamp();
      r2.drShiftTo(1, r2);
    }
    function Barrett(m2) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m2.t, this.r2);
      this.mu = this.r2.divide(m2);
      this.m = m2;
    }
    function barrettConvert(x3) {
      if (x3.s < 0 || x3.t > 2 * this.m.t) return x3.mod(this.m);
      else if (x3.compareTo(this.m) < 0) return x3;
      else {
        var r2 = nbi();
        x3.copyTo(r2);
        this.reduce(r2);
        return r2;
      }
    }
    function barrettRevert(x3) {
      return x3;
    }
    function barrettReduce(x3) {
      x3.drShiftTo(this.m.t - 1, this.r2);
      if (x3.t > this.m.t + 1) {
        x3.t = this.m.t + 1;
        x3.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x3.compareTo(this.r2) < 0) x3.dAddOffset(1, this.m.t + 1);
      x3.subTo(this.r2, x3);
      while (x3.compareTo(this.m) >= 0) x3.subTo(this.m, x3);
    }
    function barrettSqrTo(x3, r2) {
      x3.squareTo(r2);
      this.reduce(r2);
    }
    function barrettMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e2, m2) {
      var i2 = e2.bitLength(), k2, r2 = nbv(1), z3;
      if (i2 <= 0) return r2;
      else if (i2 < 18) k2 = 1;
      else if (i2 < 48) k2 = 3;
      else if (i2 < 144) k2 = 4;
      else if (i2 < 768) k2 = 5;
      else k2 = 6;
      if (i2 < 8)
        z3 = new Classic(m2);
      else if (m2.isEven())
        z3 = new Barrett(m2);
      else
        z3 = new Montgomery(m2);
      var g2 = new Array(), n2 = 3, k1 = k2 - 1, km2 = (1 << k2) - 1;
      g2[1] = z3.convert(this);
      if (k2 > 1) {
        var g22 = nbi();
        z3.sqrTo(g2[1], g22);
        while (n2 <= km2) {
          g2[n2] = nbi();
          z3.mulTo(g22, g2[n2 - 2], g2[n2]);
          n2 += 2;
        }
      }
      var j2 = e2.t - 1, w3, is1 = true, r22 = nbi(), t2;
      i2 = nbits(e2.data[j2]) - 1;
      while (j2 >= 0) {
        if (i2 >= k1) w3 = e2.data[j2] >> i2 - k1 & km2;
        else {
          w3 = (e2.data[j2] & (1 << i2 + 1) - 1) << k1 - i2;
          if (j2 > 0) w3 |= e2.data[j2 - 1] >> this.DB + i2 - k1;
        }
        n2 = k2;
        while ((w3 & 1) == 0) {
          w3 >>= 1;
          --n2;
        }
        if ((i2 -= n2) < 0) {
          i2 += this.DB;
          --j2;
        }
        if (is1) {
          g2[w3].copyTo(r2);
          is1 = false;
        } else {
          while (n2 > 1) {
            z3.sqrTo(r2, r22);
            z3.sqrTo(r22, r2);
            n2 -= 2;
          }
          if (n2 > 0) z3.sqrTo(r2, r22);
          else {
            t2 = r2;
            r2 = r22;
            r22 = t2;
          }
          z3.mulTo(r22, g2[w3], r2);
        }
        while (j2 >= 0 && (e2.data[j2] & 1 << i2) == 0) {
          z3.sqrTo(r2, r22);
          t2 = r2;
          r2 = r22;
          r22 = t2;
          if (--i2 < 0) {
            i2 = this.DB - 1;
            --j2;
          }
        }
      }
      return z3.revert(r2);
    }
    function bnGCD(a2) {
      var x3 = this.s < 0 ? this.negate() : this.clone();
      var y2 = a2.s < 0 ? a2.negate() : a2.clone();
      if (x3.compareTo(y2) < 0) {
        var t2 = x3;
        x3 = y2;
        y2 = t2;
      }
      var i2 = x3.getLowestSetBit(), g2 = y2.getLowestSetBit();
      if (g2 < 0) return x3;
      if (i2 < g2) g2 = i2;
      if (g2 > 0) {
        x3.rShiftTo(g2, x3);
        y2.rShiftTo(g2, y2);
      }
      while (x3.signum() > 0) {
        if ((i2 = x3.getLowestSetBit()) > 0) x3.rShiftTo(i2, x3);
        if ((i2 = y2.getLowestSetBit()) > 0) y2.rShiftTo(i2, y2);
        if (x3.compareTo(y2) >= 0) {
          x3.subTo(y2, x3);
          x3.rShiftTo(1, x3);
        } else {
          y2.subTo(x3, y2);
          y2.rShiftTo(1, y2);
        }
      }
      if (g2 > 0) y2.lShiftTo(g2, y2);
      return y2;
    }
    function bnpModInt(n2) {
      if (n2 <= 0) return 0;
      var d2 = this.DV % n2, r2 = this.s < 0 ? n2 - 1 : 0;
      if (this.t > 0)
        if (d2 == 0) r2 = this.data[0] % n2;
        else for (var i2 = this.t - 1; i2 >= 0; --i2) r2 = (d2 * r2 + this.data[i2]) % n2;
      return r2;
    }
    function bnModInverse(m2) {
      var ac2 = m2.isEven();
      if (this.isEven() && ac2 || m2.signum() == 0) return BigInteger.ZERO;
      var u2 = m2.clone(), v3 = this.clone();
      var a2 = nbv(1), b2 = nbv(0), c2 = nbv(0), d2 = nbv(1);
      while (u2.signum() != 0) {
        while (u2.isEven()) {
          u2.rShiftTo(1, u2);
          if (ac2) {
            if (!a2.isEven() || !b2.isEven()) {
              a2.addTo(this, a2);
              b2.subTo(m2, b2);
            }
            a2.rShiftTo(1, a2);
          } else if (!b2.isEven()) b2.subTo(m2, b2);
          b2.rShiftTo(1, b2);
        }
        while (v3.isEven()) {
          v3.rShiftTo(1, v3);
          if (ac2) {
            if (!c2.isEven() || !d2.isEven()) {
              c2.addTo(this, c2);
              d2.subTo(m2, d2);
            }
            c2.rShiftTo(1, c2);
          } else if (!d2.isEven()) d2.subTo(m2, d2);
          d2.rShiftTo(1, d2);
        }
        if (u2.compareTo(v3) >= 0) {
          u2.subTo(v3, u2);
          if (ac2) a2.subTo(c2, a2);
          b2.subTo(d2, b2);
        } else {
          v3.subTo(u2, v3);
          if (ac2) c2.subTo(a2, c2);
          d2.subTo(b2, d2);
        }
      }
      if (v3.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if (d2.compareTo(m2) >= 0) return d2.subtract(m2);
      if (d2.signum() < 0) d2.addTo(m2, d2);
      else return d2;
      if (d2.signum() < 0) return d2.add(m2);
      else return d2;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t2) {
      var i2, x3 = this.abs();
      if (x3.t == 1 && x3.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i2 = 0; i2 < lowprimes.length; ++i2)
          if (x3.data[0] == lowprimes[i2]) return true;
        return false;
      }
      if (x3.isEven()) return false;
      i2 = 1;
      while (i2 < lowprimes.length) {
        var m2 = lowprimes[i2], j2 = i2 + 1;
        while (j2 < lowprimes.length && m2 < lplim) m2 *= lowprimes[j2++];
        m2 = x3.modInt(m2);
        while (i2 < j2) if (m2 % lowprimes[i2++] == 0) return false;
      }
      return x3.millerRabin(t2);
    }
    function bnpMillerRabin(t2) {
      var n12 = this.subtract(BigInteger.ONE);
      var k2 = n12.getLowestSetBit();
      if (k2 <= 0) return false;
      var r2 = n12.shiftRight(k2);
      var prng = bnGetPrng();
      var a2;
      for (var i2 = 0; i2 < t2; ++i2) {
        do {
          a2 = new BigInteger(this.bitLength(), prng);
        } while (a2.compareTo(BigInteger.ONE) <= 0 || a2.compareTo(n12) >= 0);
        var y2 = a2.modPow(r2, this);
        if (y2.compareTo(BigInteger.ONE) != 0 && y2.compareTo(n12) != 0) {
          var j2 = 1;
          while (j2++ < k2 && y2.compareTo(n12) != 0) {
            y2 = y2.modPowInt(2, this);
            if (y2.compareTo(BigInteger.ONE) == 0) return false;
          }
          if (y2.compareTo(n12) != 0) return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        // x is an array to fill with bytes
        nextBytes: function(x3) {
          for (var i2 = 0; i2 < x3.length; ++i2) {
            x3[i2] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// ../../node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS({
  "../../node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
    var forge = require_forge();
    require_util();
    require_random();
    require_sha1();
    var pkcs1 = module2.exports = forge.pkcs1 = forge.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message, options) {
      var label;
      var seed;
      var md2;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed = arguments[3] || void 0;
        md2 = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed = options.seed || void 0;
        md2 = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md2) {
        md2 = forge.md.sha1.create();
      } else {
        md2.start();
      }
      if (!mgf1Md) {
        mgf1Md = md2;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md2.digestLength - 2;
      if (message.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md2.update(label, "raw");
      var lHash = md2.digest();
      var PS = "";
      var PS_length = maxLength - message.length;
      for (var i2 = 0; i2 < PS_length; i2++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message;
      if (!seed) {
        seed = forge.random.getBytes(md2.digestLength);
      } else if (seed.length !== md2.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed.length;
        error.digestLength = md2.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md2.digestLength - 1, mgf1Md);
      var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md2.digestLength, mgf1Md);
      var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em2, options) {
      var label;
      var md2;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md2 = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md2 = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em2.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em2.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md2 === void 0) {
        md2 = forge.md.sha1.create();
      } else {
        md2.start();
      }
      if (!mgf1Md) {
        mgf1Md = md2;
      }
      if (keyLength < 2 * md2.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md2.update(label, "raw");
      var lHash = md2.digest().getBytes();
      var y2 = em2.charAt(0);
      var maskedSeed = em2.substring(1, md2.digestLength + 1);
      var maskedDB = em2.substring(1 + md2.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md2.digestLength, mgf1Md);
      var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md2.digestLength - 1, mgf1Md);
      var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md2.digestLength);
      var error = y2 !== "\0";
      for (var i2 = 0; i2 < md2.digestLength; ++i2) {
        error |= lHash.charAt(i2) !== lHashPrime.charAt(i2);
      }
      var in_ps = 1;
      var index = md2.digestLength;
      for (var j2 = md2.digestLength; j2 < db.length; j2++) {
        var code2 = db.charCodeAt(j2);
        var is_0 = code2 & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code2 & error_mask;
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db.charCodeAt(index) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash3) {
      if (!hash3) {
        hash3 = forge.md.sha1.create();
      }
      var t2 = "";
      var count = Math.ceil(maskLength / hash3.digestLength);
      for (var i2 = 0; i2 < count; ++i2) {
        var c2 = String.fromCharCode(
          i2 >> 24 & 255,
          i2 >> 16 & 255,
          i2 >> 8 & 255,
          i2 & 255
        );
        hash3.start();
        hash3.update(seed + c2);
        t2 += hash3.digest().getBytes();
      }
      return t2.substring(0, maskLength);
    }
  }
});

// ../../node_modules/node-forge/lib/prime.js
var require_prime = __commonJS({
  "../../node_modules/node-forge/lib/prime.js"(exports2, module2) {
    var forge = require_forge();
    require_util();
    require_jsbn();
    require_random();
    (function() {
      if (forge.prime) {
        module2.exports = forge.prime;
        return;
      }
      var prime = module2.exports = forge.prime = forge.prime || {};
      var BigInteger = forge.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = function(x3, y2) {
        return x3 | y2;
      };
      prime.generateProbablePrime = function(bits, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge.random;
        var rng = {
          // x is an array to fill with bytes
          nextBytes: function(x3) {
            var b2 = prng.getBytesSync(x3.length);
            for (var i2 = 0; i2 < x3.length; ++i2) {
              x3[i2] = b2.charCodeAt(i2);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits, rng, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits, rng, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
        var num = generateRandom(bits, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +/* @__PURE__ */ new Date();
        do {
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
        forge.util.setImmediate(function() {
          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
        }
        var num = generateRandom(bits, rng);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate();
          });
        }
        generate();
        function generate() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e2) {
            if (found) {
              return;
            }
            --running;
            var data = e2.data;
            if (data.found) {
              for (var i3 = 0; i3 < workers.length; ++i3) {
                workers[i3].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng);
            }
            var hex = num.toString(16);
            e2.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range, 0);
          }
        }
      }
      function generateRandom(bits, rng) {
        var num = new BigInteger(bits, rng);
        var bits1 = bits - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits) {
        if (bits <= 100) return 27;
        if (bits <= 150) return 18;
        if (bits <= 200) return 15;
        if (bits <= 250) return 12;
        if (bits <= 300) return 9;
        if (bits <= 350) return 8;
        if (bits <= 400) return 7;
        if (bits <= 500) return 6;
        if (bits <= 600) return 5;
        if (bits <= 800) return 4;
        if (bits <= 1250) return 3;
        return 2;
      }
    })();
  }
});

// ../../node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS({
  "../../node_modules/node-forge/lib/rsa.js"(exports2, module2) {
    var forge = require_forge();
    require_asn12();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge.util.isNodejs ? require_crypto2() : null;
    var asn12 = forge.asn1;
    var util2 = forge.util;
    forge.pki = forge.pki || {};
    module2.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
    var pki = forge.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn12.Class.UNIVERSAL,
      type: asn12.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      // RSAPrivateKey
      name: "RSAPrivateKey",
      tagClass: asn12.Class.UNIVERSAL,
      type: asn12.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "RSAPrivateKey.version",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // modulus (n)
        name: "RSAPrivateKey.modulus",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        // privateExponent (d)
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        // prime1 (p)
        name: "RSAPrivateKey.prime1",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        // prime2 (q)
        name: "RSAPrivateKey.prime2",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        // exponent1 (d mod (p-1))
        name: "RSAPrivateKey.exponent1",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        // exponent2 (d mod (q-1))
        name: "RSAPrivateKey.exponent2",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        // coefficient ((inverse of q) mod p)
        name: "RSAPrivateKey.coefficient",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      // RSAPublicKey
      name: "RSAPublicKey",
      tagClass: asn12.Class.UNIVERSAL,
      type: asn12.Type.SEQUENCE,
      constructed: true,
      value: [{
        // modulus (n)
        name: "RSAPublicKey.modulus",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPublicKey.exponent",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn12.Class.UNIVERSAL,
      type: asn12.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        // subjectPublicKey
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.BITSTRING,
        constructed: false,
        value: [{
          // RSAPublicKey
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var emsaPkcs1v15encode = function(md2) {
      var oid;
      if (md2.algorithm in pki.oids) {
        oid = pki.oids[md2.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md2.algorithm;
        throw error;
      }
      var oidBytes = asn12.oidToDer(oid).getBytes();
      var digestInfo = asn12.create(
        asn12.Class.UNIVERSAL,
        asn12.Type.SEQUENCE,
        true,
        []
      );
      var digestAlgorithm = asn12.create(
        asn12.Class.UNIVERSAL,
        asn12.Type.SEQUENCE,
        true,
        []
      );
      digestAlgorithm.value.push(asn12.create(
        asn12.Class.UNIVERSAL,
        asn12.Type.OID,
        false,
        oidBytes
      ));
      digestAlgorithm.value.push(asn12.create(
        asn12.Class.UNIVERSAL,
        asn12.Type.NULL,
        false,
        ""
      ));
      var digest2 = asn12.create(
        asn12.Class.UNIVERSAL,
        asn12.Type.OCTETSTRING,
        false,
        md2.digest().getBytes()
      );
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest2);
      return asn12.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x3, key, pub) {
      if (pub) {
        return x3.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x3.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r2;
      do {
        r2 = new BigInteger(
          forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),
          16
        );
      } while (r2.compareTo(key.n) >= 0 || !r2.gcd(key.n).equals(BigInteger.ONE));
      x3 = x3.multiply(r2.modPow(key.e, key.n)).mod(key.n);
      var xp2 = x3.mod(key.p).modPow(key.dP, key.p);
      var xq = x3.mod(key.q).modPow(key.dQ, key.q);
      while (xp2.compareTo(xq) < 0) {
        xp2 = xp2.add(key.p);
      }
      var y2 = xp2.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y2 = y2.multiply(r2.modInverse(key.n)).mod(key.n);
      return y2;
    };
    pki.rsa.encrypt = function(m2, key, bt2) {
      var pub = bt2;
      var eb;
      var k2 = Math.ceil(key.n.bitLength() / 8);
      if (bt2 !== false && bt2 !== true) {
        pub = bt2 === 2;
        eb = _encodePkcs1_v1_5(m2, key, bt2);
      } else {
        eb = forge.util.createBuffer();
        eb.putBytes(m2);
      }
      var x3 = new BigInteger(eb.toHex(), 16);
      var y2 = _modPow(x3, key, pub);
      var yhex = y2.toString(16);
      var ed2 = forge.util.createBuffer();
      var zeros = k2 - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed2.putByte(0);
        --zeros;
      }
      ed2.putBytes(forge.util.hexToBytes(yhex));
      return ed2.getBytes();
    };
    pki.rsa.decrypt = function(ed2, key, pub, ml2) {
      var k2 = Math.ceil(key.n.bitLength() / 8);
      if (ed2.length !== k2) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed2.length;
        error.expected = k2;
        throw error;
      }
      var y2 = new BigInteger(forge.util.createBuffer(ed2).toHex(), 16);
      if (y2.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x3 = _modPow(y2, key, pub);
      var xhex = x3.toString(16);
      var eb = forge.util.createBuffer();
      var zeros = k2 - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0);
        --zeros;
      }
      eb.putBytes(forge.util.hexToBytes(xhex));
      if (ml2 !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits, e2, options) {
      if (typeof bits === "string") {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options = options || {};
      var prng = options.prng || forge.random;
      var rng = {
        // x is an array to fill with bytes
        nextBytes: function(x3) {
          var b2 = prng.getBytesSync(x3.length);
          for (var i2 = 0; i2 < x3.length; ++i2) {
            x3[i2] = b2.charCodeAt(i2);
          }
        }
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits,
          rng,
          eInt: e2 || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n2) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x3, y2) {
        return x3 | y2;
      };
      var t12 = +/* @__PURE__ */ new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n2 <= 0 || total < n2)) {
        if (state.state === 0) {
          var bits = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(
                BigInteger.ONE.shiftLeft(bits1),
                op_or,
                state.num
              );
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(
              _getMillerRabinTests(state.num.bitLength())
            )) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d2 = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(
              state.n,
              state.e,
              d2,
              state.p,
              state.q,
              d2.mod(state.p1),
              d2.mod(state.q1),
              state.q.modInverse(state.p)
            ),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +/* @__PURE__ */ new Date();
        total += t2 - t12;
        t12 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits, e2, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits === "object") {
          options = bits;
          bits = void 0;
        } else if (typeof bits === "function") {
          callback = bits;
          bits = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === "number") {
          if (typeof e2 === "function") {
            callback = e2;
            e2 = void 0;
          } else if (typeof e2 !== "number") {
            options = e2;
            e2 = void 0;
          }
        } else {
          options = bits;
          callback = e2;
          bits = void 0;
          e2 = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e2 === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e2;
          e2 = void 0;
        }
      }
      options = options || {};
      if (bits === void 0) {
        bits = options.bits || 2048;
      }
      if (e2 === void 0) {
        e2 = options.e || 65537;
      }
      if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e2 === 65537 || e2 === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits,
              publicExponent: e2,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki.privateKeyFromPem(priv),
                publicKey: pki.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util2.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e2),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair) {
              return util2.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki.privateKeyFromAsn1(
                  asn12.fromDer(forge.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util2.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e2),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e3) {
              var pair = e3.target.result;
              var exportOp = util2.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
              exportOp.oncomplete = function(e4) {
                var pkcs8 = e4.target.result;
                var privateKey = pki.privateKeyFromAsn1(
                  asn12.fromDer(forge.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits,
              publicExponent: e2,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki.privateKeyFromPem(keypair.privateKey),
              publicKey: pki.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki.rsa.createKeyPairGenerationState(bits, e2, options);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n2, e2) {
      var key = {
        n: n2,
        e: e2
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m2, key2, pub) {
              return _encodePkcs1_v1_5(m2, key2, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m2, key2) {
              return forge.pkcs1.encode_rsa_oaep(key2, m2, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e4) {
            return e4;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e3 = scheme.encode(data, key, true);
        return pki.rsa.encrypt(e3, key, true);
      };
      key.verify = function(digest2, signature, scheme) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest3, d3) {
              d3 = _decodePkcs1_v1_5(d3, key, true);
              var obj = asn12.fromDer(d3);
              return digest3 === obj.value[1].value;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest3, d3) {
              d3 = _decodePkcs1_v1_5(d3, key, true);
              return digest3 === d3;
            }
          };
        }
        var d2 = pki.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest2, d2, key.n.bitLength());
      };
      return key;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n2, e2, d2, p2, q2, dP, dQ, qInv) {
      var key = {
        n: n2,
        e: e2,
        d: d2,
        p: p2,
        q: q2,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d3 = pki.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d4, key2) {
              return forge.pkcs1.decode_rsa_oaep(key2, d4, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d4) {
            return d4;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d3, key, false);
      };
      key.sign = function(md2, scheme) {
        var bt2 = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt2 = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md2;
          } };
          bt2 = 1;
        }
        var d3 = scheme.encode(md2, key.n.bitLength());
        return pki.rsa.encrypt(d3, key, bt2);
      };
      return key;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
        // version (0)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          asn12.integerToDer(0).getBytes()
        ),
        // privateKeyAlgorithm
        asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
          asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OID,
            false,
            asn12.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
        ]),
        // PrivateKey
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.OCTETSTRING,
          false,
          asn12.toDer(rsaKey).getBytes()
        )
      ]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn12.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn12.fromDer(forge.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn12.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors;
        throw error;
      }
      var n2, e2, d2, p2, q2, dP, dQ, qInv;
      n2 = forge.util.createBuffer(capture.privateKeyModulus).toHex();
      e2 = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d2 = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p2 = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
      q2 = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(
        new BigInteger(n2, 16),
        new BigInteger(e2, 16),
        new BigInteger(d2, 16),
        new BigInteger(p2, 16),
        new BigInteger(q2, 16),
        new BigInteger(dP, 16),
        new BigInteger(dQ, 16),
        new BigInteger(qInv, 16)
      );
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
      return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
        // version (0 = only 2 primes, 1 multiple primes)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          asn12.integerToDer(0).getBytes()
        ),
        // modulus (n)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        ),
        // privateExponent (d)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.d)
        ),
        // privateKeyPrime1 (p)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.p)
        ),
        // privateKeyPrime2 (q)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.q)
        ),
        // privateKeyExponent1 (dP)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.dP)
        ),
        // privateKeyExponent2 (dQ)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.dQ)
        ),
        // coefficient (qInv)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.qInv)
        )
      ]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn12.validate(obj, publicKeyValidator, capture, errors)) {
        var oid = asn12.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn12.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors;
        throw error;
      }
      var n2 = forge.util.createBuffer(capture.publicKeyModulus).toHex();
      var e2 = forge.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(
        new BigInteger(n2, 16),
        new BigInteger(e2, 16)
      );
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
        // AlgorithmIdentifier
        asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
          // algorithm
          asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OID,
            false,
            asn12.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          // parameters (null)
          asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
        ]),
        // subjectPublicKey
        asn12.create(asn12.Class.UNIVERSAL, asn12.Type.BITSTRING, false, [
          pki.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki.publicKeyToRSAPublicKey = function(key) {
      return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
        // modulus (n)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        )
      ]);
    };
    function _encodePkcs1_v1_5(m2, key, bt2) {
      var eb = forge.util.createBuffer();
      var k2 = Math.ceil(key.n.bitLength() / 8);
      if (m2.length > k2 - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m2.length;
        error.max = k2 - 11;
        throw error;
      }
      eb.putByte(0);
      eb.putByte(bt2);
      var padNum = k2 - 3 - m2.length;
      var padByte;
      if (bt2 === 0 || bt2 === 1) {
        padByte = bt2 === 0 ? 0 : 255;
        for (var i2 = 0; i2 < padNum; ++i2) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge.random.getBytes(padNum);
          for (var i2 = 0; i2 < padNum; ++i2) {
            padByte = padBytes.charCodeAt(i2);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m2);
      return eb;
    }
    function _decodePkcs1_v1_5(em2, key, pub, ml2) {
      var k2 = Math.ceil(key.n.bitLength() / 8);
      var eb = forge.util.createBuffer(em2);
      var first = eb.getByte();
      var bt2 = eb.getByte();
      if (first !== 0 || pub && bt2 !== 0 && bt2 !== 1 || !pub && bt2 != 2 || pub && bt2 === 0 && typeof ml2 === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt2 === 0) {
        padNum = k2 - 3 - ml2;
        for (var i2 = 0; i2 < padNum; ++i2) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt2 === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt2 === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0 || padNum !== k2 - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits, callback2) {
        forge.prime.generateProbablePrime(bits, opts, callback2);
      }
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d2 = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(
            state.n,
            state.e,
            d2,
            state.p,
            state.q,
            d2.mod(state.p1),
            d2.mod(state.q1),
            state.q.modInverse(state.p)
          ),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b2) {
      var hex = b2.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes = forge.util.hexToBytes(hex);
      if (bytes.length > 1 && // leading 0x00 for positive integer
      (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
        return bytes.substr(1);
      }
      return bytes;
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100) return 27;
      if (bits <= 150) return 18;
      if (bits <= 200) return 15;
      if (bits <= 250) return 12;
      if (bits <= 300) return 9;
      if (bits <= 350) return 8;
      if (bits <= 400) return 7;
      if (bits <= 500) return 6;
      if (bits <= 600) return 5;
      if (bits <= 800) return 4;
      if (bits <= 1250) return 3;
      return 2;
    }
    function _detectNodeCrypto(fn2) {
      return forge.util.isNodejs && typeof _crypto[fn2] === "function";
    }
    function _detectSubtleCrypto(fn2) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.crypto === "object" && typeof util2.globalScope.crypto.subtle === "object" && typeof util2.globalScope.crypto.subtle[fn2] === "function";
    }
    function _detectSubtleMsCrypto(fn2) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.msCrypto === "object" && typeof util2.globalScope.msCrypto.subtle === "object" && typeof util2.globalScope.msCrypto.subtle[fn2] === "function";
    }
    function _intToUint8Array(x3) {
      var bytes = forge.util.hexToBytes(x3.toString(16));
      var buffer = new Uint8Array(bytes.length);
      for (var i2 = 0; i2 < bytes.length; ++i2) {
        buffer[i2] = bytes.charCodeAt(i2);
      }
      return buffer;
    }
  }
});

// ../../node_modules/pify/index.js
var require_pify = __commonJS({
  "../../node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = (fn2, options) => function(...args) {
      const P3 = options.promiseModule;
      return new P3((resolve, reject) => {
        if (options.multiArgs) {
          args.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          args.push((error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        } else {
          args.push(resolve);
        }
        fn2.apply(this, args);
      });
    };
    module2.exports = (input, options) => {
      options = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, options);
      const objType = typeof input;
      if (!(input !== null && (objType === "object" || objType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objType}\``);
      }
      const filter2 = (key) => {
        const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return options.include ? options.include.some(match) : !options.exclude.some(match);
      };
      let ret;
      if (objType === "function") {
        ret = function(...args) {
          return options.excludeMain ? input(...args) : processFn(input, options).apply(this, args);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(input));
      }
      for (const key in input) {
        const property = input[key];
        ret[key] = typeof property === "function" && filter2(key) ? processFn(property, options) : property;
      }
      return ret;
    };
  }
});

// ../../node_modules/hash.js/lib/hash/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/hash.js/lib/hash/utils.js"(exports2) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits2 = require_inherits_browser();
    exports2.inherits = inherits2;
    function isSurrogatePair(msg, i2) {
      if ((msg.charCodeAt(i2) & 64512) !== 55296) {
        return false;
      }
      if (i2 < 0 || i2 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
    }
    function toArray2(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p2 = 0;
          for (var i2 = 0; i2 < msg.length; i2++) {
            var c2 = msg.charCodeAt(i2);
            if (c2 < 128) {
              res[p2++] = c2;
            } else if (c2 < 2048) {
              res[p2++] = c2 >> 6 | 192;
              res[p2++] = c2 & 63 | 128;
            } else if (isSurrogatePair(msg, i2)) {
              c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
              res[p2++] = c2 >> 18 | 240;
              res[p2++] = c2 >> 12 & 63 | 128;
              res[p2++] = c2 >> 6 & 63 | 128;
              res[p2++] = c2 & 63 | 128;
            } else {
              res[p2++] = c2 >> 12 | 224;
              res[p2++] = c2 >> 6 & 63 | 128;
              res[p2++] = c2 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i2 = 0; i2 < msg.length; i2 += 2)
            res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
        }
      } else {
        for (i2 = 0; i2 < msg.length; i2++)
          res[i2] = msg[i2] | 0;
      }
      return res;
    }
    exports2.toArray = toArray2;
    function toHex(msg) {
      var res = "";
      for (var i2 = 0; i2 < msg.length; i2++)
        res += zero2(msg[i2].toString(16));
      return res;
    }
    exports2.toHex = toHex;
    function htonl(w3) {
      var res = w3 >>> 24 | w3 >>> 8 & 65280 | w3 << 8 & 16711680 | (w3 & 255) << 24;
      return res >>> 0;
    }
    exports2.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i2 = 0; i2 < msg.length; i2++) {
        var w3 = msg[i2];
        if (endian === "little")
          w3 = htonl(w3);
        res += zero8(w3.toString(16));
      }
      return res;
    }
    exports2.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports2.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports2.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i2 = 0, k2 = start; i2 < res.length; i2++, k2 += 4) {
        var w3;
        if (endian === "big")
          w3 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
        else
          w3 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
        res[i2] = w3 >>> 0;
      }
      return res;
    }
    exports2.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i2 = 0, k2 = 0; i2 < msg.length; i2++, k2 += 4) {
        var m2 = msg[i2];
        if (endian === "big") {
          res[k2] = m2 >>> 24;
          res[k2 + 1] = m2 >>> 16 & 255;
          res[k2 + 2] = m2 >>> 8 & 255;
          res[k2 + 3] = m2 & 255;
        } else {
          res[k2 + 3] = m2 >>> 24;
          res[k2 + 2] = m2 >>> 16 & 255;
          res[k2 + 1] = m2 >>> 8 & 255;
          res[k2] = m2 & 255;
        }
      }
      return res;
    }
    exports2.split32 = split32;
    function rotr32(w3, b2) {
      return w3 >>> b2 | w3 << 32 - b2;
    }
    exports2.rotr32 = rotr32;
    function rotl32(w3, b2) {
      return w3 << b2 | w3 >>> 32 - b2;
    }
    exports2.rotl32 = rotl32;
    function sum32(a2, b2) {
      return a2 + b2 >>> 0;
    }
    exports2.sum32 = sum32;
    function sum32_3(a2, b2, c2) {
      return a2 + b2 + c2 >>> 0;
    }
    exports2.sum32_3 = sum32_3;
    function sum32_4(a2, b2, c2, d2) {
      return a2 + b2 + c2 + d2 >>> 0;
    }
    exports2.sum32_4 = sum32_4;
    function sum32_5(a2, b2, c2, d2, e2) {
      return a2 + b2 + c2 + d2 + e2 >>> 0;
    }
    exports2.sum32_5 = sum32_5;
    function sum64(buf, pos, ah2, al2) {
      var bh2 = buf[pos];
      var bl2 = buf[pos + 1];
      var lo2 = al2 + bl2 >>> 0;
      var hi2 = (lo2 < al2 ? 1 : 0) + ah2 + bh2;
      buf[pos] = hi2 >>> 0;
      buf[pos + 1] = lo2;
    }
    exports2.sum64 = sum64;
    function sum64_hi(ah2, al2, bh2, bl2) {
      var lo2 = al2 + bl2 >>> 0;
      var hi2 = (lo2 < al2 ? 1 : 0) + ah2 + bh2;
      return hi2 >>> 0;
    }
    exports2.sum64_hi = sum64_hi;
    function sum64_lo(ah2, al2, bh2, bl2) {
      var lo2 = al2 + bl2;
      return lo2 >>> 0;
    }
    exports2.sum64_lo = sum64_lo;
    function sum64_4_hi(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
      var carry = 0;
      var lo2 = al2;
      lo2 = lo2 + bl2 >>> 0;
      carry += lo2 < al2 ? 1 : 0;
      lo2 = lo2 + cl2 >>> 0;
      carry += lo2 < cl2 ? 1 : 0;
      lo2 = lo2 + dl2 >>> 0;
      carry += lo2 < dl2 ? 1 : 0;
      var hi2 = ah2 + bh2 + ch2 + dh2 + carry;
      return hi2 >>> 0;
    }
    exports2.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
      var lo2 = al2 + bl2 + cl2 + dl2;
      return lo2 >>> 0;
    }
    exports2.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
      var carry = 0;
      var lo2 = al2;
      lo2 = lo2 + bl2 >>> 0;
      carry += lo2 < al2 ? 1 : 0;
      lo2 = lo2 + cl2 >>> 0;
      carry += lo2 < cl2 ? 1 : 0;
      lo2 = lo2 + dl2 >>> 0;
      carry += lo2 < dl2 ? 1 : 0;
      lo2 = lo2 + el2 >>> 0;
      carry += lo2 < el2 ? 1 : 0;
      var hi2 = ah2 + bh2 + ch2 + dh2 + eh2 + carry;
      return hi2 >>> 0;
    }
    exports2.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
      var lo2 = al2 + bl2 + cl2 + dl2 + el2;
      return lo2 >>> 0;
    }
    exports2.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah2, al2, num) {
      var r2 = al2 << 32 - num | ah2 >>> num;
      return r2 >>> 0;
    }
    exports2.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah2, al2, num) {
      var r2 = ah2 << 32 - num | al2 >>> num;
      return r2 >>> 0;
    }
    exports2.rotr64_lo = rotr64_lo;
    function shr64_hi(ah2, al2, num) {
      return ah2 >>> num;
    }
    exports2.shr64_hi = shr64_hi;
    function shr64_lo(ah2, al2, num) {
      var r2 = ah2 << 32 - num | al2 >>> num;
      return r2 >>> 0;
    }
    exports2.shr64_lo = shr64_lo;
  }
});

// ../../node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "../../node_modules/hash.js/lib/hash/common.js"(exports2) {
    "use strict";
    var utils = require_utils2();
    var assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports2.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r2 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r2, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r2, this.endian);
        for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
          this._update(msg, i2, i2 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest2(enc) {
      this.update(this._pad());
      assert(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k2 = bytes - (len + this.padLength) % bytes;
      var res = new Array(k2 + this.padLength);
      res[0] = 128;
      for (var i2 = 1; i2 < k2; i2++)
        res[i2] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t2 = 8; t2 < this.padLength; t2++)
          res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = len >>> 24 & 255;
        res[i2++] = len >>> 16 & 255;
        res[i2++] = len >>> 8 & 255;
        res[i2++] = len & 255;
      } else {
        res[i2++] = len & 255;
        res[i2++] = len >>> 8 & 255;
        res[i2++] = len >>> 16 & 255;
        res[i2++] = len >>> 24 & 255;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        res[i2++] = 0;
        for (t2 = 8; t2 < this.padLength; t2++)
          res[i2++] = 0;
      }
      return res;
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/common.js"(exports2) {
    "use strict";
    var utils = require_utils2();
    var rotr32 = utils.rotr32;
    function ft_1(s2, x3, y2, z3) {
      if (s2 === 0)
        return ch32(x3, y2, z3);
      if (s2 === 1 || s2 === 3)
        return p32(x3, y2, z3);
      if (s2 === 2)
        return maj32(x3, y2, z3);
    }
    exports2.ft_1 = ft_1;
    function ch32(x3, y2, z3) {
      return x3 & y2 ^ ~x3 & z3;
    }
    exports2.ch32 = ch32;
    function maj32(x3, y2, z3) {
      return x3 & y2 ^ x3 & z3 ^ y2 & z3;
    }
    exports2.maj32 = maj32;
    function p32(x3, y2, z3) {
      return x3 ^ y2 ^ z3;
    }
    exports2.p32 = p32;
    function s0_256(x3) {
      return rotr32(x3, 2) ^ rotr32(x3, 13) ^ rotr32(x3, 22);
    }
    exports2.s0_256 = s0_256;
    function s1_256(x3) {
      return rotr32(x3, 6) ^ rotr32(x3, 11) ^ rotr32(x3, 25);
    }
    exports2.s1_256 = s1_256;
    function g0_256(x3) {
      return rotr32(x3, 7) ^ rotr32(x3, 18) ^ x3 >>> 3;
    }
    exports2.g0_256 = g0_256;
    function g1_256(x3) {
      return rotr32(x3, 17) ^ rotr32(x3, 19) ^ x3 >>> 10;
    }
    exports2.g1_256 = g1_256;
  }
});

// ../../node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/1.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W2 = this.W;
      for (var i2 = 0; i2 < 16; i2++)
        W2[i2] = msg[start + i2];
      for (; i2 < W2.length; i2++)
        W2[i2] = rotl32(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16], 1);
      var a2 = this.h[0];
      var b2 = this.h[1];
      var c2 = this.h[2];
      var d2 = this.h[3];
      var e2 = this.h[4];
      for (i2 = 0; i2 < W2.length; i2++) {
        var s2 = ~~(i2 / 20);
        var t2 = sum32_5(rotl32(a2, 5), ft_1(s2, b2, c2, d2), e2, W2[i2], sha1_K[s2]);
        e2 = d2;
        d2 = c2;
        c2 = rotl32(b2, 30);
        b2 = a2;
        a2 = t2;
      }
      this.h[0] = sum32(this.h[0], a2);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c2);
      this.h[3] = sum32(this.h[3], d2);
      this.h[4] = sum32(this.h[4], e2);
    };
    SHA1.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/256.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var common = require_common();
    var shaCommon = require_common2();
    var assert = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module2.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W2 = this.W;
      for (var i2 = 0; i2 < 16; i2++)
        W2[i2] = msg[start + i2];
      for (; i2 < W2.length; i2++)
        W2[i2] = sum32_4(g1_256(W2[i2 - 2]), W2[i2 - 7], g0_256(W2[i2 - 15]), W2[i2 - 16]);
      var a2 = this.h[0];
      var b2 = this.h[1];
      var c2 = this.h[2];
      var d2 = this.h[3];
      var e2 = this.h[4];
      var f2 = this.h[5];
      var g2 = this.h[6];
      var h2 = this.h[7];
      assert(this.k.length === W2.length);
      for (i2 = 0; i2 < W2.length; i2++) {
        var T12 = sum32_5(h2, s1_256(e2), ch32(e2, f2, g2), this.k[i2], W2[i2]);
        var T22 = sum32(s0_256(a2), maj32(a2, b2, c2));
        h2 = g2;
        g2 = f2;
        f2 = e2;
        e2 = sum32(d2, T12);
        d2 = c2;
        c2 = b2;
        b2 = a2;
        a2 = sum32(T12, T22);
      }
      this.h[0] = sum32(this.h[0], a2);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c2);
      this.h[3] = sum32(this.h[3], d2);
      this.h[4] = sum32(this.h[4], e2);
      this.h[5] = sum32(this.h[5], f2);
      this.h[6] = sum32(this.h[6], g2);
      this.h[7] = sum32(this.h[7], h2);
    };
    SHA256.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/224.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module2.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/512.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var common = require_common();
    var assert = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W2 = this.W;
      for (var i2 = 0; i2 < 32; i2++)
        W2[i2] = msg[start + i2];
      for (; i2 < W2.length; i2 += 2) {
        var c0_hi = g1_512_hi(W2[i2 - 4], W2[i2 - 3]);
        var c0_lo = g1_512_lo(W2[i2 - 4], W2[i2 - 3]);
        var c1_hi = W2[i2 - 14];
        var c1_lo = W2[i2 - 13];
        var c2_hi = g0_512_hi(W2[i2 - 30], W2[i2 - 29]);
        var c2_lo = g0_512_lo(W2[i2 - 30], W2[i2 - 29]);
        var c3_hi = W2[i2 - 32];
        var c3_lo = W2[i2 - 31];
        W2[i2] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W2[i2 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W2 = this.W;
      var ah2 = this.h[0];
      var al2 = this.h[1];
      var bh2 = this.h[2];
      var bl2 = this.h[3];
      var ch2 = this.h[4];
      var cl2 = this.h[5];
      var dh2 = this.h[6];
      var dl2 = this.h[7];
      var eh2 = this.h[8];
      var el2 = this.h[9];
      var fh = this.h[10];
      var fl2 = this.h[11];
      var gh2 = this.h[12];
      var gl2 = this.h[13];
      var hh2 = this.h[14];
      var hl2 = this.h[15];
      assert(this.k.length === W2.length);
      for (var i2 = 0; i2 < W2.length; i2 += 2) {
        var c0_hi = hh2;
        var c0_lo = hl2;
        var c1_hi = s1_512_hi(eh2, el2);
        var c1_lo = s1_512_lo(eh2, el2);
        var c2_hi = ch64_hi(eh2, el2, fh, fl2, gh2, gl2);
        var c2_lo = ch64_lo(eh2, el2, fh, fl2, gh2, gl2);
        var c3_hi = this.k[i2];
        var c3_lo = this.k[i2 + 1];
        var c4_hi = W2[i2];
        var c4_lo = W2[i2 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah2, al2);
        c0_lo = s0_512_lo(ah2, al2);
        c1_hi = maj64_hi(ah2, al2, bh2, bl2, ch2, cl2);
        c1_lo = maj64_lo(ah2, al2, bh2, bl2, ch2, cl2);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh2 = gh2;
        hl2 = gl2;
        gh2 = fh;
        gl2 = fl2;
        fh = eh2;
        fl2 = el2;
        eh2 = sum64_hi(dh2, dl2, T1_hi, T1_lo);
        el2 = sum64_lo(dl2, dl2, T1_hi, T1_lo);
        dh2 = ch2;
        dl2 = cl2;
        ch2 = bh2;
        cl2 = bl2;
        bh2 = ah2;
        bl2 = al2;
        ah2 = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al2 = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah2, al2);
      sum64(this.h, 2, bh2, bl2);
      sum64(this.h, 4, ch2, cl2);
      sum64(this.h, 6, dh2, dl2);
      sum64(this.h, 8, eh2, el2);
      sum64(this.h, 10, fh, fl2);
      sum64(this.h, 12, gh2, gl2);
      sum64(this.h, 14, hh2, hl2);
    };
    SHA512.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh2, xl2, yh2, yl2, zh2) {
      var r2 = xh2 & yh2 ^ ~xh2 & zh2;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function ch64_lo(xh2, xl2, yh2, yl2, zh2, zl2) {
      var r2 = xl2 & yl2 ^ ~xl2 & zl2;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function maj64_hi(xh2, xl2, yh2, yl2, zh2) {
      var r2 = xh2 & yh2 ^ xh2 & zh2 ^ yh2 & zh2;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function maj64_lo(xh2, xl2, yh2, yl2, zh2, zl2) {
      var r2 = xl2 & yl2 ^ xl2 & zl2 ^ yl2 & zl2;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s0_512_hi(xh2, xl2) {
      var c0_hi = rotr64_hi(xh2, xl2, 28);
      var c1_hi = rotr64_hi(xl2, xh2, 2);
      var c2_hi = rotr64_hi(xl2, xh2, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s0_512_lo(xh2, xl2) {
      var c0_lo = rotr64_lo(xh2, xl2, 28);
      var c1_lo = rotr64_lo(xl2, xh2, 2);
      var c2_lo = rotr64_lo(xl2, xh2, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s1_512_hi(xh2, xl2) {
      var c0_hi = rotr64_hi(xh2, xl2, 14);
      var c1_hi = rotr64_hi(xh2, xl2, 18);
      var c2_hi = rotr64_hi(xl2, xh2, 9);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s1_512_lo(xh2, xl2) {
      var c0_lo = rotr64_lo(xh2, xl2, 14);
      var c1_lo = rotr64_lo(xh2, xl2, 18);
      var c2_lo = rotr64_lo(xl2, xh2, 9);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g0_512_hi(xh2, xl2) {
      var c0_hi = rotr64_hi(xh2, xl2, 1);
      var c1_hi = rotr64_hi(xh2, xl2, 8);
      var c2_hi = shr64_hi(xh2, xl2, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g0_512_lo(xh2, xl2) {
      var c0_lo = rotr64_lo(xh2, xl2, 1);
      var c1_lo = rotr64_lo(xh2, xl2, 8);
      var c2_lo = shr64_lo(xh2, xl2, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g1_512_hi(xh2, xl2) {
      var c0_hi = rotr64_hi(xh2, xl2, 19);
      var c1_hi = rotr64_hi(xl2, xh2, 29);
      var c2_hi = shr64_hi(xh2, xl2, 6);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g1_512_lo(xh2, xl2) {
      var c0_lo = rotr64_lo(xh2, xl2, 19);
      var c1_lo = rotr64_lo(xl2, xh2, 29);
      var c2_lo = shr64_lo(xh2, xl2, 6);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
  }
});

// ../../node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha/384.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// ../../node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "../../node_modules/hash.js/lib/hash/sha.js"(exports2) {
    "use strict";
    exports2.sha1 = require__();
    exports2.sha224 = require__3();
    exports2.sha256 = require__2();
    exports2.sha384 = require__5();
    exports2.sha512 = require__4();
  }
});

// ../../node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "../../node_modules/hash.js/lib/hash/ripemd.js"(exports2) {
    "use strict";
    var utils = require_utils2();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports2.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A2 = this.h[0];
      var B3 = this.h[1];
      var C3 = this.h[2];
      var D2 = this.h[3];
      var E3 = this.h[4];
      var Ah2 = A2;
      var Bh2 = B3;
      var Ch2 = C3;
      var Dh2 = D2;
      var Eh2 = E3;
      for (var j2 = 0; j2 < 80; j2++) {
        var T3 = sum32(
          rotl32(
            sum32_4(A2, f2(j2, B3, C3, D2), msg[r2[j2] + start], K2(j2)),
            s2[j2]
          ),
          E3
        );
        A2 = E3;
        E3 = D2;
        D2 = rotl32(C3, 10);
        C3 = B3;
        B3 = T3;
        T3 = sum32(
          rotl32(
            sum32_4(Ah2, f2(79 - j2, Bh2, Ch2, Dh2), msg[rh2[j2] + start], Kh2(j2)),
            sh2[j2]
          ),
          Eh2
        );
        Ah2 = Eh2;
        Eh2 = Dh2;
        Dh2 = rotl32(Ch2, 10);
        Ch2 = Bh2;
        Bh2 = T3;
      }
      T3 = sum32_3(this.h[1], C3, Dh2);
      this.h[1] = sum32_3(this.h[2], D2, Eh2);
      this.h[2] = sum32_3(this.h[3], E3, Ah2);
      this.h[3] = sum32_3(this.h[4], A2, Bh2);
      this.h[4] = sum32_3(this.h[0], B3, Ch2);
      this.h[0] = T3;
    };
    RIPEMD160.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f2(j2, x3, y2, z3) {
      if (j2 <= 15)
        return x3 ^ y2 ^ z3;
      else if (j2 <= 31)
        return x3 & y2 | ~x3 & z3;
      else if (j2 <= 47)
        return (x3 | ~y2) ^ z3;
      else if (j2 <= 63)
        return x3 & z3 | y2 & ~z3;
      else
        return x3 ^ (y2 | ~z3);
    }
    function K2(j2) {
      if (j2 <= 15)
        return 0;
      else if (j2 <= 31)
        return 1518500249;
      else if (j2 <= 47)
        return 1859775393;
      else if (j2 <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh2(j2) {
      if (j2 <= 15)
        return 1352829926;
      else if (j2 <= 31)
        return 1548603684;
      else if (j2 <= 47)
        return 1836072691;
      else if (j2 <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r2 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh2 = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s2 = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh2 = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// ../../node_modules/hash.js/lib/hash/hmac.js
var require_hmac3 = __commonJS({
  "../../node_modules/hash.js/lib/hash/hmac.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var assert = require_minimalistic_assert();
    function Hmac(hash3, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash3, key, enc);
      this.Hash = hash3;
      this.blockSize = hash3.blockSize / 8;
      this.outSize = hash3.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module2.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i2 = key.length; i2 < this.blockSize; i2++)
        key.push(0);
      for (i2 = 0; i2 < key.length; i2++)
        key[i2] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i2 = 0; i2 < key.length; i2++)
        key[i2] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest2(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// ../../node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "../../node_modules/hash.js/lib/hash.js"(exports2) {
    var hash3 = exports2;
    hash3.utils = require_utils2();
    hash3.common = require_common();
    hash3.sha = require_sha();
    hash3.ripemd = require_ripemd();
    hash3.hmac = require_hmac3();
    hash3.sha1 = hash3.sha.sha1;
    hash3.sha256 = hash3.sha.sha256;
    hash3.sha224 = hash3.sha.sha224;
    hash3.sha384 = hash3.sha.sha384;
    hash3.sha512 = hash3.sha.sha512;
    hash3.ripemd160 = hash3.ripemd.ripemd160;
  }
});

// ../../node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/minimalistic-crypto-utils/lib/utils.js"(exports2) {
    "use strict";
    var utils = exports2;
    function toArray2(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i2 = 0; i2 < msg.length; i2++)
          res[i2] = msg[i2] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i2 = 0; i2 < msg.length; i2 += 2)
          res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
      } else {
        for (var i2 = 0; i2 < msg.length; i2++) {
          var c2 = msg.charCodeAt(i2);
          var hi2 = c2 >> 8;
          var lo2 = c2 & 255;
          if (hi2)
            res.push(hi2, lo2);
          else
            res.push(lo2);
        }
      }
      return res;
    }
    utils.toArray = toArray2;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i2 = 0; i2 < msg.length; i2++)
        res += zero2(msg[i2].toString(16));
      return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode9(arr, enc) {
      if (enc === "hex")
        return toHex(arr);
      else
        return arr;
    };
  }
});

// ../../node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "../../node_modules/hmac-drbg/lib/hmac-drbg.js"(exports2, module2) {
    "use strict";
    var hash3 = require_hash();
    var utils = require_utils3();
    var assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module2.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i2 = 0; i2 < this.V.length; i2++) {
        this.K[i2] = 0;
        this.V[i2] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash3.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// ../../node_modules/human-crypto-keys/es/utils/prng.js
var import_util2, import_hmac_drbg, import_hash, createPrng, prng_default;
var init_prng = __esm({
  "../../node_modules/human-crypto-keys/es/utils/prng.js"() {
    import_util2 = __toESM(require_util());
    import_hmac_drbg = __toESM(require_hmac_drbg());
    import_hash = __toESM(require_hash());
    createPrng = (seed) => {
      const hmacDrgb = new import_hmac_drbg.default({
        hash: import_hash.default.sha256,
        entropy: import_util2.default.binary.hex.encode(seed),
        nonce: null,
        pers: null
      });
      return {
        getBytesSync: (size) => {
          const bytesArray = hmacDrgb.generate(size);
          const bytes = new Uint8Array(bytesArray);
          return import_util2.default.binary.raw.encode(bytes);
        }
      };
    };
    prng_default = createPrng;
  }
});

// ../../node_modules/human-crypto-keys/es/utils/disable-worker.js
var refCount, globalWorker, restore, disableWorker, disable_worker_default;
var init_disable_worker = __esm({
  "../../node_modules/human-crypto-keys/es/utils/disable-worker.js"() {
    refCount = 0;
    restore = () => {
      refCount -= 1;
      if (refCount <= 0 && globalWorker) {
        Worker = globalWorker;
      }
    };
    disableWorker = () => {
      refCount += 1;
      if (typeof Worker === "undefined") {
        return restore;
      }
      globalWorker = Worker;
      Worker = void 0;
      return restore;
    };
    disable_worker_default = disableWorker;
  }
});

// ../../node_modules/human-crypto-keys/es/keys/rsa.js
var rsa_exports = {};
__export(rsa_exports, {
  defaultParams: () => defaultParams,
  generateKeyPair: () => generateKeyPair
});
var import_rsa, import_pify, forgeGenerateKeyPair, defaultParams, parseForgePrivateKey, parseForgePublicKey, generateKeyPair;
var init_rsa = __esm({
  "../../node_modules/human-crypto-keys/es/keys/rsa.js"() {
    import_rsa = __toESM(require_rsa());
    import_pify = __toESM(require_pify());
    init_prng();
    init_disable_worker();
    forgeGenerateKeyPair = (0, import_pify.default)(import_rsa.default.generateKeyPair);
    defaultParams = {
      modulusLength: 2048,
      publicExponent: 65537,
      method: "PRIMEINC"
    };
    parseForgePrivateKey = (privateKey) => {
      const {
        n: n2,
        e: e2,
        d: d2,
        p: p2,
        q: q2,
        dP,
        dQ,
        qInv
      } = privateKey;
      return {
        modulus: new Uint8Array(n2.toByteArray()),
        publicExponent: e2.intValue(),
        privateExponent: new Uint8Array(d2.toByteArray()),
        prime1: new Uint8Array(p2.toByteArray()),
        prime2: new Uint8Array(q2.toByteArray()),
        exponent1: new Uint8Array(dP.toByteArray()),
        exponent2: new Uint8Array(dQ.toByteArray()),
        coefficient: new Uint8Array(qInv.toByteArray())
      };
    };
    parseForgePublicKey = (publicKey) => {
      const {
        n: n2,
        e: e2
      } = publicKey;
      return {
        modulus: new Uint8Array(n2.toByteArray()),
        publicExponent: e2.intValue()
      };
    };
    generateKeyPair = async (params, seed) => {
      const {
        modulusLength,
        publicExponent,
        method
      } = params;
      const restoreWorker = disable_worker_default();
      const {
        privateKey,
        publicKey
      } = await forgeGenerateKeyPair(modulusLength, publicExponent, {
        prng: prng_default(seed),
        algorithm: method
      });
      restoreWorker();
      return {
        privateKey: parseForgePrivateKey(privateKey),
        publicKey: parseForgePublicKey(publicKey)
      };
    };
  }
});

// ../../node_modules/node-forge/lib/ed25519.js
var require_ed25519 = __commonJS({
  "../../node_modules/node-forge/lib/ed25519.js"(exports2, module2) {
    var forge = require_forge();
    require_jsbn();
    require_random();
    require_sha5122();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var ByteBuffer = forge.util.ByteBuffer;
    var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
    forge.pki = forge.pki || {};
    module2.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
    var ed255192 = forge.ed25519;
    ed255192.constants = {};
    ed255192.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
    ed255192.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
    ed255192.constants.SEED_BYTE_LENGTH = 32;
    ed255192.constants.SIGN_BYTE_LENGTH = 64;
    ed255192.constants.HASH_BYTE_LENGTH = 64;
    ed255192.generateKeyPair = function(options) {
      options = options || {};
      var seed = options.seed;
      if (seed === void 0) {
        seed = forge.random.getBytesSync(ed255192.constants.SEED_BYTE_LENGTH);
      } else if (typeof seed === "string") {
        if (seed.length !== ed255192.constants.SEED_BYTE_LENGTH) {
          throw new TypeError(
            '"seed" must be ' + ed255192.constants.SEED_BYTE_LENGTH + " bytes in length."
          );
        }
      } else if (!(seed instanceof Uint8Array)) {
        throw new TypeError(
          '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
        );
      }
      seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
      var pk = new NativeBuffer(ed255192.constants.PUBLIC_KEY_BYTE_LENGTH);
      var sk = new NativeBuffer(ed255192.constants.PRIVATE_KEY_BYTE_LENGTH);
      for (var i2 = 0; i2 < 32; ++i2) {
        sk[i2] = seed[i2];
      }
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, privateKey: sk };
    };
    ed255192.publicKeyFromPrivateKey = function(options) {
      options = options || {};
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length !== ed255192.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed255192.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var pk = new NativeBuffer(ed255192.constants.PUBLIC_KEY_BYTE_LENGTH);
      for (var i2 = 0; i2 < pk.length; ++i2) {
        pk[i2] = privateKey[32 + i2];
      }
      return pk;
    };
    ed255192.sign = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length !== ed255192.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed255192.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var signedMsg = new NativeBuffer(
        ed255192.constants.SIGN_BYTE_LENGTH + msg.length
      );
      crypto_sign(signedMsg, msg, msg.length, privateKey);
      var sig = new NativeBuffer(ed255192.constants.SIGN_BYTE_LENGTH);
      for (var i2 = 0; i2 < sig.length; ++i2) {
        sig[i2] = signedMsg[i2];
      }
      return sig;
    };
    ed255192.verify = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      if (options.signature === void 0) {
        throw new TypeError(
          '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
        );
      }
      var sig = messageToNativeBuffer({
        message: options.signature,
        encoding: "binary"
      });
      if (sig.length !== ed255192.constants.SIGN_BYTE_LENGTH) {
        throw new TypeError(
          '"options.signature" must have a byte length of ' + ed255192.constants.SIGN_BYTE_LENGTH
        );
      }
      var publicKey = messageToNativeBuffer({
        message: options.publicKey,
        encoding: "binary"
      });
      if (publicKey.length !== ed255192.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.publicKey" must have a byte length of ' + ed255192.constants.PUBLIC_KEY_BYTE_LENGTH
        );
      }
      var sm2 = new NativeBuffer(ed255192.constants.SIGN_BYTE_LENGTH + msg.length);
      var m2 = new NativeBuffer(ed255192.constants.SIGN_BYTE_LENGTH + msg.length);
      var i2;
      for (i2 = 0; i2 < ed255192.constants.SIGN_BYTE_LENGTH; ++i2) {
        sm2[i2] = sig[i2];
      }
      for (i2 = 0; i2 < msg.length; ++i2) {
        sm2[i2 + ed255192.constants.SIGN_BYTE_LENGTH] = msg[i2];
      }
      return crypto_sign_open(m2, sm2, sm2.length, publicKey) >= 0;
    };
    function messageToNativeBuffer(options) {
      var message = options.message;
      if (message instanceof Uint8Array) {
        return message;
      }
      var encoding = options.encoding;
      if (message === void 0) {
        if (options.md) {
          message = options.md.digest().getBytes();
          encoding = "binary";
        } else {
          throw new TypeError('"options.message" or "options.md" not specified.');
        }
      }
      if (typeof message === "string" && !encoding) {
        throw new TypeError('"options.encoding" must be "binary" or "utf8".');
      }
      if (typeof message === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.from(message, encoding);
        }
        message = new ByteBuffer(message, encoding);
      } else if (!(message instanceof ByteBuffer)) {
        throw new TypeError(
          '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
        );
      }
      var buffer = new NativeBuffer(message.length());
      for (var i2 = 0; i2 < buffer.length; ++i2) {
        buffer[i2] = message.at(i2);
      }
      return buffer;
    }
    var gf0 = gf2();
    var gf1 = gf2([1]);
    var D2 = gf2([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf2([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X3 = gf2([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y2 = gf2([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var L2 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    var I3 = gf2([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function sha5123(msg, msgLen) {
      var md2 = forge.md.sha512.create();
      var buffer = new ByteBuffer(msg);
      md2.update(buffer.getBytes(msgLen), "binary");
      var hash3 = md2.digest().getBytes();
      if (typeof Buffer !== "undefined") {
        return Buffer.from(hash3, "binary");
      }
      var out = new NativeBuffer(ed255192.constants.HASH_BYTE_LENGTH);
      for (var i2 = 0; i2 < 64; ++i2) {
        out[i2] = hash3.charCodeAt(i2);
      }
      return out;
    }
    function crypto_sign_keypair(pk, sk) {
      var p2 = [gf2(), gf2(), gf2(), gf2()];
      var i2;
      var d2 = sha5123(sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      scalarbase(p2, d2);
      pack(pk, p2);
      for (i2 = 0; i2 < 32; ++i2) {
        sk[i2 + 32] = pk[i2];
      }
      return 0;
    }
    function crypto_sign(sm2, m2, n2, sk) {
      var i2, j2, x3 = new Float64Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()];
      var d2 = sha5123(sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      var smlen = n2 + 64;
      for (i2 = 0; i2 < n2; ++i2) {
        sm2[64 + i2] = m2[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        sm2[32 + i2] = d2[32 + i2];
      }
      var r2 = sha5123(sm2.subarray(32), n2 + 32);
      reduce(r2);
      scalarbase(p2, r2);
      pack(sm2, p2);
      for (i2 = 32; i2 < 64; ++i2) {
        sm2[i2] = sk[i2];
      }
      var h2 = sha5123(sm2, n2 + 64);
      reduce(h2);
      for (i2 = 32; i2 < 64; ++i2) {
        x3[i2] = 0;
      }
      for (i2 = 0; i2 < 32; ++i2) {
        x3[i2] = r2[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        for (j2 = 0; j2 < 32; j2++) {
          x3[i2 + j2] += h2[i2] * d2[j2];
        }
      }
      modL(sm2.subarray(32), x3);
      return smlen;
    }
    function crypto_sign_open(m2, sm2, n2, pk) {
      var i2, mlen;
      var t2 = new NativeBuffer(32);
      var p2 = [gf2(), gf2(), gf2(), gf2()], q2 = [gf2(), gf2(), gf2(), gf2()];
      mlen = -1;
      if (n2 < 64) {
        return -1;
      }
      if (unpackneg(q2, pk)) {
        return -1;
      }
      for (i2 = 0; i2 < n2; ++i2) {
        m2[i2] = sm2[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        m2[i2 + 32] = pk[i2];
      }
      var h2 = sha5123(m2, n2);
      reduce(h2);
      scalarmult(p2, q2, h2);
      scalarbase(q2, sm2.subarray(32));
      add(p2, q2);
      pack(t2, p2);
      n2 -= 64;
      if (crypto_verify_32(sm2, 0, t2, 0)) {
        for (i2 = 0; i2 < n2; ++i2) {
          m2[i2] = 0;
        }
        return -1;
      }
      for (i2 = 0; i2 < n2; ++i2) {
        m2[i2] = sm2[i2 + 64];
      }
      mlen = n2;
      return mlen;
    }
    function modL(r2, x3) {
      var carry, i2, j2, k2;
      for (i2 = 63; i2 >= 32; --i2) {
        carry = 0;
        for (j2 = i2 - 32, k2 = i2 - 12; j2 < k2; ++j2) {
          x3[j2] += carry - 16 * x3[i2] * L2[j2 - (i2 - 32)];
          carry = x3[j2] + 128 >> 8;
          x3[j2] -= carry * 256;
        }
        x3[j2] += carry;
        x3[i2] = 0;
      }
      carry = 0;
      for (j2 = 0; j2 < 32; ++j2) {
        x3[j2] += carry - (x3[31] >> 4) * L2[j2];
        carry = x3[j2] >> 8;
        x3[j2] &= 255;
      }
      for (j2 = 0; j2 < 32; ++j2) {
        x3[j2] -= carry * L2[j2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        x3[i2 + 1] += x3[i2] >> 8;
        r2[i2] = x3[i2] & 255;
      }
    }
    function reduce(r2) {
      var x3 = new Float64Array(64);
      for (var i2 = 0; i2 < 64; ++i2) {
        x3[i2] = r2[i2];
        r2[i2] = 0;
      }
      modL(r2, x3);
    }
    function add(p2, q2) {
      var a2 = gf2(), b2 = gf2(), c2 = gf2(), d2 = gf2(), e2 = gf2(), f2 = gf2(), g2 = gf2(), h2 = gf2(), t2 = gf2();
      Z3(a2, p2[1], p2[0]);
      Z3(t2, q2[1], q2[0]);
      M3(a2, a2, t2);
      A2(b2, p2[0], p2[1]);
      A2(t2, q2[0], q2[1]);
      M3(b2, b2, t2);
      M3(c2, p2[3], q2[3]);
      M3(c2, c2, D22);
      M3(d2, p2[2], q2[2]);
      A2(d2, d2, d2);
      Z3(e2, b2, a2);
      Z3(f2, d2, c2);
      A2(g2, d2, c2);
      A2(h2, b2, a2);
      M3(p2[0], e2, f2);
      M3(p2[1], h2, g2);
      M3(p2[2], g2, f2);
      M3(p2[3], e2, h2);
    }
    function cswap(p2, q2, b2) {
      for (var i2 = 0; i2 < 4; ++i2) {
        sel25519(p2[i2], q2[i2], b2);
      }
    }
    function pack(r2, p2) {
      var tx = gf2(), ty2 = gf2(), zi2 = gf2();
      inv25519(zi2, p2[2]);
      M3(tx, p2[0], zi2);
      M3(ty2, p2[1], zi2);
      pack25519(r2, ty2);
      r2[31] ^= par25519(tx) << 7;
    }
    function pack25519(o2, n2) {
      var i2, j2, b2;
      var m2 = gf2(), t2 = gf2();
      for (i2 = 0; i2 < 16; ++i2) {
        t2[i2] = n2[i2];
      }
      car25519(t2);
      car25519(t2);
      car25519(t2);
      for (j2 = 0; j2 < 2; ++j2) {
        m2[0] = t2[0] - 65517;
        for (i2 = 1; i2 < 15; ++i2) {
          m2[i2] = t2[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
          m2[i2 - 1] &= 65535;
        }
        m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
        b2 = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t2, m2, 1 - b2);
      }
      for (i2 = 0; i2 < 16; i2++) {
        o2[2 * i2] = t2[i2] & 255;
        o2[2 * i2 + 1] = t2[i2] >> 8;
      }
    }
    function unpackneg(r2, p2) {
      var t2 = gf2(), chk = gf2(), num = gf2(), den = gf2(), den2 = gf2(), den4 = gf2(), den6 = gf2();
      set25519(r2[2], gf1);
      unpack25519(r2[1], p2);
      S2(num, r2[1]);
      M3(den, num, D2);
      Z3(num, num, r2[2]);
      A2(den, r2[2], den);
      S2(den2, den);
      S2(den4, den2);
      M3(den6, den4, den2);
      M3(t2, den6, num);
      M3(t2, t2, den);
      pow2523(t2, t2);
      M3(t2, t2, num);
      M3(t2, t2, den);
      M3(t2, t2, den);
      M3(r2[0], t2, den);
      S2(chk, r2[0]);
      M3(chk, chk, den);
      if (neq25519(chk, num)) {
        M3(r2[0], r2[0], I3);
      }
      S2(chk, r2[0]);
      M3(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r2[0]) === p2[31] >> 7) {
        Z3(r2[0], gf0, r2[0]);
      }
      M3(r2[3], r2[0], r2[1]);
      return 0;
    }
    function unpack25519(o2, n2) {
      var i2;
      for (i2 = 0; i2 < 16; ++i2) {
        o2[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
      }
      o2[15] &= 32767;
    }
    function pow2523(o2, i2) {
      var c2 = gf2();
      var a2;
      for (a2 = 0; a2 < 16; ++a2) {
        c2[a2] = i2[a2];
      }
      for (a2 = 250; a2 >= 0; --a2) {
        S2(c2, c2);
        if (a2 !== 1) {
          M3(c2, c2, i2);
        }
      }
      for (a2 = 0; a2 < 16; ++a2) {
        o2[a2] = c2[a2];
      }
    }
    function neq25519(a2, b2) {
      var c2 = new NativeBuffer(32);
      var d2 = new NativeBuffer(32);
      pack25519(c2, a2);
      pack25519(d2, b2);
      return crypto_verify_32(c2, 0, d2, 0);
    }
    function crypto_verify_32(x3, xi2, y2, yi2) {
      return vn2(x3, xi2, y2, yi2, 32);
    }
    function vn2(x3, xi2, y2, yi2, n2) {
      var i2, d2 = 0;
      for (i2 = 0; i2 < n2; ++i2) {
        d2 |= x3[xi2 + i2] ^ y2[yi2 + i2];
      }
      return (1 & d2 - 1 >>> 8) - 1;
    }
    function par25519(a2) {
      var d2 = new NativeBuffer(32);
      pack25519(d2, a2);
      return d2[0] & 1;
    }
    function scalarmult(p2, q2, s2) {
      var b2, i2;
      set25519(p2[0], gf0);
      set25519(p2[1], gf1);
      set25519(p2[2], gf1);
      set25519(p2[3], gf0);
      for (i2 = 255; i2 >= 0; --i2) {
        b2 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
        cswap(p2, q2, b2);
        add(q2, p2);
        add(p2, p2);
        cswap(p2, q2, b2);
      }
    }
    function scalarbase(p2, s2) {
      var q2 = [gf2(), gf2(), gf2(), gf2()];
      set25519(q2[0], X3);
      set25519(q2[1], Y2);
      set25519(q2[2], gf1);
      M3(q2[3], X3, Y2);
      scalarmult(p2, q2, s2);
    }
    function set25519(r2, a2) {
      var i2;
      for (i2 = 0; i2 < 16; i2++) {
        r2[i2] = a2[i2] | 0;
      }
    }
    function inv25519(o2, i2) {
      var c2 = gf2();
      var a2;
      for (a2 = 0; a2 < 16; ++a2) {
        c2[a2] = i2[a2];
      }
      for (a2 = 253; a2 >= 0; --a2) {
        S2(c2, c2);
        if (a2 !== 2 && a2 !== 4) {
          M3(c2, c2, i2);
        }
      }
      for (a2 = 0; a2 < 16; ++a2) {
        o2[a2] = c2[a2];
      }
    }
    function car25519(o2) {
      var i2, v3, c2 = 1;
      for (i2 = 0; i2 < 16; ++i2) {
        v3 = o2[i2] + c2 + 65535;
        c2 = Math.floor(v3 / 65536);
        o2[i2] = v3 - c2 * 65536;
      }
      o2[0] += c2 - 1 + 37 * (c2 - 1);
    }
    function sel25519(p2, q2, b2) {
      var t2, c2 = ~(b2 - 1);
      for (var i2 = 0; i2 < 16; ++i2) {
        t2 = c2 & (p2[i2] ^ q2[i2]);
        p2[i2] ^= t2;
        q2[i2] ^= t2;
      }
    }
    function gf2(init) {
      var i2, r2 = new Float64Array(16);
      if (init) {
        for (i2 = 0; i2 < init.length; ++i2) {
          r2[i2] = init[i2];
        }
      }
      return r2;
    }
    function A2(o2, a2, b2) {
      for (var i2 = 0; i2 < 16; ++i2) {
        o2[i2] = a2[i2] + b2[i2];
      }
    }
    function Z3(o2, a2, b2) {
      for (var i2 = 0; i2 < 16; ++i2) {
        o2[i2] = a2[i2] - b2[i2];
      }
    }
    function S2(o2, a2) {
      M3(o2, a2, a2);
    }
    function M3(o2, a2, b2) {
      var v3, c2, t02 = 0, t12 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t122 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b02 = b2[0], b12 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b122 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v3 = a2[0];
      t02 += v3 * b02;
      t12 += v3 * b12;
      t2 += v3 * b22;
      t3 += v3 * b3;
      t4 += v3 * b4;
      t5 += v3 * b5;
      t6 += v3 * b6;
      t7 += v3 * b7;
      t8 += v3 * b8;
      t9 += v3 * b9;
      t10 += v3 * b10;
      t11 += v3 * b11;
      t122 += v3 * b122;
      t13 += v3 * b13;
      t14 += v3 * b14;
      t15 += v3 * b15;
      v3 = a2[1];
      t12 += v3 * b02;
      t2 += v3 * b12;
      t3 += v3 * b22;
      t4 += v3 * b3;
      t5 += v3 * b4;
      t6 += v3 * b5;
      t7 += v3 * b6;
      t8 += v3 * b7;
      t9 += v3 * b8;
      t10 += v3 * b9;
      t11 += v3 * b10;
      t122 += v3 * b11;
      t13 += v3 * b122;
      t14 += v3 * b13;
      t15 += v3 * b14;
      t16 += v3 * b15;
      v3 = a2[2];
      t2 += v3 * b02;
      t3 += v3 * b12;
      t4 += v3 * b22;
      t5 += v3 * b3;
      t6 += v3 * b4;
      t7 += v3 * b5;
      t8 += v3 * b6;
      t9 += v3 * b7;
      t10 += v3 * b8;
      t11 += v3 * b9;
      t122 += v3 * b10;
      t13 += v3 * b11;
      t14 += v3 * b122;
      t15 += v3 * b13;
      t16 += v3 * b14;
      t17 += v3 * b15;
      v3 = a2[3];
      t3 += v3 * b02;
      t4 += v3 * b12;
      t5 += v3 * b22;
      t6 += v3 * b3;
      t7 += v3 * b4;
      t8 += v3 * b5;
      t9 += v3 * b6;
      t10 += v3 * b7;
      t11 += v3 * b8;
      t122 += v3 * b9;
      t13 += v3 * b10;
      t14 += v3 * b11;
      t15 += v3 * b122;
      t16 += v3 * b13;
      t17 += v3 * b14;
      t18 += v3 * b15;
      v3 = a2[4];
      t4 += v3 * b02;
      t5 += v3 * b12;
      t6 += v3 * b22;
      t7 += v3 * b3;
      t8 += v3 * b4;
      t9 += v3 * b5;
      t10 += v3 * b6;
      t11 += v3 * b7;
      t122 += v3 * b8;
      t13 += v3 * b9;
      t14 += v3 * b10;
      t15 += v3 * b11;
      t16 += v3 * b122;
      t17 += v3 * b13;
      t18 += v3 * b14;
      t19 += v3 * b15;
      v3 = a2[5];
      t5 += v3 * b02;
      t6 += v3 * b12;
      t7 += v3 * b22;
      t8 += v3 * b3;
      t9 += v3 * b4;
      t10 += v3 * b5;
      t11 += v3 * b6;
      t122 += v3 * b7;
      t13 += v3 * b8;
      t14 += v3 * b9;
      t15 += v3 * b10;
      t16 += v3 * b11;
      t17 += v3 * b122;
      t18 += v3 * b13;
      t19 += v3 * b14;
      t20 += v3 * b15;
      v3 = a2[6];
      t6 += v3 * b02;
      t7 += v3 * b12;
      t8 += v3 * b22;
      t9 += v3 * b3;
      t10 += v3 * b4;
      t11 += v3 * b5;
      t122 += v3 * b6;
      t13 += v3 * b7;
      t14 += v3 * b8;
      t15 += v3 * b9;
      t16 += v3 * b10;
      t17 += v3 * b11;
      t18 += v3 * b122;
      t19 += v3 * b13;
      t20 += v3 * b14;
      t21 += v3 * b15;
      v3 = a2[7];
      t7 += v3 * b02;
      t8 += v3 * b12;
      t9 += v3 * b22;
      t10 += v3 * b3;
      t11 += v3 * b4;
      t122 += v3 * b5;
      t13 += v3 * b6;
      t14 += v3 * b7;
      t15 += v3 * b8;
      t16 += v3 * b9;
      t17 += v3 * b10;
      t18 += v3 * b11;
      t19 += v3 * b122;
      t20 += v3 * b13;
      t21 += v3 * b14;
      t22 += v3 * b15;
      v3 = a2[8];
      t8 += v3 * b02;
      t9 += v3 * b12;
      t10 += v3 * b22;
      t11 += v3 * b3;
      t122 += v3 * b4;
      t13 += v3 * b5;
      t14 += v3 * b6;
      t15 += v3 * b7;
      t16 += v3 * b8;
      t17 += v3 * b9;
      t18 += v3 * b10;
      t19 += v3 * b11;
      t20 += v3 * b122;
      t21 += v3 * b13;
      t22 += v3 * b14;
      t23 += v3 * b15;
      v3 = a2[9];
      t9 += v3 * b02;
      t10 += v3 * b12;
      t11 += v3 * b22;
      t122 += v3 * b3;
      t13 += v3 * b4;
      t14 += v3 * b5;
      t15 += v3 * b6;
      t16 += v3 * b7;
      t17 += v3 * b8;
      t18 += v3 * b9;
      t19 += v3 * b10;
      t20 += v3 * b11;
      t21 += v3 * b122;
      t22 += v3 * b13;
      t23 += v3 * b14;
      t24 += v3 * b15;
      v3 = a2[10];
      t10 += v3 * b02;
      t11 += v3 * b12;
      t122 += v3 * b22;
      t13 += v3 * b3;
      t14 += v3 * b4;
      t15 += v3 * b5;
      t16 += v3 * b6;
      t17 += v3 * b7;
      t18 += v3 * b8;
      t19 += v3 * b9;
      t20 += v3 * b10;
      t21 += v3 * b11;
      t22 += v3 * b122;
      t23 += v3 * b13;
      t24 += v3 * b14;
      t25 += v3 * b15;
      v3 = a2[11];
      t11 += v3 * b02;
      t122 += v3 * b12;
      t13 += v3 * b22;
      t14 += v3 * b3;
      t15 += v3 * b4;
      t16 += v3 * b5;
      t17 += v3 * b6;
      t18 += v3 * b7;
      t19 += v3 * b8;
      t20 += v3 * b9;
      t21 += v3 * b10;
      t22 += v3 * b11;
      t23 += v3 * b122;
      t24 += v3 * b13;
      t25 += v3 * b14;
      t26 += v3 * b15;
      v3 = a2[12];
      t122 += v3 * b02;
      t13 += v3 * b12;
      t14 += v3 * b22;
      t15 += v3 * b3;
      t16 += v3 * b4;
      t17 += v3 * b5;
      t18 += v3 * b6;
      t19 += v3 * b7;
      t20 += v3 * b8;
      t21 += v3 * b9;
      t22 += v3 * b10;
      t23 += v3 * b11;
      t24 += v3 * b122;
      t25 += v3 * b13;
      t26 += v3 * b14;
      t27 += v3 * b15;
      v3 = a2[13];
      t13 += v3 * b02;
      t14 += v3 * b12;
      t15 += v3 * b22;
      t16 += v3 * b3;
      t17 += v3 * b4;
      t18 += v3 * b5;
      t19 += v3 * b6;
      t20 += v3 * b7;
      t21 += v3 * b8;
      t22 += v3 * b9;
      t23 += v3 * b10;
      t24 += v3 * b11;
      t25 += v3 * b122;
      t26 += v3 * b13;
      t27 += v3 * b14;
      t28 += v3 * b15;
      v3 = a2[14];
      t14 += v3 * b02;
      t15 += v3 * b12;
      t16 += v3 * b22;
      t17 += v3 * b3;
      t18 += v3 * b4;
      t19 += v3 * b5;
      t20 += v3 * b6;
      t21 += v3 * b7;
      t22 += v3 * b8;
      t23 += v3 * b9;
      t24 += v3 * b10;
      t25 += v3 * b11;
      t26 += v3 * b122;
      t27 += v3 * b13;
      t28 += v3 * b14;
      t29 += v3 * b15;
      v3 = a2[15];
      t15 += v3 * b02;
      t16 += v3 * b12;
      t17 += v3 * b22;
      t18 += v3 * b3;
      t19 += v3 * b4;
      t20 += v3 * b5;
      t21 += v3 * b6;
      t22 += v3 * b7;
      t23 += v3 * b8;
      t24 += v3 * b9;
      t25 += v3 * b10;
      t26 += v3 * b11;
      t27 += v3 * b122;
      t28 += v3 * b13;
      t29 += v3 * b14;
      t30 += v3 * b15;
      t02 += 38 * t16;
      t12 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t122 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v3 = t02 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t02 = v3 - c2 * 65536;
      v3 = t12 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t12 = v3 - c2 * 65536;
      v3 = t2 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t2 = v3 - c2 * 65536;
      v3 = t3 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t3 = v3 - c2 * 65536;
      v3 = t4 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t4 = v3 - c2 * 65536;
      v3 = t5 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t5 = v3 - c2 * 65536;
      v3 = t6 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t6 = v3 - c2 * 65536;
      v3 = t7 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t7 = v3 - c2 * 65536;
      v3 = t8 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t8 = v3 - c2 * 65536;
      v3 = t9 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t9 = v3 - c2 * 65536;
      v3 = t10 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t10 = v3 - c2 * 65536;
      v3 = t11 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t11 = v3 - c2 * 65536;
      v3 = t122 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t122 = v3 - c2 * 65536;
      v3 = t13 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t13 = v3 - c2 * 65536;
      v3 = t14 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t14 = v3 - c2 * 65536;
      v3 = t15 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t15 = v3 - c2 * 65536;
      t02 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v3 = t02 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t02 = v3 - c2 * 65536;
      v3 = t12 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t12 = v3 - c2 * 65536;
      v3 = t2 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t2 = v3 - c2 * 65536;
      v3 = t3 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t3 = v3 - c2 * 65536;
      v3 = t4 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t4 = v3 - c2 * 65536;
      v3 = t5 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t5 = v3 - c2 * 65536;
      v3 = t6 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t6 = v3 - c2 * 65536;
      v3 = t7 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t7 = v3 - c2 * 65536;
      v3 = t8 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t8 = v3 - c2 * 65536;
      v3 = t9 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t9 = v3 - c2 * 65536;
      v3 = t10 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t10 = v3 - c2 * 65536;
      v3 = t11 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t11 = v3 - c2 * 65536;
      v3 = t122 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t122 = v3 - c2 * 65536;
      v3 = t13 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t13 = v3 - c2 * 65536;
      v3 = t14 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t14 = v3 - c2 * 65536;
      v3 = t15 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t15 = v3 - c2 * 65536;
      t02 += c2 - 1 + 37 * (c2 - 1);
      o2[0] = t02;
      o2[1] = t12;
      o2[2] = t2;
      o2[3] = t3;
      o2[4] = t4;
      o2[5] = t5;
      o2[6] = t6;
      o2[7] = t7;
      o2[8] = t8;
      o2[9] = t9;
      o2[10] = t10;
      o2[11] = t11;
      o2[12] = t122;
      o2[13] = t13;
      o2[14] = t14;
      o2[15] = t15;
    }
  }
});

// ../../node_modules/human-crypto-keys/es/utils/binary.js
var typedArrayToUint8Array2;
var init_binary2 = __esm({
  "../../node_modules/human-crypto-keys/es/utils/binary.js"() {
    typedArrayToUint8Array2 = (typedArray) => new Uint8Array(typedArray.buffer.slice(typedArray.byteOffset, typedArray.byteOffset + typedArray.byteLength));
  }
});

// ../../node_modules/human-crypto-keys/es/keys/ed25519.js
var ed25519_exports = {};
__export(ed25519_exports, {
  defaultParams: () => defaultParams2,
  generateKeyPair: () => generateKeyPair2
});
var import_ed25519, defaultParams2, generateKeyPair2;
var init_ed25519 = __esm({
  "../../node_modules/human-crypto-keys/es/keys/ed25519.js"() {
    import_ed25519 = __toESM(require_ed25519());
    init_binary2();
    defaultParams2 = {};
    generateKeyPair2 = (params, seed) => {
      seed = seed.slice(0, 32);
      const {
        publicKey
      } = import_ed25519.default.generateKeyPair({
        seed
      });
      return {
        privateKey: {
          seed
        },
        publicKey: {
          bytes: typedArrayToUint8Array2(publicKey)
        }
      };
    };
  }
});

// ../../node_modules/human-crypto-keys/es/utils/errors.js
var BaseError2, UnknownAlgorithmError, UnknownAlgorithmParamError, NilAlgorithmParamError, TypeMismatchAlgorithmParamError;
var init_errors2 = __esm({
  "../../node_modules/human-crypto-keys/es/utils/errors.js"() {
    BaseError2 = class extends Error {
      constructor(message, code2, props) {
        super(message);
        Object.assign(this, {
          ...props,
          code: code2,
          name: this.constructor.name
        });
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
          return;
        }
        this.stack = new Error(message).stack;
      }
    };
    UnknownAlgorithmError = class extends BaseError2 {
      constructor(algorithm) {
        super(`Unknown algorithm \`${algorithm}\``, "UNKNOWN_ALGORITHM");
      }
    };
    UnknownAlgorithmParamError = class extends BaseError2 {
      constructor(param) {
        super(`Unknown algorithm param \`${param}\``, "UNKNOWN_ALGORITHM_PARAM");
      }
    };
    NilAlgorithmParamError = class extends BaseError2 {
      constructor(param) {
        super(`Algorithm param \`${param}\` can't be null or undefined`, "NIL_ALGORITHM_PARAM");
      }
    };
    TypeMismatchAlgorithmParamError = class extends BaseError2 {
      constructor(param, type) {
        super(`Expected algorithm param \`${param}\` to be of type \`${type}\``, "TYPE_ALGORITHM_PARAM");
      }
    };
  }
});

// ../../node_modules/human-crypto-keys/es/algorithm.js
var supportedAlgorithms, buildParams, parseAlgorithm, algorithm_default;
var init_algorithm = __esm({
  "../../node_modules/human-crypto-keys/es/algorithm.js"() {
    init_es2();
    init_rsa();
    init_ed25519();
    init_errors2();
    supportedAlgorithms = {
      rsa: rsa_exports,
      ed25519: ed25519_exports
    };
    buildParams = (defaultParams3, customParams) => Object.keys(customParams).reduce((params, key) => {
      if (defaultParams3[key] == null) {
        throw new UnknownAlgorithmParamError(key);
      }
      if (customParams[key] == null) {
        throw new NilAlgorithmParamError(key);
      }
      if (typeof customParams[key] !== typeof defaultParams3[key]) {
        throw new TypeMismatchAlgorithmParamError(key, typeof defaultParams3[key]);
      }
      params[key] = customParams[key];
      return params;
    }, {
      ...defaultParams3
    });
    parseAlgorithm = (keyAlgorithm) => {
      const algorithm = typeof keyAlgorithm === "string" ? {
        id: keyAlgorithm
      } : keyAlgorithm;
      const type = supportedAlgorithms[algorithm.id] ? algorithm.id : getKeyTypeFromAlgorithm(algorithm.id);
      if (!type) {
        throw new UnknownAlgorithmError(algorithm.id);
      }
      const {
        generateKeyPair: generateKeyPair4,
        defaultParams: defaultParams3
      } = supportedAlgorithms[type];
      const {
        id: id2,
        ...customParams
      } = algorithm;
      const params = buildParams(defaultParams3, customParams);
      return {
        id: id2,
        type,
        params,
        generate: generateKeyPair4
      };
    };
    algorithm_default = parseAlgorithm;
  }
});

// ../../node_modules/human-crypto-keys/es/index.js
var es_exports = {};
__export(es_exports, {
  generateKeyPair: () => generateKeyPair3,
  getKeyPairFromMnemonic: () => getKeyPairFromMnemonic,
  getKeyPairFromSeed: () => getKeyPairFromSeed
});
var bip39, composeKeys, generateKeys, generateKeyPair3, getKeyPairFromMnemonic, getKeyPairFromSeed;
var init_es3 = __esm({
  "../../node_modules/human-crypto-keys/es/index.js"() {
    bip39 = __toESM(require_src());
    init_algorithm();
    init_es2();
    composeKeys = ({
      privateKey,
      publicKey
    }, keyAlgorithm, options) => {
      options = {
        privateKeyFormat: "pkcs8-pem",
        publicKeyFormat: "spki-pem",
        ...options
      };
      const {
        privateKeyFormat,
        publicKeyFormat,
        encryptionAlgorithm,
        password
      } = options;
      return {
        privateKey: composePrivateKey7({
          format: privateKeyFormat,
          keyAlgorithm,
          keyData: privateKey,
          encryptionAlgorithm
        }, {
          password
        }),
        publicKey: composePublicKey5({
          format: publicKeyFormat,
          keyAlgorithm,
          keyData: publicKey
        })
      };
    };
    generateKeys = async (seed, algorithm, options) => {
      const {
        id: id2,
        params,
        generate
      } = algorithm_default(algorithm);
      const keyPair = await generate(params, seed);
      const keyAlgorithm = {
        id: id2,
        ...params
      };
      const composedKeyPair = composeKeys(keyPair, keyAlgorithm, options);
      return {
        keyAlgorithm,
        composedKeyPair
      };
    };
    generateKeyPair3 = async (algorithm, options) => {
      const mnemonic = bip39.generateMnemonic();
      const seedBuffer = await bip39.mnemonicToSeed(mnemonic);
      const seed = new Uint8Array(seedBuffer.buffer);
      const {
        keyAlgorithm,
        composedKeyPair
      } = await generateKeys(seed, algorithm, options);
      return {
        algorithm: keyAlgorithm,
        mnemonic,
        seed,
        ...composedKeyPair
      };
    };
    getKeyPairFromMnemonic = async (mnemonic, algorithm, options) => {
      const seedBuffer = await bip39.mnemonicToSeed(mnemonic);
      const seed = new Uint8Array(seedBuffer.buffer);
      return getKeyPairFromSeed(seed, algorithm, options);
    };
    getKeyPairFromSeed = async (seed, algorithm, options) => {
      const {
        composedKeyPair
      } = await generateKeys(seed, algorithm, options);
      return composedKeyPair;
    };
  }
});

// ../../node_modules/libp2p-crypto/src/webcrypto.js
var require_webcrypto = __commonJS({
  "../../node_modules/libp2p-crypto/src/webcrypto.js"(exports2) {
    "use strict";
    exports2.get = (win = self) => {
      const nativeCrypto = win.crypto || win.msCrypto;
      if (!nativeCrypto || !nativeCrypto.subtle) {
        throw Object.assign(
          new Error(
            "Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"
          ),
          { code: "ERR_MISSING_WEB_CRYPTO" }
        );
      }
      return nativeCrypto;
    };
  }
});

// ../../node_modules/libp2p-crypto/src/hmac/lengths.js
var require_lengths = __commonJS({
  "../../node_modules/libp2p-crypto/src/hmac/lengths.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      SHA1: 20,
      SHA256: 32,
      SHA512: 64
    };
  }
});

// ../../node_modules/libp2p-crypto/src/hmac/index-browser.js
var require_index_browser = __commonJS({
  "../../node_modules/libp2p-crypto/src/hmac/index-browser.js"(exports2) {
    "use strict";
    var webcrypto = require_webcrypto();
    var lengths = require_lengths();
    var hashTypes = {
      SHA1: "SHA-1",
      SHA256: "SHA-256",
      SHA512: "SHA-512"
    };
    var sign2 = async (key, data) => {
      const buf = await webcrypto.get().subtle.sign({ name: "HMAC" }, key, data);
      return new Uint8Array(buf, buf.byteOffset, buf.byteLength);
    };
    exports2.create = async function(hashType, secret) {
      const hash3 = hashTypes[hashType];
      const key = await webcrypto.get().subtle.importKey(
        "raw",
        secret,
        {
          name: "HMAC",
          hash: { name: hash3 }
        },
        false,
        ["sign"]
      );
      return {
        async digest(data) {
          return sign2(key, data);
        },
        length: lengths[hashType]
      };
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/forge.js
var require_forge2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/forge.js"(exports2, module2) {
    module2.exports = {
      // default options
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/baseN.js
var require_baseN2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/baseN.js"(exports2, module2) {
    var api = {};
    module2.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet2, maxline) {
      if (typeof alphabet2 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet2);
      } else {
        var i2 = 0;
        var base3 = alphabet2.length;
        var first = alphabet2.charAt(0);
        var digits = [0];
        for (i2 = 0; i2 < input.length; ++i2) {
          for (var j2 = 0, carry = input[i2]; j2 < digits.length; ++j2) {
            carry += digits[j2] << 8;
            digits[j2] = carry % base3;
            carry = carry / base3 | 0;
          }
          while (carry > 0) {
            digits.push(carry % base3);
            carry = carry / base3 | 0;
          }
        }
        for (i2 = 0; input[i2] === 0 && i2 < input.length - 1; ++i2) {
          output += first;
        }
        for (i2 = digits.length - 1; i2 >= 0; --i2) {
          output += alphabet2[digits[i2]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet2) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet2 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table = _reverseAlphabets[alphabet2];
      if (!table) {
        table = _reverseAlphabets[alphabet2] = [];
        for (var i2 = 0; i2 < alphabet2.length; ++i2) {
          table[alphabet2.charCodeAt(i2)] = i2;
        }
      }
      input = input.replace(/\s/g, "");
      var base3 = alphabet2.length;
      var first = alphabet2.charAt(0);
      var bytes = [0];
      for (var i2 = 0; i2 < input.length; i2++) {
        var value = table[input.charCodeAt(i2)];
        if (value === void 0) {
          return;
        }
        for (var j2 = 0, carry = value; j2 < bytes.length; ++j2) {
          carry += bytes[j2] * base3;
          bytes[j2] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k2 = 0; input[k2] === first && k2 < input.length - 1; ++k2) {
        bytes.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes.reverse());
      }
      return new Uint8Array(bytes.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet2) {
      var i2 = 0;
      var base3 = alphabet2.length;
      var first = alphabet2.charAt(0);
      var digits = [0];
      for (i2 = 0; i2 < input.length(); ++i2) {
        for (var j2 = 0, carry = input.at(i2); j2 < digits.length; ++j2) {
          carry += digits[j2] << 8;
          digits[j2] = carry % base3;
          carry = carry / base3 | 0;
        }
        while (carry > 0) {
          digits.push(carry % base3);
          carry = carry / base3 | 0;
        }
      }
      var output = "";
      for (i2 = 0; input.at(i2) === 0 && i2 < input.length() - 1; ++i2) {
        output += first;
      }
      for (i2 = digits.length - 1; i2 >= 0; --i2) {
        output += alphabet2[digits[i2]];
      }
      return output;
    }
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/util.js
var require_util2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/util.js"(exports2, module2) {
    var forge = require_forge2();
    var baseN = require_baseN2();
    var util2 = module2.exports = forge.util = forge.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util2.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util2.setImmediate = setImmediate;
        } else {
          util2.setImmediate = util2.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util2.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util2.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util2.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        var msg = "forge.setImmediate";
        var callbacks = [];
        util2.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util2.setImmediate;
        util2.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util2.nextTick = util2.setImmediate;
    })();
    util2.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util2.globalScope = function() {
      if (util2.isNodejs) {
        return global;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util2.isArray = Array.isArray || function(x3) {
      return Object.prototype.toString.call(x3) === "[object Array]";
    };
    util2.isArrayBuffer = function(x3) {
      return typeof ArrayBuffer !== "undefined" && x3 instanceof ArrayBuffer;
    };
    util2.isArrayBufferView = function(x3) {
      return x3 && util2.isArrayBuffer(x3.buffer) && x3.byteLength !== void 0;
    };
    function _checkBitsParam(n2) {
      if (!(n2 === 8 || n2 === 16 || n2 === 24 || n2 === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n2);
      }
    }
    util2.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b2) {
      this.data = "";
      this.read = 0;
      if (typeof b2 === "string") {
        this.data = b2;
      } else if (util2.isArrayBuffer(b2) || util2.isArrayBufferView(b2)) {
        if (typeof Buffer !== "undefined" && b2 instanceof Buffer) {
          this.data = b2.toString("binary");
        } else {
          var arr = new Uint8Array(b2);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e2) {
            for (var i2 = 0; i2 < arr.length; ++i2) {
              this.putByte(arr[i2]);
            }
          }
        }
      } else if (b2 instanceof ByteStringBuffer || typeof b2 === "object" && typeof b2.data === "string" && typeof b2.read === "number") {
        this.data = b2.data;
        this.read = b2.read;
      }
      this._constructedStringLength = 0;
    }
    util2.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util2.ByteStringBuffer.prototype._optimizeConstructedString = function(x3) {
      this._constructedStringLength += x3;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util2.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util2.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util2.ByteStringBuffer.prototype.putByte = function(b2) {
      return this.putBytes(String.fromCharCode(b2));
    };
    util2.ByteStringBuffer.prototype.fillWithByte = function(b2, n2) {
      b2 = String.fromCharCode(b2);
      var d2 = this.data;
      while (n2 > 0) {
        if (n2 & 1) {
          d2 += b2;
        }
        n2 >>>= 1;
        if (n2 > 0) {
          b2 += b2;
        }
      }
      this.data = d2;
      this._optimizeConstructedString(n2);
      return this;
    };
    util2.ByteStringBuffer.prototype.putBytes = function(bytes) {
      this.data += bytes;
      this._optimizeConstructedString(bytes.length);
      return this;
    };
    util2.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util2.encodeUtf8(str));
    };
    util2.ByteStringBuffer.prototype.putInt16 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt24 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt32 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt16Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt24Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt32Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 24 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt = function(i2, n2) {
      _checkBitsParam(n2);
      var bytes = "";
      do {
        n2 -= 8;
        bytes += String.fromCharCode(i2 >> n2 & 255);
      } while (n2 > 0);
      return this.putBytes(bytes);
    };
    util2.ByteStringBuffer.prototype.putSignedInt = function(i2, n2) {
      if (i2 < 0) {
        i2 += 2 << n2 - 1;
      }
      return this.putInt(i2, n2);
    };
    util2.ByteStringBuffer.prototype.putBuffer = function(buffer) {
      return this.putBytes(buffer.getBytes());
    };
    util2.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util2.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt = function(n2) {
      _checkBitsParam(n2);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n2 -= 8;
      } while (n2 > 0);
      return rval;
    };
    util2.ByteStringBuffer.prototype.getSignedInt = function(n2) {
      var x3 = this.getInt(n2);
      var max = 2 << n2 - 2;
      if (x3 >= max) {
        x3 -= max << 1;
      }
      return x3;
    };
    util2.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util2.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util2.ByteStringBuffer.prototype.at = function(i2) {
      return this.data.charCodeAt(this.read + i2);
    };
    util2.ByteStringBuffer.prototype.setAt = function(i2, b2) {
      this.data = this.data.substr(0, this.read + i2) + String.fromCharCode(b2) + this.data.substr(this.read + i2 + 1);
      return this;
    };
    util2.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util2.ByteStringBuffer.prototype.copy = function() {
      var c2 = util2.createBuffer(this.data);
      c2.read = this.read;
      return c2;
    };
    util2.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util2.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util2.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util2.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.length; ++i2) {
        var b2 = this.data.charCodeAt(i2);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util2.ByteStringBuffer.prototype.toString = function() {
      return util2.decodeUtf8(this.bytes());
    };
    function DataBuffer(b2, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer2 = util2.isArrayBuffer(b2);
      var isArrayBufferView2 = util2.isArrayBufferView(b2);
      if (isArrayBuffer2 || isArrayBufferView2) {
        if (isArrayBuffer2) {
          this.data = new DataView(b2);
        } else {
          this.data = new DataView(b2.buffer, b2.byteOffset, b2.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b2 !== null && b2 !== void 0) {
        this.putBytes(b2);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    util2.DataBuffer = DataBuffer;
    util2.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util2.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util2.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src2 = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src2);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util2.DataBuffer.prototype.putByte = function(b2) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b2);
      return this;
    };
    util2.DataBuffer.prototype.fillWithByte = function(b2, n2) {
      this.accommodate(n2);
      for (var i2 = 0; i2 < n2; ++i2) {
        this.data.setUint8(b2);
      }
      return this;
    };
    util2.DataBuffer.prototype.putBytes = function(bytes, encoding) {
      if (util2.isArrayBufferView(bytes)) {
        var src2 = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        var len = src2.byteLength - src2.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src2);
        this.write += len;
        return this;
      }
      if (util2.isArrayBuffer(bytes)) {
        var src2 = new Uint8Array(bytes);
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src2, this.write);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes instanceof util2.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util2.isArrayBufferView(bytes.data)) {
        var src2 = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(bytes.data.byteLength, this.write);
        dst.set(src2);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes instanceof util2.ByteStringBuffer) {
        bytes = bytes.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.hex.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.base64.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes = util2.encodeUtf8(bytes);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util2.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes);
    };
    util2.DataBuffer.prototype.putBuffer = function(buffer) {
      this.putBytes(buffer);
      buffer.clear();
      return this;
    };
    util2.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util2.DataBuffer.prototype.putInt16 = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2);
      this.write += 2;
      return this;
    };
    util2.DataBuffer.prototype.putInt24 = function(i2) {
      this.accommodate(3);
      this.data.setInt16(this.write, i2 >> 8 & 65535);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.write += 3;
      return this;
    };
    util2.DataBuffer.prototype.putInt32 = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2);
      this.write += 4;
      return this;
    };
    util2.DataBuffer.prototype.putInt16Le = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2, true);
      this.write += 2;
      return this;
    };
    util2.DataBuffer.prototype.putInt24Le = function(i2) {
      this.accommodate(3);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.data.setInt16(this.write, i2 >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util2.DataBuffer.prototype.putInt32Le = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2, true);
      this.write += 4;
      return this;
    };
    util2.DataBuffer.prototype.putInt = function(i2, n2) {
      _checkBitsParam(n2);
      this.accommodate(n2 / 8);
      do {
        n2 -= 8;
        this.data.setInt8(this.write++, i2 >> n2 & 255);
      } while (n2 > 0);
      return this;
    };
    util2.DataBuffer.prototype.putSignedInt = function(i2, n2) {
      _checkBitsParam(n2);
      this.accommodate(n2 / 8);
      if (i2 < 0) {
        i2 += 2 << n2 - 1;
      }
      return this.putInt(i2, n2);
    };
    util2.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util2.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util2.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util2.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util2.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util2.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util2.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util2.DataBuffer.prototype.getInt = function(n2) {
      _checkBitsParam(n2);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n2 -= 8;
      } while (n2 > 0);
      return rval;
    };
    util2.DataBuffer.prototype.getSignedInt = function(n2) {
      var x3 = this.getInt(n2);
      var max = 2 << n2 - 2;
      if (x3 >= max) {
        x3 -= max << 1;
      }
      return x3;
    };
    util2.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util2.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util2.DataBuffer.prototype.at = function(i2) {
      return this.data.getUint8(this.read + i2);
    };
    util2.DataBuffer.prototype.setAt = function(i2, b2) {
      this.data.setUint8(i2, b2);
      return this;
    };
    util2.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util2.DataBuffer.prototype.copy = function() {
      return new util2.DataBuffer(this);
    };
    util2.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src2 = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src2.byteLength);
        dst.set(src2);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util2.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util2.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util2.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.byteLength; ++i2) {
        var b2 = this.data.getUint8(i2);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util2.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util2.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util2.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util2.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util2.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util2.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util2.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util2.encodeUtf8(input);
      }
      return new util2.ByteBuffer(input);
    };
    util2.fillString = function(c2, n2) {
      var s2 = "";
      while (n2 > 0) {
        if (n2 & 1) {
          s2 += c2;
        }
        n2 >>>= 1;
        if (n2 > 0) {
          c2 += c2;
        }
      }
      return s2;
    };
    util2.xorBytes = function(s12, s2, n2) {
      var s3 = "";
      var b2 = "";
      var t2 = "";
      var i2 = 0;
      var c2 = 0;
      for (; n2 > 0; --n2, ++i2) {
        b2 = s12.charCodeAt(i2) ^ s2.charCodeAt(i2);
        if (c2 >= 10) {
          s3 += t2;
          t2 = "";
          c2 = 0;
        }
        t2 += String.fromCharCode(b2);
        ++c2;
      }
      s3 += t2;
      return s3;
    };
    util2.hexToBytes = function(hex) {
      var rval = "";
      var i2 = 0;
      if (hex.length & true) {
        i2 = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i2 < hex.length; i2 += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i2, 2), 16));
      }
      return rval;
    };
    util2.bytesToHex = function(bytes) {
      return util2.createBuffer(bytes).toHex();
    };
    util2.int32ToBytes = function(i2) {
      return String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      /*43 -43 = 0*/
      /*'+',  1,  2,  3,'/' */
      62,
      -1,
      -1,
      -1,
      63,
      /*'0','1','2','3','4','5','6','7','8','9' */
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      /*15, 16, 17,'=', 19, 20, 21 */
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      /*65 - 43 = 22*/
      /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      /*91 - 43 = 48 */
      /*48, 49, 50, 51, 52, 53 */
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      /*97 - 43 = 54*/
      /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util2.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.length) {
        chr1 = input.charCodeAt(i2++);
        chr2 = input.charCodeAt(i2++);
        chr3 = input.charCodeAt(i2++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util2.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i2 = 0;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util2.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util2.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util2.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util2.binary.raw.encode = function(bytes) {
      return String.fromCharCode.apply(null, bytes);
    };
    util2.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j2 = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j2++] = str.charCodeAt(i2);
      }
      return output ? j2 - offset : out;
    };
    util2.binary.hex.encode = util2.bytesToHex;
    util2.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i2 = 0, j2 = offset;
      if (hex.length & 1) {
        i2 = 1;
        out[j2++] = parseInt(hex[0], 16);
      }
      for (; i2 < hex.length; i2 += 2) {
        out[j2++] = parseInt(hex.substr(i2, 2), 16);
      }
      return output ? j2 - offset : out;
    };
    util2.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.byteLength) {
        chr1 = input[i2++];
        chr2 = input[i2++];
        chr3 = input[i2++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util2.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i2 = 0, j2 = offset;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        out[j2++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j2++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j2++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j2 - offset : out.subarray(0, j2);
    };
    util2.binary.base58.encode = function(input, maxline) {
      return util2.binary.baseN.encode(input, _base58, maxline);
    };
    util2.binary.base58.decode = function(input, maxline) {
      return util2.binary.baseN.decode(input, _base58, maxline);
    };
    util2.text = {
      utf8: {},
      utf16: {}
    };
    util2.text.utf8.encode = function(str, output, offset) {
      str = util2.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j2 = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j2++] = str.charCodeAt(i2);
      }
      return output ? j2 - offset : out;
    };
    util2.text.utf8.decode = function(bytes) {
      return util2.decodeUtf8(String.fromCharCode.apply(null, bytes));
    };
    util2.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j2 = offset;
      var k2 = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        view[k2++] = str.charCodeAt(i2);
        j2 += 2;
      }
      return output ? j2 - offset : out;
    };
    util2.text.utf16.decode = function(bytes) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
    };
    util2.deflate = function(api, bytes, raw) {
      bytes = util2.decode64(api.deflate(util2.encode64(bytes)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes = bytes.substring(start, bytes.length - 4);
      }
      return bytes;
    };
    util2.inflate = function(api, bytes, raw) {
      var rval = api.inflate(util2.encode64(bytes)).rval;
      return rval === null ? null : util2.decode64(rval);
    };
    var _setStorageObject = function(api, id2, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id2);
      } else {
        obj = util2.encode64(JSON.stringify(obj));
        rval = api.setItem(id2, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id2) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id2);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util2.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id2, key, data) {
      var obj = _getStorageObject(api, id2);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id2, obj);
    };
    var _getItem = function(api, id2, key) {
      var rval = _getStorageObject(api, id2);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id2, key) {
      var obj = _getStorageObject(api, id2);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty2 = true;
        for (var prop in obj) {
          empty2 = false;
          break;
        }
        if (empty2) {
          obj = null;
        }
        _setStorageObject(api, id2, obj);
      }
    };
    var _clearItems = function(api, id2) {
      _setStorageObject(api, id2, null);
    };
    var _callStorageFunction = function(func, args, location2) {
      var rval = null;
      if (typeof location2 === "undefined") {
        location2 = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location2) {
        type = location2[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util2.setItem = function(api, id2, key, data, location2) {
      _callStorageFunction(_setItem, arguments, location2);
    };
    util2.getItem = function(api, id2, key, location2) {
      return _callStorageFunction(_getItem, arguments, location2);
    };
    util2.removeItem = function(api, id2, key, location2) {
      _callStorageFunction(_removeItem, arguments, location2);
    };
    util2.clearItems = function(api, id2, location2) {
      _callStorageFunction(_clearItems, arguments, location2);
    };
    util2.parseUrl = function(str) {
      var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
      regex.lastIndex = 0;
      var m2 = regex.exec(str);
      var url = m2 === null ? null : {
        full: str,
        scheme: m2[1],
        host: m2[2],
        port: m2[3],
        path: m2[4]
      };
      if (url) {
        url.fullHost = url.host;
        if (url.port) {
          if (url.port !== 80 && url.scheme === "http") {
            url.fullHost += ":" + url.port;
          } else if (url.port !== 443 && url.scheme === "https") {
            url.fullHost += ":" + url.port;
          }
        } else if (url.scheme === "http") {
          url.port = 80;
        } else if (url.scheme === "https") {
          url.port = 443;
        }
        url.full = url.scheme + "://" + url.fullHost;
      }
      return url;
    };
    var _queryVariables = null;
    util2.getQueryVariables = function(query) {
      var parse = function(q2) {
        var rval2 = {};
        var kvpairs = q2.split("&");
        for (var i2 = 0; i2 < kvpairs.length; i2++) {
          var pos = kvpairs[i2].indexOf("=");
          var key;
          var val;
          if (pos > 0) {
            key = kvpairs[i2].substring(0, pos);
            val = kvpairs[i2].substring(pos + 1);
          } else {
            key = kvpairs[i2];
            val = null;
          }
          if (!(key in rval2)) {
            rval2[key] = [];
          }
          if (!(key in Object.prototype) && val !== null) {
            rval2[key].push(unescape(val));
          }
        }
        return rval2;
      };
      var rval;
      if (typeof query === "undefined") {
        if (_queryVariables === null) {
          if (typeof window !== "undefined" && window.location && window.location.search) {
            _queryVariables = parse(window.location.search.substring(1));
          } else {
            _queryVariables = {};
          }
        }
        rval = _queryVariables;
      } else {
        rval = parse(query);
      }
      return rval;
    };
    util2.parseFragment = function(fragment) {
      var fp2 = fragment;
      var fq = "";
      var pos = fragment.indexOf("?");
      if (pos > 0) {
        fp2 = fragment.substring(0, pos);
        fq = fragment.substring(pos + 1);
      }
      var path = fp2.split("/");
      if (path.length > 0 && path[0] === "") {
        path.shift();
      }
      var query = fq === "" ? {} : util2.getQueryVariables(fq);
      return {
        pathString: fp2,
        queryString: fq,
        path,
        query
      };
    };
    util2.makeRequest = function(reqString) {
      var frag = util2.parseFragment(reqString);
      var req = {
        // full path string
        path: frag.pathString,
        // full query string
        query: frag.queryString,
        /**
         * Get path or element in path.
         *
         * @param i optional path index.
         *
         * @return path or part of path if i provided.
         */
        getPath: function(i2) {
          return typeof i2 === "undefined" ? frag.path : frag.path[i2];
        },
        /**
         * Get query, values for a key, or value for a key index.
         *
         * @param k optional query key.
         * @param i optional query key index.
         *
         * @return query, values for a key, or value for a key index.
         */
        getQuery: function(k2, i2) {
          var rval;
          if (typeof k2 === "undefined") {
            rval = frag.query;
          } else {
            rval = frag.query[k2];
            if (rval && typeof i2 !== "undefined") {
              rval = rval[i2];
            }
          }
          return rval;
        },
        getQueryLast: function(k2, _default) {
          var rval;
          var vals = req.getQuery(k2);
          if (vals) {
            rval = vals[vals.length - 1];
          } else {
            rval = _default;
          }
          return rval;
        }
      };
      return req;
    };
    util2.makeLink = function(path, query, fragment) {
      path = jQuery.isArray(path) ? path.join("/") : path;
      var qstr = jQuery.param(query || {});
      fragment = fragment || "";
      return path + (qstr.length > 0 ? "?" + qstr : "") + (fragment.length > 0 ? "#" + fragment : "");
    };
    util2.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util2.format = function(format) {
      var re = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while (match = re.exec(format)) {
        part = format.substring(last, re.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re.lastIndex;
        var code2 = match[0][1];
        switch (code2) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code2 + "?>");
        }
      }
      parts.push(format.substring(last));
      return parts.join("");
    };
    util2.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n2 = number, c2 = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d2 = dec_point === void 0 ? "," : dec_point;
      var t2 = thousands_sep === void 0 ? "." : thousands_sep, s2 = n2 < 0 ? "-" : "";
      var i2 = parseInt(n2 = Math.abs(+n2 || 0).toFixed(c2), 10) + "";
      var j2 = i2.length > 3 ? i2.length % 3 : 0;
      return s2 + (j2 ? i2.substr(0, j2) + t2 : "") + i2.substr(j2).replace(/(\d{3})(?=\d)/g, "$1" + t2) + (c2 ? d2 + Math.abs(n2 - i2).toFixed(c2).slice(2) : "");
    };
    util2.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util2.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util2.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util2.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util2.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util2.bytesFromIP = function(ip2) {
      if (ip2.indexOf(".") !== -1) {
        return util2.bytesFromIPv4(ip2);
      }
      if (ip2.indexOf(":") !== -1) {
        return util2.bytesFromIPv6(ip2);
      }
      return null;
    };
    util2.bytesFromIPv4 = function(ip2) {
      ip2 = ip2.split(".");
      if (ip2.length !== 4) {
        return null;
      }
      var b2 = util2.createBuffer();
      for (var i2 = 0; i2 < ip2.length; ++i2) {
        var num = parseInt(ip2[i2], 10);
        if (isNaN(num)) {
          return null;
        }
        b2.putByte(num);
      }
      return b2.getBytes();
    };
    util2.bytesFromIPv6 = function(ip2) {
      var blanks = 0;
      ip2 = ip2.split(":").filter(function(e2) {
        if (e2.length === 0) ++blanks;
        return true;
      });
      var zeros = (8 - ip2.length + blanks) * 2;
      var b2 = util2.createBuffer();
      for (var i2 = 0; i2 < 8; ++i2) {
        if (!ip2[i2] || ip2[i2].length === 0) {
          b2.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes = util2.hexToBytes(ip2[i2]);
        if (bytes.length < 2) {
          b2.putByte(0);
        }
        b2.putBytes(bytes);
      }
      return b2.getBytes();
    };
    util2.bytesToIP = function(bytes) {
      if (bytes.length === 4) {
        return util2.bytesToIPv4(bytes);
      }
      if (bytes.length === 16) {
        return util2.bytesToIPv6(bytes);
      }
      return null;
    };
    util2.bytesToIPv4 = function(bytes) {
      if (bytes.length !== 4) {
        return null;
      }
      var ip2 = [];
      for (var i2 = 0; i2 < bytes.length; ++i2) {
        ip2.push(bytes.charCodeAt(i2));
      }
      return ip2.join(".");
    };
    util2.bytesToIPv6 = function(bytes) {
      if (bytes.length !== 16) {
        return null;
      }
      var ip2 = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i2 = 0; i2 < bytes.length; i2 += 2) {
        var hex = util2.bytesToHex(bytes[i2] + bytes[i2 + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip2.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last.end = idx;
            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip2.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip2.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip2.unshift("");
          }
          if (group.end === 7) {
            ip2.push("");
          }
        }
      }
      return ip2.join(":");
    };
    util2.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util2 && !options.update) {
        return callback(null, util2.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util2.cores = navigator.hardwareConcurrency;
        return callback(null, util2.cores);
      }
      if (typeof Worker === "undefined") {
        util2.cores = 1;
        return callback(null, util2.cores);
      }
      if (typeof Blob === "undefined") {
        util2.cores = 2;
        return callback(null, util2.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        (function() {
          self.addEventListener("message", function(e2) {
            var st2 = Date.now();
            var et = st2 + 4;
            while (Date.now() < et) ;
            self.postMessage({ st: st2, et });
          });
        }).toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x3) {
            return avg2 + x3;
          }, 0) / max.length);
          util2.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util2.cores);
        }
        map(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e2) {
            results.push(e2.data);
            if (results.length === numWorkers) {
              for (var i3 = 0; i3 < numWorkers; ++i3) {
                workers[i3].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          workers[i2].postMessage(i2);
        }
      }
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n2 = 0; n2 < numWorkers; ++n2) {
          var r12 = results[n2];
          var overlap = overlaps[n2] = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            if (n2 === i2) {
              continue;
            }
            var r2 = results[i2];
            if (r12.st > r2.st && r12.st < r2.et || r2.st > r12.st && r2.st < r12.et) {
              overlap.push(i2);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/cipher.js
var require_cipher2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/cipher.js"(exports2, module2) {
    var forge = require_forge2();
    require_util2();
    module2.exports = forge.cipher = forge.cipher || {};
    forge.cipher.algorithms = forge.cipher.algorithms || {};
    forge.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge.cipher.registerAlgorithm = function(name2, algorithm) {
      name2 = name2.toUpperCase();
      forge.cipher.algorithms[name2] = algorithm;
    };
    forge.cipher.getAlgorithm = function(name2) {
      name2 = name2.toUpperCase();
      if (name2 in forge.cipher.algorithms) {
        return forge.cipher.algorithms[name2];
      }
      return null;
    };
    var BlockCipher = forge.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge.util.createBuffer();
      this.output = options.output || forge.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/cipherModes.js
var require_cipherModes2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
    var forge = require_forge2();
    require_util2();
    forge.cipher = forge.cipher || {};
    var modes = module2.exports = forge.cipher.modes = forge.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = this._prev[i2] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._prev[i2] ^ this._outBlock[i2]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32() ^ this._outBlock[i2];
          output.putInt32(this._inBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32() ^ this._outBlock[i2];
        this._partialOutput.putInt32(this._partialBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32();
          output.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
          this._inBlock[i2] = this._outBlock[i2];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._outBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv2 = forge.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv2.length();
      if (ivLength === 12) {
        this._j0 = [iv2.getInt32(), iv2.getInt32(), iv2.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv2.length() > 0) {
          this._j0 = this.ghash(
            this._hashSubkey,
            this._j0,
            [iv2.getInt32(), iv2.getInt32(), iv2.getInt32(), iv2.getInt32()]
          );
        }
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [0, 0].concat(from64To32(ivLength * 8))
        );
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(this._outBlock[i2] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._outBlock[i2] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this.tag.putInt32(this._s[i2] ^ tag[i2]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x3, y2) {
      var z_i = [0, 0, 0, 0];
      var v_i = y2.slice(0);
      for (var i2 = 0; i2 < 128; ++i2) {
        var x_i = x3[i2 / 32 | 0] & 1 << 31 - i2 % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x3, out) {
      var lsb = x3[3] & 1;
      for (var i2 = 3; i2 > 0; --i2) {
        out[i2] = x3[i2] >>> 1 | (x3[i2 - 1] & 1) << 31;
      }
      out[0] = x3[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x3) {
      var z3 = [0, 0, 0, 0];
      for (var i2 = 0; i2 < 32; ++i2) {
        var idx = i2 / 8 | 0;
        var x_i = x3[idx] >>> (7 - i2 % 8) * 4 & 15;
        var ah2 = this._m[i2][x_i];
        z3[0] ^= ah2[0];
        z3[1] ^= ah2[1];
        z3[2] ^= ah2[2];
        z3[3] ^= ah2[3];
      }
      return z3;
    };
    modes.gcm.prototype.ghash = function(h2, y2, x3) {
      y2[0] ^= x3[0];
      y2[1] ^= x3[1];
      y2[2] ^= x3[2];
      y2[3] ^= x3[3];
      return this.tableMultiply(y2);
    };
    modes.gcm.prototype.generateHashTable = function(h2, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m2 = new Array(size);
      for (var i2 = 0; i2 < size; ++i2) {
        var tmp = [0, 0, 0, 0];
        var idx = i2 / perInt | 0;
        var shft = (perInt - 1 - i2 % perInt) * bits;
        tmp[idx] = 1 << bits - 1 << shft;
        m2[i2] = this.generateSubHashTable(this.multiply(tmp, h2), bits);
      }
      return m2;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size = 1 << bits;
      var half = size >>> 1;
      var m2 = new Array(size);
      m2[half] = mid.slice(0);
      var i2 = half >>> 1;
      while (i2 > 0) {
        this.pow(m2[2 * i2], m2[i2] = []);
        i2 >>= 1;
      }
      i2 = 2;
      while (i2 < half) {
        for (var j2 = 1; j2 < i2; ++j2) {
          var m_i = m2[i2];
          var m_j = m2[j2];
          m2[i2 + j2] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i2 *= 2;
      }
      m2[0] = [0, 0, 0, 0];
      for (i2 = half + 1; i2 < size; ++i2) {
        var c2 = m2[i2 ^ half];
        m2[i2] = [mid[0] ^ c2[0], mid[1] ^ c2[1], mid[2] ^ c2[2], mid[3] ^ c2[3]];
      }
      return m2;
    };
    function transformIV(iv2, blockSize) {
      if (typeof iv2 === "string") {
        iv2 = forge.util.createBuffer(iv2);
      }
      if (forge.util.isArray(iv2) && iv2.length > 4) {
        var tmp = iv2;
        iv2 = forge.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          iv2.putByte(tmp[i2]);
        }
      }
      if (iv2.length() < blockSize) {
        throw new Error(
          "Invalid IV length; got " + iv2.length() + " bytes and expected " + blockSize + " bytes."
        );
      }
      if (!forge.util.isArray(iv2)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i2 = 0; i2 < blocks; ++i2) {
          ints.push(iv2.getInt32());
        }
        iv2 = ints;
      }
      return iv2;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/aes.js
var require_aes2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/aes.js"(exports2, module2) {
    var forge = require_forge2();
    require_cipher2();
    require_cipherModes2();
    require_util2();
    module2.exports = forge.aes = forge.aes || {};
    forge.aes.startEncrypting = function(key, iv2, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode
      });
      cipher.start(iv2);
      return cipher;
    };
    forge.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.aes.startDecrypting = function(key, iv2, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode
      });
      cipher.start(iv2);
      return cipher;
    };
    forge.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.aes.Algorithm = function(name2, mode) {
      if (!init) {
        initialize();
      }
      var self2 = this;
      self2.name = name2;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge.util.createBuffer(key);
      } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          key.putByte(tmp[i2]);
        }
      }
      if (!forge.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i2 = 0; i2 < len; ++i2) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge.aes._expandKey = function(key, decrypt2) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt2);
    };
    forge.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
    function registerAlgorithm(name2, mode) {
      var factory = function() {
        return new forge.aes.Algorithm(name2, mode);
      };
      forge.cipher.registerAlgorithm(name2, factory);
    }
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i2 = 0; i2 < 128; ++i2) {
        xtime[i2] = i2 << 1;
        xtime[i2 + 128] = i2 + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i2 = 0; i2 < 4; ++i2) {
        mix[i2] = new Array(256);
        imix[i2] = new Array(256);
      }
      var e2 = 0, ei2 = 0, e22, e4, e8, sx, sx2, me, ime;
      for (var i2 = 0; i2 < 256; ++i2) {
        sx = ei2 ^ ei2 << 1 ^ ei2 << 2 ^ ei2 << 3 ^ ei2 << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e2] = sx;
        isbox[sx] = e2;
        sx2 = xtime[sx];
        e22 = xtime[e2];
        e4 = xtime[e22];
        e8 = xtime[e4];
        me = sx2 << 24 ^ // 2
        sx << 16 ^ // 1
        sx << 8 ^ // 1
        (sx ^ sx2);
        ime = (e22 ^ e4 ^ e8) << 24 ^ // E (14)
        (e2 ^ e8) << 16 ^ // 9
        (e2 ^ e4 ^ e8) << 8 ^ // D (13)
        (e2 ^ e22 ^ e8);
        for (var n2 = 0; n2 < 4; ++n2) {
          mix[n2][e2] = me;
          imix[n2][sx] = ime;
          me = me << 24 | me >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e2 === 0) {
          e2 = ei2 = 1;
        } else {
          e2 = e22 ^ xtime[xtime[xtime[e22 ^ e8]]];
          ei2 ^= xtime[xtime[ei2]];
        }
      }
    }
    function _expandKey(key, decrypt2) {
      var w3 = key.slice(0);
      var temp, iNk = 1;
      var Nk = w3.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i2 = Nk; i2 < end; ++i2) {
        temp = w3[i2 - 1];
        if (i2 % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i2 % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w3[i2] = w3[i2 - Nk] ^ temp;
      }
      if (decrypt2) {
        var tmp;
        var m02 = imix[0];
        var m12 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w3.slice(0);
        end = w3.length;
        for (var i2 = 0, wi2 = end - Nb; i2 < end; i2 += Nb, wi2 -= Nb) {
          if (i2 === 0 || i2 === end - Nb) {
            wnew[i2] = w3[wi2];
            wnew[i2 + 1] = w3[wi2 + 3];
            wnew[i2 + 2] = w3[wi2 + 2];
            wnew[i2 + 3] = w3[wi2 + 1];
          } else {
            for (var n2 = 0; n2 < Nb; ++n2) {
              tmp = w3[wi2 + n2];
              wnew[i2 + (3 & -n2)] = m02[sbox[tmp >>> 24]] ^ m12[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w3 = wnew;
      }
      return w3;
    }
    function _updateBlock(w3, input, output, decrypt2) {
      var Nr2 = w3.length / 4 - 1;
      var m02, m12, m2, m3, sub;
      if (decrypt2) {
        m02 = imix[0];
        m12 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m02 = mix[0];
        m12 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a2, b2, c2, d2, a22, b22, c22;
      a2 = input[0] ^ w3[0];
      b2 = input[decrypt2 ? 3 : 1] ^ w3[1];
      c2 = input[2] ^ w3[2];
      d2 = input[decrypt2 ? 1 : 3] ^ w3[3];
      var i2 = 3;
      for (var round = 1; round < Nr2; ++round) {
        a22 = m02[a2 >>> 24] ^ m12[b2 >>> 16 & 255] ^ m2[c2 >>> 8 & 255] ^ m3[d2 & 255] ^ w3[++i2];
        b22 = m02[b2 >>> 24] ^ m12[c2 >>> 16 & 255] ^ m2[d2 >>> 8 & 255] ^ m3[a2 & 255] ^ w3[++i2];
        c22 = m02[c2 >>> 24] ^ m12[d2 >>> 16 & 255] ^ m2[a2 >>> 8 & 255] ^ m3[b2 & 255] ^ w3[++i2];
        d2 = m02[d2 >>> 24] ^ m12[a2 >>> 16 & 255] ^ m2[b2 >>> 8 & 255] ^ m3[c2 & 255] ^ w3[++i2];
        a2 = a22;
        b2 = b22;
        c2 = c22;
      }
      output[0] = sub[a2 >>> 24] << 24 ^ sub[b2 >>> 16 & 255] << 16 ^ sub[c2 >>> 8 & 255] << 8 ^ sub[d2 & 255] ^ w3[++i2];
      output[decrypt2 ? 3 : 1] = sub[b2 >>> 24] << 24 ^ sub[c2 >>> 16 & 255] << 16 ^ sub[d2 >>> 8 & 255] << 8 ^ sub[a2 & 255] ^ w3[++i2];
      output[2] = sub[c2 >>> 24] << 24 ^ sub[d2 >>> 16 & 255] << 16 ^ sub[a2 >>> 8 & 255] << 8 ^ sub[b2 & 255] ^ w3[++i2];
      output[decrypt2 ? 1 : 3] = sub[d2 >>> 24] << 24 ^ sub[a2 >>> 16 & 255] << 16 ^ sub[b2 >>> 8 & 255] << 8 ^ sub[c2 & 255] ^ w3[++i2];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv2, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv2;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// ../../node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET2, name2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET2.length; i2++) {
    var x3 = ALPHABET2.charAt(i2);
    var xc2 = x3.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x3 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode9(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j3 = zeroes;
    while (it4 !== size) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode8(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode9,
    decodeUnsafe,
    decode: decode8
  };
}
var src, _brrp__multiformats_scope_baseX, base_x_default;
var init_base_x = __esm({
  "../../node_modules/multiformats/esm/vendor/base-x.js"() {
    src = base;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
  }
});

// ../../node_modules/multiformats/esm/src/bytes.js
var empty, equals, coerce, fromString, toString3;
var init_bytes = __esm({
  "../../node_modules/multiformats/esm/src/bytes.js"() {
    empty = new Uint8Array(0);
    equals = (aa2, bb) => {
      if (aa2 === bb)
        return true;
      if (aa2.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii2 = 0; ii2 < aa2.byteLength; ii2++) {
        if (aa2[ii2] !== bb[ii2]) {
          return false;
        }
      }
      return true;
    };
    coerce = (o2) => {
      if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
        return o2;
      if (o2 instanceof ArrayBuffer)
        return new Uint8Array(o2);
      if (ArrayBuffer.isView(o2)) {
        return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    fromString = (str) => new TextEncoder().encode(str);
    toString3 = (b2) => new TextDecoder().decode(b2);
  }
});

// ../../node_modules/multiformats/esm/src/bases/base.js
var Encoder, Decoder, ComposedDecoder, or, Codec, from, baseX, decode2, encode4, rfc4648;
var init_base = __esm({
  "../../node_modules/multiformats/esm/src/bases/base.js"() {
    init_base_x();
    init_bytes();
    Encoder = class {
      constructor(name2, prefix, baseEncode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder = class {
      constructor(name2, prefix, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or(this, decoder);
      }
    };
    ComposedDecoder = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or = (left, right) => new ComposedDecoder({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    Codec = class {
      constructor(name2, prefix, baseEncode, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name2, prefix, baseEncode);
        this.decoder = new Decoder(name2, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    from = ({ name: name2, prefix, encode: encode9, decode: decode8 }) => new Codec(name2, prefix, encode9, decode8);
    baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
      const { encode: encode9, decode: decode8 } = base_x_default(alphabet2, name2);
      return from({
        prefix,
        name: name2,
        encode: encode9,
        decode: (text) => coerce(decode8(text))
      });
    };
    decode2 = (string2, alphabet2, bitsPerChar, name2) => {
      const codes = {};
      for (let i2 = 0; i2 < alphabet2.length; ++i2) {
        codes[alphabet2[i2]] = i2;
      }
      let end = string2.length;
      while (string2[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i2 = 0; i2 < end; ++i2) {
        const value = codes[string2[i2]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name2} character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode4 = (data, alphabet2, bitsPerChar) => {
      const pad = alphabet2[alphabet2.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i2 = 0; i2 < data.length; ++i2) {
        buffer = buffer << 8 | data[i2];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet2[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet2[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
      return from({
        prefix,
        name: name2,
        encode(input) {
          return encode4(input, alphabet2, bitsPerChar);
        },
        decode(input) {
          return decode2(input, alphabet2, bitsPerChar, name2);
        }
      });
    };
  }
});

// ../../node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity;
var init_identity = __esm({
  "../../node_modules/multiformats/esm/src/bases/identity.js"() {
    init_base();
    init_bytes();
    identity = from({
      prefix: "\0",
      name: "identity",
      encode: (buf) => toString3(buf),
      decode: (str) => fromString(str)
    });
  }
});

// ../../node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2;
var init_base2 = __esm({
  "../../node_modules/multiformats/esm/src/bases/base2.js"() {
    init_base();
    base2 = rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
  }
});

// ../../node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8;
var init_base8 = __esm({
  "../../node_modules/multiformats/esm/src/bases/base8.js"() {
    init_base();
    base8 = rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
  }
});

// ../../node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10;
var init_base10 = __esm({
  "../../node_modules/multiformats/esm/src/bases/base10.js"() {
    init_base();
    base10 = baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
  }
});

// ../../node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16, base16upper;
var init_base16 = __esm({
  "../../node_modules/multiformats/esm/src/bases/base16.js"() {
    init_base();
    base16 = rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper = rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
  }
});

// ../../node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z;
var init_base32 = __esm({
  "../../node_modules/multiformats/esm/src/bases/base32.js"() {
    init_base();
    base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// ../../node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36, base36upper;
var init_base36 = __esm({
  "../../node_modules/multiformats/esm/src/bases/base36.js"() {
    init_base();
    base36 = baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper = baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});

// ../../node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc, base58flickr;
var init_base58 = __esm({
  "../../node_modules/multiformats/esm/src/bases/base58.js"() {
    init_base();
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// ../../node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64, base64pad, base64url, base64urlpad;
var init_base64 = __esm({
  "../../node_modules/multiformats/esm/src/bases/base64.js"() {
    init_base();
    base64 = rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad = rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url = rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad = rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});

// ../../node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
function encode5(data) {
  return data.reduce((p2, c2) => {
    p2 += alphabetBytesToChars[c2];
    return p2;
  }, "");
}
function decode3(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var alphabet, alphabetBytesToChars, alphabetCharsToBytes, base256emoji;
var init_base256emoji = __esm({
  "../../node_modules/multiformats/esm/src/bases/base256emoji.js"() {
    init_base();
    alphabet = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
    alphabetBytesToChars = alphabet.reduce((p2, c2, i2) => {
      p2[i2] = c2;
      return p2;
    }, []);
    alphabetCharsToBytes = alphabet.reduce((p2, c2, i2) => {
      p2[c2.codePointAt(0)] = i2;
      return p2;
    }, []);
    base256emoji = from({
      prefix: "🚀",
      name: "base256emoji",
      encode: encode5,
      decode: decode3
    });
  }
});

// ../../node_modules/multiformats/esm/vendor/varint.js
function encode6(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode6.bytes = offset - oldOffset + 1;
  return out;
}
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf.length;
  do {
    if (counter >= l2) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf[counter++];
    res += shift < 28 ? (b2 & REST$1) << shift : (b2 & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var encode_1, MSB, REST, MSBALL, INT, decode4, MSB$1, REST$1, N1, N2, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default;
var init_varint = __esm({
  "../../node_modules/multiformats/esm/vendor/varint.js"() {
    encode_1 = encode6;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    decode4 = read;
    MSB$1 = 128;
    REST$1 = 127;
    N1 = Math.pow(2, 7);
    N2 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    varint = {
      encode: encode_1,
      decode: decode4,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
  }
});

// ../../node_modules/multiformats/esm/src/varint.js
var decode5, encodeTo, encodingLength;
var init_varint2 = __esm({
  "../../node_modules/multiformats/esm/src/varint.js"() {
    init_varint();
    decode5 = (data, offset = 0) => {
      const code2 = varint_default.decode(data, offset);
      return [
        code2,
        varint_default.decode.bytes
      ];
    };
    encodeTo = (int, target, offset = 0) => {
      varint_default.encode(int, target, offset);
      return target;
    };
    encodingLength = (int) => {
      return varint_default.encodingLength(int);
    };
  }
});

// ../../node_modules/multiformats/esm/src/hashes/digest.js
var create, decode6, equals2, Digest;
var init_digest = __esm({
  "../../node_modules/multiformats/esm/src/hashes/digest.js"() {
    init_bytes();
    init_varint2();
    create = (code2, digest2) => {
      const size = digest2.byteLength;
      const sizeOffset = encodingLength(code2);
      const digestOffset = sizeOffset + encodingLength(size);
      const bytes = new Uint8Array(digestOffset + size);
      encodeTo(code2, bytes, 0);
      encodeTo(size, bytes, sizeOffset);
      bytes.set(digest2, digestOffset);
      return new Digest(code2, size, digest2, bytes);
    };
    decode6 = (multihash) => {
      const bytes = coerce(multihash);
      const [code2, sizeOffset] = decode5(bytes);
      const [size, digestOffset] = decode5(bytes.subarray(sizeOffset));
      const digest2 = bytes.subarray(sizeOffset + digestOffset);
      if (digest2.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest(code2, size, digest2, bytes);
    };
    equals2 = (a2, b2) => {
      if (a2 === b2) {
        return true;
      } else {
        return a2.code === b2.code && a2.size === b2.size && equals(a2.bytes, b2.bytes);
      }
    };
    Digest = class {
      constructor(code2, size, digest2, bytes) {
        this.code = code2;
        this.size = size;
        this.digest = digest2;
        this.bytes = bytes;
      }
    };
  }
});

// ../../node_modules/multiformats/esm/src/hashes/hasher.js
var from2, Hasher;
var init_hasher = __esm({
  "../../node_modules/multiformats/esm/src/hashes/hasher.js"() {
    init_digest();
    from2 = ({ name: name2, code: code2, encode: encode9 }) => new Hasher(name2, code2, encode9);
    Hasher = class {
      constructor(name2, code2, encode9) {
        this.name = name2;
        this.code = code2;
        this.encode = encode9;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// ../../node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha2562,
  sha512: () => sha5122
});
var sha, sha2562, sha5122;
var init_sha2_browser = __esm({
  "../../node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
    init_hasher();
    sha = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
    sha2562 = from2({
      name: "sha2-256",
      code: 18,
      encode: sha("SHA-256")
    });
    sha5122 = from2({
      name: "sha2-512",
      code: 19,
      encode: sha("SHA-512")
    });
  }
});

// ../../node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code, name, encode7, digest, identity2;
var init_identity2 = __esm({
  "../../node_modules/multiformats/esm/src/hashes/identity.js"() {
    init_bytes();
    init_digest();
    code = 0;
    name = "identity";
    encode7 = coerce;
    digest = (input) => create(code, encode7(input));
    identity2 = {
      code,
      name,
      encode: encode7,
      digest
    };
  }
});

// ../../node_modules/multiformats/esm/src/codecs/raw.js
var init_raw = __esm({
  "../../node_modules/multiformats/esm/src/codecs/raw.js"() {
    init_bytes();
  }
});

// ../../node_modules/multiformats/esm/src/codecs/json.js
var textEncoder, textDecoder;
var init_json = __esm({
  "../../node_modules/multiformats/esm/src/codecs/json.js"() {
    textEncoder = new TextEncoder();
    textDecoder = new TextDecoder();
  }
});

// ../../node_modules/multiformats/esm/src/cid.js
var CID, parseCIDtoBytes, toStringV0, toStringV1, DAG_PB_CODE, SHA_256_CODE, encodeCID, cidSymbol, readonly, hidden, version, deprecate, IS_CID_DEPRECATION;
var init_cid = __esm({
  "../../node_modules/multiformats/esm/src/cid.js"() {
    init_varint2();
    init_digest();
    init_base58();
    init_base32();
    init_bytes();
    CID = class _CID {
      constructor(version2, code2, multihash, bytes) {
        this.code = code2;
        this.version = version2;
        this.multihash = multihash;
        this.bytes = bytes;
        this.byteOffset = bytes.byteOffset;
        this.byteLength = bytes.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code2, multihash } = this;
            if (code2 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code2, digest: digest2 } = this.multihash;
            const multihash = create(code2, digest2);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
      }
      toString(base3) {
        const { bytes, version: version2, _baseCache } = this;
        switch (version2) {
          case 0:
            return toStringV0(bytes, _baseCache, base3 || base58btc.encoder);
          default:
            return toStringV1(bytes, _baseCache, base3 || base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof _CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version2, code: code2, multihash, bytes } = value;
          return new _CID(version2, code2, multihash, bytes || encodeCID(version2, code2, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version2, multihash, code: code2 } = value;
          const digest2 = decode6(multihash);
          return _CID.create(version2, code2, digest2);
        } else {
          return null;
        }
      }
      static create(version2, code2, digest2) {
        if (typeof code2 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version2) {
          case 0: {
            if (code2 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new _CID(version2, code2, digest2, digest2.bytes);
            }
          }
          case 1: {
            const bytes = encodeCID(version2, code2, digest2.bytes);
            return new _CID(version2, code2, digest2, bytes);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest2) {
        return _CID.create(0, DAG_PB_CODE, digest2);
      }
      static createV1(code2, digest2) {
        return _CID.create(1, code2, digest2);
      }
      static decode(bytes) {
        const [cid, remainder] = _CID.decodeFirst(bytes);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes) {
        const specs = _CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest2) : _CID.createV1(specs.codec, digest2);
        return [
          cid,
          bytes.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i2, length2] = decode5(initialBytes.subarray(offset));
          offset += length2;
          return i2;
        };
        let version2 = next();
        let codec = DAG_PB_CODE;
        if (version2 === 18) {
          version2 = 0;
          offset = 0;
        } else if (version2 === 1) {
          codec = next();
        }
        if (version2 !== 0 && version2 !== 1) {
          throw new RangeError(`Invalid CID version ${version2}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version2,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base3) {
        const [prefix, bytes] = parseCIDtoBytes(source, base3);
        const cid = _CID.decode(bytes);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    parseCIDtoBytes = (source, base3) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(`${base58btc.prefix}${source}`)
          ];
        }
        case base58btc.prefix: {
          const decoder = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(source)
          ];
        }
        case base32.prefix: {
          const decoder = base3 || base32;
          return [
            base32.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base3 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base3.decode(source)
          ];
        }
      }
    };
    toStringV0 = (bytes, cache, base3) => {
      const { prefix } = base3;
      if (prefix !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
      }
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes).slice(1);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV1 = (bytes, cache, base3) => {
      const { prefix } = base3;
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    encodeCID = (version2, code2, multihash) => {
      const codeOffset = encodingLength(version2);
      const hashOffset = codeOffset + encodingLength(code2);
      const bytes = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo(version2, bytes, 0);
      encodeTo(code2, bytes, codeOffset);
      bytes.set(multihash, hashOffset);
      return bytes;
    };
    cidSymbol = Symbol.for("@ipld/js-cid/CID");
    readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    version = "0.0.0-dev";
    deprecate = (range, message) => {
      if (range.test(version)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  }
});

// ../../node_modules/multiformats/esm/src/index.js
var init_src = __esm({
  "../../node_modules/multiformats/esm/src/index.js"() {
    init_cid();
    init_varint2();
    init_bytes();
    init_hasher();
    init_digest();
  }
});

// ../../node_modules/multiformats/esm/src/basics.js
var bases, hashes;
var init_basics = __esm({
  "../../node_modules/multiformats/esm/src/basics.js"() {
    init_identity();
    init_base2();
    init_base8();
    init_base10();
    init_base16();
    init_base32();
    init_base36();
    init_base58();
    init_base64();
    init_base256emoji();
    init_sha2_browser();
    init_identity2();
    init_raw();
    init_json();
    init_src();
    bases = {
      ...identity_exports,
      ...base2_exports,
      ...base8_exports,
      ...base10_exports,
      ...base16_exports,
      ...base32_exports,
      ...base36_exports,
      ...base58_exports,
      ...base64_exports,
      ...base256emoji_exports
    };
    hashes = {
      ...sha2_browser_exports,
      ...identity_exports2
    };
  }
});

// ../../node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}
var init_as_uint8array = __esm({
  "../../node_modules/uint8arrays/esm/src/util/as-uint8array.js"() {
  }
});

// ../../node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}
var init_alloc = __esm({
  "../../node_modules/uint8arrays/esm/src/alloc.js"() {
    init_as_uint8array();
  }
});

// ../../node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name2, prefix, encode9, decode8) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode9
    },
    decoder: { decode: decode8 }
  };
}
var string, ascii, BASES, bases_default;
var init_bases = __esm({
  "../../node_modules/uint8arrays/esm/src/util/bases.js"() {
    init_basics();
    init_alloc();
    string = createCodec("utf8", "u", (buf) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    ascii = createCodec("ascii", "a", (buf) => {
      let string2 = "a";
      for (let i2 = 0; i2 < buf.length; i2++) {
        string2 += String.fromCharCode(buf[i2]);
      }
      return string2;
    }, (str) => {
      str = str.substring(1);
      const buf = allocUnsafe(str.length);
      for (let i2 = 0; i2 < str.length; i2++) {
        buf[i2] = str.charCodeAt(i2);
      }
      return buf;
    });
    BASES = {
      utf8: string,
      "utf-8": string,
      hex: bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...bases
    };
    bases_default = BASES;
  }
});

// ../../node_modules/uint8arrays/esm/src/to-string.js
var to_string_exports = {};
__export(to_string_exports, {
  toString: () => toString4
});
function toString4(array, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
var init_to_string = __esm({
  "../../node_modules/uint8arrays/esm/src/to-string.js"() {
    init_bases();
  }
});

// ../../node_modules/uint8arrays/esm/src/from-string.js
var from_string_exports = {};
__export(from_string_exports, {
  fromString: () => fromString2
});
function fromString2(string2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
var init_from_string = __esm({
  "../../node_modules/uint8arrays/esm/src/from-string.js"() {
    init_bases();
    init_as_uint8array();
  }
});

// ../../node_modules/libp2p-crypto/src/aes/ciphers-browser.js
var require_ciphers_browser = __commonJS({
  "../../node_modules/libp2p-crypto/src/aes/ciphers-browser.js"(exports2, module2) {
    "use strict";
    require_aes2();
    var forge = require_forge2();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    module2.exports = {
      createCipheriv: (mode, key, iv2) => {
        const cipher2 = forge.cipher.createCipher("AES-CTR", uint8ArrayToString(key, "ascii"));
        cipher2.start({ iv: uint8ArrayToString(iv2, "ascii") });
        return {
          update: (data) => {
            cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, "ascii")));
            return uint8ArrayFromString(cipher2.output.getBytes(), "ascii");
          }
        };
      },
      createDecipheriv: (mode, key, iv2) => {
        const cipher2 = forge.cipher.createDecipher("AES-CTR", uint8ArrayToString(key, "ascii"));
        cipher2.start({ iv: uint8ArrayToString(iv2, "ascii") });
        return {
          update: (data) => {
            cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, "ascii")));
            return uint8ArrayFromString(cipher2.output.getBytes(), "ascii");
          }
        };
      }
    };
  }
});

// ../../node_modules/err-code/index.js
var require_err_code = __commonJS({
  "../../node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code2, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code2 === "object") {
        props = code2;
        code2 = "";
      }
      if (code2) {
        props.code = code2;
      }
      try {
        return assign(err, props);
      } catch (_3) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});

// ../../node_modules/libp2p-crypto/src/aes/cipher-mode.js
var require_cipher_mode = __commonJS({
  "../../node_modules/libp2p-crypto/src/aes/cipher-mode.js"(exports2, module2) {
    "use strict";
    var errcode = require_err_code();
    var CIPHER_MODES = {
      16: "aes-128-ctr",
      32: "aes-256-ctr"
    };
    module2.exports = function(key) {
      const mode = CIPHER_MODES[key.length];
      if (!mode) {
        const modes = Object.entries(CIPHER_MODES).map(([k2, v3]) => `${k2} (${v3})`).join(" / ");
        throw errcode(new Error(`Invalid key length ${key.length} bytes. Must be ${modes}`), "ERR_INVALID_KEY_LENGTH");
      }
      return mode;
    };
  }
});

// ../../node_modules/libp2p-crypto/src/aes/index.js
var require_aes3 = __commonJS({
  "../../node_modules/libp2p-crypto/src/aes/index.js"(exports2) {
    "use strict";
    var ciphers = require_ciphers_browser();
    var cipherMode = require_cipher_mode();
    exports2.create = async function(key, iv2) {
      const mode = cipherMode(key);
      const cipher = ciphers.createCipheriv(mode, key, iv2);
      const decipher = ciphers.createDecipheriv(mode, key, iv2);
      const res = {
        async encrypt(data) {
          return cipher.update(data);
        },
        async decrypt(data) {
          return decipher.update(data);
        }
      };
      return res;
    };
  }
});

// ../../node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../../node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn2, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn2.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// ../../node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "../../node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base642 = exports2;
    base642.length = function length2(string2) {
      var p2 = string2.length;
      if (!p2)
        return 0;
      var n2 = 0;
      while (--p2 % 4 > 1 && string2.charAt(p2) === "=")
        ++n2;
      return Math.ceil(string2.length * 3) / 4 - n2;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i2 = 0; i2 < 64; )
      s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
    var i2;
    base642.encode = function encode9(buffer, start, end) {
      var parts = null, chunk = [];
      var i3 = 0, j2 = 0, t2;
      while (start < end) {
        var b2 = buffer[start++];
        switch (j2) {
          case 0:
            chunk[i3++] = b64[b2 >> 2];
            t2 = (b2 & 3) << 4;
            j2 = 1;
            break;
          case 1:
            chunk[i3++] = b64[t2 | b2 >> 4];
            t2 = (b2 & 15) << 2;
            j2 = 2;
            break;
          case 2:
            chunk[i3++] = b64[t2 | b2 >> 6];
            chunk[i3++] = b64[b2 & 63];
            j2 = 0;
            break;
        }
        if (i3 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i3 = 0;
        }
      }
      if (j2) {
        chunk[i3++] = b64[t2];
        chunk[i3++] = 61;
        if (j2 === 1)
          chunk[i3++] = 61;
      }
      if (parts) {
        if (i3)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i3));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode8(string2, buffer, offset) {
      var start = offset;
      var j2 = 0, t2;
      for (var i3 = 0; i3 < string2.length; ) {
        var c2 = string2.charCodeAt(i3++);
        if (c2 === 61 && j2 > 1)
          break;
        if ((c2 = s64[c2]) === void 0)
          throw Error(invalidEncoding);
        switch (j2) {
          case 0:
            t2 = c2;
            j2 = 1;
            break;
          case 1:
            buffer[offset++] = t2 << 2 | (c2 & 48) >> 4;
            t2 = c2;
            j2 = 2;
            break;
          case 2:
            buffer[offset++] = (t2 & 15) << 4 | (c2 & 60) >> 2;
            t2 = c2;
            j2 = 3;
            break;
          case 3:
            buffer[offset++] = (t2 & 3) << 6 | c2;
            j2 = 0;
            break;
        }
      }
      if (j2 === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base642.test = function test2(string2) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
    };
  }
});

// ../../node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../../node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on2(evt, fn2, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn: fn2,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn2) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn2 === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i2 = 0; i2 < listeners.length; )
            if (listeners[i2].fn === fn2)
              listeners.splice(i2, 1);
            else
              ++i2;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i2 = 1;
        for (; i2 < arguments.length; )
          args.push(arguments[i2++]);
        for (i2 = 0; i2 < listeners.length; )
          listeners[i2].fn.apply(listeners[i2++].ctx, args);
      }
      return this;
    };
  }
});

// ../../node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "../../node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign2 = val < 0 ? 1 : 0;
          if (sign2)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign2 << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign2 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign2 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 1401298464324817e-60 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign2 = val < 0 ? 1 : 0;
          if (sign2)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign2 << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo2 = readUint(buf, pos + off0), hi2 = readUint(buf, pos + off1);
          var sign2 = (hi2 >> 31) * 2 + 1, exponent = hi2 >>> 20 & 2047, mantissa = 4294967296 * (hi2 & 1048575) + lo2;
          return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 5e-324 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// ../../node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../../node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e2) {
      }
      return null;
    }
  }
});

// ../../node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "../../node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string2) {
      var len = 0, c2 = 0;
      for (var i2 = 0; i2 < string2.length; ++i2) {
        c2 = string2.charCodeAt(i2);
        if (c2 < 128)
          len += 1;
        else if (c2 < 2048)
          len += 2;
        else if ((c2 & 64512) === 55296 && (string2.charCodeAt(i2 + 1) & 64512) === 56320) {
          ++i2;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i2 = 0, t2;
      while (start < end) {
        t2 = buffer[start++];
        if (t2 < 128)
          chunk[i2++] = t2;
        else if (t2 > 191 && t2 < 224)
          chunk[i2++] = (t2 & 31) << 6 | buffer[start++] & 63;
        else if (t2 > 239 && t2 < 365) {
          t2 = ((t2 & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i2++] = 55296 + (t2 >> 10);
          chunk[i2++] = 56320 + (t2 & 1023);
        } else
          chunk[i2++] = (t2 & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    utf8.write = function utf8_write(string2, buffer, offset) {
      var start = offset, c12, c2;
      for (var i2 = 0; i2 < string2.length; ++i2) {
        c12 = string2.charCodeAt(i2);
        if (c12 < 128) {
          buffer[offset++] = c12;
        } else if (c12 < 2048) {
          buffer[offset++] = c12 >> 6 | 192;
          buffer[offset++] = c12 & 63 | 128;
        } else if ((c12 & 64512) === 55296 && ((c2 = string2.charCodeAt(i2 + 1)) & 64512) === 56320) {
          c12 = 65536 + ((c12 & 1023) << 10) + (c2 & 1023);
          ++i2;
          buffer[offset++] = c12 >> 18 | 240;
          buffer[offset++] = c12 >> 12 & 63 | 128;
          buffer[offset++] = c12 >> 6 & 63 | 128;
          buffer[offset++] = c12 & 63 | 128;
        } else {
          buffer[offset++] = c12 >> 12 | 224;
          buffer[offset++] = c12 >> 6 & 63 | 128;
          buffer[offset++] = c12 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// ../../node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../../node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// ../../node_modules/libp2p-crypto/node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util2 = require_minimal();
    function LongBits(lo2, hi2) {
      this.lo = lo2 >>> 0;
      this.hi = hi2 >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign2 = value < 0;
      if (sign2)
        value = -value;
      var lo2 = value >>> 0, hi2 = (value - lo2) / 4294967296 >>> 0;
      if (sign2) {
        hi2 = ~hi2 >>> 0;
        lo2 = ~lo2 >>> 0;
        if (++lo2 > 4294967295) {
          lo2 = 0;
          if (++hi2 > 4294967295)
            hi2 = 0;
        }
      }
      return new LongBits(lo2, hi2);
    };
    LongBits.from = function from3(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util2.isString(value)) {
        if (util2.Long)
          value = util2.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo2 = ~this.lo + 1 >>> 0, hi2 = ~this.hi >>> 0;
        if (!lo2)
          hi2 = hi2 + 1 >>> 0;
        return -(lo2 + hi2 * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash3) {
      if (hash3 === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash3, 0) | charCodeAt.call(hash3, 1) << 8 | charCodeAt.call(hash3, 2) << 16 | charCodeAt.call(hash3, 3) << 24) >>> 0,
        (charCodeAt.call(hash3, 4) | charCodeAt.call(hash3, 5) << 8 | charCodeAt.call(hash3, 6) << 16 | charCodeAt.call(hash3, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length2() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util2 = exports2;
    util2.asPromise = require_aspromise();
    util2.base64 = require_base64();
    util2.EventEmitter = require_eventemitter();
    util2.float = require_float();
    util2.inquire = require_inquire();
    util2.utf8 = require_utf8();
    util2.pool = require_pool();
    util2.LongBits = require_longbits();
    util2.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util2.global = util2.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util2.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util2.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util2.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util2.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer4 = util2.inquire("buffer").Buffer;
        return Buffer4.prototype.utf8Write ? Buffer4 : (
          /* istanbul ignore next */
          null
        );
      } catch (e2) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value) {
      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash3, unsigned) {
      var bits = util2.LongBits.fromHash(hash3);
      if (util2.Long)
        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge2(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i2 = 0; i2 < keys.length; ++i2)
        if (dst[keys[i2]] === void 0 || !ifNotSet)
          dst[keys[i2]] = src2[keys[i2]];
      return dst;
    }
    util2.merge = merge2;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name2;
      } });
      CustomError.prototype.toString = function toString5() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys = Object.keys(this), i3 = keys.length - 1; i3 > -1; --i3)
          if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== void 0 && this[keys[i3]] !== null)
            return keys[i3];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name2)
            delete this[fieldNames[i2]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer4 = util2.Buffer;
      if (!Buffer4) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer4.from !== Uint8Array.from && Buffer4.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer4(value, encoding);
      };
      util2._Buffer_allocUnsafe = Buffer4.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer4(size);
      };
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util2 = require_minimal();
    var BufferWriter;
    var LongBits = util2.LongBits;
    var base642 = util2.base64;
    var utf8 = util2.utf8;
    function Op2(fn2, len, val) {
      this.fn = fn2;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op2(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create2 = function create3() {
      return util2.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create2();
    Writer.alloc = function alloc(size) {
      return new util2.Array(size);
    };
    if (util2.Array !== Array)
      Writer.alloc = util2.pool(Writer.alloc, util2.Array.prototype.subarray);
    Writer.prototype._push = function push(fn2, len, val) {
      this.tail = this.tail.next = new Op2(fn2, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op2.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util2.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util2.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util2.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i2 = 0; i2 < val.length; ++i2)
        buf[pos + i2] = val[i2];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util2.isString(value)) {
        var buf = Writer.alloc(len = base642.length(value));
        base642.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op2(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op2(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create2();
      BufferWriter._configure();
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util2 = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util2._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else for (var i2 = 0; i2 < val.length; )
          buf[pos++] = val[i2++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util2.isString(value))
        value = util2._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util2.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util2.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/libp2p-crypto/node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util2 = require_minimal();
    var BufferReader;
    var LongBits = util2.LongBits;
    var utf8 = util2.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create2 = function create3() {
      return util2.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util2.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create2();
    Reader.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
    util2.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i2 = 0;
      if (this.len - this.pos > 4) {
        for (; i2 < 4; ++i2) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i2 = 0;
      } else {
        for (; i2 < 3; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i2 < 5; ++i2) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i2 < 5; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util2.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util2.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length2 = this.uint32(), start = this.pos, end = this.pos + length2;
      if (end > this.len)
        throw indexOutOfRange(this, length2);
      this.pos += length2;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length2) {
      if (typeof length2 === "number") {
        if (this.pos + length2 > this.len)
          throw indexOutOfRange(this, length2);
        this.pos += length2;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create2();
      BufferReader._configure();
      var fn2 = util2.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util2.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn2](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn2](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn2](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn2](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn2](false);
        }
      });
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util2 = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util2.Buffer)
        BufferReader.prototype._slice = util2.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/libp2p-crypto/node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util2 = require_minimal();
    (Service.prototype = Object.create(util2.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util2.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util2.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../../node_modules/libp2p-crypto/node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// ../../node_modules/libp2p-crypto/node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// ../../node_modules/libp2p-crypto/node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// ../../node_modules/libp2p-crypto/src/keys/keys.js
var require_keys2 = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/keys.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["libp2p-crypto-keys"] || ($protobuf.roots["libp2p-crypto-keys"] = {});
    $root.KeyType = function() {
      var valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = "RSA"] = 0;
      values[valuesById[1] = "Ed25519"] = 1;
      values[valuesById[2] = "Secp256k1"] = 2;
      return values;
    }();
    $root.PublicKey = function() {
      function PublicKey(p2) {
        if (p2) {
          for (var ks2 = Object.keys(p2), i2 = 0; i2 < ks2.length; ++i2)
            if (p2[ks2[i2]] != null)
              this[ks2[i2]] = p2[ks2[i2]];
        }
      }
      PublicKey.prototype.Type = 0;
      PublicKey.prototype.Data = $util.newBuffer([]);
      PublicKey.encode = function encode9(m2, w3) {
        if (!w3)
          w3 = $Writer.create();
        w3.uint32(8).int32(m2.Type);
        w3.uint32(18).bytes(m2.Data);
        return w3;
      };
      PublicKey.decode = function decode8(r2, l2) {
        if (!(r2 instanceof $Reader))
          r2 = $Reader.create(r2);
        var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.PublicKey();
        while (r2.pos < c2) {
          var t2 = r2.uint32();
          switch (t2 >>> 3) {
            case 1:
              m2.Type = r2.int32();
              break;
            case 2:
              m2.Data = r2.bytes();
              break;
            default:
              r2.skipType(t2 & 7);
              break;
          }
        }
        if (!m2.hasOwnProperty("Type"))
          throw $util.ProtocolError("missing required 'Type'", { instance: m2 });
        if (!m2.hasOwnProperty("Data"))
          throw $util.ProtocolError("missing required 'Data'", { instance: m2 });
        return m2;
      };
      PublicKey.fromObject = function fromObject(d2) {
        if (d2 instanceof $root.PublicKey)
          return d2;
        var m2 = new $root.PublicKey();
        switch (d2.Type) {
          case "RSA":
          case 0:
            m2.Type = 0;
            break;
          case "Ed25519":
          case 1:
            m2.Type = 1;
            break;
          case "Secp256k1":
          case 2:
            m2.Type = 2;
            break;
        }
        if (d2.Data != null) {
          if (typeof d2.Data === "string")
            $util.base64.decode(d2.Data, m2.Data = $util.newBuffer($util.base64.length(d2.Data)), 0);
          else if (d2.Data.length)
            m2.Data = d2.Data;
        }
        return m2;
      };
      PublicKey.toObject = function toObject(m2, o2) {
        if (!o2)
          o2 = {};
        var d2 = {};
        if (o2.defaults) {
          d2.Type = o2.enums === String ? "RSA" : 0;
          if (o2.bytes === String)
            d2.Data = "";
          else {
            d2.Data = [];
            if (o2.bytes !== Array)
              d2.Data = $util.newBuffer(d2.Data);
          }
        }
        if (m2.Type != null && m2.hasOwnProperty("Type")) {
          d2.Type = o2.enums === String ? $root.KeyType[m2.Type] : m2.Type;
        }
        if (m2.Data != null && m2.hasOwnProperty("Data")) {
          d2.Data = o2.bytes === String ? $util.base64.encode(m2.Data, 0, m2.Data.length) : o2.bytes === Array ? Array.prototype.slice.call(m2.Data) : m2.Data;
        }
        return d2;
      };
      PublicKey.prototype.toJSON = function toJSON2() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return PublicKey;
    }();
    $root.PrivateKey = function() {
      function PrivateKey(p2) {
        if (p2) {
          for (var ks2 = Object.keys(p2), i2 = 0; i2 < ks2.length; ++i2)
            if (p2[ks2[i2]] != null)
              this[ks2[i2]] = p2[ks2[i2]];
        }
      }
      PrivateKey.prototype.Type = 0;
      PrivateKey.prototype.Data = $util.newBuffer([]);
      PrivateKey.encode = function encode9(m2, w3) {
        if (!w3)
          w3 = $Writer.create();
        w3.uint32(8).int32(m2.Type);
        w3.uint32(18).bytes(m2.Data);
        return w3;
      };
      PrivateKey.decode = function decode8(r2, l2) {
        if (!(r2 instanceof $Reader))
          r2 = $Reader.create(r2);
        var c2 = l2 === void 0 ? r2.len : r2.pos + l2, m2 = new $root.PrivateKey();
        while (r2.pos < c2) {
          var t2 = r2.uint32();
          switch (t2 >>> 3) {
            case 1:
              m2.Type = r2.int32();
              break;
            case 2:
              m2.Data = r2.bytes();
              break;
            default:
              r2.skipType(t2 & 7);
              break;
          }
        }
        if (!m2.hasOwnProperty("Type"))
          throw $util.ProtocolError("missing required 'Type'", { instance: m2 });
        if (!m2.hasOwnProperty("Data"))
          throw $util.ProtocolError("missing required 'Data'", { instance: m2 });
        return m2;
      };
      PrivateKey.fromObject = function fromObject(d2) {
        if (d2 instanceof $root.PrivateKey)
          return d2;
        var m2 = new $root.PrivateKey();
        switch (d2.Type) {
          case "RSA":
          case 0:
            m2.Type = 0;
            break;
          case "Ed25519":
          case 1:
            m2.Type = 1;
            break;
          case "Secp256k1":
          case 2:
            m2.Type = 2;
            break;
        }
        if (d2.Data != null) {
          if (typeof d2.Data === "string")
            $util.base64.decode(d2.Data, m2.Data = $util.newBuffer($util.base64.length(d2.Data)), 0);
          else if (d2.Data.length)
            m2.Data = d2.Data;
        }
        return m2;
      };
      PrivateKey.toObject = function toObject(m2, o2) {
        if (!o2)
          o2 = {};
        var d2 = {};
        if (o2.defaults) {
          d2.Type = o2.enums === String ? "RSA" : 0;
          if (o2.bytes === String)
            d2.Data = "";
          else {
            d2.Data = [];
            if (o2.bytes !== Array)
              d2.Data = $util.newBuffer(d2.Data);
          }
        }
        if (m2.Type != null && m2.hasOwnProperty("Type")) {
          d2.Type = o2.enums === String ? $root.KeyType[m2.Type] : m2.Type;
        }
        if (m2.Data != null && m2.hasOwnProperty("Data")) {
          d2.Data = o2.bytes === String ? $util.base64.encode(m2.Data, 0, m2.Data.length) : o2.bytes === Array ? Array.prototype.slice.call(m2.Data) : m2.Data;
        }
        return d2;
      };
      PrivateKey.prototype.toJSON = function toJSON2() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return PrivateKey;
    }();
    module2.exports = $root;
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/oids.js
var require_oids2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/oids.js"(exports2, module2) {
    var forge = require_forge2();
    forge.pki = forge.pki || {};
    var oids = module2.exports = forge.pki.oids = forge.oids = forge.oids || {};
    function _IN(id2, name2) {
      oids[id2] = name2;
      oids[name2] = id2;
    }
    function _I_(id2, name2) {
      oids[id2] = name2;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.5", "serialName");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/asn1.js
var require_asn13 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/asn1.js"(exports2, module2) {
    var forge = require_forge2();
    require_util2();
    require_oids2();
    var asn12 = module2.exports = forge.asn1 = forge.asn1 || {};
    asn12.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn12.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn12.create = function(tagClass, type, constructed, value, options) {
      if (forge.util.isArray(value)) {
        var tmp = [];
        for (var i2 = 0; i2 < value.length; ++i2) {
          if (value[i2] !== void 0) {
            tmp.push(value[i2]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge.util.isArray(value),
        value
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn12.copy(obj);
      }
      return obj;
    };
    asn12.copy = function(obj, options) {
      var copy;
      if (forge.util.isArray(obj)) {
        copy = [];
        for (var i2 = 0; i2 < obj.length; ++i2) {
          copy.push(asn12.copy(obj[i2], options));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn12.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn12.equals = function(obj1, obj2, options) {
      if (forge.util.isArray(obj1)) {
        if (!forge.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i2 = 0; i2 < obj1.length; ++i2) {
          if (!asn12.equals(obj1[i2], obj2[i2])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn12.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn12.getBerValueLength = function(b2) {
      var b22 = b2.getByte();
      if (b22 === 128) {
        return void 0;
      }
      var length2;
      var longForm = b22 & 128;
      if (!longForm) {
        length2 = b22;
      } else {
        length2 = b2.getInt((b22 & 127) << 3);
      }
      return length2;
    };
    function _checkBufferLength(bytes, remaining, n2) {
      if (n2 > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes.length();
        error.remaining = remaining;
        error.requested = n2;
        throw error;
      }
    }
    var _getValueLength = function(bytes, remaining) {
      var b2 = bytes.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length2;
      var longForm = b2 & 128;
      if (!longForm) {
        length2 = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes, remaining, longFormBytes);
        length2 = bytes.getInt(longFormBytes << 3);
      }
      if (length2 < 0) {
        throw new Error("Negative length: " + length2);
      }
      return length2;
    };
    asn12.fromDer = function(bytes, options) {
      if (options === void 0) {
        options = {
          strict: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      return _fromDer(bytes, bytes.length(), 0, options);
    };
    function _fromDer(bytes, remaining, depth, options) {
      var start;
      _checkBufferLength(bytes, remaining, 2);
      var b12 = bytes.getByte();
      remaining--;
      var tagClass = b12 & 192;
      var type = b12 & 31;
      start = bytes.length();
      var length2 = _getValueLength(bytes, remaining);
      remaining -= start - bytes.length();
      if (length2 !== void 0 && length2 > remaining) {
        if (options.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes.length();
          error.remaining = remaining;
          error.requested = length2;
          throw error;
        }
        length2 = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b12 & 32) === 32;
      if (constructed) {
        value = [];
        if (length2 === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes, remaining, 2);
            if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
              bytes.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes.length();
            value.push(_fromDer(bytes, remaining, depth + 1, options));
            remaining -= start - bytes.length();
          }
        } else {
          while (length2 > 0) {
            start = bytes.length();
            value.push(_fromDer(bytes, length2, depth + 1, options));
            remaining -= start - bytes.length();
            length2 -= start - bytes.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn12.Class.UNIVERSAL && type === asn12.Type.BITSTRING) {
        bitStringContents = bytes.bytes(length2);
      }
      if (value === void 0 && options.decodeBitStrings && tagClass === asn12.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
      // .. other parts of forge expect to decode OCTET STRINGs manually
      type === asn12.Type.BITSTRING && length2 > 1) {
        var savedRead = bytes.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn12.Type.BITSTRING) {
          _checkBufferLength(bytes, remaining, 1);
          unused = bytes.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes.length();
            var subOptions = {
              // enforce strict mode to avoid parsing ASN.1 from plain data
              verbose: options.verbose,
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
            var used = start - bytes.length();
            remaining -= used;
            if (type == asn12.Type.BITSTRING) {
              used++;
            }
            var tc2 = composed.tagClass;
            if (used === length2 && (tc2 === asn12.Class.UNIVERSAL || tc2 === asn12.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length2 === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length2 = remaining;
        }
        if (type === asn12.Type.BMPSTRING) {
          value = "";
          for (; length2 > 0; length2 -= 2) {
            _checkBufferLength(bytes, remaining, 2);
            value += String.fromCharCode(bytes.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes.getBytes(length2);
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn12.create(tagClass, type, constructed, value, asn1Options);
    }
    asn12.toDer = function(obj) {
      var bytes = forge.util.createBuffer();
      var b12 = obj.tagClass | obj.type;
      var value = forge.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn12.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b12 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            value.putBuffer(asn12.toDer(obj.value[i2]));
          }
        }
      } else {
        if (obj.type === asn12.Type.BMPSTRING) {
          for (var i2 = 0; i2 < obj.value.length; ++i2) {
            value.putInt16(obj.value.charCodeAt(i2));
          }
        } else {
          if (obj.type === asn12.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
          (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes.putByte(b12);
      if (value.length() <= 127) {
        bytes.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes.putByte(lenBytes.length | 128);
        for (var i2 = lenBytes.length - 1; i2 >= 0; --i2) {
          bytes.putByte(lenBytes.charCodeAt(i2));
        }
      }
      bytes.putBuffer(value);
      return bytes;
    };
    asn12.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes = forge.util.createBuffer();
      bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last, valueBytes, value, b2;
      for (var i2 = 2; i2 < values.length; ++i2) {
        last = true;
        valueBytes = [];
        value = parseInt(values[i2], 10);
        do {
          b2 = value & 127;
          value = value >>> 7;
          if (!last) {
            b2 |= 128;
          }
          valueBytes.push(b2);
          last = false;
        } while (value > 0);
        for (var n2 = valueBytes.length - 1; n2 >= 0; --n2) {
          bytes.putByte(valueBytes[n2]);
        }
      }
      return bytes;
    };
    asn12.derToOid = function(bytes) {
      var oid;
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      var b2 = bytes.getByte();
      oid = Math.floor(b2 / 40) + "." + b2 % 40;
      var value = 0;
      while (bytes.length() > 0) {
        b2 = bytes.getByte();
        value = value << 7;
        if (b2 & 128) {
          value += b2 & 127;
        } else {
          oid += "." + (value + b2);
          value = 0;
        }
      }
      return oid;
    };
    asn12.utcTimeToDate = function(utc) {
      var date = /* @__PURE__ */ new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh2 = parseInt(utc.substr(6, 2), 10);
      var mm2 = parseInt(utc.substr(8, 2), 10);
      var ss2 = 0;
      if (utc.length > 11) {
        var c2 = utc.charAt(10);
        var end = 10;
        if (c2 !== "+" && c2 !== "-") {
          ss2 = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh2, mm2, ss2, 0);
      if (end) {
        c2 = utc.charAt(end);
        if (c2 === "+" || c2 === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c2 === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn12.generalizedTimeToDate = function(gentime) {
      var date = /* @__PURE__ */ new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh2 = parseInt(gentime.substr(8, 2), 10);
      var mm2 = parseInt(gentime.substr(10, 2), 10);
      var ss2 = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c2 = gentime.charAt(end);
      if (c2 === "+" || c2 === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c2 === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh2, mm2, ss2, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh2, mm2, ss2, fff);
      }
      return date;
    };
    asn12.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push(("" + date.getUTCFullYear()).substr(2));
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format.length; ++i2) {
        if (format[i2].length < 2) {
          rval += "0";
        }
        rval += format[i2];
      }
      rval += "Z";
      return rval;
    };
    asn12.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push("" + date.getUTCFullYear());
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format.length; ++i2) {
        if (format[i2].length < 2) {
          rval += "0";
        }
        rval += format[i2];
      }
      rval += "Z";
      return rval;
    };
    asn12.integerToDer = function(x3) {
      var rval = forge.util.createBuffer();
      if (x3 >= -128 && x3 < 128) {
        return rval.putSignedInt(x3, 8);
      }
      if (x3 >= -32768 && x3 < 32768) {
        return rval.putSignedInt(x3, 16);
      }
      if (x3 >= -8388608 && x3 < 8388608) {
        return rval.putSignedInt(x3, 24);
      }
      if (x3 >= -2147483648 && x3 < 2147483648) {
        return rval.putSignedInt(x3, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x3;
      throw error;
    };
    asn12.derToInteger = function(bytes) {
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      var n2 = bytes.length() * 8;
      if (n2 > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes.getSignedInt(n2);
    };
    asn12.validate = function(obj, v3, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v3.tagClass || typeof v3.tagClass === "undefined") && (obj.type === v3.type || typeof v3.type === "undefined")) {
        if (obj.constructed === v3.constructed || typeof v3.constructed === "undefined") {
          rval = true;
          if (v3.value && forge.util.isArray(v3.value)) {
            var j2 = 0;
            for (var i2 = 0; rval && i2 < v3.value.length; ++i2) {
              rval = v3.value[i2].optional || false;
              if (obj.value[j2]) {
                rval = asn12.validate(obj.value[j2], v3.value[i2], capture, errors);
                if (rval) {
                  ++j2;
                } else if (v3.value[i2].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push(
                  "[" + v3.name + '] Tag class "' + v3.tagClass + '", type "' + v3.type + '" expected value length "' + v3.value.length + '", got "' + obj.value.length + '"'
                );
              }
            }
          }
          if (rval && capture) {
            if (v3.capture) {
              capture[v3.capture] = obj.value;
            }
            if (v3.captureAsn1) {
              capture[v3.captureAsn1] = obj;
            }
            if (v3.captureBitStringContents && "bitStringContents" in obj) {
              capture[v3.captureBitStringContents] = obj.bitStringContents;
            }
            if (v3.captureBitStringValue && "bitStringContents" in obj) {
              var value;
              if (obj.bitStringContents.length < 2) {
                capture[v3.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error(
                    "captureBitStringValue only supported for zero unused bits"
                  );
                }
                capture[v3.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors) {
          errors.push(
            "[" + v3.name + '] Expected constructed "' + v3.constructed + '", got "' + obj.constructed + '"'
          );
        }
      } else if (errors) {
        if (obj.tagClass !== v3.tagClass) {
          errors.push(
            "[" + v3.name + '] Expected tag class "' + v3.tagClass + '", got "' + obj.tagClass + '"'
          );
        }
        if (obj.type !== v3.type) {
          errors.push(
            "[" + v3.name + '] Expected type "' + v3.type + '", got "' + obj.type + '"'
          );
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn12.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i2 = 0; i2 < level * indentation; ++i2) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn12.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn12.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn12.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn12.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn12.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn12.Type.NONE:
            rval += " (None)";
            break;
          case asn12.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn12.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn12.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn12.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn12.Type.NULL:
            rval += " (Null)";
            break;
          case asn12.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn12.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn12.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn12.Type.REAL:
            rval += " (Real)";
            break;
          case asn12.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn12.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn12.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn12.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn12.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn12.Type.SET:
            rval += " (Set)";
            break;
          case asn12.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn12.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn12.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn12.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn12.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            subvalues += 1;
            sub += asn12.prettyPrint(obj.value[i2], level + 1, indentation);
            if (i2 + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn12.Type.OID) {
          var oid = asn12.derToOid(obj.value);
          rval += oid;
          if (forge.pki && forge.pki.oids) {
            if (oid in forge.pki.oids) {
              rval += " (" + forge.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn12.Type.INTEGER) {
          try {
            rval += asn12.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn12.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn12.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.type === asn12.Type.UTF8) {
          rval += forge.util.decodeUtf8(obj.value);
        } else if (obj.type === asn12.Type.PRINTABLESTRING || obj.type === asn12.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/des.js
var require_des2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/des.js"(exports2, module2) {
    var forge = require_forge2();
    require_cipher2();
    require_cipherModes2();
    require_util2();
    module2.exports = forge.des = forge.des || {};
    forge.des.startEncrypting = function(key, iv2, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode: mode || (iv2 === null ? "ECB" : "CBC")
      });
      cipher.start(iv2);
      return cipher;
    };
    forge.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.des.startDecrypting = function(key, iv2, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode: mode || (iv2 === null ? "ECB" : "CBC")
      });
      cipher.start(iv2);
      return cipher;
    };
    forge.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.des.Algorithm = function(name2, mode) {
      var self2 = this;
      self2.name = name2;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
    function registerAlgorithm(name2, mode) {
      var factory = function() {
        return new forge.des.Algorithm(name2, mode);
      };
      forge.cipher.registerAlgorithm(name2, factory);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n2 = 0, tmp;
      for (var j2 = 0; j2 < iterations; j2++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i2 = 0; i2 < shifts.length; ++i2) {
          if (shifts[i2]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n2++] = lefttmp ^ tmp;
          keys[n2++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt2) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt2 ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt2 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j2 = 0; j2 < iterations; j2 += 3) {
        var endloop = looping[j2 + 1];
        var loopinc = looping[j2 + 2];
        for (var i2 = looping[j2]; i2 != endloop; i2 += loopinc) {
          var right1 = right ^ keys[i2];
          var right2 = (right >>> 4 | right << 28) ^ keys[i2 + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv2, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv2;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/md.js
var require_md3 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/md.js"(exports2, module2) {
    var forge = require_forge2();
    module2.exports = forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/hmac.js
var require_hmac4 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/hmac.js"(exports2, module2) {
    var forge = require_forge2();
    require_md3();
    require_util2();
    var hmac = module2.exports = forge.hmac = forge.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md2, key) {
        if (md2 !== null) {
          if (typeof md2 === "string") {
            md2 = md2.toLowerCase();
            if (md2 in forge.md.algorithms) {
              _md = forge.md.algorithms[md2].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md2 + '"');
            }
          } else {
            _md = md2;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge.util.createBuffer(key);
          } else if (forge.util.isArray(key)) {
            var tmp = key;
            key = forge.util.createBuffer();
            for (var i2 = 0; i2 < tmp.length; ++i2) {
              key.putByte(tmp[i2]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge.util.createBuffer();
          _opadding = forge.util.createBuffer();
          keylen = key.length();
          for (var i2 = 0; i2 < keylen; ++i2) {
            var tmp = key.at(i2);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i2 = 0; i2 < tmp; ++i2) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes) {
        _md.update(bytes);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf23 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
    var forge = require_forge2();
    require_hmac4();
    require_md3();
    require_util2();
    var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
    var crypto2;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript) {
      crypto2 = require_crypto2();
    }
    module2.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p2, s2, c2, dkLen, md2, callback) {
      if (typeof md2 === "function") {
        callback = md2;
        md2 = null;
      }
      if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto2.pbkdf2 && (md2 === null || typeof md2 !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md2 || md2 === "sha1"))) {
        if (typeof md2 !== "string") {
          md2 = "sha1";
        }
        p2 = Buffer.from(p2, "binary");
        s2 = Buffer.from(s2, "binary");
        if (!callback) {
          if (crypto2.pbkdf2Sync.length === 4) {
            return crypto2.pbkdf2Sync(p2, s2, c2, dkLen).toString("binary");
          }
          return crypto2.pbkdf2Sync(p2, s2, c2, dkLen, md2).toString("binary");
        }
        if (crypto2.pbkdf2Sync.length === 4) {
          return crypto2.pbkdf2(p2, s2, c2, dkLen, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto2.pbkdf2(p2, s2, c2, dkLen, md2, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md2 === "undefined" || md2 === null) {
        md2 = "sha1";
      }
      if (typeof md2 === "string") {
        if (!(md2 in forge.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md2);
        }
        md2 = forge.md[md2].create();
      }
      var hLen = md2.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r2 = dkLen - (len - 1) * hLen;
      var prf = forge.hmac.create();
      prf.start(md2, p2);
      var dk = "";
      var xor, u_c, u_c1;
      if (!callback) {
        for (var i2 = 1; i2 <= len; ++i2) {
          prf.start(null, null);
          prf.update(s2);
          prf.update(forge.util.int32ToBytes(i2));
          xor = u_c1 = prf.digest().getBytes();
          for (var j2 = 2; j2 <= c2; ++j2) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i2 < len ? xor : xor.substr(0, r2);
        }
        return dk;
      }
      var i2 = 1, j2;
      function outer() {
        if (i2 > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s2);
        prf.update(forge.util.int32ToBytes(i2));
        xor = u_c1 = prf.digest().getBytes();
        j2 = 2;
        inner();
      }
      function inner() {
        if (j2 <= c2) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
          ++j2;
          return forge.util.setImmediate(inner);
        }
        dk += i2 < len ? xor : xor.substr(0, r2);
        ++i2;
        outer();
      }
      outer();
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/pem.js
var require_pem4 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/pem.js"(exports2, module2) {
    var forge = require_forge2();
    require_util2();
    var pem = module2.exports = forge.pem = forge.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i2 = 0; i2 < msg.headers.length; ++i2) {
          rval += foldHeader(msg.headers[i2]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var msg = {
          type: match[1],
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li2 = 0;
        while (match && li2 < lines.length) {
          var line = lines[li2].replace(/\s+$/, "");
          for (var nl2 = li2 + 1; nl2 < lines.length; ++nl2) {
            var next = lines[nl2];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li2 = nl2;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values = match[2].split(",");
            for (var vi2 = 0; vi2 < values.length; ++vi2) {
              header.values.push(ltrim(values[vi2]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li2;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = function(match, $1) {
        return " " + $1;
      };
      for (var i2 = 0; i2 < header.values.length; ++i2) {
        values.push(header.values[i2].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length2 = 0;
      var candidate = -1;
      for (var i2 = 0; i2 < rval.length; ++i2, ++length2) {
        if (length2 > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length2 = i2 - candidate - 1;
          candidate = -1;
          ++i2;
        } else if (rval[i2] === " " || rval[i2] === "	" || rval[i2] === ",") {
          candidate = i2;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/sha256.js
var require_sha2563 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/sha256.js"(exports2, module2) {
    var forge = require_forge2();
    require_md3();
    require_util2();
    var sha2563 = module2.exports = forge.sha256 = forge.sha256 || {};
    forge.md.sha256 = forge.md.algorithms.sha256 = sha2563;
    sha2563.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w2 = new Array(64);
      var md2 = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength64 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w2, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var next, carry;
        var bits = md2.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md2.fullMessageLength.length - 1; ++i2) {
          next = md2.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w2, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    function _update(s2, w3, bytes) {
      var t12, t2, s02, s12, ch2, maj, i2, a2, b2, c2, d2, e2, f2, g2, h2;
      var len = bytes.length();
      while (len >= 64) {
        for (i2 = 0; i2 < 16; ++i2) {
          w3[i2] = bytes.getInt32();
        }
        for (; i2 < 64; ++i2) {
          t12 = w3[i2 - 2];
          t12 = (t12 >>> 17 | t12 << 15) ^ (t12 >>> 19 | t12 << 13) ^ t12 >>> 10;
          t2 = w3[i2 - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w3[i2] = t12 + w3[i2 - 7] + t2 + w3[i2 - 16] | 0;
        }
        a2 = s2.h0;
        b2 = s2.h1;
        c2 = s2.h2;
        d2 = s2.h3;
        e2 = s2.h4;
        f2 = s2.h5;
        g2 = s2.h6;
        h2 = s2.h7;
        for (i2 = 0; i2 < 64; ++i2) {
          s12 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
          ch2 = g2 ^ e2 & (f2 ^ g2);
          s02 = (a2 >>> 2 | a2 << 30) ^ (a2 >>> 13 | a2 << 19) ^ (a2 >>> 22 | a2 << 10);
          maj = a2 & b2 | c2 & (a2 ^ b2);
          t12 = h2 + s12 + ch2 + _k[i2] + w3[i2];
          t2 = s02 + maj;
          h2 = g2;
          g2 = f2;
          f2 = e2;
          e2 = d2 + t12 >>> 0;
          d2 = c2;
          c2 = b2;
          b2 = a2;
          a2 = t12 + t2 >>> 0;
        }
        s2.h0 = s2.h0 + a2 | 0;
        s2.h1 = s2.h1 + b2 | 0;
        s2.h2 = s2.h2 + c2 | 0;
        s2.h3 = s2.h3 + d2 | 0;
        s2.h4 = s2.h4 + e2 | 0;
        s2.h5 = s2.h5 + f2 | 0;
        s2.h6 = s2.h6 + g2 | 0;
        s2.h7 = s2.h7 + h2 | 0;
        len -= 64;
      }
    }
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/prng.js
var require_prng2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/prng.js"(exports2, module2) {
    var forge = require_forge2();
    require_util2();
    var _crypto = null;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require_crypto2();
    }
    var prng = module2.exports = forge.prng = forge.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        // number of reseeds so far
        reseeds: 0,
        // amount of data generated so far
        generated: 0,
        // no initial key bytes
        keyBytes: ""
      };
      var md2 = plugin.md;
      var pools = new Array(32);
      for (var i2 = 0; i2 < 32; ++i2) {
        pools[i2] = md2.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b2 = forge.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err) {
          if (err) {
            return callback(err);
          }
          if (b2.length() >= count) {
            return callback(null, b2.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge.util.setImmediate(generate);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b2 = forge.util.createBuffer();
        while (b2.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b2.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md3 = ctx.plugin.md.create();
        md3.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k2 = 0; k2 < 32; ++k2) {
          if (ctx.reseeds % _2powK === 0) {
            md3.update(ctx.pools[k2].digest().getBytes());
            ctx.pools[k2].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md3.digest().getBytes();
        md3.start();
        md3.update(ctx.keyBytes);
        var seedBytes = md3.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b2 = forge.util.createBuffer();
        if (getRandomValues) {
          while (b2.length() < needed) {
            var count = Math.max(1, Math.min(needed - b2.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i3 = 0; i3 < entropy.length; ++i3) {
                b2.putInt32(entropy[i3]);
              }
            } catch (e2) {
              if (!(typeof QuotaExceededError !== "undefined" && e2 instanceof QuotaExceededError)) {
                throw e2;
              }
            }
          }
        }
        if (b2.length() < needed) {
          var hi2, lo2, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b2.length() < needed) {
            lo2 = 16807 * (seed & 65535);
            hi2 = 16807 * (seed >> 16);
            lo2 += (hi2 & 32767) << 16;
            lo2 += hi2 >> 15;
            lo2 = (lo2 & 2147483647) + (lo2 >> 31);
            seed = lo2 & 4294967295;
            for (var i3 = 0; i3 < 3; ++i3) {
              next = seed >>> (i3 << 3);
              next ^= Math.floor(Math.random() * 256);
              b2.putByte(String.fromCharCode(next & 255));
            }
          }
        }
        return b2.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e2) {
            callback(e2);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes) {
        var count = bytes.length;
        for (var i3 = 0; i3 < count; ++i3) {
          ctx.pools[ctx.pool].update(bytes.substr(i3, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i3, n2) {
        var bytes = "";
        for (var x3 = 0; x3 < n2; x3 += 8) {
          bytes += String.fromCharCode(i3 >> x3 & 255);
        }
        ctx.collect(bytes);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e2) {
              var data = e2.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = function(e2) {
            var data = e2.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
                worker.postMessage({ forge: { prng: { err, bytes } } });
              });
            }
          };
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/random.js
var require_random2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/random.js"(exports2, module2) {
    var forge = require_forge2();
    require_aes2();
    require_sha2563();
    require_prng2();
    require_util2();
    (function() {
      if (forge.random && forge.random.getBytes) {
        module2.exports = forge.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key2, seed) {
          forge.aes._updateBlock(key2, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge.md.sha256;
        function spawnPrng() {
          var ctx = forge.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
        if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e2) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e2) {
              _ctx.collectInt(e2.clientX, 16);
              _ctx.collectInt(e2.clientY, 16);
            });
            jQuery2().keypress(function(e2) {
              _ctx.collectInt(e2.charCode, 8);
            });
          }
        }
        if (!forge.random) {
          forge.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge.random[key] = _ctx[key];
          }
        }
        forge.random.createInstance = spawnPrng;
        module2.exports = forge.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/rc2.js
var require_rc22 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/rc2.js"(exports2, module2) {
    var forge = require_forge2();
    require_util2();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s2 = [1, 2, 3, 5];
    var rol = function(word, bits) {
      return word << bits & 65535 | (word & 65535) >> 16 - bits;
    };
    var ror = function(word, bits) {
      return (word & 65535) >> bits | word << 16 - bits & 65535;
    };
    module2.exports = forge.rc2 = forge.rc2 || {};
    forge.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L2 = key;
      var T3 = key.length();
      var T12 = effKeyBits;
      var T8 = Math.ceil(T12 / 8);
      var TM = 255 >> (T12 & 7);
      var i2;
      for (i2 = T3; i2 < 128; i2++) {
        L2.putByte(piTable[L2.at(i2 - 1) + L2.at(i2 - T3) & 255]);
      }
      L2.setAt(128 - T8, piTable[L2.at(128 - T8) & TM]);
      for (i2 = 127 - T8; i2 >= 0; i2--) {
        L2.setAt(i2, piTable[L2.at(i2 + 1) ^ L2.at(i2 + T8)]);
      }
      return L2;
    };
    var createCipher = function(key, bits, encrypt2) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i2, j2, K2 = [];
      key = forge.rc2.expandKey(key, bits);
      for (i2 = 0; i2 < 64; i2++) {
        K2.push(key.getInt16Le());
      }
      if (encrypt2) {
        mixRound = function(R2) {
          for (i2 = 0; i2 < 4; i2++) {
            R2[i2] += K2[j2] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
            R2[i2] = rol(R2[i2], s2[i2]);
            j2++;
          }
        };
        mashRound = function(R2) {
          for (i2 = 0; i2 < 4; i2++) {
            R2[i2] += K2[R2[(i2 + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R2) {
          for (i2 = 3; i2 >= 0; i2--) {
            R2[i2] = ror(R2[i2], s2[i2]);
            R2[i2] -= K2[j2] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
            j2--;
          }
        };
        mashRound = function(R2) {
          for (i2 = 3; i2 >= 0; i2--) {
            R2[i2] -= K2[R2[(i2 + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R2 = [];
        for (i2 = 0; i2 < 4; i2++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt2) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R2.push(val & 65535);
        }
        j2 = encrypt2 ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R2);
          }
        }
        for (i2 = 0; i2 < 4; i2++) {
          if (_iv !== null) {
            if (encrypt2) {
              _iv.putInt16Le(R2[i2]);
            } else {
              R2[i2] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R2[i2]);
        }
      };
      var cipher = null;
      cipher = {
        /**
         * Starts or restarts the encryption or decryption process, whichever
         * was previously configured.
         *
         * To use the cipher in CBC mode, iv may be given either as a string
         * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
         *
         * @param iv the initialization vector to use, null for ECB mode.
         * @param output the output the buffer to write to, null to create one.
         */
        start: function(iv2, output) {
          if (iv2) {
            if (typeof iv2 === "string") {
              iv2 = forge.util.createBuffer(iv2);
            }
          }
          _finish = false;
          _input = forge.util.createBuffer();
          _output = output || new forge.util.createBuffer();
          _iv = iv2;
          cipher.output = _output;
        },
        /**
         * Updates the next block.
         *
         * @param input the buffer to read from.
         */
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        /**
         * Finishes encrypting or decrypting.
         *
         * @param pad a padding function to use, null for PKCS#7 padding,
         *           signature(blockSize, buffer, decrypt).
         *
         * @return true if successful, false on error.
         */
        finish: function(pad) {
          var rval = true;
          if (encrypt2) {
            if (pad) {
              rval = pad(8, _input, !encrypt2);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt2) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt2);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge.rc2.startEncrypting = function(key, iv2, output) {
      var cipher = forge.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv2, output);
      return cipher;
    };
    forge.rc2.createEncryptionCipher = function(key, bits) {
      return createCipher(key, bits, true);
    };
    forge.rc2.startDecrypting = function(key, iv2, output) {
      var cipher = forge.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv2, output);
      return cipher;
    };
    forge.rc2.createDecryptionCipher = function(key, bits) {
      return createCipher(key, bits, false);
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/jsbn.js
var require_jsbn2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
    var forge = require_forge2();
    module2.exports = forge.jsbn = forge.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a2, b2, c2) {
      this.data = [];
      if (a2 != null)
        if ("number" == typeof a2) this.fromNumber(a2, b2, c2);
        else if (b2 == null && "string" != typeof a2) this.fromString(a2, 256);
        else this.fromString(a2, b2);
    }
    forge.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i2, x3, w3, j2, c2, n2) {
      while (--n2 >= 0) {
        var v3 = x3 * this.data[i2++] + w3.data[j2] + c2;
        c2 = Math.floor(v3 / 67108864);
        w3.data[j2++] = v3 & 67108863;
      }
      return c2;
    }
    function am2(i2, x3, w3, j2, c2, n2) {
      var xl2 = x3 & 32767, xh2 = x3 >> 15;
      while (--n2 >= 0) {
        var l2 = this.data[i2] & 32767;
        var h2 = this.data[i2++] >> 15;
        var m2 = xh2 * l2 + h2 * xl2;
        l2 = xl2 * l2 + ((m2 & 32767) << 15) + w3.data[j2] + (c2 & 1073741823);
        c2 = (l2 >>> 30) + (m2 >>> 15) + xh2 * h2 + (c2 >>> 30);
        w3.data[j2++] = l2 & 1073741823;
      }
      return c2;
    }
    function am3(i2, x3, w3, j2, c2, n2) {
      var xl2 = x3 & 16383, xh2 = x3 >> 14;
      while (--n2 >= 0) {
        var l2 = this.data[i2] & 16383;
        var h2 = this.data[i2++] >> 14;
        var m2 = xh2 * l2 + h2 * xl2;
        l2 = xl2 * l2 + ((m2 & 16383) << 14) + w3.data[j2] + c2;
        c2 = (l2 >> 28) + (m2 >> 14) + xh2 * h2;
        w3.data[j2++] = l2 & 268435455;
      }
      return c2;
    }
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr2;
    var vv2;
    rr2 = "0".charCodeAt(0);
    for (vv2 = 0; vv2 <= 9; ++vv2) BI_RC[rr2++] = vv2;
    rr2 = "a".charCodeAt(0);
    for (vv2 = 10; vv2 < 36; ++vv2) BI_RC[rr2++] = vv2;
    rr2 = "A".charCodeAt(0);
    for (vv2 = 10; vv2 < 36; ++vv2) BI_RC[rr2++] = vv2;
    function int2char(n2) {
      return BI_RM.charAt(n2);
    }
    function intAt(s2, i2) {
      var c2 = BI_RC[s2.charCodeAt(i2)];
      return c2 == null ? -1 : c2;
    }
    function bnpCopyTo(r2) {
      for (var i2 = this.t - 1; i2 >= 0; --i2) r2.data[i2] = this.data[i2];
      r2.t = this.t;
      r2.s = this.s;
    }
    function bnpFromInt(x3) {
      this.t = 1;
      this.s = x3 < 0 ? -1 : 0;
      if (x3 > 0) this.data[0] = x3;
      else if (x3 < -1) this.data[0] = x3 + this.DV;
      else this.t = 0;
    }
    function nbv(i2) {
      var r2 = nbi();
      r2.fromInt(i2);
      return r2;
    }
    function bnpFromString(s2, b2) {
      var k2;
      if (b2 == 16) k2 = 4;
      else if (b2 == 8) k2 = 3;
      else if (b2 == 256) k2 = 8;
      else if (b2 == 2) k2 = 1;
      else if (b2 == 32) k2 = 5;
      else if (b2 == 4) k2 = 2;
      else {
        this.fromRadix(s2, b2);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i2 = s2.length, mi2 = false, sh2 = 0;
      while (--i2 >= 0) {
        var x3 = k2 == 8 ? s2[i2] & 255 : intAt(s2, i2);
        if (x3 < 0) {
          if (s2.charAt(i2) == "-") mi2 = true;
          continue;
        }
        mi2 = false;
        if (sh2 == 0)
          this.data[this.t++] = x3;
        else if (sh2 + k2 > this.DB) {
          this.data[this.t - 1] |= (x3 & (1 << this.DB - sh2) - 1) << sh2;
          this.data[this.t++] = x3 >> this.DB - sh2;
        } else
          this.data[this.t - 1] |= x3 << sh2;
        sh2 += k2;
        if (sh2 >= this.DB) sh2 -= this.DB;
      }
      if (k2 == 8 && (s2[0] & 128) != 0) {
        this.s = -1;
        if (sh2 > 0) this.data[this.t - 1] |= (1 << this.DB - sh2) - 1 << sh2;
      }
      this.clamp();
      if (mi2) BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c2 = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c2) --this.t;
    }
    function bnToString(b2) {
      if (this.s < 0) return "-" + this.negate().toString(b2);
      var k2;
      if (b2 == 16) k2 = 4;
      else if (b2 == 8) k2 = 3;
      else if (b2 == 2) k2 = 1;
      else if (b2 == 32) k2 = 5;
      else if (b2 == 4) k2 = 2;
      else return this.toRadix(b2);
      var km2 = (1 << k2) - 1, d2, m2 = false, r2 = "", i2 = this.t;
      var p2 = this.DB - i2 * this.DB % k2;
      if (i2-- > 0) {
        if (p2 < this.DB && (d2 = this.data[i2] >> p2) > 0) {
          m2 = true;
          r2 = int2char(d2);
        }
        while (i2 >= 0) {
          if (p2 < k2) {
            d2 = (this.data[i2] & (1 << p2) - 1) << k2 - p2;
            d2 |= this.data[--i2] >> (p2 += this.DB - k2);
          } else {
            d2 = this.data[i2] >> (p2 -= k2) & km2;
            if (p2 <= 0) {
              p2 += this.DB;
              --i2;
            }
          }
          if (d2 > 0) m2 = true;
          if (m2) r2 += int2char(d2);
        }
      }
      return m2 ? r2 : "0";
    }
    function bnNegate() {
      var r2 = nbi();
      BigInteger.ZERO.subTo(this, r2);
      return r2;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a2) {
      var r2 = this.s - a2.s;
      if (r2 != 0) return r2;
      var i2 = this.t;
      r2 = i2 - a2.t;
      if (r2 != 0) return this.s < 0 ? -r2 : r2;
      while (--i2 >= 0) if ((r2 = this.data[i2] - a2.data[i2]) != 0) return r2;
      return 0;
    }
    function nbits(x3) {
      var r2 = 1, t2;
      if ((t2 = x3 >>> 16) != 0) {
        x3 = t2;
        r2 += 16;
      }
      if ((t2 = x3 >> 8) != 0) {
        x3 = t2;
        r2 += 8;
      }
      if ((t2 = x3 >> 4) != 0) {
        x3 = t2;
        r2 += 4;
      }
      if ((t2 = x3 >> 2) != 0) {
        x3 = t2;
        r2 += 2;
      }
      if ((t2 = x3 >> 1) != 0) {
        x3 = t2;
        r2 += 1;
      }
      return r2;
    }
    function bnBitLength() {
      if (this.t <= 0) return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n2, r2) {
      var i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) r2.data[i2 + n2] = this.data[i2];
      for (i2 = n2 - 1; i2 >= 0; --i2) r2.data[i2] = 0;
      r2.t = this.t + n2;
      r2.s = this.s;
    }
    function bnpDRShiftTo(n2, r2) {
      for (var i2 = n2; i2 < this.t; ++i2) r2.data[i2 - n2] = this.data[i2];
      r2.t = Math.max(this.t - n2, 0);
      r2.s = this.s;
    }
    function bnpLShiftTo(n2, r2) {
      var bs2 = n2 % this.DB;
      var cbs = this.DB - bs2;
      var bm2 = (1 << cbs) - 1;
      var ds2 = Math.floor(n2 / this.DB), c2 = this.s << bs2 & this.DM, i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) {
        r2.data[i2 + ds2 + 1] = this.data[i2] >> cbs | c2;
        c2 = (this.data[i2] & bm2) << bs2;
      }
      for (i2 = ds2 - 1; i2 >= 0; --i2) r2.data[i2] = 0;
      r2.data[ds2] = c2;
      r2.t = this.t + ds2 + 1;
      r2.s = this.s;
      r2.clamp();
    }
    function bnpRShiftTo(n2, r2) {
      r2.s = this.s;
      var ds2 = Math.floor(n2 / this.DB);
      if (ds2 >= this.t) {
        r2.t = 0;
        return;
      }
      var bs2 = n2 % this.DB;
      var cbs = this.DB - bs2;
      var bm2 = (1 << bs2) - 1;
      r2.data[0] = this.data[ds2] >> bs2;
      for (var i2 = ds2 + 1; i2 < this.t; ++i2) {
        r2.data[i2 - ds2 - 1] |= (this.data[i2] & bm2) << cbs;
        r2.data[i2 - ds2] = this.data[i2] >> bs2;
      }
      if (bs2 > 0) r2.data[this.t - ds2 - 1] |= (this.s & bm2) << cbs;
      r2.t = this.t - ds2;
      r2.clamp();
    }
    function bnpSubTo(a2, r2) {
      var i2 = 0, c2 = 0, m2 = Math.min(a2.t, this.t);
      while (i2 < m2) {
        c2 += this.data[i2] - a2.data[i2];
        r2.data[i2++] = c2 & this.DM;
        c2 >>= this.DB;
      }
      if (a2.t < this.t) {
        c2 -= a2.s;
        while (i2 < this.t) {
          c2 += this.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += this.s;
      } else {
        c2 += this.s;
        while (i2 < a2.t) {
          c2 -= a2.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 -= a2.s;
      }
      r2.s = c2 < 0 ? -1 : 0;
      if (c2 < -1) r2.data[i2++] = this.DV + c2;
      else if (c2 > 0) r2.data[i2++] = c2;
      r2.t = i2;
      r2.clamp();
    }
    function bnpMultiplyTo(a2, r2) {
      var x3 = this.abs(), y2 = a2.abs();
      var i2 = x3.t;
      r2.t = i2 + y2.t;
      while (--i2 >= 0) r2.data[i2] = 0;
      for (i2 = 0; i2 < y2.t; ++i2) r2.data[i2 + x3.t] = x3.am(0, y2.data[i2], r2, i2, 0, x3.t);
      r2.s = 0;
      r2.clamp();
      if (this.s != a2.s) BigInteger.ZERO.subTo(r2, r2);
    }
    function bnpSquareTo(r2) {
      var x3 = this.abs();
      var i2 = r2.t = 2 * x3.t;
      while (--i2 >= 0) r2.data[i2] = 0;
      for (i2 = 0; i2 < x3.t - 1; ++i2) {
        var c2 = x3.am(i2, x3.data[i2], r2, 2 * i2, 0, 1);
        if ((r2.data[i2 + x3.t] += x3.am(i2 + 1, 2 * x3.data[i2], r2, 2 * i2 + 1, c2, x3.t - i2 - 1)) >= x3.DV) {
          r2.data[i2 + x3.t] -= x3.DV;
          r2.data[i2 + x3.t + 1] = 1;
        }
      }
      if (r2.t > 0) r2.data[r2.t - 1] += x3.am(i2, x3.data[i2], r2, 2 * i2, 0, 1);
      r2.s = 0;
      r2.clamp();
    }
    function bnpDivRemTo(m2, q2, r2) {
      var pm2 = m2.abs();
      if (pm2.t <= 0) return;
      var pt3 = this.abs();
      if (pt3.t < pm2.t) {
        if (q2 != null) q2.fromInt(0);
        if (r2 != null) this.copyTo(r2);
        return;
      }
      if (r2 == null) r2 = nbi();
      var y2 = nbi(), ts2 = this.s, ms2 = m2.s;
      var nsh = this.DB - nbits(pm2.data[pm2.t - 1]);
      if (nsh > 0) {
        pm2.lShiftTo(nsh, y2);
        pt3.lShiftTo(nsh, r2);
      } else {
        pm2.copyTo(y2);
        pt3.copyTo(r2);
      }
      var ys2 = y2.t;
      var y02 = y2.data[ys2 - 1];
      if (y02 == 0) return;
      var yt2 = y02 * (1 << this.F1) + (ys2 > 1 ? y2.data[ys2 - 2] >> this.F2 : 0);
      var d12 = this.FV / yt2, d2 = (1 << this.F1) / yt2, e2 = 1 << this.F2;
      var i2 = r2.t, j2 = i2 - ys2, t2 = q2 == null ? nbi() : q2;
      y2.dlShiftTo(j2, t2);
      if (r2.compareTo(t2) >= 0) {
        r2.data[r2.t++] = 1;
        r2.subTo(t2, r2);
      }
      BigInteger.ONE.dlShiftTo(ys2, t2);
      t2.subTo(y2, y2);
      while (y2.t < ys2) y2.data[y2.t++] = 0;
      while (--j2 >= 0) {
        var qd2 = r2.data[--i2] == y02 ? this.DM : Math.floor(r2.data[i2] * d12 + (r2.data[i2 - 1] + e2) * d2);
        if ((r2.data[i2] += y2.am(0, qd2, r2, j2, 0, ys2)) < qd2) {
          y2.dlShiftTo(j2, t2);
          r2.subTo(t2, r2);
          while (r2.data[i2] < --qd2) r2.subTo(t2, r2);
        }
      }
      if (q2 != null) {
        r2.drShiftTo(ys2, q2);
        if (ts2 != ms2) BigInteger.ZERO.subTo(q2, q2);
      }
      r2.t = ys2;
      r2.clamp();
      if (nsh > 0) r2.rShiftTo(nsh, r2);
      if (ts2 < 0) BigInteger.ZERO.subTo(r2, r2);
    }
    function bnMod(a2) {
      var r2 = nbi();
      this.abs().divRemTo(a2, null, r2);
      if (this.s < 0 && r2.compareTo(BigInteger.ZERO) > 0) a2.subTo(r2, r2);
      return r2;
    }
    function Classic(m2) {
      this.m = m2;
    }
    function cConvert(x3) {
      if (x3.s < 0 || x3.compareTo(this.m) >= 0) return x3.mod(this.m);
      else return x3;
    }
    function cRevert(x3) {
      return x3;
    }
    function cReduce(x3) {
      x3.divRemTo(this.m, null, x3);
    }
    function cMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    function cSqrTo(x3, r2) {
      x3.squareTo(r2);
      this.reduce(r2);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1) return 0;
      var x3 = this.data[0];
      if ((x3 & 1) == 0) return 0;
      var y2 = x3 & 3;
      y2 = y2 * (2 - (x3 & 15) * y2) & 15;
      y2 = y2 * (2 - (x3 & 255) * y2) & 255;
      y2 = y2 * (2 - ((x3 & 65535) * y2 & 65535)) & 65535;
      y2 = y2 * (2 - x3 * y2 % this.DV) % this.DV;
      return y2 > 0 ? this.DV - y2 : -y2;
    }
    function Montgomery(m2) {
      this.m = m2;
      this.mp = m2.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m2.DB - 15) - 1;
      this.mt2 = 2 * m2.t;
    }
    function montConvert(x3) {
      var r2 = nbi();
      x3.abs().dlShiftTo(this.m.t, r2);
      r2.divRemTo(this.m, null, r2);
      if (x3.s < 0 && r2.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r2, r2);
      return r2;
    }
    function montRevert(x3) {
      var r2 = nbi();
      x3.copyTo(r2);
      this.reduce(r2);
      return r2;
    }
    function montReduce(x3) {
      while (x3.t <= this.mt2)
        x3.data[x3.t++] = 0;
      for (var i2 = 0; i2 < this.m.t; ++i2) {
        var j2 = x3.data[i2] & 32767;
        var u02 = j2 * this.mpl + ((j2 * this.mph + (x3.data[i2] >> 15) * this.mpl & this.um) << 15) & x3.DM;
        j2 = i2 + this.m.t;
        x3.data[j2] += this.m.am(0, u02, x3, i2, 0, this.m.t);
        while (x3.data[j2] >= x3.DV) {
          x3.data[j2] -= x3.DV;
          x3.data[++j2]++;
        }
      }
      x3.clamp();
      x3.drShiftTo(this.m.t, x3);
      if (x3.compareTo(this.m) >= 0) x3.subTo(this.m, x3);
    }
    function montSqrTo(x3, r2) {
      x3.squareTo(r2);
      this.reduce(r2);
    }
    function montMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e2, z3) {
      if (e2 > 4294967295 || e2 < 1) return BigInteger.ONE;
      var r2 = nbi(), r22 = nbi(), g2 = z3.convert(this), i2 = nbits(e2) - 1;
      g2.copyTo(r2);
      while (--i2 >= 0) {
        z3.sqrTo(r2, r22);
        if ((e2 & 1 << i2) > 0) z3.mulTo(r22, g2, r2);
        else {
          var t2 = r2;
          r2 = r22;
          r22 = t2;
        }
      }
      return z3.revert(r2);
    }
    function bnModPowInt(e2, m2) {
      var z3;
      if (e2 < 256 || m2.isEven()) z3 = new Classic(m2);
      else z3 = new Montgomery(m2);
      return this.exp(e2, z3);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r2 = nbi();
      this.copyTo(r2);
      return r2;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1) return this.data[0] - this.DV;
        else if (this.t == 0) return -1;
      } else if (this.t == 1) return this.data[0];
      else if (this.t == 0) return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r2) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r2));
    }
    function bnSigNum() {
      if (this.s < 0) return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;
      else return 1;
    }
    function bnpToRadix(b2) {
      if (b2 == null) b2 = 10;
      if (this.signum() == 0 || b2 < 2 || b2 > 36) return "0";
      var cs2 = this.chunkSize(b2);
      var a2 = Math.pow(b2, cs2);
      var d2 = nbv(a2), y2 = nbi(), z3 = nbi(), r2 = "";
      this.divRemTo(d2, y2, z3);
      while (y2.signum() > 0) {
        r2 = (a2 + z3.intValue()).toString(b2).substr(1) + r2;
        y2.divRemTo(d2, y2, z3);
      }
      return z3.intValue().toString(b2) + r2;
    }
    function bnpFromRadix(s2, b2) {
      this.fromInt(0);
      if (b2 == null) b2 = 10;
      var cs2 = this.chunkSize(b2);
      var d2 = Math.pow(b2, cs2), mi2 = false, j2 = 0, w3 = 0;
      for (var i2 = 0; i2 < s2.length; ++i2) {
        var x3 = intAt(s2, i2);
        if (x3 < 0) {
          if (s2.charAt(i2) == "-" && this.signum() == 0) mi2 = true;
          continue;
        }
        w3 = b2 * w3 + x3;
        if (++j2 >= cs2) {
          this.dMultiply(d2);
          this.dAddOffset(w3, 0);
          j2 = 0;
          w3 = 0;
        }
      }
      if (j2 > 0) {
        this.dMultiply(Math.pow(b2, j2));
        this.dAddOffset(w3, 0);
      }
      if (mi2) BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a2, b2, c2) {
      if ("number" == typeof b2) {
        if (a2 < 2) this.fromInt(1);
        else {
          this.fromNumber(a2, c2);
          if (!this.testBit(a2 - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a2 - 1), op_or, this);
          if (this.isEven()) this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b2)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a2) this.subTo(BigInteger.ONE.shiftLeft(a2 - 1), this);
          }
        }
      } else {
        var x3 = new Array(), t2 = a2 & 7;
        x3.length = (a2 >> 3) + 1;
        b2.nextBytes(x3);
        if (t2 > 0) x3[0] &= (1 << t2) - 1;
        else x3[0] = 0;
        this.fromString(x3, 256);
      }
    }
    function bnToByteArray() {
      var i2 = this.t, r2 = new Array();
      r2[0] = this.s;
      var p2 = this.DB - i2 * this.DB % 8, d2, k2 = 0;
      if (i2-- > 0) {
        if (p2 < this.DB && (d2 = this.data[i2] >> p2) != (this.s & this.DM) >> p2)
          r2[k2++] = d2 | this.s << this.DB - p2;
        while (i2 >= 0) {
          if (p2 < 8) {
            d2 = (this.data[i2] & (1 << p2) - 1) << 8 - p2;
            d2 |= this.data[--i2] >> (p2 += this.DB - 8);
          } else {
            d2 = this.data[i2] >> (p2 -= 8) & 255;
            if (p2 <= 0) {
              p2 += this.DB;
              --i2;
            }
          }
          if ((d2 & 128) != 0) d2 |= -256;
          if (k2 == 0 && (this.s & 128) != (d2 & 128)) ++k2;
          if (k2 > 0 || d2 != this.s) r2[k2++] = d2;
        }
      }
      return r2;
    }
    function bnEquals(a2) {
      return this.compareTo(a2) == 0;
    }
    function bnMin(a2) {
      return this.compareTo(a2) < 0 ? this : a2;
    }
    function bnMax(a2) {
      return this.compareTo(a2) > 0 ? this : a2;
    }
    function bnpBitwiseTo(a2, op2, r2) {
      var i2, f2, m2 = Math.min(a2.t, this.t);
      for (i2 = 0; i2 < m2; ++i2) r2.data[i2] = op2(this.data[i2], a2.data[i2]);
      if (a2.t < this.t) {
        f2 = a2.s & this.DM;
        for (i2 = m2; i2 < this.t; ++i2) r2.data[i2] = op2(this.data[i2], f2);
        r2.t = this.t;
      } else {
        f2 = this.s & this.DM;
        for (i2 = m2; i2 < a2.t; ++i2) r2.data[i2] = op2(f2, a2.data[i2]);
        r2.t = a2.t;
      }
      r2.s = op2(this.s, a2.s);
      r2.clamp();
    }
    function op_and(x3, y2) {
      return x3 & y2;
    }
    function bnAnd(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_and, r2);
      return r2;
    }
    function op_or(x3, y2) {
      return x3 | y2;
    }
    function bnOr(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_or, r2);
      return r2;
    }
    function op_xor(x3, y2) {
      return x3 ^ y2;
    }
    function bnXor(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_xor, r2);
      return r2;
    }
    function op_andnot(x3, y2) {
      return x3 & ~y2;
    }
    function bnAndNot(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_andnot, r2);
      return r2;
    }
    function bnNot() {
      var r2 = nbi();
      for (var i2 = 0; i2 < this.t; ++i2) r2.data[i2] = this.DM & ~this.data[i2];
      r2.t = this.t;
      r2.s = ~this.s;
      return r2;
    }
    function bnShiftLeft(n2) {
      var r2 = nbi();
      if (n2 < 0) this.rShiftTo(-n2, r2);
      else this.lShiftTo(n2, r2);
      return r2;
    }
    function bnShiftRight(n2) {
      var r2 = nbi();
      if (n2 < 0) this.lShiftTo(-n2, r2);
      else this.rShiftTo(n2, r2);
      return r2;
    }
    function lbit(x3) {
      if (x3 == 0) return -1;
      var r2 = 0;
      if ((x3 & 65535) == 0) {
        x3 >>= 16;
        r2 += 16;
      }
      if ((x3 & 255) == 0) {
        x3 >>= 8;
        r2 += 8;
      }
      if ((x3 & 15) == 0) {
        x3 >>= 4;
        r2 += 4;
      }
      if ((x3 & 3) == 0) {
        x3 >>= 2;
        r2 += 2;
      }
      if ((x3 & 1) == 0) ++r2;
      return r2;
    }
    function bnGetLowestSetBit() {
      for (var i2 = 0; i2 < this.t; ++i2)
        if (this.data[i2] != 0) return i2 * this.DB + lbit(this.data[i2]);
      if (this.s < 0) return this.t * this.DB;
      return -1;
    }
    function cbit(x3) {
      var r2 = 0;
      while (x3 != 0) {
        x3 &= x3 - 1;
        ++r2;
      }
      return r2;
    }
    function bnBitCount() {
      var r2 = 0, x3 = this.s & this.DM;
      for (var i2 = 0; i2 < this.t; ++i2) r2 += cbit(this.data[i2] ^ x3);
      return r2;
    }
    function bnTestBit(n2) {
      var j2 = Math.floor(n2 / this.DB);
      if (j2 >= this.t) return this.s != 0;
      return (this.data[j2] & 1 << n2 % this.DB) != 0;
    }
    function bnpChangeBit(n2, op2) {
      var r2 = BigInteger.ONE.shiftLeft(n2);
      this.bitwiseTo(r2, op2, r2);
      return r2;
    }
    function bnSetBit(n2) {
      return this.changeBit(n2, op_or);
    }
    function bnClearBit(n2) {
      return this.changeBit(n2, op_andnot);
    }
    function bnFlipBit(n2) {
      return this.changeBit(n2, op_xor);
    }
    function bnpAddTo(a2, r2) {
      var i2 = 0, c2 = 0, m2 = Math.min(a2.t, this.t);
      while (i2 < m2) {
        c2 += this.data[i2] + a2.data[i2];
        r2.data[i2++] = c2 & this.DM;
        c2 >>= this.DB;
      }
      if (a2.t < this.t) {
        c2 += a2.s;
        while (i2 < this.t) {
          c2 += this.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += this.s;
      } else {
        c2 += this.s;
        while (i2 < a2.t) {
          c2 += a2.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += a2.s;
      }
      r2.s = c2 < 0 ? -1 : 0;
      if (c2 > 0) r2.data[i2++] = c2;
      else if (c2 < -1) r2.data[i2++] = this.DV + c2;
      r2.t = i2;
      r2.clamp();
    }
    function bnAdd(a2) {
      var r2 = nbi();
      this.addTo(a2, r2);
      return r2;
    }
    function bnSubtract(a2) {
      var r2 = nbi();
      this.subTo(a2, r2);
      return r2;
    }
    function bnMultiply(a2) {
      var r2 = nbi();
      this.multiplyTo(a2, r2);
      return r2;
    }
    function bnDivide(a2) {
      var r2 = nbi();
      this.divRemTo(a2, r2, null);
      return r2;
    }
    function bnRemainder(a2) {
      var r2 = nbi();
      this.divRemTo(a2, null, r2);
      return r2;
    }
    function bnDivideAndRemainder(a2) {
      var q2 = nbi(), r2 = nbi();
      this.divRemTo(a2, q2, r2);
      return new Array(q2, r2);
    }
    function bnpDMultiply(n2) {
      this.data[this.t] = this.am(0, n2 - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n2, w3) {
      if (n2 == 0) return;
      while (this.t <= w3) this.data[this.t++] = 0;
      this.data[w3] += n2;
      while (this.data[w3] >= this.DV) {
        this.data[w3] -= this.DV;
        if (++w3 >= this.t) this.data[this.t++] = 0;
        ++this.data[w3];
      }
    }
    function NullExp() {
    }
    function nNop(x3) {
      return x3;
    }
    function nMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
    }
    function nSqrTo(x3, r2) {
      x3.squareTo(r2);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e2) {
      return this.exp(e2, new NullExp());
    }
    function bnpMultiplyLowerTo(a2, n2, r2) {
      var i2 = Math.min(this.t + a2.t, n2);
      r2.s = 0;
      r2.t = i2;
      while (i2 > 0) r2.data[--i2] = 0;
      var j2;
      for (j2 = r2.t - this.t; i2 < j2; ++i2) r2.data[i2 + this.t] = this.am(0, a2.data[i2], r2, i2, 0, this.t);
      for (j2 = Math.min(a2.t, n2); i2 < j2; ++i2) this.am(0, a2.data[i2], r2, i2, 0, n2 - i2);
      r2.clamp();
    }
    function bnpMultiplyUpperTo(a2, n2, r2) {
      --n2;
      var i2 = r2.t = this.t + a2.t - n2;
      r2.s = 0;
      while (--i2 >= 0) r2.data[i2] = 0;
      for (i2 = Math.max(n2 - this.t, 0); i2 < a2.t; ++i2)
        r2.data[this.t + i2 - n2] = this.am(n2 - i2, a2.data[i2], r2, 0, 0, this.t + i2 - n2);
      r2.clamp();
      r2.drShiftTo(1, r2);
    }
    function Barrett(m2) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m2.t, this.r2);
      this.mu = this.r2.divide(m2);
      this.m = m2;
    }
    function barrettConvert(x3) {
      if (x3.s < 0 || x3.t > 2 * this.m.t) return x3.mod(this.m);
      else if (x3.compareTo(this.m) < 0) return x3;
      else {
        var r2 = nbi();
        x3.copyTo(r2);
        this.reduce(r2);
        return r2;
      }
    }
    function barrettRevert(x3) {
      return x3;
    }
    function barrettReduce(x3) {
      x3.drShiftTo(this.m.t - 1, this.r2);
      if (x3.t > this.m.t + 1) {
        x3.t = this.m.t + 1;
        x3.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x3.compareTo(this.r2) < 0) x3.dAddOffset(1, this.m.t + 1);
      x3.subTo(this.r2, x3);
      while (x3.compareTo(this.m) >= 0) x3.subTo(this.m, x3);
    }
    function barrettSqrTo(x3, r2) {
      x3.squareTo(r2);
      this.reduce(r2);
    }
    function barrettMulTo(x3, y2, r2) {
      x3.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e2, m2) {
      var i2 = e2.bitLength(), k2, r2 = nbv(1), z3;
      if (i2 <= 0) return r2;
      else if (i2 < 18) k2 = 1;
      else if (i2 < 48) k2 = 3;
      else if (i2 < 144) k2 = 4;
      else if (i2 < 768) k2 = 5;
      else k2 = 6;
      if (i2 < 8)
        z3 = new Classic(m2);
      else if (m2.isEven())
        z3 = new Barrett(m2);
      else
        z3 = new Montgomery(m2);
      var g2 = new Array(), n2 = 3, k1 = k2 - 1, km2 = (1 << k2) - 1;
      g2[1] = z3.convert(this);
      if (k2 > 1) {
        var g22 = nbi();
        z3.sqrTo(g2[1], g22);
        while (n2 <= km2) {
          g2[n2] = nbi();
          z3.mulTo(g22, g2[n2 - 2], g2[n2]);
          n2 += 2;
        }
      }
      var j2 = e2.t - 1, w3, is1 = true, r22 = nbi(), t2;
      i2 = nbits(e2.data[j2]) - 1;
      while (j2 >= 0) {
        if (i2 >= k1) w3 = e2.data[j2] >> i2 - k1 & km2;
        else {
          w3 = (e2.data[j2] & (1 << i2 + 1) - 1) << k1 - i2;
          if (j2 > 0) w3 |= e2.data[j2 - 1] >> this.DB + i2 - k1;
        }
        n2 = k2;
        while ((w3 & 1) == 0) {
          w3 >>= 1;
          --n2;
        }
        if ((i2 -= n2) < 0) {
          i2 += this.DB;
          --j2;
        }
        if (is1) {
          g2[w3].copyTo(r2);
          is1 = false;
        } else {
          while (n2 > 1) {
            z3.sqrTo(r2, r22);
            z3.sqrTo(r22, r2);
            n2 -= 2;
          }
          if (n2 > 0) z3.sqrTo(r2, r22);
          else {
            t2 = r2;
            r2 = r22;
            r22 = t2;
          }
          z3.mulTo(r22, g2[w3], r2);
        }
        while (j2 >= 0 && (e2.data[j2] & 1 << i2) == 0) {
          z3.sqrTo(r2, r22);
          t2 = r2;
          r2 = r22;
          r22 = t2;
          if (--i2 < 0) {
            i2 = this.DB - 1;
            --j2;
          }
        }
      }
      return z3.revert(r2);
    }
    function bnGCD(a2) {
      var x3 = this.s < 0 ? this.negate() : this.clone();
      var y2 = a2.s < 0 ? a2.negate() : a2.clone();
      if (x3.compareTo(y2) < 0) {
        var t2 = x3;
        x3 = y2;
        y2 = t2;
      }
      var i2 = x3.getLowestSetBit(), g2 = y2.getLowestSetBit();
      if (g2 < 0) return x3;
      if (i2 < g2) g2 = i2;
      if (g2 > 0) {
        x3.rShiftTo(g2, x3);
        y2.rShiftTo(g2, y2);
      }
      while (x3.signum() > 0) {
        if ((i2 = x3.getLowestSetBit()) > 0) x3.rShiftTo(i2, x3);
        if ((i2 = y2.getLowestSetBit()) > 0) y2.rShiftTo(i2, y2);
        if (x3.compareTo(y2) >= 0) {
          x3.subTo(y2, x3);
          x3.rShiftTo(1, x3);
        } else {
          y2.subTo(x3, y2);
          y2.rShiftTo(1, y2);
        }
      }
      if (g2 > 0) y2.lShiftTo(g2, y2);
      return y2;
    }
    function bnpModInt(n2) {
      if (n2 <= 0) return 0;
      var d2 = this.DV % n2, r2 = this.s < 0 ? n2 - 1 : 0;
      if (this.t > 0)
        if (d2 == 0) r2 = this.data[0] % n2;
        else for (var i2 = this.t - 1; i2 >= 0; --i2) r2 = (d2 * r2 + this.data[i2]) % n2;
      return r2;
    }
    function bnModInverse(m2) {
      var ac2 = m2.isEven();
      if (this.isEven() && ac2 || m2.signum() == 0) return BigInteger.ZERO;
      var u2 = m2.clone(), v3 = this.clone();
      var a2 = nbv(1), b2 = nbv(0), c2 = nbv(0), d2 = nbv(1);
      while (u2.signum() != 0) {
        while (u2.isEven()) {
          u2.rShiftTo(1, u2);
          if (ac2) {
            if (!a2.isEven() || !b2.isEven()) {
              a2.addTo(this, a2);
              b2.subTo(m2, b2);
            }
            a2.rShiftTo(1, a2);
          } else if (!b2.isEven()) b2.subTo(m2, b2);
          b2.rShiftTo(1, b2);
        }
        while (v3.isEven()) {
          v3.rShiftTo(1, v3);
          if (ac2) {
            if (!c2.isEven() || !d2.isEven()) {
              c2.addTo(this, c2);
              d2.subTo(m2, d2);
            }
            c2.rShiftTo(1, c2);
          } else if (!d2.isEven()) d2.subTo(m2, d2);
          d2.rShiftTo(1, d2);
        }
        if (u2.compareTo(v3) >= 0) {
          u2.subTo(v3, u2);
          if (ac2) a2.subTo(c2, a2);
          b2.subTo(d2, b2);
        } else {
          v3.subTo(u2, v3);
          if (ac2) c2.subTo(a2, c2);
          d2.subTo(b2, d2);
        }
      }
      if (v3.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if (d2.compareTo(m2) >= 0) return d2.subtract(m2);
      if (d2.signum() < 0) d2.addTo(m2, d2);
      else return d2;
      if (d2.signum() < 0) return d2.add(m2);
      else return d2;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t2) {
      var i2, x3 = this.abs();
      if (x3.t == 1 && x3.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i2 = 0; i2 < lowprimes.length; ++i2)
          if (x3.data[0] == lowprimes[i2]) return true;
        return false;
      }
      if (x3.isEven()) return false;
      i2 = 1;
      while (i2 < lowprimes.length) {
        var m2 = lowprimes[i2], j2 = i2 + 1;
        while (j2 < lowprimes.length && m2 < lplim) m2 *= lowprimes[j2++];
        m2 = x3.modInt(m2);
        while (i2 < j2) if (m2 % lowprimes[i2++] == 0) return false;
      }
      return x3.millerRabin(t2);
    }
    function bnpMillerRabin(t2) {
      var n12 = this.subtract(BigInteger.ONE);
      var k2 = n12.getLowestSetBit();
      if (k2 <= 0) return false;
      var r2 = n12.shiftRight(k2);
      var prng = bnGetPrng();
      var a2;
      for (var i2 = 0; i2 < t2; ++i2) {
        do {
          a2 = new BigInteger(this.bitLength(), prng);
        } while (a2.compareTo(BigInteger.ONE) <= 0 || a2.compareTo(n12) >= 0);
        var y2 = a2.modPow(r2, this);
        if (y2.compareTo(BigInteger.ONE) != 0 && y2.compareTo(n12) != 0) {
          var j2 = 1;
          while (j2++ < k2 && y2.compareTo(n12) != 0) {
            y2 = y2.modPowInt(2, this);
            if (y2.compareTo(BigInteger.ONE) == 0) return false;
          }
          if (y2.compareTo(n12) != 0) return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        // x is an array to fill with bytes
        nextBytes: function(x3) {
          for (var i2 = 0; i2 < x3.length; ++i2) {
            x3[i2] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/sha1.js
var require_sha12 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/sha1.js"(exports2, module2) {
    var forge = require_forge2();
    require_md3();
    require_util2();
    var sha12 = module2.exports = forge.sha1 = forge.sha1 || {};
    forge.md.sha1 = forge.md.algorithms.sha1 = sha12;
    sha12.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w2 = new Array(80);
      var md2 = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength64 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w2, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var next, carry;
        var bits = md2.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md2.fullMessageLength.length - 1; ++i2) {
          next = md2.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w2, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s2, w3, bytes) {
      var t2, a2, b2, c2, d2, e2, f2, i2;
      var len = bytes.length();
      while (len >= 64) {
        a2 = s2.h0;
        b2 = s2.h1;
        c2 = s2.h2;
        d2 = s2.h3;
        e2 = s2.h4;
        for (i2 = 0; i2 < 16; ++i2) {
          t2 = bytes.getInt32();
          w3[i2] = t2;
          f2 = d2 ^ b2 & (c2 ^ d2);
          t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 20; ++i2) {
          t2 = w3[i2 - 3] ^ w3[i2 - 8] ^ w3[i2 - 14] ^ w3[i2 - 16];
          t2 = t2 << 1 | t2 >>> 31;
          w3[i2] = t2;
          f2 = d2 ^ b2 & (c2 ^ d2);
          t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 32; ++i2) {
          t2 = w3[i2 - 3] ^ w3[i2 - 8] ^ w3[i2 - 14] ^ w3[i2 - 16];
          t2 = t2 << 1 | t2 >>> 31;
          w3[i2] = t2;
          f2 = b2 ^ c2 ^ d2;
          t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 40; ++i2) {
          t2 = w3[i2 - 6] ^ w3[i2 - 16] ^ w3[i2 - 28] ^ w3[i2 - 32];
          t2 = t2 << 2 | t2 >>> 30;
          w3[i2] = t2;
          f2 = b2 ^ c2 ^ d2;
          t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 60; ++i2) {
          t2 = w3[i2 - 6] ^ w3[i2 - 16] ^ w3[i2 - 28] ^ w3[i2 - 32];
          t2 = t2 << 2 | t2 >>> 30;
          w3[i2] = t2;
          f2 = b2 & c2 | d2 & (b2 ^ c2);
          t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 2400959708 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        for (; i2 < 80; ++i2) {
          t2 = w3[i2 - 6] ^ w3[i2 - 16] ^ w3[i2 - 28] ^ w3[i2 - 32];
          t2 = t2 << 2 | t2 >>> 30;
          w3[i2] = t2;
          f2 = b2 ^ c2 ^ d2;
          t2 = (a2 << 5 | a2 >>> 27) + f2 + e2 + 3395469782 + t2;
          e2 = d2;
          d2 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t2;
        }
        s2.h0 = s2.h0 + a2 | 0;
        s2.h1 = s2.h1 + b2 | 0;
        s2.h2 = s2.h2 + c2 | 0;
        s2.h3 = s2.h3 + d2 | 0;
        s2.h4 = s2.h4 + e2 | 0;
        len -= 64;
      }
    }
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/pkcs1.js
var require_pkcs12 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
    var forge = require_forge2();
    require_util2();
    require_random2();
    require_sha12();
    var pkcs1 = module2.exports = forge.pkcs1 = forge.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message, options) {
      var label;
      var seed;
      var md2;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed = arguments[3] || void 0;
        md2 = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed = options.seed || void 0;
        md2 = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md2) {
        md2 = forge.md.sha1.create();
      } else {
        md2.start();
      }
      if (!mgf1Md) {
        mgf1Md = md2;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md2.digestLength - 2;
      if (message.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md2.update(label, "raw");
      var lHash = md2.digest();
      var PS = "";
      var PS_length = maxLength - message.length;
      for (var i2 = 0; i2 < PS_length; i2++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message;
      if (!seed) {
        seed = forge.random.getBytes(md2.digestLength);
      } else if (seed.length !== md2.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed.length;
        error.digestLength = md2.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md2.digestLength - 1, mgf1Md);
      var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md2.digestLength, mgf1Md);
      var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em2, options) {
      var label;
      var md2;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md2 = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md2 = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em2.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em2.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md2 === void 0) {
        md2 = forge.md.sha1.create();
      } else {
        md2.start();
      }
      if (!mgf1Md) {
        mgf1Md = md2;
      }
      if (keyLength < 2 * md2.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md2.update(label, "raw");
      var lHash = md2.digest().getBytes();
      var y2 = em2.charAt(0);
      var maskedSeed = em2.substring(1, md2.digestLength + 1);
      var maskedDB = em2.substring(1 + md2.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md2.digestLength, mgf1Md);
      var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md2.digestLength - 1, mgf1Md);
      var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md2.digestLength);
      var error = y2 !== "\0";
      for (var i2 = 0; i2 < md2.digestLength; ++i2) {
        error |= lHash.charAt(i2) !== lHashPrime.charAt(i2);
      }
      var in_ps = 1;
      var index = md2.digestLength;
      for (var j2 = md2.digestLength; j2 < db.length; j2++) {
        var code2 = db.charCodeAt(j2);
        var is_0 = code2 & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code2 & error_mask;
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db.charCodeAt(index) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash3) {
      if (!hash3) {
        hash3 = forge.md.sha1.create();
      }
      var t2 = "";
      var count = Math.ceil(maskLength / hash3.digestLength);
      for (var i2 = 0; i2 < count; ++i2) {
        var c2 = String.fromCharCode(
          i2 >> 24 & 255,
          i2 >> 16 & 255,
          i2 >> 8 & 255,
          i2 & 255
        );
        hash3.start();
        hash3.update(seed + c2);
        t2 += hash3.digest().getBytes();
      }
      return t2.substring(0, maskLength);
    }
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/prime.js
var require_prime2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/prime.js"(exports2, module2) {
    var forge = require_forge2();
    require_util2();
    require_jsbn2();
    require_random2();
    (function() {
      if (forge.prime) {
        module2.exports = forge.prime;
        return;
      }
      var prime = module2.exports = forge.prime = forge.prime || {};
      var BigInteger = forge.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = function(x3, y2) {
        return x3 | y2;
      };
      prime.generateProbablePrime = function(bits, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge.random;
        var rng = {
          // x is an array to fill with bytes
          nextBytes: function(x3) {
            var b2 = prng.getBytesSync(x3.length);
            for (var i2 = 0; i2 < x3.length; ++i2) {
              x3[i2] = b2.charCodeAt(i2);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits, rng, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits, rng, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
        var num = generateRandom(bits, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +/* @__PURE__ */ new Date();
        do {
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
        forge.util.setImmediate(function() {
          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
        }
        var num = generateRandom(bits, rng);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate();
          });
        }
        generate();
        function generate() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e2) {
            if (found) {
              return;
            }
            --running;
            var data = e2.data;
            if (data.found) {
              for (var i3 = 0; i3 < workers.length; ++i3) {
                workers[i3].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng);
            }
            var hex = num.toString(16);
            e2.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range, 0);
          }
        }
      }
      function generateRandom(bits, rng) {
        var num = new BigInteger(bits, rng);
        var bits1 = bits - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits) {
        if (bits <= 100) return 27;
        if (bits <= 150) return 18;
        if (bits <= 200) return 15;
        if (bits <= 250) return 12;
        if (bits <= 300) return 9;
        if (bits <= 350) return 8;
        if (bits <= 400) return 7;
        if (bits <= 500) return 6;
        if (bits <= 600) return 5;
        if (bits <= 800) return 4;
        if (bits <= 1250) return 3;
        return 2;
      }
    })();
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/rsa.js
var require_rsa2 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/rsa.js"(exports2, module2) {
    var forge = require_forge2();
    require_asn13();
    require_jsbn2();
    require_oids2();
    require_pkcs12();
    require_prime2();
    require_random2();
    require_util2();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge.util.isNodejs ? require_crypto2() : null;
    var asn12 = forge.asn1;
    var util2 = forge.util;
    forge.pki = forge.pki || {};
    module2.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
    var pki = forge.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn12.Class.UNIVERSAL,
      type: asn12.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      // RSAPrivateKey
      name: "RSAPrivateKey",
      tagClass: asn12.Class.UNIVERSAL,
      type: asn12.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "RSAPrivateKey.version",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // modulus (n)
        name: "RSAPrivateKey.modulus",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        // privateExponent (d)
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        // prime1 (p)
        name: "RSAPrivateKey.prime1",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        // prime2 (q)
        name: "RSAPrivateKey.prime2",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        // exponent1 (d mod (p-1))
        name: "RSAPrivateKey.exponent1",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        // exponent2 (d mod (q-1))
        name: "RSAPrivateKey.exponent2",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        // coefficient ((inverse of q) mod p)
        name: "RSAPrivateKey.coefficient",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      // RSAPublicKey
      name: "RSAPublicKey",
      tagClass: asn12.Class.UNIVERSAL,
      type: asn12.Type.SEQUENCE,
      constructed: true,
      value: [{
        // modulus (n)
        name: "RSAPublicKey.modulus",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPublicKey.exponent",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn12.Class.UNIVERSAL,
      type: asn12.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        // subjectPublicKey
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.BITSTRING,
        constructed: false,
        value: [{
          // RSAPublicKey
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var emsaPkcs1v15encode = function(md2) {
      var oid;
      if (md2.algorithm in pki.oids) {
        oid = pki.oids[md2.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md2.algorithm;
        throw error;
      }
      var oidBytes = asn12.oidToDer(oid).getBytes();
      var digestInfo = asn12.create(
        asn12.Class.UNIVERSAL,
        asn12.Type.SEQUENCE,
        true,
        []
      );
      var digestAlgorithm = asn12.create(
        asn12.Class.UNIVERSAL,
        asn12.Type.SEQUENCE,
        true,
        []
      );
      digestAlgorithm.value.push(asn12.create(
        asn12.Class.UNIVERSAL,
        asn12.Type.OID,
        false,
        oidBytes
      ));
      digestAlgorithm.value.push(asn12.create(
        asn12.Class.UNIVERSAL,
        asn12.Type.NULL,
        false,
        ""
      ));
      var digest2 = asn12.create(
        asn12.Class.UNIVERSAL,
        asn12.Type.OCTETSTRING,
        false,
        md2.digest().getBytes()
      );
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest2);
      return asn12.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x3, key, pub) {
      if (pub) {
        return x3.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x3.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r2;
      do {
        r2 = new BigInteger(
          forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),
          16
        );
      } while (r2.compareTo(key.n) >= 0 || !r2.gcd(key.n).equals(BigInteger.ONE));
      x3 = x3.multiply(r2.modPow(key.e, key.n)).mod(key.n);
      var xp2 = x3.mod(key.p).modPow(key.dP, key.p);
      var xq = x3.mod(key.q).modPow(key.dQ, key.q);
      while (xp2.compareTo(xq) < 0) {
        xp2 = xp2.add(key.p);
      }
      var y2 = xp2.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y2 = y2.multiply(r2.modInverse(key.n)).mod(key.n);
      return y2;
    };
    pki.rsa.encrypt = function(m2, key, bt2) {
      var pub = bt2;
      var eb;
      var k2 = Math.ceil(key.n.bitLength() / 8);
      if (bt2 !== false && bt2 !== true) {
        pub = bt2 === 2;
        eb = _encodePkcs1_v1_5(m2, key, bt2);
      } else {
        eb = forge.util.createBuffer();
        eb.putBytes(m2);
      }
      var x3 = new BigInteger(eb.toHex(), 16);
      var y2 = _modPow(x3, key, pub);
      var yhex = y2.toString(16);
      var ed2 = forge.util.createBuffer();
      var zeros = k2 - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed2.putByte(0);
        --zeros;
      }
      ed2.putBytes(forge.util.hexToBytes(yhex));
      return ed2.getBytes();
    };
    pki.rsa.decrypt = function(ed2, key, pub, ml2) {
      var k2 = Math.ceil(key.n.bitLength() / 8);
      if (ed2.length !== k2) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed2.length;
        error.expected = k2;
        throw error;
      }
      var y2 = new BigInteger(forge.util.createBuffer(ed2).toHex(), 16);
      if (y2.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x3 = _modPow(y2, key, pub);
      var xhex = x3.toString(16);
      var eb = forge.util.createBuffer();
      var zeros = k2 - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0);
        --zeros;
      }
      eb.putBytes(forge.util.hexToBytes(xhex));
      if (ml2 !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits, e2, options) {
      if (typeof bits === "string") {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options = options || {};
      var prng = options.prng || forge.random;
      var rng = {
        // x is an array to fill with bytes
        nextBytes: function(x3) {
          var b2 = prng.getBytesSync(x3.length);
          for (var i2 = 0; i2 < x3.length; ++i2) {
            x3[i2] = b2.charCodeAt(i2);
          }
        }
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits,
          rng,
          eInt: e2 || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n2) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x3, y2) {
        return x3 | y2;
      };
      var t12 = +/* @__PURE__ */ new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n2 <= 0 || total < n2)) {
        if (state.state === 0) {
          var bits = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(
                BigInteger.ONE.shiftLeft(bits1),
                op_or,
                state.num
              );
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(
              _getMillerRabinTests(state.num.bitLength())
            )) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d2 = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(
              state.n,
              state.e,
              d2,
              state.p,
              state.q,
              d2.mod(state.p1),
              d2.mod(state.q1),
              state.q.modInverse(state.p)
            ),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +/* @__PURE__ */ new Date();
        total += t2 - t12;
        t12 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits, e2, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits === "object") {
          options = bits;
          bits = void 0;
        } else if (typeof bits === "function") {
          callback = bits;
          bits = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === "number") {
          if (typeof e2 === "function") {
            callback = e2;
            e2 = void 0;
          } else if (typeof e2 !== "number") {
            options = e2;
            e2 = void 0;
          }
        } else {
          options = bits;
          callback = e2;
          bits = void 0;
          e2 = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e2 === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e2;
          e2 = void 0;
        }
      }
      options = options || {};
      if (bits === void 0) {
        bits = options.bits || 2048;
      }
      if (e2 === void 0) {
        e2 = options.e || 65537;
      }
      if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e2 === 65537 || e2 === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits,
              publicExponent: e2,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki.privateKeyFromPem(priv),
                publicKey: pki.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util2.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e2),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair) {
              return util2.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki.privateKeyFromAsn1(
                  asn12.fromDer(forge.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util2.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e2),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e3) {
              var pair = e3.target.result;
              var exportOp = util2.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
              exportOp.oncomplete = function(e4) {
                var pkcs8 = e4.target.result;
                var privateKey = pki.privateKeyFromAsn1(
                  asn12.fromDer(forge.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits,
              publicExponent: e2,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki.privateKeyFromPem(keypair.privateKey),
              publicKey: pki.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki.rsa.createKeyPairGenerationState(bits, e2, options);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n2, e2) {
      var key = {
        n: n2,
        e: e2
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m2, key2, pub) {
              return _encodePkcs1_v1_5(m2, key2, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m2, key2) {
              return forge.pkcs1.encode_rsa_oaep(key2, m2, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e4) {
            return e4;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e3 = scheme.encode(data, key, true);
        return pki.rsa.encrypt(e3, key, true);
      };
      key.verify = function(digest2, signature, scheme) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest3, d3) {
              d3 = _decodePkcs1_v1_5(d3, key, true);
              var obj = asn12.fromDer(d3);
              return digest3 === obj.value[1].value;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest3, d3) {
              d3 = _decodePkcs1_v1_5(d3, key, true);
              return digest3 === d3;
            }
          };
        }
        var d2 = pki.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest2, d2, key.n.bitLength());
      };
      return key;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n2, e2, d2, p2, q2, dP, dQ, qInv) {
      var key = {
        n: n2,
        e: e2,
        d: d2,
        p: p2,
        q: q2,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d3 = pki.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d4, key2) {
              return forge.pkcs1.decode_rsa_oaep(key2, d4, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d4) {
            return d4;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d3, key, false);
      };
      key.sign = function(md2, scheme) {
        var bt2 = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt2 = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md2;
          } };
          bt2 = 1;
        }
        var d3 = scheme.encode(md2, key.n.bitLength());
        return pki.rsa.encrypt(d3, key, bt2);
      };
      return key;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
        // version (0)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          asn12.integerToDer(0).getBytes()
        ),
        // privateKeyAlgorithm
        asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
          asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OID,
            false,
            asn12.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
        ]),
        // PrivateKey
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.OCTETSTRING,
          false,
          asn12.toDer(rsaKey).getBytes()
        )
      ]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn12.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn12.fromDer(forge.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn12.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors;
        throw error;
      }
      var n2, e2, d2, p2, q2, dP, dQ, qInv;
      n2 = forge.util.createBuffer(capture.privateKeyModulus).toHex();
      e2 = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d2 = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p2 = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
      q2 = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(
        new BigInteger(n2, 16),
        new BigInteger(e2, 16),
        new BigInteger(d2, 16),
        new BigInteger(p2, 16),
        new BigInteger(q2, 16),
        new BigInteger(dP, 16),
        new BigInteger(dQ, 16),
        new BigInteger(qInv, 16)
      );
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
      return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
        // version (0 = only 2 primes, 1 multiple primes)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          asn12.integerToDer(0).getBytes()
        ),
        // modulus (n)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        ),
        // privateExponent (d)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.d)
        ),
        // privateKeyPrime1 (p)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.p)
        ),
        // privateKeyPrime2 (q)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.q)
        ),
        // privateKeyExponent1 (dP)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.dP)
        ),
        // privateKeyExponent2 (dQ)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.dQ)
        ),
        // coefficient (qInv)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.qInv)
        )
      ]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn12.validate(obj, publicKeyValidator, capture, errors)) {
        var oid = asn12.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn12.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors;
        throw error;
      }
      var n2 = forge.util.createBuffer(capture.publicKeyModulus).toHex();
      var e2 = forge.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(
        new BigInteger(n2, 16),
        new BigInteger(e2, 16)
      );
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
        // AlgorithmIdentifier
        asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
          // algorithm
          asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.OID,
            false,
            asn12.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          // parameters (null)
          asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
        ]),
        // subjectPublicKey
        asn12.create(asn12.Class.UNIVERSAL, asn12.Type.BITSTRING, false, [
          pki.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki.publicKeyToRSAPublicKey = function(key) {
      return asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
        // modulus (n)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        )
      ]);
    };
    function _encodePkcs1_v1_5(m2, key, bt2) {
      var eb = forge.util.createBuffer();
      var k2 = Math.ceil(key.n.bitLength() / 8);
      if (m2.length > k2 - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m2.length;
        error.max = k2 - 11;
        throw error;
      }
      eb.putByte(0);
      eb.putByte(bt2);
      var padNum = k2 - 3 - m2.length;
      var padByte;
      if (bt2 === 0 || bt2 === 1) {
        padByte = bt2 === 0 ? 0 : 255;
        for (var i2 = 0; i2 < padNum; ++i2) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge.random.getBytes(padNum);
          for (var i2 = 0; i2 < padNum; ++i2) {
            padByte = padBytes.charCodeAt(i2);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m2);
      return eb;
    }
    function _decodePkcs1_v1_5(em2, key, pub, ml2) {
      var k2 = Math.ceil(key.n.bitLength() / 8);
      var eb = forge.util.createBuffer(em2);
      var first = eb.getByte();
      var bt2 = eb.getByte();
      if (first !== 0 || pub && bt2 !== 0 && bt2 !== 1 || !pub && bt2 != 2 || pub && bt2 === 0 && typeof ml2 === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt2 === 0) {
        padNum = k2 - 3 - ml2;
        for (var i2 = 0; i2 < padNum; ++i2) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt2 === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt2 === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0 || padNum !== k2 - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits, callback2) {
        forge.prime.generateProbablePrime(bits, opts, callback2);
      }
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d2 = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(
            state.n,
            state.e,
            d2,
            state.p,
            state.q,
            d2.mod(state.p1),
            d2.mod(state.q1),
            state.q.modInverse(state.p)
          ),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b2) {
      var hex = b2.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes = forge.util.hexToBytes(hex);
      if (bytes.length > 1 && // leading 0x00 for positive integer
      (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
        return bytes.substr(1);
      }
      return bytes;
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100) return 27;
      if (bits <= 150) return 18;
      if (bits <= 200) return 15;
      if (bits <= 250) return 12;
      if (bits <= 300) return 9;
      if (bits <= 350) return 8;
      if (bits <= 400) return 7;
      if (bits <= 500) return 6;
      if (bits <= 600) return 5;
      if (bits <= 800) return 4;
      if (bits <= 1250) return 3;
      return 2;
    }
    function _detectNodeCrypto(fn2) {
      return forge.util.isNodejs && typeof _crypto[fn2] === "function";
    }
    function _detectSubtleCrypto(fn2) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.crypto === "object" && typeof util2.globalScope.crypto.subtle === "object" && typeof util2.globalScope.crypto.subtle[fn2] === "function";
    }
    function _detectSubtleMsCrypto(fn2) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.msCrypto === "object" && typeof util2.globalScope.msCrypto.subtle === "object" && typeof util2.globalScope.msCrypto.subtle[fn2] === "function";
    }
    function _intToUint8Array(x3) {
      var bytes = forge.util.hexToBytes(x3.toString(16));
      var buffer = new Uint8Array(bytes.length);
      for (var i2 = 0; i2 < bytes.length; ++i2) {
        buffer[i2] = bytes.charCodeAt(i2);
      }
      return buffer;
    }
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/pbe.js"(exports2, module2) {
    var forge = require_forge2();
    require_aes2();
    require_asn13();
    require_des2();
    require_md3();
    require_oids2();
    require_pbkdf23();
    require_pem4();
    require_random2();
    require_rc22();
    require_rsa2();
    require_util2();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var asn12 = forge.asn1;
    var pki = forge.pki = forge.pki || {};
    module2.exports = pki.pbe = forge.pbe = forge.pbe || {};
    var oids = pki.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn12.Class.UNIVERSAL,
      type: asn12.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        // encryptedData
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn12.Class.UNIVERSAL,
      type: asn12.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            // prf
            name: "PBES2Algorithms.params.prf",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn12.Class.UNIVERSAL,
              type: asn12.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn12.Class.UNIVERSAL,
      type: asn12.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || "aes128";
      options.prfAlgorithm = options.prfAlgorithm || "sha1";
      var salt = forge.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn12.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge.des.createEncryptionCipher;
            break;
          default:
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
        }
        var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
        var md2 = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md2);
        var iv2 = forge.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv2);
        cipher.update(asn12.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.SEQUENCE,
          true,
          [
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OID,
              false,
              asn12.oidToDer(oids["pkcs5PBES2"]).getBytes()
            ),
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // keyDerivationFunc
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(oids["pkcs5PBKDF2"]).getBytes()
                ),
                // PBKDF2-params
                params
              ]),
              // encryptionScheme
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OID,
                  false,
                  asn12.oidToDer(encOid).getBytes()
                ),
                // iv
                asn12.create(
                  asn12.Class.UNIVERSAL,
                  asn12.Type.OCTETSTRING,
                  false,
                  iv2
                )
              ])
            ])
          ]
        );
      } else if (options.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge.util.ByteBuffer(salt);
        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv2 = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge.des.createEncryptionCipher(dk);
        cipher.start(iv2);
        cipher.update(asn12.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.SEQUENCE,
          true,
          [
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OID,
              false,
              asn12.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
            ),
            // pkcs-12PbeParams
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
              // salt
              asn12.create(asn12.Class.UNIVERSAL, asn12.Type.OCTETSTRING, false, salt),
              // iteration count
              asn12.create(
                asn12.Class.UNIVERSAL,
                asn12.Type.INTEGER,
                false,
                countBytes.getBytes()
              )
            ])
          ]
        );
      } else {
        var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
        // encryptionAlgorithm
        encryptionAlgorithm,
        // encryptedData
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.OCTETSTRING,
          false,
          encryptedData
        )
      ]);
      return rval;
    };
    pki.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn12.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn12.derToOid(capture.encryptionOid);
      var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn12.fromDer(cipher.output);
      }
      return rval;
    };
    pki.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn12.toDer(epki).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn12.fromDer(msg.body);
    };
    pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
        rval = pki.encryptPrivateKeyInfo(rval, password, options);
        return pki.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv2;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv2 = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv2 = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv2 = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv2 = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv2 = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge.pbe.opensslDeriveBytes(password, iv2.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv2);
      cipher.update(asn12.toDer(pki.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge.util.bytesToHex(iv2).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge.pem.encode(msg);
    };
    pki.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv2 = forge.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge.pbe.opensslDeriveBytes(password, iv2.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv2);
        cipher.update(forge.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki.decryptPrivateKeyInfo(asn12.fromDer(rval), password);
      } else {
        rval = asn12.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki.pbe.generatePkcs12Key = function(password, salt, id2, iter, n2, md2) {
      var j2, l2;
      if (typeof md2 === "undefined" || md2 === null) {
        if (!("sha1" in forge.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md2 = forge.md.sha1.create();
      }
      var u2 = md2.digestLength;
      var v3 = md2.blockLength;
      var result = new forge.util.ByteBuffer();
      var passBuf = new forge.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l2 = 0; l2 < password.length; l2++) {
          passBuf.putInt16(password.charCodeAt(l2));
        }
        passBuf.putInt16(0);
      }
      var p2 = passBuf.length();
      var s2 = salt.length();
      var D2 = new forge.util.ByteBuffer();
      D2.fillWithByte(id2, v3);
      var Slen = v3 * Math.ceil(s2 / v3);
      var S2 = new forge.util.ByteBuffer();
      for (l2 = 0; l2 < Slen; l2++) {
        S2.putByte(salt.at(l2 % s2));
      }
      var Plen = v3 * Math.ceil(p2 / v3);
      var P3 = new forge.util.ByteBuffer();
      for (l2 = 0; l2 < Plen; l2++) {
        P3.putByte(passBuf.at(l2 % p2));
      }
      var I3 = S2;
      I3.putBuffer(P3);
      var c2 = Math.ceil(n2 / u2);
      for (var i2 = 1; i2 <= c2; i2++) {
        var buf = new forge.util.ByteBuffer();
        buf.putBytes(D2.bytes());
        buf.putBytes(I3.bytes());
        for (var round = 0; round < iter; round++) {
          md2.start();
          md2.update(buf.getBytes());
          buf = md2.digest();
        }
        var B3 = new forge.util.ByteBuffer();
        for (l2 = 0; l2 < v3; l2++) {
          B3.putByte(buf.at(l2 % u2));
        }
        var k2 = Math.ceil(s2 / v3) + Math.ceil(p2 / v3);
        var Inew = new forge.util.ByteBuffer();
        for (j2 = 0; j2 < k2; j2++) {
          var chunk = new forge.util.ByteBuffer(I3.getBytes(v3));
          var x3 = 511;
          for (l2 = B3.length() - 1; l2 >= 0; l2--) {
            x3 = x3 >> 8;
            x3 += B3.at(l2) + chunk.at(l2);
            chunk.setAt(l2, x3 & 255);
          }
          Inew.putBuffer(chunk);
        }
        I3 = Inew;
        result.putBuffer(buf);
      }
      result.truncate(result.length() - n2);
      return result;
    };
    pki.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki.oids["pkcs5PBES2"]:
          return pki.pbe.getCipherForPBES2(oid, params, password);
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error.oid = oid;
          error.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error;
      }
    };
    pki.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn12.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      oid = asn12.derToOid(capture.kdfOid);
      if (oid !== pki.oids["pkcs5PBKDF2"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error.oid = oid;
        error.supportedOids = ["pkcs5PBKDF2"];
        throw error;
      }
      oid = asn12.derToOid(capture.encOid);
      if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error.oid = oid;
        error.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge.des.createDecryptionCipher;
          break;
      }
      var md2 = prfOidToMessageDigest(capture.prfOid);
      var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md2);
      var iv2 = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv2);
      return cipher;
    };
    pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn12.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var salt = forge.util.createBuffer(capture.salt);
      var count = forge.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge.des.startDecrypting;
          break;
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key2, iv3) {
            var cipher = forge.rc2.createDecryptionCipher(key2, 40);
            cipher.start(iv3, null);
            return cipher;
          };
          break;
        default:
          var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error.oid = oid;
          throw error;
      }
      var md2 = prfOidToMessageDigest(capture.prfOid);
      var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md2);
      md2.start();
      var iv2 = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md2);
      return cipherFn(key, iv2);
    };
    pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md2) {
      if (typeof md2 === "undefined" || md2 === null) {
        if (!("md5" in forge.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md2 = forge.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash3(md2, password + salt)];
      for (var length2 = 16, i2 = 1; length2 < dkLen; ++i2, length2 += 16) {
        digests.push(hash3(md2, digests[i2 - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash3(md2, bytes) {
      return md2.start().update(bytes).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki.oids[asn12.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error = new Error("Unsupported PRF OID.");
          error.oid = prfOid;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error = new Error("Unsupported PRF algorithm.");
          error.algorithm = prfAlgorithm;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
        // salt
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.OCTETSTRING,
          false,
          salt
        ),
        // iteration count
        asn12.create(
          asn12.Class.UNIVERSAL,
          asn12.Type.INTEGER,
          false,
          countBytes.getBytes()
        )
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(
          // key length
          asn12.create(
            asn12.Class.UNIVERSAL,
            asn12.Type.INTEGER,
            false,
            forge.util.hexToBytes(dkLen.toString(16))
          ),
          // AlgorithmIdentifier
          asn12.create(asn12.Class.UNIVERSAL, asn12.Type.SEQUENCE, true, [
            // algorithm
            asn12.create(
              asn12.Class.UNIVERSAL,
              asn12.Type.OID,
              false,
              asn12.oidToDer(pki.oids[prfAlgorithm]).getBytes()
            ),
            // parameters (null)
            asn12.create(asn12.Class.UNIVERSAL, asn12.Type.NULL, false, "")
          ])
        );
      }
      return params;
    }
  }
});

// ../../node_modules/uint8arrays/esm/src/concat.js
var concat_exports = {};
__export(concat_exports, {
  concat: () => concat
});
function concat(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}
var init_concat = __esm({
  "../../node_modules/uint8arrays/esm/src/concat.js"() {
    init_alloc();
    init_as_uint8array();
  }
});

// ../../node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js
var require_aes_gcm_browser = __commonJS({
  "../../node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js"(exports2, module2) {
    "use strict";
    var { concat: concat2 } = (init_concat(), __toCommonJS(concat_exports));
    var { fromString: fromString3 } = (init_from_string(), __toCommonJS(from_string_exports));
    var webcrypto = require_webcrypto();
    function create2({
      algorithm = "AES-GCM",
      nonceLength = 12,
      keyLength = 16,
      digest: digest2 = "SHA-256",
      saltLength = 16,
      iterations = 32767
    } = {}) {
      const crypto2 = webcrypto.get();
      keyLength *= 8;
      async function encrypt2(data, password) {
        const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
        const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
        const aesGcm = { name: algorithm, iv: nonce };
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", fromString3(password), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
        const cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
        const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
        return concat2([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
      }
      async function decrypt2(data, password) {
        const salt = data.slice(0, saltLength);
        const nonce = data.slice(saltLength, saltLength + nonceLength);
        const ciphertext = data.slice(saltLength + nonceLength);
        const aesGcm = { name: algorithm, iv: nonce };
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const rawKey = await crypto2.subtle.importKey("raw", fromString3(password), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
        const cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
        const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
        return new Uint8Array(plaintext);
      }
      return {
        encrypt: encrypt2,
        decrypt: decrypt2
      };
    }
    module2.exports = {
      create: create2
    };
  }
});

// ../../node_modules/libp2p-crypto/src/keys/importer.js
var require_importer = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/importer.js"(exports2, module2) {
    "use strict";
    var { base64: base642 } = (init_base64(), __toCommonJS(base64_exports));
    var ciphers = require_aes_gcm_browser();
    module2.exports = {
      /**
       * Attempts to decrypt a base64 encoded PrivateKey string
       * with the given password. The privateKey must have been exported
       * using the same password and underlying cipher (aes-gcm)
       *
       * @param {string} privateKey - A base64 encoded encrypted key
       * @param {string} password
       * @returns {Promise<Uint8Array>} The private key protobuf
       */
      import: async function(privateKey, password) {
        const encryptedKey = base642.decode(privateKey);
        const cipher = ciphers.create();
        return await cipher.decrypt(encryptedKey, password);
      }
    };
  }
});

// ../../node_modules/uint8arrays/esm/src/equals.js
var equals_exports = {};
__export(equals_exports, {
  equals: () => equals3
});
function equals3(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (a2.byteLength !== b2.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a2.byteLength; i2++) {
    if (a2[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
var init_equals = __esm({
  "../../node_modules/uint8arrays/esm/src/equals.js"() {
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/sha512.js
var require_sha5123 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/sha512.js"(exports2, module2) {
    var forge = require_forge2();
    require_md3();
    require_util2();
    var sha5123 = module2.exports = forge.sha512 = forge.sha512 || {};
    forge.md.sha512 = forge.md.algorithms.sha512 = sha5123;
    var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
    sha384.create = function() {
      return sha5123.create("SHA-384");
    };
    forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
    forge.sha512.sha256 = forge.sha512.sha256 || {
      create: function() {
        return sha5123.create("SHA-512/256");
      }
    };
    forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
    forge.sha512.sha224 = forge.sha512.sha224 || {
      create: function() {
        return sha5123.create("SHA-512/224");
      }
    };
    forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
    sha5123.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h2 = null;
      var _input = forge.util.createBuffer();
      var _w2 = new Array(80);
      for (var wi2 = 0; wi2 < 80; ++wi2) {
        _w2[wi2] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md2 = {
        // SHA-512 => sha512
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 16
      };
      md2.start = function() {
        md2.messageLength = 0;
        md2.fullMessageLength = md2.messageLength128 = [];
        var int32s = md2.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md2.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _h2 = new Array(_state.length);
        for (var i2 = 0; i2 < _state.length; ++i2) {
          _h2[i2] = _state[i2].slice(0);
        }
        return md2;
      };
      md2.start();
      md2.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md2.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md2.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md2.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md2.fullMessageLength[i2] / 4294967296 >>> 0);
          md2.fullMessageLength[i2] = md2.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h2, _w2, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md2;
      };
      md2.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md2.fullMessageLength[md2.fullMessageLength.length - 1] + md2.messageLengthSize;
        var overflow = remaining & md2.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md2.blockLength - overflow));
        var next, carry;
        var bits = md2.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md2.fullMessageLength.length - 1; ++i2) {
          next = md2.fullMessageLength[i2 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var h2 = new Array(_h2.length);
        for (var i2 = 0; i2 < _h2.length; ++i2) {
          h2[i2] = _h2[i2].slice(0);
        }
        _update(h2, _w2, finalBlock);
        var rval = forge.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h2.length;
        } else if (algorithm === "SHA-384") {
          hlen = h2.length - 2;
        } else {
          hlen = h2.length - 4;
        }
        for (var i2 = 0; i2 < hlen; ++i2) {
          rval.putInt32(h2[i2][0]);
          if (i2 !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h2[i2][1]);
          }
        }
        return rval;
      };
      return md2;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s2, w3, bytes) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i2, hi2, lo2, w22, w7, w15, w16;
      var len = bytes.length();
      while (len >= 128) {
        for (i2 = 0; i2 < 16; ++i2) {
          w3[i2][0] = bytes.getInt32() >>> 0;
          w3[i2][1] = bytes.getInt32() >>> 0;
        }
        for (; i2 < 80; ++i2) {
          w22 = w3[i2 - 2];
          hi2 = w22[0];
          lo2 = w22[1];
          t1_hi = ((hi2 >>> 19 | lo2 << 13) ^ // ROTR 19
          (lo2 >>> 29 | hi2 << 3) ^ // ROTR 61/(swap + ROTR 29)
          hi2 >>> 6) >>> 0;
          t1_lo = ((hi2 << 13 | lo2 >>> 19) ^ // ROTR 19
          (lo2 << 3 | hi2 >>> 29) ^ // ROTR 61/(swap + ROTR 29)
          (hi2 << 26 | lo2 >>> 6)) >>> 0;
          w15 = w3[i2 - 15];
          hi2 = w15[0];
          lo2 = w15[1];
          t2_hi = ((hi2 >>> 1 | lo2 << 31) ^ // ROTR 1
          (hi2 >>> 8 | lo2 << 24) ^ // ROTR 8
          hi2 >>> 7) >>> 0;
          t2_lo = ((hi2 << 31 | lo2 >>> 1) ^ // ROTR 1
          (hi2 << 24 | lo2 >>> 8) ^ // ROTR 8
          (hi2 << 25 | lo2 >>> 7)) >>> 0;
          w7 = w3[i2 - 7];
          w16 = w3[i2 - 16];
          lo2 = t1_lo + w7[1] + t2_lo + w16[1];
          w3[i2][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo2 / 4294967296 >>> 0) >>> 0;
          w3[i2][1] = lo2 >>> 0;
        }
        a_hi = s2[0][0];
        a_lo = s2[0][1];
        b_hi = s2[1][0];
        b_lo = s2[1][1];
        c_hi = s2[2][0];
        c_lo = s2[2][1];
        d_hi = s2[3][0];
        d_lo = s2[3][1];
        e_hi = s2[4][0];
        e_lo = s2[4][1];
        f_hi = s2[5][0];
        f_lo = s2[5][1];
        g_hi = s2[6][0];
        g_lo = s2[6][1];
        h_hi = s2[7][0];
        h_lo = s2[7][1];
        for (i2 = 0; i2 < 80; ++i2) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
          (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
          (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
          (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
          (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
          (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
          (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo2 = h_lo + s1_lo + ch_lo + _k[i2][1] + w3[i2][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i2][0] + w3[i2][0] + (lo2 / 4294967296 >>> 0) >>> 0;
          t1_lo = lo2 >>> 0;
          lo2 = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo2 / 4294967296 >>> 0) >>> 0;
          t2_lo = lo2 >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo2 = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo2 / 4294967296 >>> 0) >>> 0;
          e_lo = lo2 >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo2 = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo2 / 4294967296 >>> 0) >>> 0;
          a_lo = lo2 >>> 0;
        }
        lo2 = s2[0][1] + a_lo;
        s2[0][0] = s2[0][0] + a_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[0][1] = lo2 >>> 0;
        lo2 = s2[1][1] + b_lo;
        s2[1][0] = s2[1][0] + b_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[1][1] = lo2 >>> 0;
        lo2 = s2[2][1] + c_lo;
        s2[2][0] = s2[2][0] + c_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[2][1] = lo2 >>> 0;
        lo2 = s2[3][1] + d_lo;
        s2[3][0] = s2[3][0] + d_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[3][1] = lo2 >>> 0;
        lo2 = s2[4][1] + e_lo;
        s2[4][0] = s2[4][0] + e_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[4][1] = lo2 >>> 0;
        lo2 = s2[5][1] + f_lo;
        s2[5][0] = s2[5][0] + f_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[5][1] = lo2 >>> 0;
        lo2 = s2[6][1] + g_lo;
        s2[6][0] = s2[6][0] + g_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[6][1] = lo2 >>> 0;
        lo2 = s2[7][1] + h_lo;
        s2[7][0] = s2[7][0] + h_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s2[7][1] = lo2 >>> 0;
        len -= 128;
      }
    }
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/asn1-validator.js
var require_asn1_validator = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/asn1-validator.js"(exports2) {
    var forge = require_forge2();
    require_asn13();
    var asn12 = forge.asn1;
    exports2.privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn12.Class.UNIVERSAL,
      type: asn12.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn12.Class.UNIVERSAL,
        type: asn12.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    exports2.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn12.Class.UNIVERSAL,
      type: asn12.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [
        {
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn12.Class.UNIVERSAL,
            type: asn12.Type.OID,
            constructed: false,
            capture: "publicKeyOid"
          }]
        },
        // capture group for ed25519PublicKey
        {
          tagClass: asn12.Class.UNIVERSAL,
          type: asn12.Type.BITSTRING,
          constructed: false,
          composed: true,
          captureBitStringValue: "ed25519PublicKey"
        }
        // FIXME: this is capture group for rsaPublicKey, use it in this API or
        // discard?
        /* {
          // subjectPublicKey
          name: 'SubjectPublicKeyInfo.subjectPublicKey',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          value: [{
            // RSAPublicKey
            name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            captureAsn1: 'rsaPublicKey'
          }]
        } */
      ]
    };
  }
});

// ../../node_modules/libp2p-crypto/node_modules/node-forge/lib/ed25519.js
var require_ed255192 = __commonJS({
  "../../node_modules/libp2p-crypto/node_modules/node-forge/lib/ed25519.js"(exports2, module2) {
    var forge = require_forge2();
    require_jsbn2();
    require_random2();
    require_sha5123();
    require_util2();
    var asn1Validator = require_asn1_validator();
    var publicKeyValidator = asn1Validator.publicKeyValidator;
    var privateKeyValidator = asn1Validator.privateKeyValidator;
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var ByteBuffer = forge.util.ByteBuffer;
    var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
    forge.pki = forge.pki || {};
    module2.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
    var ed255192 = forge.ed25519;
    ed255192.constants = {};
    ed255192.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
    ed255192.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
    ed255192.constants.SEED_BYTE_LENGTH = 32;
    ed255192.constants.SIGN_BYTE_LENGTH = 64;
    ed255192.constants.HASH_BYTE_LENGTH = 64;
    ed255192.generateKeyPair = function(options) {
      options = options || {};
      var seed = options.seed;
      if (seed === void 0) {
        seed = forge.random.getBytesSync(ed255192.constants.SEED_BYTE_LENGTH);
      } else if (typeof seed === "string") {
        if (seed.length !== ed255192.constants.SEED_BYTE_LENGTH) {
          throw new TypeError(
            '"seed" must be ' + ed255192.constants.SEED_BYTE_LENGTH + " bytes in length."
          );
        }
      } else if (!(seed instanceof Uint8Array)) {
        throw new TypeError(
          '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
        );
      }
      seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
      var pk = new NativeBuffer(ed255192.constants.PUBLIC_KEY_BYTE_LENGTH);
      var sk = new NativeBuffer(ed255192.constants.PRIVATE_KEY_BYTE_LENGTH);
      for (var i2 = 0; i2 < 32; ++i2) {
        sk[i2] = seed[i2];
      }
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, privateKey: sk };
    };
    ed255192.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge.asn1.derToOid(capture.privateKeyOid);
      var ed25519Oid = forge.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var privateKey = capture.privateKey;
      var privateKeyBytes = messageToNativeBuffer({
        message: forge.asn1.fromDer(privateKey).value,
        encoding: "binary"
      });
      return { privateKeyBytes };
    };
    ed255192.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge.asn1.derToOid(capture.publicKeyOid);
      var ed25519Oid = forge.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var publicKeyBytes = capture.ed25519PublicKey;
      if (publicKeyBytes.length !== ed255192.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new Error("Key length is invalid.");
      }
      return messageToNativeBuffer({
        message: publicKeyBytes,
        encoding: "binary"
      });
    };
    ed255192.publicKeyFromPrivateKey = function(options) {
      options = options || {};
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length !== ed255192.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed255192.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var pk = new NativeBuffer(ed255192.constants.PUBLIC_KEY_BYTE_LENGTH);
      for (var i2 = 0; i2 < pk.length; ++i2) {
        pk[i2] = privateKey[32 + i2];
      }
      return pk;
    };
    ed255192.sign = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length === ed255192.constants.SEED_BYTE_LENGTH) {
        var keyPair = ed255192.generateKeyPair({ seed: privateKey });
        privateKey = keyPair.privateKey;
      } else if (privateKey.length !== ed255192.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed255192.constants.SEED_BYTE_LENGTH + " or " + ed255192.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var signedMsg = new NativeBuffer(
        ed255192.constants.SIGN_BYTE_LENGTH + msg.length
      );
      crypto_sign(signedMsg, msg, msg.length, privateKey);
      var sig = new NativeBuffer(ed255192.constants.SIGN_BYTE_LENGTH);
      for (var i2 = 0; i2 < sig.length; ++i2) {
        sig[i2] = signedMsg[i2];
      }
      return sig;
    };
    ed255192.verify = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      if (options.signature === void 0) {
        throw new TypeError(
          '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
        );
      }
      var sig = messageToNativeBuffer({
        message: options.signature,
        encoding: "binary"
      });
      if (sig.length !== ed255192.constants.SIGN_BYTE_LENGTH) {
        throw new TypeError(
          '"options.signature" must have a byte length of ' + ed255192.constants.SIGN_BYTE_LENGTH
        );
      }
      var publicKey = messageToNativeBuffer({
        message: options.publicKey,
        encoding: "binary"
      });
      if (publicKey.length !== ed255192.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.publicKey" must have a byte length of ' + ed255192.constants.PUBLIC_KEY_BYTE_LENGTH
        );
      }
      var sm2 = new NativeBuffer(ed255192.constants.SIGN_BYTE_LENGTH + msg.length);
      var m2 = new NativeBuffer(ed255192.constants.SIGN_BYTE_LENGTH + msg.length);
      var i2;
      for (i2 = 0; i2 < ed255192.constants.SIGN_BYTE_LENGTH; ++i2) {
        sm2[i2] = sig[i2];
      }
      for (i2 = 0; i2 < msg.length; ++i2) {
        sm2[i2 + ed255192.constants.SIGN_BYTE_LENGTH] = msg[i2];
      }
      return crypto_sign_open(m2, sm2, sm2.length, publicKey) >= 0;
    };
    function messageToNativeBuffer(options) {
      var message = options.message;
      if (message instanceof Uint8Array || message instanceof NativeBuffer) {
        return message;
      }
      var encoding = options.encoding;
      if (message === void 0) {
        if (options.md) {
          message = options.md.digest().getBytes();
          encoding = "binary";
        } else {
          throw new TypeError('"options.message" or "options.md" not specified.');
        }
      }
      if (typeof message === "string" && !encoding) {
        throw new TypeError('"options.encoding" must be "binary" or "utf8".');
      }
      if (typeof message === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.from(message, encoding);
        }
        message = new ByteBuffer(message, encoding);
      } else if (!(message instanceof ByteBuffer)) {
        throw new TypeError(
          '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
        );
      }
      var buffer = new NativeBuffer(message.length());
      for (var i2 = 0; i2 < buffer.length; ++i2) {
        buffer[i2] = message.at(i2);
      }
      return buffer;
    }
    var gf0 = gf2();
    var gf1 = gf2([1]);
    var D2 = gf2([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf2([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X3 = gf2([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y2 = gf2([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var L2 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    var I3 = gf2([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function sha5123(msg, msgLen) {
      var md2 = forge.md.sha512.create();
      var buffer = new ByteBuffer(msg);
      md2.update(buffer.getBytes(msgLen), "binary");
      var hash3 = md2.digest().getBytes();
      if (typeof Buffer !== "undefined") {
        return Buffer.from(hash3, "binary");
      }
      var out = new NativeBuffer(ed255192.constants.HASH_BYTE_LENGTH);
      for (var i2 = 0; i2 < 64; ++i2) {
        out[i2] = hash3.charCodeAt(i2);
      }
      return out;
    }
    function crypto_sign_keypair(pk, sk) {
      var p2 = [gf2(), gf2(), gf2(), gf2()];
      var i2;
      var d2 = sha5123(sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      scalarbase(p2, d2);
      pack(pk, p2);
      for (i2 = 0; i2 < 32; ++i2) {
        sk[i2 + 32] = pk[i2];
      }
      return 0;
    }
    function crypto_sign(sm2, m2, n2, sk) {
      var i2, j2, x3 = new Float64Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()];
      var d2 = sha5123(sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      var smlen = n2 + 64;
      for (i2 = 0; i2 < n2; ++i2) {
        sm2[64 + i2] = m2[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        sm2[32 + i2] = d2[32 + i2];
      }
      var r2 = sha5123(sm2.subarray(32), n2 + 32);
      reduce(r2);
      scalarbase(p2, r2);
      pack(sm2, p2);
      for (i2 = 32; i2 < 64; ++i2) {
        sm2[i2] = sk[i2];
      }
      var h2 = sha5123(sm2, n2 + 64);
      reduce(h2);
      for (i2 = 32; i2 < 64; ++i2) {
        x3[i2] = 0;
      }
      for (i2 = 0; i2 < 32; ++i2) {
        x3[i2] = r2[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        for (j2 = 0; j2 < 32; j2++) {
          x3[i2 + j2] += h2[i2] * d2[j2];
        }
      }
      modL(sm2.subarray(32), x3);
      return smlen;
    }
    function crypto_sign_open(m2, sm2, n2, pk) {
      var i2, mlen;
      var t2 = new NativeBuffer(32);
      var p2 = [gf2(), gf2(), gf2(), gf2()], q2 = [gf2(), gf2(), gf2(), gf2()];
      mlen = -1;
      if (n2 < 64) {
        return -1;
      }
      if (unpackneg(q2, pk)) {
        return -1;
      }
      for (i2 = 0; i2 < n2; ++i2) {
        m2[i2] = sm2[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        m2[i2 + 32] = pk[i2];
      }
      var h2 = sha5123(m2, n2);
      reduce(h2);
      scalarmult(p2, q2, h2);
      scalarbase(q2, sm2.subarray(32));
      add(p2, q2);
      pack(t2, p2);
      n2 -= 64;
      if (crypto_verify_32(sm2, 0, t2, 0)) {
        for (i2 = 0; i2 < n2; ++i2) {
          m2[i2] = 0;
        }
        return -1;
      }
      for (i2 = 0; i2 < n2; ++i2) {
        m2[i2] = sm2[i2 + 64];
      }
      mlen = n2;
      return mlen;
    }
    function modL(r2, x3) {
      var carry, i2, j2, k2;
      for (i2 = 63; i2 >= 32; --i2) {
        carry = 0;
        for (j2 = i2 - 32, k2 = i2 - 12; j2 < k2; ++j2) {
          x3[j2] += carry - 16 * x3[i2] * L2[j2 - (i2 - 32)];
          carry = x3[j2] + 128 >> 8;
          x3[j2] -= carry * 256;
        }
        x3[j2] += carry;
        x3[i2] = 0;
      }
      carry = 0;
      for (j2 = 0; j2 < 32; ++j2) {
        x3[j2] += carry - (x3[31] >> 4) * L2[j2];
        carry = x3[j2] >> 8;
        x3[j2] &= 255;
      }
      for (j2 = 0; j2 < 32; ++j2) {
        x3[j2] -= carry * L2[j2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        x3[i2 + 1] += x3[i2] >> 8;
        r2[i2] = x3[i2] & 255;
      }
    }
    function reduce(r2) {
      var x3 = new Float64Array(64);
      for (var i2 = 0; i2 < 64; ++i2) {
        x3[i2] = r2[i2];
        r2[i2] = 0;
      }
      modL(r2, x3);
    }
    function add(p2, q2) {
      var a2 = gf2(), b2 = gf2(), c2 = gf2(), d2 = gf2(), e2 = gf2(), f2 = gf2(), g2 = gf2(), h2 = gf2(), t2 = gf2();
      Z3(a2, p2[1], p2[0]);
      Z3(t2, q2[1], q2[0]);
      M3(a2, a2, t2);
      A2(b2, p2[0], p2[1]);
      A2(t2, q2[0], q2[1]);
      M3(b2, b2, t2);
      M3(c2, p2[3], q2[3]);
      M3(c2, c2, D22);
      M3(d2, p2[2], q2[2]);
      A2(d2, d2, d2);
      Z3(e2, b2, a2);
      Z3(f2, d2, c2);
      A2(g2, d2, c2);
      A2(h2, b2, a2);
      M3(p2[0], e2, f2);
      M3(p2[1], h2, g2);
      M3(p2[2], g2, f2);
      M3(p2[3], e2, h2);
    }
    function cswap(p2, q2, b2) {
      for (var i2 = 0; i2 < 4; ++i2) {
        sel25519(p2[i2], q2[i2], b2);
      }
    }
    function pack(r2, p2) {
      var tx = gf2(), ty2 = gf2(), zi2 = gf2();
      inv25519(zi2, p2[2]);
      M3(tx, p2[0], zi2);
      M3(ty2, p2[1], zi2);
      pack25519(r2, ty2);
      r2[31] ^= par25519(tx) << 7;
    }
    function pack25519(o2, n2) {
      var i2, j2, b2;
      var m2 = gf2(), t2 = gf2();
      for (i2 = 0; i2 < 16; ++i2) {
        t2[i2] = n2[i2];
      }
      car25519(t2);
      car25519(t2);
      car25519(t2);
      for (j2 = 0; j2 < 2; ++j2) {
        m2[0] = t2[0] - 65517;
        for (i2 = 1; i2 < 15; ++i2) {
          m2[i2] = t2[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
          m2[i2 - 1] &= 65535;
        }
        m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
        b2 = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t2, m2, 1 - b2);
      }
      for (i2 = 0; i2 < 16; i2++) {
        o2[2 * i2] = t2[i2] & 255;
        o2[2 * i2 + 1] = t2[i2] >> 8;
      }
    }
    function unpackneg(r2, p2) {
      var t2 = gf2(), chk = gf2(), num = gf2(), den = gf2(), den2 = gf2(), den4 = gf2(), den6 = gf2();
      set25519(r2[2], gf1);
      unpack25519(r2[1], p2);
      S2(num, r2[1]);
      M3(den, num, D2);
      Z3(num, num, r2[2]);
      A2(den, r2[2], den);
      S2(den2, den);
      S2(den4, den2);
      M3(den6, den4, den2);
      M3(t2, den6, num);
      M3(t2, t2, den);
      pow2523(t2, t2);
      M3(t2, t2, num);
      M3(t2, t2, den);
      M3(t2, t2, den);
      M3(r2[0], t2, den);
      S2(chk, r2[0]);
      M3(chk, chk, den);
      if (neq25519(chk, num)) {
        M3(r2[0], r2[0], I3);
      }
      S2(chk, r2[0]);
      M3(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r2[0]) === p2[31] >> 7) {
        Z3(r2[0], gf0, r2[0]);
      }
      M3(r2[3], r2[0], r2[1]);
      return 0;
    }
    function unpack25519(o2, n2) {
      var i2;
      for (i2 = 0; i2 < 16; ++i2) {
        o2[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
      }
      o2[15] &= 32767;
    }
    function pow2523(o2, i2) {
      var c2 = gf2();
      var a2;
      for (a2 = 0; a2 < 16; ++a2) {
        c2[a2] = i2[a2];
      }
      for (a2 = 250; a2 >= 0; --a2) {
        S2(c2, c2);
        if (a2 !== 1) {
          M3(c2, c2, i2);
        }
      }
      for (a2 = 0; a2 < 16; ++a2) {
        o2[a2] = c2[a2];
      }
    }
    function neq25519(a2, b2) {
      var c2 = new NativeBuffer(32);
      var d2 = new NativeBuffer(32);
      pack25519(c2, a2);
      pack25519(d2, b2);
      return crypto_verify_32(c2, 0, d2, 0);
    }
    function crypto_verify_32(x3, xi2, y2, yi2) {
      return vn2(x3, xi2, y2, yi2, 32);
    }
    function vn2(x3, xi2, y2, yi2, n2) {
      var i2, d2 = 0;
      for (i2 = 0; i2 < n2; ++i2) {
        d2 |= x3[xi2 + i2] ^ y2[yi2 + i2];
      }
      return (1 & d2 - 1 >>> 8) - 1;
    }
    function par25519(a2) {
      var d2 = new NativeBuffer(32);
      pack25519(d2, a2);
      return d2[0] & 1;
    }
    function scalarmult(p2, q2, s2) {
      var b2, i2;
      set25519(p2[0], gf0);
      set25519(p2[1], gf1);
      set25519(p2[2], gf1);
      set25519(p2[3], gf0);
      for (i2 = 255; i2 >= 0; --i2) {
        b2 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
        cswap(p2, q2, b2);
        add(q2, p2);
        add(p2, p2);
        cswap(p2, q2, b2);
      }
    }
    function scalarbase(p2, s2) {
      var q2 = [gf2(), gf2(), gf2(), gf2()];
      set25519(q2[0], X3);
      set25519(q2[1], Y2);
      set25519(q2[2], gf1);
      M3(q2[3], X3, Y2);
      scalarmult(p2, q2, s2);
    }
    function set25519(r2, a2) {
      var i2;
      for (i2 = 0; i2 < 16; i2++) {
        r2[i2] = a2[i2] | 0;
      }
    }
    function inv25519(o2, i2) {
      var c2 = gf2();
      var a2;
      for (a2 = 0; a2 < 16; ++a2) {
        c2[a2] = i2[a2];
      }
      for (a2 = 253; a2 >= 0; --a2) {
        S2(c2, c2);
        if (a2 !== 2 && a2 !== 4) {
          M3(c2, c2, i2);
        }
      }
      for (a2 = 0; a2 < 16; ++a2) {
        o2[a2] = c2[a2];
      }
    }
    function car25519(o2) {
      var i2, v3, c2 = 1;
      for (i2 = 0; i2 < 16; ++i2) {
        v3 = o2[i2] + c2 + 65535;
        c2 = Math.floor(v3 / 65536);
        o2[i2] = v3 - c2 * 65536;
      }
      o2[0] += c2 - 1 + 37 * (c2 - 1);
    }
    function sel25519(p2, q2, b2) {
      var t2, c2 = ~(b2 - 1);
      for (var i2 = 0; i2 < 16; ++i2) {
        t2 = c2 & (p2[i2] ^ q2[i2]);
        p2[i2] ^= t2;
        q2[i2] ^= t2;
      }
    }
    function gf2(init) {
      var i2, r2 = new Float64Array(16);
      if (init) {
        for (i2 = 0; i2 < init.length; ++i2) {
          r2[i2] = init[i2];
        }
      }
      return r2;
    }
    function A2(o2, a2, b2) {
      for (var i2 = 0; i2 < 16; ++i2) {
        o2[i2] = a2[i2] + b2[i2];
      }
    }
    function Z3(o2, a2, b2) {
      for (var i2 = 0; i2 < 16; ++i2) {
        o2[i2] = a2[i2] - b2[i2];
      }
    }
    function S2(o2, a2) {
      M3(o2, a2, a2);
    }
    function M3(o2, a2, b2) {
      var v3, c2, t02 = 0, t12 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t122 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b02 = b2[0], b12 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b122 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v3 = a2[0];
      t02 += v3 * b02;
      t12 += v3 * b12;
      t2 += v3 * b22;
      t3 += v3 * b3;
      t4 += v3 * b4;
      t5 += v3 * b5;
      t6 += v3 * b6;
      t7 += v3 * b7;
      t8 += v3 * b8;
      t9 += v3 * b9;
      t10 += v3 * b10;
      t11 += v3 * b11;
      t122 += v3 * b122;
      t13 += v3 * b13;
      t14 += v3 * b14;
      t15 += v3 * b15;
      v3 = a2[1];
      t12 += v3 * b02;
      t2 += v3 * b12;
      t3 += v3 * b22;
      t4 += v3 * b3;
      t5 += v3 * b4;
      t6 += v3 * b5;
      t7 += v3 * b6;
      t8 += v3 * b7;
      t9 += v3 * b8;
      t10 += v3 * b9;
      t11 += v3 * b10;
      t122 += v3 * b11;
      t13 += v3 * b122;
      t14 += v3 * b13;
      t15 += v3 * b14;
      t16 += v3 * b15;
      v3 = a2[2];
      t2 += v3 * b02;
      t3 += v3 * b12;
      t4 += v3 * b22;
      t5 += v3 * b3;
      t6 += v3 * b4;
      t7 += v3 * b5;
      t8 += v3 * b6;
      t9 += v3 * b7;
      t10 += v3 * b8;
      t11 += v3 * b9;
      t122 += v3 * b10;
      t13 += v3 * b11;
      t14 += v3 * b122;
      t15 += v3 * b13;
      t16 += v3 * b14;
      t17 += v3 * b15;
      v3 = a2[3];
      t3 += v3 * b02;
      t4 += v3 * b12;
      t5 += v3 * b22;
      t6 += v3 * b3;
      t7 += v3 * b4;
      t8 += v3 * b5;
      t9 += v3 * b6;
      t10 += v3 * b7;
      t11 += v3 * b8;
      t122 += v3 * b9;
      t13 += v3 * b10;
      t14 += v3 * b11;
      t15 += v3 * b122;
      t16 += v3 * b13;
      t17 += v3 * b14;
      t18 += v3 * b15;
      v3 = a2[4];
      t4 += v3 * b02;
      t5 += v3 * b12;
      t6 += v3 * b22;
      t7 += v3 * b3;
      t8 += v3 * b4;
      t9 += v3 * b5;
      t10 += v3 * b6;
      t11 += v3 * b7;
      t122 += v3 * b8;
      t13 += v3 * b9;
      t14 += v3 * b10;
      t15 += v3 * b11;
      t16 += v3 * b122;
      t17 += v3 * b13;
      t18 += v3 * b14;
      t19 += v3 * b15;
      v3 = a2[5];
      t5 += v3 * b02;
      t6 += v3 * b12;
      t7 += v3 * b22;
      t8 += v3 * b3;
      t9 += v3 * b4;
      t10 += v3 * b5;
      t11 += v3 * b6;
      t122 += v3 * b7;
      t13 += v3 * b8;
      t14 += v3 * b9;
      t15 += v3 * b10;
      t16 += v3 * b11;
      t17 += v3 * b122;
      t18 += v3 * b13;
      t19 += v3 * b14;
      t20 += v3 * b15;
      v3 = a2[6];
      t6 += v3 * b02;
      t7 += v3 * b12;
      t8 += v3 * b22;
      t9 += v3 * b3;
      t10 += v3 * b4;
      t11 += v3 * b5;
      t122 += v3 * b6;
      t13 += v3 * b7;
      t14 += v3 * b8;
      t15 += v3 * b9;
      t16 += v3 * b10;
      t17 += v3 * b11;
      t18 += v3 * b122;
      t19 += v3 * b13;
      t20 += v3 * b14;
      t21 += v3 * b15;
      v3 = a2[7];
      t7 += v3 * b02;
      t8 += v3 * b12;
      t9 += v3 * b22;
      t10 += v3 * b3;
      t11 += v3 * b4;
      t122 += v3 * b5;
      t13 += v3 * b6;
      t14 += v3 * b7;
      t15 += v3 * b8;
      t16 += v3 * b9;
      t17 += v3 * b10;
      t18 += v3 * b11;
      t19 += v3 * b122;
      t20 += v3 * b13;
      t21 += v3 * b14;
      t22 += v3 * b15;
      v3 = a2[8];
      t8 += v3 * b02;
      t9 += v3 * b12;
      t10 += v3 * b22;
      t11 += v3 * b3;
      t122 += v3 * b4;
      t13 += v3 * b5;
      t14 += v3 * b6;
      t15 += v3 * b7;
      t16 += v3 * b8;
      t17 += v3 * b9;
      t18 += v3 * b10;
      t19 += v3 * b11;
      t20 += v3 * b122;
      t21 += v3 * b13;
      t22 += v3 * b14;
      t23 += v3 * b15;
      v3 = a2[9];
      t9 += v3 * b02;
      t10 += v3 * b12;
      t11 += v3 * b22;
      t122 += v3 * b3;
      t13 += v3 * b4;
      t14 += v3 * b5;
      t15 += v3 * b6;
      t16 += v3 * b7;
      t17 += v3 * b8;
      t18 += v3 * b9;
      t19 += v3 * b10;
      t20 += v3 * b11;
      t21 += v3 * b122;
      t22 += v3 * b13;
      t23 += v3 * b14;
      t24 += v3 * b15;
      v3 = a2[10];
      t10 += v3 * b02;
      t11 += v3 * b12;
      t122 += v3 * b22;
      t13 += v3 * b3;
      t14 += v3 * b4;
      t15 += v3 * b5;
      t16 += v3 * b6;
      t17 += v3 * b7;
      t18 += v3 * b8;
      t19 += v3 * b9;
      t20 += v3 * b10;
      t21 += v3 * b11;
      t22 += v3 * b122;
      t23 += v3 * b13;
      t24 += v3 * b14;
      t25 += v3 * b15;
      v3 = a2[11];
      t11 += v3 * b02;
      t122 += v3 * b12;
      t13 += v3 * b22;
      t14 += v3 * b3;
      t15 += v3 * b4;
      t16 += v3 * b5;
      t17 += v3 * b6;
      t18 += v3 * b7;
      t19 += v3 * b8;
      t20 += v3 * b9;
      t21 += v3 * b10;
      t22 += v3 * b11;
      t23 += v3 * b122;
      t24 += v3 * b13;
      t25 += v3 * b14;
      t26 += v3 * b15;
      v3 = a2[12];
      t122 += v3 * b02;
      t13 += v3 * b12;
      t14 += v3 * b22;
      t15 += v3 * b3;
      t16 += v3 * b4;
      t17 += v3 * b5;
      t18 += v3 * b6;
      t19 += v3 * b7;
      t20 += v3 * b8;
      t21 += v3 * b9;
      t22 += v3 * b10;
      t23 += v3 * b11;
      t24 += v3 * b122;
      t25 += v3 * b13;
      t26 += v3 * b14;
      t27 += v3 * b15;
      v3 = a2[13];
      t13 += v3 * b02;
      t14 += v3 * b12;
      t15 += v3 * b22;
      t16 += v3 * b3;
      t17 += v3 * b4;
      t18 += v3 * b5;
      t19 += v3 * b6;
      t20 += v3 * b7;
      t21 += v3 * b8;
      t22 += v3 * b9;
      t23 += v3 * b10;
      t24 += v3 * b11;
      t25 += v3 * b122;
      t26 += v3 * b13;
      t27 += v3 * b14;
      t28 += v3 * b15;
      v3 = a2[14];
      t14 += v3 * b02;
      t15 += v3 * b12;
      t16 += v3 * b22;
      t17 += v3 * b3;
      t18 += v3 * b4;
      t19 += v3 * b5;
      t20 += v3 * b6;
      t21 += v3 * b7;
      t22 += v3 * b8;
      t23 += v3 * b9;
      t24 += v3 * b10;
      t25 += v3 * b11;
      t26 += v3 * b122;
      t27 += v3 * b13;
      t28 += v3 * b14;
      t29 += v3 * b15;
      v3 = a2[15];
      t15 += v3 * b02;
      t16 += v3 * b12;
      t17 += v3 * b22;
      t18 += v3 * b3;
      t19 += v3 * b4;
      t20 += v3 * b5;
      t21 += v3 * b6;
      t22 += v3 * b7;
      t23 += v3 * b8;
      t24 += v3 * b9;
      t25 += v3 * b10;
      t26 += v3 * b11;
      t27 += v3 * b122;
      t28 += v3 * b13;
      t29 += v3 * b14;
      t30 += v3 * b15;
      t02 += 38 * t16;
      t12 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t122 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v3 = t02 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t02 = v3 - c2 * 65536;
      v3 = t12 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t12 = v3 - c2 * 65536;
      v3 = t2 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t2 = v3 - c2 * 65536;
      v3 = t3 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t3 = v3 - c2 * 65536;
      v3 = t4 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t4 = v3 - c2 * 65536;
      v3 = t5 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t5 = v3 - c2 * 65536;
      v3 = t6 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t6 = v3 - c2 * 65536;
      v3 = t7 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t7 = v3 - c2 * 65536;
      v3 = t8 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t8 = v3 - c2 * 65536;
      v3 = t9 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t9 = v3 - c2 * 65536;
      v3 = t10 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t10 = v3 - c2 * 65536;
      v3 = t11 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t11 = v3 - c2 * 65536;
      v3 = t122 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t122 = v3 - c2 * 65536;
      v3 = t13 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t13 = v3 - c2 * 65536;
      v3 = t14 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t14 = v3 - c2 * 65536;
      v3 = t15 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t15 = v3 - c2 * 65536;
      t02 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v3 = t02 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t02 = v3 - c2 * 65536;
      v3 = t12 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t12 = v3 - c2 * 65536;
      v3 = t2 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t2 = v3 - c2 * 65536;
      v3 = t3 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t3 = v3 - c2 * 65536;
      v3 = t4 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t4 = v3 - c2 * 65536;
      v3 = t5 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t5 = v3 - c2 * 65536;
      v3 = t6 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t6 = v3 - c2 * 65536;
      v3 = t7 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t7 = v3 - c2 * 65536;
      v3 = t8 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t8 = v3 - c2 * 65536;
      v3 = t9 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t9 = v3 - c2 * 65536;
      v3 = t10 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t10 = v3 - c2 * 65536;
      v3 = t11 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t11 = v3 - c2 * 65536;
      v3 = t122 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t122 = v3 - c2 * 65536;
      v3 = t13 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t13 = v3 - c2 * 65536;
      v3 = t14 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t14 = v3 - c2 * 65536;
      v3 = t15 + c2 + 65535;
      c2 = Math.floor(v3 / 65536);
      t15 = v3 - c2 * 65536;
      t02 += c2 - 1 + 37 * (c2 - 1);
      o2[0] = t02;
      o2[1] = t12;
      o2[2] = t2;
      o2[3] = t3;
      o2[4] = t4;
      o2[5] = t5;
      o2[6] = t6;
      o2[7] = t7;
      o2[8] = t8;
      o2[9] = t9;
      o2[10] = t10;
      o2[11] = t11;
      o2[12] = t122;
      o2[13] = t13;
      o2[14] = t14;
      o2[15] = t15;
    }
  }
});

// ../../node_modules/iso-random-stream/src/random.browser.js
var require_random_browser = __commonJS({
  "../../node_modules/iso-random-stream/src/random.browser.js"(exports2, module2) {
    "use strict";
    var MAX_BYTES = 65536;
    function randomBytes2(size) {
      const bytes = new Uint8Array(size);
      let generated = 0;
      if (size > 0) {
        if (size > MAX_BYTES) {
          while (generated < size) {
            if (generated + MAX_BYTES > size) {
              crypto.getRandomValues(
                bytes.subarray(generated, generated + (size - generated))
              );
              generated += size - generated;
            } else {
              crypto.getRandomValues(
                bytes.subarray(generated, generated + MAX_BYTES)
              );
              generated += MAX_BYTES;
            }
          }
        } else {
          crypto.getRandomValues(bytes);
        }
      }
      return bytes;
    }
    module2.exports = randomBytes2;
  }
});

// ../../node_modules/libp2p-crypto/src/random-bytes.js
var require_random_bytes = __commonJS({
  "../../node_modules/libp2p-crypto/src/random-bytes.js"(exports2, module2) {
    "use strict";
    var randomBytes2 = require_random_browser();
    var errcode = require_err_code();
    module2.exports = function(length2) {
      if (isNaN(length2) || length2 <= 0) {
        throw errcode(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH");
      }
      return randomBytes2(length2);
    };
  }
});

// ../../node_modules/libp2p-crypto/src/util.js
var require_util3 = __commonJS({
  "../../node_modules/libp2p-crypto/src/util.js"(exports2) {
    "use strict";
    require_util2();
    require_jsbn2();
    var forge = require_forge2();
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    exports2.bigIntegerToUintBase64url = (num, len) => {
      let buf = Uint8Array.from(num.abs().toByteArray());
      buf = buf[0] === 0 ? buf.slice(1) : buf;
      if (len != null) {
        if (buf.length > len) throw new Error("byte array longer than desired length");
        buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);
      }
      return uint8ArrayToString(buf, "base64url");
    };
    exports2.base64urlToBigInteger = (str) => {
      const buf = exports2.base64urlToBuffer(str);
      return new forge.jsbn.BigInteger(uint8ArrayToString(buf, "base16"), 16);
    };
    exports2.base64urlToBuffer = (str, len) => {
      let buf = uint8ArrayFromString(str, "base64urlpad");
      if (len != null) {
        if (buf.length > len) throw new Error("byte array longer than desired length");
        buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);
      }
      return buf;
    };
  }
});

// ../../node_modules/libp2p-crypto/src/keys/rsa-utils.js
var require_rsa_utils = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/rsa-utils.js"(exports2) {
    "use strict";
    require_asn13();
    require_rsa2();
    var forge = require_forge2();
    var { bigIntegerToUintBase64url, base64urlToBigInteger } = require_util3();
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    exports2.pkcs1ToJwk = function(bytes) {
      const asn12 = forge.asn1.fromDer(uint8ArrayToString(bytes, "ascii"));
      const privateKey = forge.pki.privateKeyFromAsn1(asn12);
      return {
        kty: "RSA",
        n: bigIntegerToUintBase64url(privateKey.n),
        e: bigIntegerToUintBase64url(privateKey.e),
        d: bigIntegerToUintBase64url(privateKey.d),
        p: bigIntegerToUintBase64url(privateKey.p),
        q: bigIntegerToUintBase64url(privateKey.q),
        dp: bigIntegerToUintBase64url(privateKey.dP),
        dq: bigIntegerToUintBase64url(privateKey.dQ),
        qi: bigIntegerToUintBase64url(privateKey.qInv),
        alg: "RS256",
        kid: "2011-04-29"
      };
    };
    exports2.jwkToPkcs1 = function(jwk) {
      const asn12 = forge.pki.privateKeyToAsn1({
        n: base64urlToBigInteger(jwk.n),
        e: base64urlToBigInteger(jwk.e),
        d: base64urlToBigInteger(jwk.d),
        p: base64urlToBigInteger(jwk.p),
        q: base64urlToBigInteger(jwk.q),
        dP: base64urlToBigInteger(jwk.dp),
        dQ: base64urlToBigInteger(jwk.dq),
        qInv: base64urlToBigInteger(jwk.qi)
      });
      return uint8ArrayFromString(forge.asn1.toDer(asn12).getBytes(), "ascii");
    };
    exports2.pkixToJwk = function(bytes) {
      const asn12 = forge.asn1.fromDer(uint8ArrayToString(bytes, "ascii"));
      const publicKey = forge.pki.publicKeyFromAsn1(asn12);
      return {
        kty: "RSA",
        n: bigIntegerToUintBase64url(publicKey.n),
        e: bigIntegerToUintBase64url(publicKey.e),
        alg: "RS256",
        kid: "2011-04-29"
      };
    };
    exports2.jwkToPkix = function(jwk) {
      const asn12 = forge.pki.publicKeyToAsn1({
        n: base64urlToBigInteger(jwk.n),
        e: base64urlToBigInteger(jwk.e)
      });
      return uint8ArrayFromString(forge.asn1.toDer(asn12).getBytes(), "ascii");
    };
  }
});

// ../../node_modules/libp2p-crypto/src/keys/jwk2pem.js
var require_jwk2pem = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/jwk2pem.js"(exports2, module2) {
    "use strict";
    require_rsa2();
    var forge = require_forge2();
    var { base64urlToBigInteger } = require_util3();
    function convert(key, types) {
      return types.map((t2) => base64urlToBigInteger(key[t2]));
    }
    function jwk2priv(key) {
      return forge.pki.setRsaPrivateKey(...convert(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
    }
    function jwk2pub(key) {
      return forge.pki.setRsaPublicKey(...convert(key, ["n", "e"]));
    }
    module2.exports = {
      jwk2pub,
      jwk2priv
    };
  }
});

// ../../node_modules/libp2p-crypto/src/keys/rsa-browser.js
var require_rsa_browser = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/rsa-browser.js"(exports2) {
    "use strict";
    var webcrypto = require_webcrypto();
    var randomBytes2 = require_random_bytes();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    exports2.utils = require_rsa_utils();
    exports2.generateKey = async function(bits) {
      const pair = await webcrypto.get().subtle.generateKey(
        {
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: bits,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: { name: "SHA-256" }
        },
        true,
        ["sign", "verify"]
      );
      const keys = await exportKey(pair);
      return {
        privateKey: keys[0],
        publicKey: keys[1]
      };
    };
    exports2.unmarshalPrivateKey = async function(key) {
      const privateKey = await webcrypto.get().subtle.importKey(
        "jwk",
        key,
        {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        },
        true,
        ["sign"]
      );
      const pair = [
        privateKey,
        await derivePublicFromPrivate(key)
      ];
      const keys = await exportKey({
        privateKey: pair[0],
        publicKey: pair[1]
      });
      return {
        privateKey: keys[0],
        publicKey: keys[1]
      };
    };
    exports2.getRandomValues = randomBytes2;
    exports2.hashAndSign = async function(key, msg) {
      const privateKey = await webcrypto.get().subtle.importKey(
        "jwk",
        key,
        {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        },
        false,
        ["sign"]
      );
      const sig = await webcrypto.get().subtle.sign(
        { name: "RSASSA-PKCS1-v1_5" },
        privateKey,
        Uint8Array.from(msg)
      );
      return new Uint8Array(sig, sig.byteOffset, sig.byteLength);
    };
    exports2.hashAndVerify = async function(key, sig, msg) {
      const publicKey = await webcrypto.get().subtle.importKey(
        "jwk",
        key,
        {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        },
        false,
        ["verify"]
      );
      return webcrypto.get().subtle.verify(
        { name: "RSASSA-PKCS1-v1_5" },
        publicKey,
        sig,
        msg
      );
    };
    function exportKey(pair) {
      return Promise.all([
        webcrypto.get().subtle.exportKey("jwk", pair.privateKey),
        webcrypto.get().subtle.exportKey("jwk", pair.publicKey)
      ]);
    }
    function derivePublicFromPrivate(jwKey) {
      return webcrypto.get().subtle.importKey(
        "jwk",
        {
          kty: jwKey.kty,
          n: jwKey.n,
          e: jwKey.e
        },
        {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        },
        true,
        ["verify"]
      );
    }
    var { jwk2pub, jwk2priv } = require_jwk2pem();
    function convertKey(key, pub, msg, handle) {
      const fkey = pub ? jwk2pub(key) : jwk2priv(key);
      const fmsg = uint8ArrayToString(Uint8Array.from(msg), "ascii");
      const fomsg = handle(fmsg, fkey);
      return uint8ArrayFromString(fomsg, "ascii");
    }
    exports2.encrypt = function(key, msg) {
      return convertKey(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
    };
    exports2.decrypt = function(key, msg) {
      return convertKey(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
    };
  }
});

// ../../node_modules/libp2p-crypto/src/keys/exporter.js
var require_exporter = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/exporter.js"(exports2, module2) {
    "use strict";
    var { base64: base642 } = (init_base64(), __toCommonJS(base64_exports));
    var ciphers = require_aes_gcm_browser();
    module2.exports = {
      /**
       * Exports the given PrivateKey as a base64 encoded string.
       * The PrivateKey is encrypted via a password derived PBKDF2 key
       * leveraging the aes-gcm cipher algorithm.
       *
       * @param {Uint8Array} privateKey - The PrivateKey protobuf
       * @param {string} password
       * @returns {Promise<string>} A base64 encoded string
       */
      export: async function(privateKey, password) {
        const cipher = ciphers.create();
        const encryptedKey = await cipher.encrypt(privateKey, password);
        return base642.encode(encryptedKey);
      }
    };
  }
});

// ../../node_modules/libp2p-crypto/src/keys/rsa-class.js
var require_rsa_class = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/rsa-class.js"(exports2, module2) {
    "use strict";
    var { sha256: sha2563 } = (init_sha2_browser(), __toCommonJS(sha2_browser_exports));
    var errcode = require_err_code();
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    require_sha5123();
    require_ed255192();
    var forge = require_forge2();
    var crypto2 = require_rsa_browser();
    var pbm = require_keys2();
    var exporter = require_exporter();
    var RsaPublicKey2 = class {
      constructor(key) {
        this._key = key;
      }
      async verify(data, sig) {
        return crypto2.hashAndVerify(this._key, sig, data);
      }
      marshal() {
        return crypto2.utils.jwkToPkix(this._key);
      }
      get bytes() {
        return pbm.PublicKey.encode({
          Type: pbm.KeyType.RSA,
          Data: this.marshal()
        }).finish();
      }
      encrypt(bytes) {
        return crypto2.encrypt(this._key, bytes);
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes } = await sha2563.digest(this.bytes);
        return bytes;
      }
    };
    var RsaPrivateKey2 = class {
      // key       - Object of the jwk format
      // publicKey - Uint8Array of the spki format
      constructor(key, publicKey) {
        this._key = key;
        this._publicKey = publicKey;
      }
      genSecret() {
        return crypto2.getRandomValues(16);
      }
      async sign(message) {
        return crypto2.hashAndSign(this._key, message);
      }
      get public() {
        if (!this._publicKey) {
          throw errcode(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED");
        }
        return new RsaPublicKey2(this._publicKey);
      }
      decrypt(bytes) {
        return crypto2.decrypt(this._key, bytes);
      }
      marshal() {
        return crypto2.utils.jwkToPkcs1(this._key);
      }
      get bytes() {
        return pbm.PrivateKey.encode({
          Type: pbm.KeyType.RSA,
          Data: this.marshal()
        }).finish();
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes } = await sha2563.digest(this.bytes);
        return bytes;
      }
      /**
       * Gets the ID of the key.
       *
       * The key id is the base58 encoding of the SHA-256 multihash of its public key.
       * The public key is a protobuf encoding containing a type and the DER encoding
       * of the PKCS SubjectPublicKeyInfo.
       *
       * @returns {Promise<string>}
       */
      async id() {
        const hash3 = await this.public.hash();
        return uint8ArrayToString(hash3, "base58btc");
      }
      /**
       * Exports the key into a password protected PEM format
       *
       * @param {string} password - The password to read the encrypted PEM
       * @param {string} [format=pkcs-8] - The format in which to export as
       */
      async export(password, format = "pkcs-8") {
        if (format === "pkcs-8") {
          const buffer = new forge.util.ByteBuffer(this.marshal());
          const asn12 = forge.asn1.fromDer(buffer);
          const privateKey = forge.pki.privateKeyFromAsn1(asn12);
          const options = {
            algorithm: "aes256",
            count: 1e4,
            saltSize: 128 / 8,
            prfAlgorithm: "sha512"
          };
          return forge.pki.encryptRsaPrivateKey(privateKey, password, options);
        } else if (format === "libp2p-key") {
          return exporter.export(this.bytes, password);
        } else {
          throw errcode(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
        }
      }
    };
    async function unmarshalRsaPrivateKey(bytes) {
      const jwk = crypto2.utils.pkcs1ToJwk(bytes);
      const keys = await crypto2.unmarshalPrivateKey(jwk);
      return new RsaPrivateKey2(keys.privateKey, keys.publicKey);
    }
    function unmarshalRsaPublicKey(bytes) {
      const jwk = crypto2.utils.pkixToJwk(bytes);
      return new RsaPublicKey2(jwk);
    }
    async function fromJwk(jwk) {
      const keys = await crypto2.unmarshalPrivateKey(jwk);
      return new RsaPrivateKey2(keys.privateKey, keys.publicKey);
    }
    async function generateKeyPair4(bits) {
      const keys = await crypto2.generateKey(bits);
      return new RsaPrivateKey2(keys.privateKey, keys.publicKey);
    }
    module2.exports = {
      RsaPublicKey: RsaPublicKey2,
      RsaPrivateKey: RsaPrivateKey2,
      unmarshalRsaPublicKey,
      unmarshalRsaPrivateKey,
      generateKeyPair: generateKeyPair4,
      fromJwk
    };
  }
});

// ../../node_modules/libp2p-crypto/src/keys/ed25519.js
var require_ed255193 = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/ed25519.js"(exports2) {
    "use strict";
    require_ed255192();
    var forge = require_forge2();
    exports2.publicKeyLength = forge.pki.ed25519.constants.PUBLIC_KEY_BYTE_LENGTH;
    exports2.privateKeyLength = forge.pki.ed25519.constants.PRIVATE_KEY_BYTE_LENGTH;
    exports2.generateKey = async function() {
      return forge.pki.ed25519.generateKeyPair();
    };
    exports2.generateKeyFromSeed = async function(seed) {
      return forge.pki.ed25519.generateKeyPair({ seed });
    };
    exports2.hashAndSign = async function(key, msg) {
      return forge.pki.ed25519.sign({ message: msg, privateKey: key });
    };
    exports2.hashAndVerify = async function(key, sig, msg) {
      return forge.pki.ed25519.verify({ signature: sig, message: msg, publicKey: key });
    };
  }
});

// ../../node_modules/libp2p-crypto/src/keys/ed25519-class.js
var require_ed25519_class = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/ed25519-class.js"(exports2, module2) {
    "use strict";
    var errcode = require_err_code();
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var { sha256: sha2563 } = (init_sha2_browser(), __toCommonJS(sha2_browser_exports));
    var { base58btc: base58btc2 } = (init_base58(), __toCommonJS(base58_exports));
    var { identity: identity3 } = (init_identity2(), __toCommonJS(identity_exports2));
    var crypto2 = require_ed255193();
    var pbm = require_keys2();
    var exporter = require_exporter();
    var Ed25519PublicKey = class {
      constructor(key) {
        this._key = ensureKey(key, crypto2.publicKeyLength);
      }
      async verify(data, sig) {
        return crypto2.hashAndVerify(this._key, sig, data);
      }
      marshal() {
        return this._key;
      }
      get bytes() {
        return pbm.PublicKey.encode({
          Type: pbm.KeyType.Ed25519,
          Data: this.marshal()
        }).finish();
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes } = await sha2563.digest(this.bytes);
        return bytes;
      }
    };
    var Ed25519PrivateKey = class {
      // key       - 64 byte Uint8Array containing private key
      // publicKey - 32 byte Uint8Array containing public key
      constructor(key, publicKey) {
        this._key = ensureKey(key, crypto2.privateKeyLength);
        this._publicKey = ensureKey(publicKey, crypto2.publicKeyLength);
      }
      async sign(message) {
        return crypto2.hashAndSign(this._key, message);
      }
      get public() {
        return new Ed25519PublicKey(this._publicKey);
      }
      marshal() {
        return this._key;
      }
      get bytes() {
        return pbm.PrivateKey.encode({
          Type: pbm.KeyType.Ed25519,
          Data: this.marshal()
        }).finish();
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes } = await sha2563.digest(this.bytes);
        return bytes;
      }
      /**
       * Gets the ID of the key.
       *
       * The key id is the base58 encoding of the identity multihash containing its public key.
       * The public key is a protobuf encoding containing a type and the DER encoding
       * of the PKCS SubjectPublicKeyInfo.
       *
       * @returns {Promise<string>}
       */
      async id() {
        const encoding = await identity3.digest(this.public.bytes);
        return base58btc2.encode(encoding.bytes).substring(1);
      }
      /**
       * Exports the key into a password protected `format`
       *
       * @param {string} password - The password to encrypt the key
       * @param {string} [format=libp2p-key] - The format in which to export as
       * @returns {Promise<Uint8Array>} The encrypted private key
       */
      async export(password, format = "libp2p-key") {
        if (format === "libp2p-key") {
          return exporter.export(this.bytes, password);
        } else {
          throw errcode(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
        }
      }
    };
    function unmarshalEd25519PrivateKey(bytes) {
      if (bytes.length > crypto2.privateKeyLength) {
        bytes = ensureKey(bytes, crypto2.privateKeyLength + crypto2.publicKeyLength);
        const privateKeyBytes2 = bytes.slice(0, crypto2.privateKeyLength);
        const publicKeyBytes2 = bytes.slice(crypto2.privateKeyLength, bytes.length);
        return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
      }
      bytes = ensureKey(bytes, crypto2.privateKeyLength);
      const privateKeyBytes = bytes.slice(0, crypto2.privateKeyLength);
      const publicKeyBytes = bytes.slice(crypto2.publicKeyLength);
      return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
    }
    function unmarshalEd25519PublicKey(bytes) {
      bytes = ensureKey(bytes, crypto2.publicKeyLength);
      return new Ed25519PublicKey(bytes);
    }
    async function generateKeyPair4() {
      const { privateKey, publicKey } = await crypto2.generateKey();
      return new Ed25519PrivateKey(privateKey, publicKey);
    }
    async function generateKeyPairFromSeed(seed) {
      const { privateKey, publicKey } = await crypto2.generateKeyFromSeed(seed);
      return new Ed25519PrivateKey(privateKey, publicKey);
    }
    function ensureKey(key, length2) {
      key = Uint8Array.from(key || []);
      if (key.length !== length2) {
        throw errcode(new Error(`Key must be a Uint8Array of length ${length2}, got ${key.length}`), "ERR_INVALID_KEY_TYPE");
      }
      return key;
    }
    module2.exports = {
      Ed25519PublicKey,
      Ed25519PrivateKey,
      unmarshalEd25519PrivateKey,
      unmarshalEd25519PublicKey,
      generateKeyPair: generateKeyPair4,
      generateKeyPairFromSeed
    };
  }
});

// ../../node_modules/secp256k1/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/secp256k1/lib/index.js"(exports2, module2) {
    var errors = {
      IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
      TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
      TWEAK_MUL: "The tweak was out of range or equal to zero",
      CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
      SECKEY_INVALID: "Private Key is invalid",
      PUBKEY_PARSE: "Public Key could not be parsed",
      PUBKEY_SERIALIZE: "Public Key serialization error",
      PUBKEY_COMBINE: "The sum of the public keys is not valid",
      SIG_PARSE: "Signature could not be parsed",
      SIGN: "The nonce generation function failed, or the private key was invalid",
      RECOVER: "Public key could not be recover",
      ECDH: "Scalar was invalid (zero or overflow)"
    };
    function assert(cond, msg) {
      if (!cond) throw new Error(msg);
    }
    function isUint8Array(name2, value, length2) {
      assert(value instanceof Uint8Array, `Expected ${name2} to be an Uint8Array`);
      if (length2 !== void 0) {
        if (Array.isArray(length2)) {
          const numbers = length2.join(", ");
          const msg = `Expected ${name2} to be an Uint8Array with length [${numbers}]`;
          assert(length2.includes(value.length), msg);
        } else {
          const msg = `Expected ${name2} to be an Uint8Array with length ${length2}`;
          assert(value.length === length2, msg);
        }
      }
    }
    function isCompressed(value) {
      assert(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
    }
    function getAssertedOutput(output = (len) => new Uint8Array(len), length2) {
      if (typeof output === "function") output = output(length2);
      isUint8Array("output", output, length2);
      return output;
    }
    function toTypeString(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    }
    module2.exports = (secp256k1) => {
      return {
        contextRandomize(seed) {
          assert(
            seed === null || seed instanceof Uint8Array,
            "Expected seed to be an Uint8Array or null"
          );
          if (seed !== null) isUint8Array("seed", seed, 32);
          switch (secp256k1.contextRandomize(seed)) {
            case 1:
              throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
          }
        },
        privateKeyVerify(seckey) {
          isUint8Array("private key", seckey, 32);
          return secp256k1.privateKeyVerify(seckey) === 0;
        },
        privateKeyNegate(seckey) {
          isUint8Array("private key", seckey, 32);
          switch (secp256k1.privateKeyNegate(seckey)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        privateKeyTweakAdd(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.TWEAK_ADD);
          }
        },
        privateKeyTweakMul(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.TWEAK_MUL);
          }
        },
        publicKeyVerify(pubkey) {
          isUint8Array("public key", pubkey, [33, 65]);
          return secp256k1.publicKeyVerify(pubkey) === 0;
        },
        publicKeyCreate(seckey, compressed = true, output) {
          isUint8Array("private key", seckey, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCreate(output, seckey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SECKEY_INVALID);
            case 2:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyConvert(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyConvert(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyNegate(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyNegate(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
            case 3:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyCombine(pubkeys, compressed = true, output) {
          assert(Array.isArray(pubkeys), "Expected public keys to be an Array");
          assert(pubkeys.length > 0, "Expected public keys array will have more than zero items");
          for (const pubkey of pubkeys) {
            isUint8Array("public key", pubkey, [33, 65]);
          }
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCombine(output, pubkeys)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_COMBINE);
            case 3:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.TWEAK_ADD);
          }
        },
        publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.TWEAK_MUL);
          }
        },
        signatureNormalize(sig) {
          isUint8Array("signature", sig, 64);
          switch (secp256k1.signatureNormalize(sig)) {
            case 0:
              return sig;
            case 1:
              throw new Error(errors.SIG_PARSE);
          }
        },
        signatureExport(sig, output) {
          isUint8Array("signature", sig, 64);
          output = getAssertedOutput(output, 72);
          const obj = { output, outputlen: 72 };
          switch (secp256k1.signatureExport(obj, sig)) {
            case 0:
              return output.slice(0, obj.outputlen);
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        signatureImport(sig, output) {
          isUint8Array("signature", sig);
          output = getAssertedOutput(output, 64);
          switch (secp256k1.signatureImport(output, sig)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdsaSign(msg32, seckey, options = {}, output) {
          isUint8Array("message", msg32, 32);
          isUint8Array("private key", seckey, 32);
          assert(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0) isUint8Array("options.data", options.data);
          if (options.noncefn !== void 0) assert(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
          output = getAssertedOutput(output, 64);
          const obj = { signature: output, recid: null };
          switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
            case 0:
              return obj;
            case 1:
              throw new Error(errors.SIGN);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdsaVerify(sig, msg32, pubkey) {
          isUint8Array("signature", sig, 64);
          isUint8Array("message", msg32, 32);
          isUint8Array("public key", pubkey, [33, 65]);
          switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
            case 0:
              return true;
            case 3:
              return false;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_PARSE);
          }
        },
        ecdsaRecover(sig, recid, msg32, compressed = true, output) {
          isUint8Array("signature", sig, 64);
          assert(
            toTypeString(recid) === "Number" && recid >= 0 && recid <= 3,
            "Expected recovery id to be a Number within interval [0, 3]"
          );
          isUint8Array("message", msg32, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.RECOVER);
            case 3:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdh(pubkey, seckey, options = {}, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("private key", seckey, 32);
          assert(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0) isUint8Array("options.data", options.data);
          if (options.hashfn !== void 0) {
            assert(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
            if (options.xbuf !== void 0) isUint8Array("options.xbuf", options.xbuf, 32);
            if (options.ybuf !== void 0) isUint8Array("options.ybuf", options.ybuf, 32);
            isUint8Array("output", output);
          } else {
            output = getAssertedOutput(output, 32);
          }
          switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.ECDH);
          }
        }
      };
    };
  }
});

// ../../node_modules/elliptic/package.json
var require_package = __commonJS({
  "../../node_modules/elliptic/package.json"(exports2, module2) {
    module2.exports = {
      name: "elliptic",
      version: "6.6.1",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/utils.js"(exports2) {
    "use strict";
    var utils = exports2;
    var BN = require_bn();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils3();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w3, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i2;
      for (i2 = 0; i2 < naf.length; i2 += 1) {
        naf[i2] = 0;
      }
      var ws2 = 1 << w3 + 1;
      var k2 = num.clone();
      for (i2 = 0; i2 < naf.length; i2++) {
        var z3;
        var mod2 = k2.andln(ws2 - 1);
        if (k2.isOdd()) {
          if (mod2 > (ws2 >> 1) - 1)
            z3 = (ws2 >> 1) - mod2;
          else
            z3 = mod2;
          k2.isubn(z3);
        } else {
          z3 = 0;
        }
        naf[i2] = z3;
        k2.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d12 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d12) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d12 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u12;
        if ((m14 & 1) === 0) {
          u12 = 0;
        } else {
          m8 = k1.andln(7) + d12 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u12 = -m14;
          else
            u12 = m14;
        }
        jsf[0].push(u12);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d12 === u12 + 1)
          d12 = 1 - d12;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name2, computer) {
      var key = "_" + name2;
      obj.prototype[name2] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// ../../node_modules/brorand/index.js
var require_brorand = __commonJS({
  "../../node_modules/brorand/index.js"(exports2, module2) {
    var r2;
    module2.exports = function rand(len) {
      if (!r2)
        r2 = new Rand(null);
      return r2.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module2.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n2) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n2);
      var res = new Uint8Array(n2);
      for (var i2 = 0; i2 < res.length; i2++)
        res[i2] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n2) {
          var arr = new Uint8Array(n2);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n2) {
          var arr = new Uint8Array(n2);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto2 = require_crypto2();
        if (typeof crypto2.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n2) {
          return crypto2.randomBytes(n2);
        };
      } catch (e2) {
      }
    }
    var crypto2;
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/base.js
var require_base2 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/base.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils4();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module2.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k2) {
      assert(p2.precomputed);
      var doubles = p2._getDoubles();
      var naf = getNAF(k2, 1, this._bitLength);
      var I3 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I3 /= 3;
      var repr = [];
      var j2;
      var nafW;
      for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
        nafW = 0;
        for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
          nafW = (nafW << 1) + naf[l2];
        repr.push(nafW);
      }
      var a2 = this.jpoint(null, null, null);
      var b2 = this.jpoint(null, null, null);
      for (var i2 = I3; i2 > 0; i2--) {
        for (j2 = 0; j2 < repr.length; j2++) {
          nafW = repr[j2];
          if (nafW === i2)
            b2 = b2.mixedAdd(doubles.points[j2]);
          else if (nafW === -i2)
            b2 = b2.mixedAdd(doubles.points[j2].neg());
        }
        a2 = a2.add(b2);
      }
      return a2.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p2, k2) {
      var w3 = 4;
      var nafPoints = p2._getNAFPoints(w3);
      w3 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k2, w3, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i2 = naf.length - 1; i2 >= 0; i2--) {
        for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
          l2++;
        if (i2 >= 0)
          l2++;
        acc = acc.dblp(l2);
        if (i2 < 0)
          break;
        var z3 = naf[i2];
        assert(z3 !== 0);
        if (p2.type === "affine") {
          if (z3 > 0)
            acc = acc.mixedAdd(wnd[z3 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z3 - 1 >> 1].neg());
        } else {
          if (z3 > 0)
            acc = acc.add(wnd[z3 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z3 - 1 >> 1].neg());
        }
      }
      return p2.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i2;
      var j2;
      var p2;
      for (i2 = 0; i2 < len; i2++) {
        p2 = points[i2];
        var nafPoints = p2._getNAFPoints(defW);
        wndWidth[i2] = nafPoints.wnd;
        wnd[i2] = nafPoints.points;
      }
      for (i2 = len - 1; i2 >= 1; i2 -= 2) {
        var a2 = i2 - 1;
        var b2 = i2;
        if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
          naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
          naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
          max = Math.max(naf[a2].length, max);
          max = Math.max(naf[b2].length, max);
          continue;
        }
        var comb = [
          points[a2],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b2]
          /* 7 */
        ];
        if (points[a2].y.cmp(points[b2].y) === 0) {
          comb[1] = points[a2].add(points[b2]);
          comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
        } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
          comb[1] = points[a2].toJ().mixedAdd(points[b2]);
          comb[2] = points[a2].add(points[b2].neg());
        } else {
          comb[1] = points[a2].toJ().mixedAdd(points[b2]);
          comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a2], coeffs[b2]);
        max = Math.max(jsf[0].length, max);
        naf[a2] = new Array(max);
        naf[b2] = new Array(max);
        for (j2 = 0; j2 < max; j2++) {
          var ja2 = jsf[0][j2] | 0;
          var jb = jsf[1][j2] | 0;
          naf[a2][j2] = index[(ja2 + 1) * 3 + (jb + 1)];
          naf[b2][j2] = 0;
          wnd[a2] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i2 = max; i2 >= 0; i2--) {
        var k2 = 0;
        while (i2 >= 0) {
          var zero = true;
          for (j2 = 0; j2 < len; j2++) {
            tmp[j2] = naf[j2][i2] | 0;
            if (tmp[j2] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k2++;
          i2--;
        }
        if (i2 >= 0)
          k2++;
        acc = acc.dblp(k2);
        if (i2 < 0)
          break;
        for (j2 = 0; j2 < len; j2++) {
          var z3 = tmp[j2];
          p2;
          if (z3 === 0)
            continue;
          else if (z3 > 0)
            p2 = wnd[j2][z3 - 1 >> 1];
          else if (z3 < 0)
            p2 = wnd[j2][-z3 - 1 >> 1].neg();
          if (p2.type === "affine")
            acc = acc.mixedAdd(p2);
          else
            acc = acc.add(p2);
        }
      }
      for (i2 = 0; i2 < len; i2++)
        wnd[i2] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x3 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x3);
      return [4].concat(x3, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode9(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k2) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i2 = 0; i2 < power; i2 += step) {
        for (var j2 = 0; j2 < step; j2++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i2 = 1; i2 < max; i2++)
        res[i2] = res[i2 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k2) {
      var r2 = this;
      for (var i2 = 0; i2 < k2; i2++)
        r2 = r2.dbl();
      return r2;
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/short.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var BN = require_bn();
    var inherits2 = require_inherits_browser();
    var Base = require_base2();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits2(ShortCurve, Base);
    module2.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s2 = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l12 = ntinv.redAdd(s2).fromRed();
      var l2 = ntinv.redSub(s2).fromRed();
      return [l12, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u2 = lambda;
      var v3 = this.n.clone();
      var x12 = new BN(1);
      var y12 = new BN(0);
      var x22 = new BN(0);
      var y2 = new BN(1);
      var a02;
      var b02;
      var a12;
      var b12;
      var a2;
      var b2;
      var prevR;
      var i2 = 0;
      var r2;
      var x3;
      while (u2.cmpn(0) !== 0) {
        var q2 = v3.div(u2);
        r2 = v3.sub(q2.mul(u2));
        x3 = x22.sub(q2.mul(x12));
        var y3 = y2.sub(q2.mul(y12));
        if (!a12 && r2.cmp(aprxSqrt) < 0) {
          a02 = prevR.neg();
          b02 = x12;
          a12 = r2.neg();
          b12 = x3;
        } else if (a12 && ++i2 === 2) {
          break;
        }
        prevR = r2;
        v3 = u2;
        u2 = r2;
        x22 = x12;
        x12 = x3;
        y2 = y12;
        y12 = y3;
      }
      a2 = r2.neg();
      b2 = x3;
      var len1 = a12.sqr().add(b12.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a02;
        b2 = b02;
      }
      if (a12.negative) {
        a12 = a12.neg();
        b12 = b12.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a12, b: b12 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k2) {
      var basis = this.endo.basis;
      var v12 = basis[0];
      var v22 = basis[1];
      var c12 = v22.b.mul(k2).divRound(this.n);
      var c2 = v12.b.neg().mul(k2).divRound(this.n);
      var p12 = c12.mul(v12.a);
      var p2 = c2.mul(v22.a);
      var q1 = c12.mul(v12.b);
      var q2 = c2.mul(v22.b);
      var k1 = k2.sub(p12).sub(p2);
      var k22 = q1.add(q2).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x3, odd) {
      x3 = new BN(x3, 16);
      if (!x3.red)
        x3 = x3.toRed(this.red);
      var y2 = x3.redSqr().redMul(x3).redIAdd(x3.redMul(this.a)).redIAdd(this.b);
      var y3 = y2.redSqrt();
      if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y3.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y3 = y3.redNeg();
      return this.point(x3, y3);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x3 = point.x;
      var y2 = point.y;
      var ax = this.a.redMul(x3);
      var rhs = x3.redSqr().redMul(x3).redIAdd(ax).redIAdd(this.b);
      return y2.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i2 = 0; i2 < points.length; i2++) {
        var split = this._endoSplit(coeffs[i2]);
        var p2 = points[i2];
        var beta = p2._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p2 = p2.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i2 * 2] = p2;
        npoints[i2 * 2 + 1] = beta;
        ncoeffs[i2 * 2] = split.k1;
        ncoeffs[i2 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
      for (var j2 = 0; j2 < i2 * 2; j2++) {
        npoints[j2] = null;
        ncoeffs[j2] = null;
      }
      return res;
    };
    function Point(curve, x3, y2, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x3 === null && y2 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x3, 16);
        this.y = new BN(y2, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits2(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x3, y2, isRed) {
      return new Point(this, x3, y2, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p2) {
          return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON2() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p2) {
      if (this.inf)
        return p2;
      if (p2.inf)
        return this;
      if (this.eq(p2))
        return this.dbl();
      if (this.neg().eq(p2))
        return this.curve.point(null, null);
      if (this.x.cmp(p2.x) === 0)
        return this.curve.point(null, null);
      var c2 = this.y.redSub(p2.y);
      if (c2.cmpn(0) !== 0)
        c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
      var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
      var ny2 = c2.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny2);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a2 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c2 = x22.redAdd(x22).redIAdd(x22).redIAdd(a2).redMul(dyinv);
      var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
      var ny2 = c2.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny2);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k2) {
      k2 = new BN(k2, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k2))
        return this.curve._fixedNafMul(this, k2);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k2]);
      else
        return this.curve._wnafMul(this, k2);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p2) {
      return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p2) {
          return p2.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x3, y2, z3) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x3 === null && y2 === null && z3 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x3, 16);
        this.y = new BN(y2, 16);
        this.z = new BN(z3, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits2(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x3, y2, z3) {
      return new JPoint(this, x3, y2, z3);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay2 = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay2);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p2) {
      if (this.isInfinity())
        return p2;
      if (p2.isInfinity())
        return this;
      var pz2 = p2.z.redSqr();
      var z22 = this.z.redSqr();
      var u12 = this.x.redMul(pz2);
      var u2 = p2.x.redMul(z22);
      var s12 = this.y.redMul(pz2.redMul(p2.z));
      var s2 = p2.y.redMul(z22.redMul(this.z));
      var h2 = u12.redSub(u2);
      var r2 = s12.redSub(s2);
      if (h2.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h2.redSqr();
      var h3 = h22.redMul(h2);
      var v3 = u12.redMul(h22);
      var nx = r2.redSqr().redIAdd(h3).redISub(v3).redISub(v3);
      var ny2 = r2.redMul(v3.redISub(nx)).redISub(s12.redMul(h3));
      var nz = this.z.redMul(p2.z).redMul(h2);
      return this.curve.jpoint(nx, ny2, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p2) {
      if (this.isInfinity())
        return p2.toJ();
      if (p2.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u12 = this.x;
      var u2 = p2.x.redMul(z22);
      var s12 = this.y;
      var s2 = p2.y.redMul(z22).redMul(this.z);
      var h2 = u12.redSub(u2);
      var r2 = s12.redSub(s2);
      if (h2.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h2.redSqr();
      var h3 = h22.redMul(h2);
      var v3 = u12.redMul(h22);
      var nx = r2.redSqr().redIAdd(h3).redISub(v3).redISub(v3);
      var ny2 = r2.redMul(v3.redISub(nx)).redISub(s12.redMul(h3));
      var nz = this.z.redMul(h2);
      return this.curve.jpoint(nx, ny2, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i2;
      if (this.curve.zeroA || this.curve.threeA) {
        var r2 = this;
        for (i2 = 0; i2 < pow; i2++)
          r2 = r2.dbl();
        return r2;
      }
      var a2 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy2 = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy2.redAdd(jy2);
      for (i2 = 0; i2 < pow; i2++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
        var t12 = jx.redMul(jyd2);
        var nx = c2.redSqr().redISub(t12.redAdd(t12));
        var t2 = t12.redISub(nx);
        var dny = c2.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i2 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny2;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy2 = this.y.redSqr();
        var yyyy = yy2.redSqr();
        var s2 = this.x.redAdd(yy2).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m2 = xx.redAdd(xx).redIAdd(xx);
        var t2 = m2.redSqr().redISub(s2).redISub(s2);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t2;
        ny2 = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a2 = this.x.redSqr();
        var b2 = this.y.redSqr();
        var c2 = b2.redSqr();
        var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
        d2 = d2.redIAdd(d2);
        var e2 = a2.redAdd(a2).redIAdd(a2);
        var f2 = e2.redSqr();
        var c8 = c2.redIAdd(c2);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f2.redISub(d2).redISub(d2);
        ny2 = e2.redMul(d2.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny2, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny2;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy2 = this.y.redSqr();
        var yyyy = yy2.redSqr();
        var s2 = this.x.redAdd(yy2).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t2 = m2.redSqr().redISub(s2).redISub(s2);
        nx = t2;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny2 = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny2 = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny2, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a2 = this.curve.a;
      var jx = this.x;
      var jy2 = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy22 = jy2.redSqr();
      var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t12 = jxd4.redMul(jy22);
      var nx = c2.redSqr().redISub(t12.redAdd(t12));
      var t2 = t12.redISub(nx);
      var jyd8 = jy22.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny2 = c2.redMul(t2).redISub(jyd8);
      var nz = jy2.redAdd(jy2).redMul(jz);
      return this.curve.jpoint(nx, ny2, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy2 = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy2.redSqr();
      var m2 = xx.redAdd(xx).redIAdd(xx);
      var mm2 = m2.redSqr();
      var e2 = this.x.redAdd(yy2).redSqr().redISub(xx).redISub(yyyy);
      e2 = e2.redIAdd(e2);
      e2 = e2.redAdd(e2).redIAdd(e2);
      e2 = e2.redISub(mm2);
      var ee2 = e2.redSqr();
      var t2 = yyyy.redIAdd(yyyy);
      t2 = t2.redIAdd(t2);
      t2 = t2.redIAdd(t2);
      t2 = t2.redIAdd(t2);
      var u2 = m2.redIAdd(e2).redSqr().redISub(mm2).redISub(ee2).redISub(t2);
      var yyu4 = yy2.redMul(u2);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee2).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny2 = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee2)));
      ny2 = ny2.redIAdd(ny2);
      ny2 = ny2.redIAdd(ny2);
      ny2 = ny2.redIAdd(ny2);
      var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee2);
      return this.curve.jpoint(nx, ny2, nz);
    };
    JPoint.prototype.mul = function mul(k2, kbase) {
      k2 = new BN(k2, kbase);
      return this.curve._wnafMul(this, k2);
    };
    JPoint.prototype.eq = function eq(p2) {
      if (p2.type === "affine")
        return this.eq(p2.toJ());
      if (this === p2)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p2.z.redSqr();
      if (this.x.redMul(pz2).redISub(p2.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z3 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p2.z);
      return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x3) {
      var zs2 = this.z.redSqr();
      var rx = x3.toRed(this.curve.red).redMul(zs2);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc2 = x3.clone();
      var t2 = this.curve.redN.redMul(zs2);
      for (; ; ) {
        xc2.iadd(this.curve.n);
        if (xc2.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t2);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/mont.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var inherits2 = require_inherits_browser();
    var Base = require_base2();
    var utils = require_utils4();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits2(MontCurve, Base);
    module2.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x3 = point.normalize().x;
      var x22 = x3.redSqr();
      var rhs = x22.redMul(x3).redAdd(x22.redMul(this.a)).redAdd(x3);
      var y2 = rhs.redSqrt();
      return y2.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x3, z3) {
      Base.BasePoint.call(this, curve, "projective");
      if (x3 === null && z3 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x3, 16);
        this.z = new BN(z3, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits2(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x3, z3) {
      return new Point(this, x3, z3);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a2 = this.x.redAdd(this.z);
      var aa2 = a2.redSqr();
      var b2 = this.x.redSub(this.z);
      var bb = b2.redSqr();
      var c2 = aa2.redSub(bb);
      var nx = aa2.redMul(bb);
      var nz = c2.redMul(bb.redAdd(this.curve.a24.redMul(c2)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p2, diff) {
      var a2 = this.x.redAdd(this.z);
      var b2 = this.x.redSub(this.z);
      var c2 = p2.x.redAdd(p2.z);
      var d2 = p2.x.redSub(p2.z);
      var da2 = d2.redMul(a2);
      var cb = c2.redMul(b2);
      var nx = diff.z.redMul(da2.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da2.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k2) {
      var t2 = k2.clone();
      var a2 = this;
      var b2 = this.curve.point(null, null);
      var c2 = this;
      for (var bits = []; t2.cmpn(0) !== 0; t2.iushrn(1))
        bits.push(t2.andln(1));
      for (var i2 = bits.length - 1; i2 >= 0; i2--) {
        if (bits[i2] === 0) {
          a2 = a2.diffAdd(b2, c2);
          b2 = b2.dbl();
        } else {
          b2 = a2.diffAdd(b2, c2);
          a2 = a2.dbl();
        }
      }
      return b2;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var BN = require_bn();
    var inherits2 = require_inherits_browser();
    var Base = require_base2();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits2(EdwardsCurve, Base);
    module2.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x3, y2, z3, t2) {
      return this.point(x3, y2, z3, t2);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x3, odd) {
      x3 = new BN(x3, 16);
      if (!x3.red)
        x3 = x3.toRed(this.red);
      var x22 = x3.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y2 = rhs.redMul(lhs.redInvm());
      var y3 = y2.redSqrt();
      if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y3.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y3 = y3.redNeg();
      return this.point(x3, y3);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y2, odd) {
      y2 = new BN(y2, 16);
      if (!y2.red)
        y2 = y2.toRed(this.red);
      var y22 = y2.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y2);
      }
      var x3 = x22.redSqrt();
      if (x3.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x3.fromRed().isOdd() !== odd)
        x3 = x3.redNeg();
      return this.point(x3, y2);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x22 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x3, y2, z3, t2) {
      Base.BasePoint.call(this, curve, "projective");
      if (x3 === null && y2 === null && z3 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x3, 16);
        this.y = new BN(y2, 16);
        this.z = z3 ? new BN(z3, 16) : this.curve.one;
        this.t = t2 && new BN(t2, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits2(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x3, y2, z3, t2) {
      return new Point(this, x3, y2, z3, t2);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a2 = this.x.redSqr();
      var b2 = this.y.redSqr();
      var c2 = this.z.redSqr();
      c2 = c2.redIAdd(c2);
      var d2 = this.curve._mulA(a2);
      var e2 = this.x.redAdd(this.y).redSqr().redISub(a2).redISub(b2);
      var g2 = d2.redAdd(b2);
      var f2 = g2.redSub(c2);
      var h2 = d2.redSub(b2);
      var nx = e2.redMul(f2);
      var ny2 = g2.redMul(h2);
      var nt2 = e2.redMul(h2);
      var nz = f2.redMul(g2);
      return this.curve.point(nx, ny2, nz, nt2);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b2 = this.x.redAdd(this.y).redSqr();
      var c2 = this.x.redSqr();
      var d2 = this.y.redSqr();
      var nx;
      var ny2;
      var nz;
      var e2;
      var h2;
      var j2;
      if (this.curve.twisted) {
        e2 = this.curve._mulA(c2);
        var f2 = e2.redAdd(d2);
        if (this.zOne) {
          nx = b2.redSub(c2).redSub(d2).redMul(f2.redSub(this.curve.two));
          ny2 = f2.redMul(e2.redSub(d2));
          nz = f2.redSqr().redSub(f2).redSub(f2);
        } else {
          h2 = this.z.redSqr();
          j2 = f2.redSub(h2).redISub(h2);
          nx = b2.redSub(c2).redISub(d2).redMul(j2);
          ny2 = f2.redMul(e2.redSub(d2));
          nz = f2.redMul(j2);
        }
      } else {
        e2 = c2.redAdd(d2);
        h2 = this.curve._mulC(this.z).redSqr();
        j2 = e2.redSub(h2).redSub(h2);
        nx = this.curve._mulC(b2.redISub(e2)).redMul(j2);
        ny2 = this.curve._mulC(e2).redMul(c2.redISub(d2));
        nz = e2.redMul(j2);
      }
      return this.curve.point(nx, ny2, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p2) {
      var a2 = this.y.redSub(this.x).redMul(p2.y.redSub(p2.x));
      var b2 = this.y.redAdd(this.x).redMul(p2.y.redAdd(p2.x));
      var c2 = this.t.redMul(this.curve.dd).redMul(p2.t);
      var d2 = this.z.redMul(p2.z.redAdd(p2.z));
      var e2 = b2.redSub(a2);
      var f2 = d2.redSub(c2);
      var g2 = d2.redAdd(c2);
      var h2 = b2.redAdd(a2);
      var nx = e2.redMul(f2);
      var ny2 = g2.redMul(h2);
      var nt2 = e2.redMul(h2);
      var nz = f2.redMul(g2);
      return this.curve.point(nx, ny2, nz, nt2);
    };
    Point.prototype._projAdd = function _projAdd(p2) {
      var a2 = this.z.redMul(p2.z);
      var b2 = a2.redSqr();
      var c2 = this.x.redMul(p2.x);
      var d2 = this.y.redMul(p2.y);
      var e2 = this.curve.d.redMul(c2).redMul(d2);
      var f2 = b2.redSub(e2);
      var g2 = b2.redAdd(e2);
      var tmp = this.x.redAdd(this.y).redMul(p2.x.redAdd(p2.y)).redISub(c2).redISub(d2);
      var nx = a2.redMul(f2).redMul(tmp);
      var ny2;
      var nz;
      if (this.curve.twisted) {
        ny2 = a2.redMul(g2).redMul(d2.redSub(this.curve._mulA(c2)));
        nz = f2.redMul(g2);
      } else {
        ny2 = a2.redMul(g2).redMul(d2.redSub(c2));
        nz = this.curve._mulC(f2).redMul(g2);
      }
      return this.curve.point(nx, ny2, nz);
    };
    Point.prototype.add = function add(p2) {
      if (this.isInfinity())
        return p2;
      if (p2.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p2);
      else
        return this._projAdd(p2);
    };
    Point.prototype.mul = function mul(k2) {
      if (this._hasDoubles(k2))
        return this.curve._fixedNafMul(this, k2);
      else
        return this.curve._wnafMul(this, k2);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi2 = this.z.redInvm();
      this.x = this.x.redMul(zi2);
      this.y = this.y.redMul(zi2);
      if (this.t)
        this.t = this.t.redMul(zi2);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x3) {
      var rx = x3.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc2 = x3.clone();
      var t2 = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc2.iadd(this.curve.n);
        if (xc2.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t2);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// ../../node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curve/index.js"(exports2) {
    "use strict";
    var curve = exports2;
    curve.base = require_base2();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// ../../node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports2, module2) {
    module2.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/curves.js"(exports2) {
    "use strict";
    var curves = exports2;
    var hash3 = require_hash();
    var curve = require_curve();
    var utils = require_utils4();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name2, options) {
      Object.defineProperty(curves, name2, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name2, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash3.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash3.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash3.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e2) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash3.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// ../../node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/ec/key.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils4();
    var assert = utils.assert;
    function KeyPair(ec2, options) {
      this.ec = ec2;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module2.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec2, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec2, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign2(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature, options) {
      return this.ec.verify(msg, signature, this, void 0, options);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/ec/signature.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils4();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module2.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p2) {
      var initial = buf[p2.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      if (buf[p2.place] === 0) {
        return false;
      }
      var val = 0;
      for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p2.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i2 = 0;
      var len = buf.length - 1;
      while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len) {
        i2++;
      }
      if (i2 === 0) {
        return buf;
      }
      return buf.slice(i2);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p2 = new Position();
      if (data[p2.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p2);
      if (len === false) {
        return false;
      }
      if (len + p2.place !== data.length) {
        return false;
      }
      if (data[p2.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p2);
      if (rlen === false) {
        return false;
      }
      if ((data[p2.place] & 128) !== 0) {
        return false;
      }
      var r2 = data.slice(p2.place, rlen + p2.place);
      p2.place += rlen;
      if (data[p2.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p2);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p2.place) {
        return false;
      }
      if ((data[p2.place] & 128) !== 0) {
        return false;
      }
      var s2 = data.slice(p2.place, slen + p2.place);
      if (r2[0] === 0) {
        if (r2[1] & 128) {
          r2 = r2.slice(1);
        } else {
          return false;
        }
      }
      if (s2[0] === 0) {
        if (s2[1] & 128) {
          s2 = s2.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r2);
      this.s = new BN(s2);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r2 = this.r.toArray();
      var s2 = this.s.toArray();
      if (r2[0] & 128)
        r2 = [0].concat(r2);
      if (s2[0] & 128)
        s2 = [0].concat(s2);
      r2 = rmPadding(r2);
      s2 = rmPadding(s2);
      while (!s2[0] && !(s2[1] & 128)) {
        s2 = s2.slice(1);
      }
      var arr = [2];
      constructLength(arr, r2.length);
      arr = arr.concat(r2);
      arr.push(2);
      constructLength(arr, s2.length);
      var backHalf = arr.concat(s2);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/ec/index.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils4();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module2.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
      var byteLength;
      if (BN.isBN(msg) || typeof msg === "number") {
        msg = new BN(msg, 16);
        byteLength = msg.byteLength();
      } else if (typeof msg === "object") {
        byteLength = msg.length;
        msg = new BN(msg, 16);
      } else {
        var str = msg.toString();
        byteLength = str.length + 1 >>> 1;
        msg = new BN(str, 16);
      }
      if (typeof bitLength !== "number") {
        bitLength = byteLength * 8;
      }
      var delta = bitLength - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
        assert(
          typeof msg === "object" && msg && typeof msg.length === "number",
          "Expected message to be an array-like, a hex string, or a BN instance"
        );
        assert(msg.length >>> 0 === msg.length);
        for (var i2 = 0; i2 < msg.length; i2++) assert((msg[i2] & 255) === msg[i2]);
      }
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(msg, false, options.msgBitLength);
      assert(!msg.isNeg(), "Can not sign a negative message");
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      assert(new BN(nonce).eq(msg), "Can not sign message");
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k2 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k2 = this._truncateToN(k2, true);
        if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
          continue;
        var kp2 = this.g.mul(k2);
        if (kp2.isInfinity())
          continue;
        var kpX = kp2.getX();
        var r2 = kpX.umod(this.n);
        if (r2.cmpn(0) === 0)
          continue;
        var s2 = k2.invm(this.n).mul(r2.mul(key.getPrivate()).iadd(msg));
        s2 = s2.umod(this.n);
        if (s2.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp2.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
        if (options.canonical && s2.cmp(this.nh) > 0) {
          s2 = this.n.sub(s2);
          recoveryParam ^= 1;
        }
        return new Signature({ r: r2, s: s2, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc, options) {
      if (!options)
        options = {};
      msg = this._truncateToN(msg, false, options.msgBitLength);
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r2 = signature.r;
      var s2 = signature.s;
      if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
        return false;
      if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
        return false;
      var sinv = s2.invm(this.n);
      var u12 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r2).umod(this.n);
      var p2;
      if (!this.curve._maxwellTrick) {
        p2 = this.g.mulAdd(u12, key.getPublic(), u2);
        if (p2.isInfinity())
          return false;
        return p2.getX().umod(this.n).cmp(r2) === 0;
      }
      p2 = this.g.jmulAdd(u12, key.getPublic(), u2);
      if (p2.isInfinity())
        return false;
      return p2.eqXToP(r2);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j2, enc) {
      assert((3 & j2) === j2, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n2 = this.n;
      var e2 = new BN(msg);
      var r2 = signature.r;
      var s2 = signature.s;
      var isYOdd = j2 & 1;
      var isSecondKey = j2 >> 1;
      if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
      else
        r2 = this.curve.pointFromX(r2, isYOdd);
      var rInv = signature.r.invm(n2);
      var s12 = n2.sub(e2).mul(rInv).umod(n2);
      var s22 = s2.mul(rInv).umod(n2);
      return this.g.mulAdd(s12, r2, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e2, signature, Q3, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i2 = 0; i2 < 4; i2++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e2, signature, i2);
        } catch (e3) {
          continue;
        }
        if (Qprime.eq(Q3))
          return i2;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash3 = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a2 = hash3.slice(0, eddsa.encodingLength);
      a2[0] &= 248;
      a2[lastIx] &= 127;
      a2[lastIx] |= 64;
      return a2;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash3() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign2(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module2.exports = KeyPair;
  }
});

// ../../node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports2, module2) {
    "use strict";
    var BN = require_bn();
    var utils = require_utils4();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S2() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R2() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module2.exports = Signature;
  }
});

// ../../node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "../../node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports2, module2) {
    "use strict";
    var hash3 = require_hash();
    var curves = require_curves();
    var utils = require_utils4();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash3.sha512;
    }
    module2.exports = EDDSA;
    EDDSA.prototype.sign = function sign2(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r2 = this.hashInt(key.messagePrefix(), message);
      var R2 = this.g.mul(r2);
      var Rencoded = this.encodePoint(R2);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S2 = r2.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R2, S: S2, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
        return false;
      }
      var key = this.keyFromPublic(pub);
      var h2 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h2));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash4 = this.hash();
      for (var i2 = 0; i2 < arguments.length; i2++)
        hash4.update(arguments[i2]);
      return utils.intFromLE(hash4.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y2 = utils.intFromLE(normed);
      return this.curve.pointFromY(y2, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// ../../node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "../../node_modules/elliptic/lib/elliptic.js"(exports2) {
    "use strict";
    var elliptic = exports2;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils4();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// ../../node_modules/secp256k1/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "../../node_modules/secp256k1/lib/elliptic.js"(exports2, module2) {
    var EC = require_elliptic().ec;
    var ec2 = new EC("secp256k1");
    var ecparams = ec2.curve;
    var BN = ecparams.n.constructor;
    function loadCompressedPublicKey(first, xbuf) {
      let x3 = new BN(xbuf);
      if (x3.cmp(ecparams.p) >= 0) return null;
      x3 = x3.toRed(ecparams.red);
      let y2 = x3.redSqr().redIMul(x3).redIAdd(ecparams.b).redSqrt();
      if (first === 3 !== y2.isOdd()) y2 = y2.redNeg();
      const x32 = x3.redSqr().redIMul(x3);
      if (!y2.redSqr().redISub(x32.redIAdd(ecparams.b)).isZero()) return null;
      return ec2.keyPair({ pub: { x: x3, y: y2 } });
    }
    function loadUncompressedPublicKey(first, xbuf, ybuf) {
      let x3 = new BN(xbuf);
      let y2 = new BN(ybuf);
      if (x3.cmp(ecparams.p) >= 0 || y2.cmp(ecparams.p) >= 0) return null;
      x3 = x3.toRed(ecparams.red);
      y2 = y2.toRed(ecparams.red);
      if ((first === 6 || first === 7) && y2.isOdd() !== (first === 7)) return null;
      const x32 = x3.redSqr().redIMul(x3);
      if (!y2.redSqr().redISub(x32.redIAdd(ecparams.b)).isZero()) return null;
      return ec2.keyPair({ pub: { x: x3, y: y2 } });
    }
    function loadPublicKey(pubkey) {
      const first = pubkey[0];
      switch (first) {
        case 2:
        case 3:
          if (pubkey.length !== 33) return null;
          return loadCompressedPublicKey(first, pubkey.subarray(1, 33));
        case 4:
        case 6:
        case 7:
          if (pubkey.length !== 65) return null;
          return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
        default:
          return null;
      }
    }
    function savePublicKey(output, point) {
      const pubkey = point.encode(null, output.length === 33);
      for (let i2 = 0; i2 < output.length; ++i2) output[i2] = pubkey[i2];
    }
    module2.exports = {
      contextRandomize() {
        return 0;
      },
      privateKeyVerify(seckey) {
        const bn2 = new BN(seckey);
        return bn2.cmp(ecparams.n) < 0 && !bn2.isZero() ? 0 : 1;
      },
      privateKeyNegate(seckey) {
        const bn2 = new BN(seckey);
        const negate = ecparams.n.sub(bn2).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
        seckey.set(negate);
        return 0;
      },
      privateKeyTweakAdd(seckey, tweak) {
        const bn2 = new BN(tweak);
        if (bn2.cmp(ecparams.n) >= 0) return 1;
        bn2.iadd(new BN(seckey));
        if (bn2.cmp(ecparams.n) >= 0) bn2.isub(ecparams.n);
        if (bn2.isZero()) return 1;
        const tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      privateKeyTweakMul(seckey, tweak) {
        let bn2 = new BN(tweak);
        if (bn2.cmp(ecparams.n) >= 0 || bn2.isZero()) return 1;
        bn2.imul(new BN(seckey));
        if (bn2.cmp(ecparams.n) >= 0) bn2 = bn2.umod(ecparams.n);
        const tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      publicKeyVerify(pubkey) {
        const pair = loadPublicKey(pubkey);
        return pair === null ? 1 : 0;
      },
      publicKeyCreate(output, seckey) {
        const bn2 = new BN(seckey);
        if (bn2.cmp(ecparams.n) >= 0 || bn2.isZero()) return 1;
        const point = ec2.keyFromPrivate(seckey).getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyConvert(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null) return 1;
        const point = pair.getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyNegate(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null) return 1;
        const point = pair.getPublic();
        point.y = point.y.redNeg();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyCombine(output, pubkeys) {
        const pairs = new Array(pubkeys.length);
        for (let i2 = 0; i2 < pubkeys.length; ++i2) {
          pairs[i2] = loadPublicKey(pubkeys[i2]);
          if (pairs[i2] === null) return 1;
        }
        let point = pairs[0].getPublic();
        for (let i2 = 1; i2 < pairs.length; ++i2) point = point.add(pairs[i2].pub);
        if (point.isInfinity()) return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakAdd(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null) return 1;
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0) return 2;
        const point = pair.getPublic().add(ecparams.g.mul(tweak));
        if (point.isInfinity()) return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakMul(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null) return 1;
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2;
        const point = pair.getPublic().mul(tweak);
        savePublicKey(output, point);
        return 0;
      },
      signatureNormalize(sig) {
        const r2 = new BN(sig.subarray(0, 32));
        const s2 = new BN(sig.subarray(32, 64));
        if (r2.cmp(ecparams.n) >= 0 || s2.cmp(ecparams.n) >= 0) return 1;
        if (s2.cmp(ec2.nh) === 1) {
          sig.set(ecparams.n.sub(s2).toArrayLike(Uint8Array, "be", 32), 32);
        }
        return 0;
      },
      // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
      // Adapted for Uint8Array instead Buffer
      signatureExport(obj, sig) {
        const sigR = sig.subarray(0, 32);
        const sigS = sig.subarray(32, 64);
        if (new BN(sigR).cmp(ecparams.n) >= 0) return 1;
        if (new BN(sigS).cmp(ecparams.n) >= 0) return 1;
        const { output } = obj;
        let r2 = output.subarray(4, 4 + 33);
        r2[0] = 0;
        r2.set(sigR, 1);
        let lenR = 33;
        let posR = 0;
        for (; lenR > 1 && r2[posR] === 0 && !(r2[posR + 1] & 128); --lenR, ++posR) ;
        r2 = r2.subarray(posR);
        if (r2[0] & 128) return 1;
        if (lenR > 1 && r2[0] === 0 && !(r2[1] & 128)) return 1;
        let s2 = output.subarray(6 + 33, 6 + 33 + 33);
        s2[0] = 0;
        s2.set(sigS, 1);
        let lenS = 33;
        let posS = 0;
        for (; lenS > 1 && s2[posS] === 0 && !(s2[posS + 1] & 128); --lenS, ++posS) ;
        s2 = s2.subarray(posS);
        if (s2[0] & 128) return 1;
        if (lenS > 1 && s2[0] === 0 && !(s2[1] & 128)) return 1;
        obj.outputlen = 6 + lenR + lenS;
        output[0] = 48;
        output[1] = obj.outputlen - 2;
        output[2] = 2;
        output[3] = r2.length;
        output.set(r2, 4);
        output[4 + lenR] = 2;
        output[5 + lenR] = s2.length;
        output.set(s2, 6 + lenR);
        return 0;
      },
      // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
      // Adapted for Uint8Array instead Buffer
      signatureImport(output, sig) {
        if (sig.length < 8) return 1;
        if (sig.length > 72) return 1;
        if (sig[0] !== 48) return 1;
        if (sig[1] !== sig.length - 2) return 1;
        if (sig[2] !== 2) return 1;
        const lenR = sig[3];
        if (lenR === 0) return 1;
        if (5 + lenR >= sig.length) return 1;
        if (sig[4 + lenR] !== 2) return 1;
        const lenS = sig[5 + lenR];
        if (lenS === 0) return 1;
        if (6 + lenR + lenS !== sig.length) return 1;
        if (sig[4] & 128) return 1;
        if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128)) return 1;
        if (sig[lenR + 6] & 128) return 1;
        if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128)) return 1;
        let sigR = sig.subarray(4, 4 + lenR);
        if (sigR.length === 33 && sigR[0] === 0) sigR = sigR.subarray(1);
        if (sigR.length > 32) return 1;
        let sigS = sig.subarray(6 + lenR);
        if (sigS.length === 33 && sigS[0] === 0) sigS = sigS.slice(1);
        if (sigS.length > 32) throw new Error("S length is too long");
        let r2 = new BN(sigR);
        if (r2.cmp(ecparams.n) >= 0) r2 = new BN(0);
        let s2 = new BN(sig.subarray(6 + lenR));
        if (s2.cmp(ecparams.n) >= 0) s2 = new BN(0);
        output.set(r2.toArrayLike(Uint8Array, "be", 32), 0);
        output.set(s2.toArrayLike(Uint8Array, "be", 32), 32);
        return 0;
      },
      ecdsaSign(obj, message, seckey, data, noncefn) {
        if (noncefn) {
          const _noncefn = noncefn;
          noncefn = (counter) => {
            const nonce = _noncefn(message, seckey, null, data, counter);
            const isValid = nonce instanceof Uint8Array && nonce.length === 32;
            if (!isValid) throw new Error("This is the way");
            return new BN(nonce);
          };
        }
        const d2 = new BN(seckey);
        if (d2.cmp(ecparams.n) >= 0 || d2.isZero()) return 1;
        let sig;
        try {
          sig = ec2.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
        } catch (err) {
          return 1;
        }
        obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
        obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
        obj.recid = sig.recoveryParam;
        return 0;
      },
      ecdsaVerify(sig, msg32, pubkey) {
        const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
        const sigr = new BN(sigObj.r);
        const sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
        if (sigs.cmp(ec2.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3;
        const pair = loadPublicKey(pubkey);
        if (pair === null) return 2;
        const point = pair.getPublic();
        const isValid = ec2.verify(msg32, sigObj, point);
        return isValid ? 0 : 3;
      },
      ecdsaRecover(output, sig, recid, msg32) {
        const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
        const sigr = new BN(sigObj.r);
        const sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
        if (sigr.isZero() || sigs.isZero()) return 2;
        let point;
        try {
          point = ec2.recoverPubKey(msg32, sigObj, recid);
        } catch (err) {
          return 2;
        }
        savePublicKey(output, point);
        return 0;
      },
      ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
        const pair = loadPublicKey(pubkey);
        if (pair === null) return 1;
        const scalar = new BN(seckey);
        if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2;
        const point = pair.getPublic().mul(scalar);
        if (hashfn === void 0) {
          const data2 = point.encode(null, true);
          const sha2563 = ec2.hash().update(data2).digest();
          for (let i2 = 0; i2 < 32; ++i2) output[i2] = sha2563[i2];
        } else {
          if (!xbuf) xbuf = new Uint8Array(32);
          const x3 = point.getX().toArray("be", 32);
          for (let i2 = 0; i2 < 32; ++i2) xbuf[i2] = x3[i2];
          if (!ybuf) ybuf = new Uint8Array(32);
          const y2 = point.getY().toArray("be", 32);
          for (let i2 = 0; i2 < 32; ++i2) ybuf[i2] = y2[i2];
          const hash3 = hashfn(xbuf, ybuf, data);
          const isValid = hash3 instanceof Uint8Array && hash3.length === output.length;
          if (!isValid) return 2;
          output.set(hash3);
        }
        return 0;
      }
    };
  }
});

// ../../node_modules/secp256k1/elliptic.js
var require_elliptic3 = __commonJS({
  "../../node_modules/secp256k1/elliptic.js"(exports2, module2) {
    module2.exports = require_lib()(require_elliptic2());
  }
});

// ../../node_modules/libp2p-crypto/src/keys/secp256k1.js
var require_secp256k12 = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/secp256k1.js"(exports2, module2) {
    "use strict";
    var secp256k1 = require_elliptic3();
    var { sha256: sha2563 } = (init_sha2_browser(), __toCommonJS(sha2_browser_exports));
    module2.exports = (randomBytes2) => {
      const privateKeyLength = 32;
      function generateKey() {
        let privateKey;
        do {
          privateKey = randomBytes2(32);
        } while (!secp256k1.privateKeyVerify(privateKey));
        return privateKey;
      }
      async function hashAndSign(key, msg) {
        const { digest: digest2 } = await sha2563.digest(msg);
        const sig = secp256k1.ecdsaSign(digest2, key);
        return secp256k1.signatureExport(sig.signature);
      }
      async function hashAndVerify(key, sig, msg) {
        const { digest: digest2 } = await sha2563.digest(msg);
        sig = secp256k1.signatureImport(sig);
        return secp256k1.ecdsaVerify(sig, digest2, key);
      }
      function compressPublicKey(key) {
        if (!secp256k1.publicKeyVerify(key)) {
          throw new Error("Invalid public key");
        }
        return secp256k1.publicKeyConvert(key, true);
      }
      function decompressPublicKey(key) {
        return secp256k1.publicKeyConvert(key, false);
      }
      function validatePrivateKey(key) {
        if (!secp256k1.privateKeyVerify(key)) {
          throw new Error("Invalid private key");
        }
      }
      function validatePublicKey(key) {
        if (!secp256k1.publicKeyVerify(key)) {
          throw new Error("Invalid public key");
        }
      }
      function computePublicKey(privateKey) {
        validatePrivateKey(privateKey);
        return secp256k1.publicKeyCreate(privateKey);
      }
      return {
        generateKey,
        privateKeyLength,
        hashAndSign,
        hashAndVerify,
        compressPublicKey,
        decompressPublicKey,
        validatePrivateKey,
        validatePublicKey,
        computePublicKey
      };
    };
  }
});

// ../../node_modules/libp2p-crypto/src/keys/secp256k1-class.js
var require_secp256k1_class = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/secp256k1-class.js"(exports2, module2) {
    "use strict";
    var { sha256: sha2563 } = (init_sha2_browser(), __toCommonJS(sha2_browser_exports));
    var errcode = require_err_code();
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var exporter = require_exporter();
    module2.exports = (keysProtobuf, randomBytes2, crypto2) => {
      crypto2 = crypto2 || require_secp256k12()(randomBytes2);
      class Secp256k1PublicKey {
        constructor(key) {
          crypto2.validatePublicKey(key);
          this._key = key;
        }
        verify(data, sig) {
          return crypto2.hashAndVerify(this._key, sig, data);
        }
        marshal() {
          return crypto2.compressPublicKey(this._key);
        }
        get bytes() {
          return keysProtobuf.PublicKey.encode({
            Type: keysProtobuf.KeyType.Secp256k1,
            Data: this.marshal()
          }).finish();
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes } = await sha2563.digest(this.bytes);
          return bytes;
        }
      }
      class Secp256k1PrivateKey {
        constructor(key, publicKey) {
          this._key = key;
          this._publicKey = publicKey || crypto2.computePublicKey(key);
          crypto2.validatePrivateKey(this._key);
          crypto2.validatePublicKey(this._publicKey);
        }
        sign(message) {
          return crypto2.hashAndSign(this._key, message);
        }
        get public() {
          return new Secp256k1PublicKey(this._publicKey);
        }
        marshal() {
          return this._key;
        }
        get bytes() {
          return keysProtobuf.PrivateKey.encode({
            Type: keysProtobuf.KeyType.Secp256k1,
            Data: this.marshal()
          }).finish();
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes } = await sha2563.digest(this.bytes);
          return bytes;
        }
        /**
         * Gets the ID of the key.
         *
         * The key id is the base58 encoding of the SHA-256 multihash of its public key.
         * The public key is a protobuf encoding containing a type and the DER encoding
         * of the PKCS SubjectPublicKeyInfo.
         *
         * @returns {Promise<string>}
         */
        async id() {
          const hash3 = await this.public.hash();
          return uint8ArrayToString(hash3, "base58btc");
        }
        /**
         * Exports the key into a password protected `format`
         *
         * @param {string} password - The password to encrypt the key
         * @param {string} [format=libp2p-key] - The format in which to export as
         * @returns {Promise<string>} The encrypted private key
         */
        async export(password, format = "libp2p-key") {
          if (format === "libp2p-key") {
            return exporter.export(this.bytes, password);
          } else {
            throw errcode(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
          }
        }
      }
      function unmarshalSecp256k1PrivateKey(bytes) {
        return new Secp256k1PrivateKey(bytes);
      }
      function unmarshalSecp256k1PublicKey(bytes) {
        return new Secp256k1PublicKey(bytes);
      }
      async function generateKeyPair4() {
        const privateKeyBytes = await crypto2.generateKey();
        return new Secp256k1PrivateKey(privateKeyBytes);
      }
      return {
        Secp256k1PublicKey,
        Secp256k1PrivateKey,
        unmarshalSecp256k1PrivateKey,
        unmarshalSecp256k1PublicKey,
        generateKeyPair: generateKeyPair4
      };
    };
  }
});

// ../../node_modules/libp2p-crypto/src/keys/key-stretcher.js
var require_key_stretcher = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/key-stretcher.js"(exports2, module2) {
    "use strict";
    var errcode = require_err_code();
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var hmac = require_index_browser();
    var cipherMap = {
      "AES-128": {
        ivSize: 16,
        keySize: 16
      },
      "AES-256": {
        ivSize: 16,
        keySize: 32
      },
      Blowfish: {
        ivSize: 8,
        cipherKeySize: 32
      }
    };
    module2.exports = async (cipherType, hash3, secret) => {
      const cipher = cipherMap[cipherType];
      if (!cipher) {
        const allowed = Object.keys(cipherMap).join(" / ");
        throw errcode(new Error(`unknown cipher type '${cipherType}'. Must be ${allowed}`), "ERR_INVALID_CIPHER_TYPE");
      }
      if (!hash3) {
        throw errcode(new Error("missing hash type"), "ERR_MISSING_HASH_TYPE");
      }
      const cipherKeySize = cipher.keySize;
      const ivSize = cipher.ivSize;
      const hmacKeySize = 20;
      const seed = uint8ArrayFromString("key expansion");
      const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
      const m2 = await hmac.create(hash3, secret);
      let a2 = await m2.digest(seed);
      const result = [];
      let j2 = 0;
      while (j2 < resultLength) {
        const b2 = await m2.digest(uint8ArrayConcat([a2, seed]));
        let todo = b2.length;
        if (j2 + todo > resultLength) {
          todo = resultLength - j2;
        }
        result.push(b2);
        j2 += todo;
        a2 = await m2.digest(a2);
      }
      const half = resultLength / 2;
      const resultBuffer = uint8ArrayConcat(result);
      const r12 = resultBuffer.slice(0, half);
      const r2 = resultBuffer.slice(half, resultLength);
      const createKey = (res) => ({
        iv: res.slice(0, ivSize),
        cipherKey: res.slice(ivSize, ivSize + cipherKeySize),
        macKey: res.slice(ivSize + cipherKeySize)
      });
      return {
        k1: createKey(r12),
        k2: createKey(r2)
      };
    };
  }
});

// ../../node_modules/libp2p-crypto/src/keys/validate-curve-type.js
var require_validate_curve_type = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/validate-curve-type.js"(exports2, module2) {
    "use strict";
    var errcode = require_err_code();
    module2.exports = function(curveTypes, type) {
      if (!curveTypes.includes(type)) {
        const names = curveTypes.join(" / ");
        throw errcode(new Error(`Unknown curve: ${type}. Must be ${names}`), "ERR_INVALID_CURVE");
      }
    };
  }
});

// ../../node_modules/libp2p-crypto/src/keys/ecdh-browser.js
var require_ecdh_browser = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/ecdh-browser.js"(exports2) {
    "use strict";
    var errcode = require_err_code();
    var webcrypto = require_webcrypto();
    var { base64urlToBuffer } = require_util3();
    var validateCurveType = require_validate_curve_type();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var bits = {
      "P-256": 256,
      "P-384": 384,
      "P-521": 521
    };
    exports2.generateEphmeralKeyPair = async function(curve) {
      validateCurveType(Object.keys(bits), curve);
      const pair = await webcrypto.get().subtle.generateKey(
        {
          name: "ECDH",
          namedCurve: curve
        },
        true,
        ["deriveBits"]
      );
      const genSharedKey = async (theirPub, forcePrivate) => {
        let privateKey;
        if (forcePrivate) {
          privateKey = await webcrypto.get().subtle.importKey(
            "jwk",
            unmarshalPrivateKey(curve, forcePrivate),
            {
              name: "ECDH",
              namedCurve: curve
            },
            false,
            ["deriveBits"]
          );
        } else {
          privateKey = pair.privateKey;
        }
        const keys = [
          await webcrypto.get().subtle.importKey(
            "jwk",
            unmarshalPublicKey(curve, theirPub),
            {
              name: "ECDH",
              namedCurve: curve
            },
            false,
            []
          ),
          privateKey
        ];
        const buffer = await webcrypto.get().subtle.deriveBits(
          {
            name: "ECDH",
            namedCurve: curve,
            public: keys[0]
          },
          keys[1],
          bits[curve]
        );
        return new Uint8Array(buffer, buffer.byteOffset, buffer.byteLength);
      };
      const publicKey = await webcrypto.get().subtle.exportKey("jwk", pair.publicKey);
      return {
        key: marshalPublicKey(publicKey),
        genSharedKey
      };
    };
    var curveLengths = {
      "P-256": 32,
      "P-384": 48,
      "P-521": 66
    };
    function marshalPublicKey(jwk) {
      const byteLen = curveLengths[jwk.crv];
      return uint8ArrayConcat([
        Uint8Array.from([4]),
        // uncompressed point
        base64urlToBuffer(jwk.x, byteLen),
        base64urlToBuffer(jwk.y, byteLen)
      ], 1 + byteLen * 2);
    }
    function unmarshalPublicKey(curve, key) {
      const byteLen = curveLengths[curve];
      if (uint8ArrayEquals(!key.slice(0, 1), Uint8Array.from([4]))) {
        throw errcode(new Error("Cannot unmarshal public key - invalid key format"), "ERR_INVALID_KEY_FORMAT");
      }
      return {
        kty: "EC",
        crv: curve,
        x: uint8ArrayToString(key.slice(1, byteLen + 1), "base64url"),
        y: uint8ArrayToString(key.slice(1 + byteLen), "base64url"),
        ext: true
      };
    }
    var unmarshalPrivateKey = (curve, key) => ({
      ...unmarshalPublicKey(curve, key.public),
      d: uint8ArrayToString(key.private, "base64url")
    });
  }
});

// ../../node_modules/libp2p-crypto/src/keys/ephemeral-keys.js
var require_ephemeral_keys = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/ephemeral-keys.js"(exports2, module2) {
    "use strict";
    var ecdh = require_ecdh_browser();
    module2.exports = async (curve) => ecdh.generateEphmeralKeyPair(curve);
  }
});

// ../../node_modules/libp2p-crypto/src/keys/index.js
var require_keys3 = __commonJS({
  "../../node_modules/libp2p-crypto/src/keys/index.js"(exports2, module2) {
    "use strict";
    var keysPBM = require_keys2();
    require_asn13();
    require_pbe();
    var forge = require_forge2();
    var errcode = require_err_code();
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var importer = require_importer();
    var supportedKeys = {
      rsa: require_rsa_class(),
      ed25519: require_ed25519_class(),
      secp256k1: require_secp256k1_class()(keysPBM, require_random_bytes())
    };
    var ErrMissingSecp256K1 = {
      message: "secp256k1 support requires libp2p-crypto-secp256k1 package",
      code: "ERR_MISSING_PACKAGE"
    };
    function typeToKey(type) {
      const key = supportedKeys[type.toLowerCase()];
      if (!key) {
        const supported = Object.keys(supportedKeys).join(" / ");
        throw errcode(new Error(`invalid or unsupported key type ${type}. Must be ${supported}`), "ERR_UNSUPPORTED_KEY_TYPE");
      }
      return key;
    }
    var generateKeyPair4 = async (type, bits) => {
      return typeToKey(type).generateKeyPair(bits);
    };
    var generateKeyPairFromSeed = async (type, seed, bits) => {
      const key = typeToKey(type);
      if (type.toLowerCase() !== "ed25519") {
        throw errcode(new Error("Seed key derivation is unimplemented for RSA or secp256k1"), "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
      }
      return key.generateKeyPairFromSeed(seed, bits);
    };
    var unmarshalPublicKey = (buf) => {
      const decoded = keysPBM.PublicKey.decode(buf);
      const data = decoded.Data;
      switch (decoded.Type) {
        case keysPBM.KeyType.RSA:
          return supportedKeys.rsa.unmarshalRsaPublicKey(data);
        case keysPBM.KeyType.Ed25519:
          return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
        case keysPBM.KeyType.Secp256k1:
          if (supportedKeys.secp256k1) {
            return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
          } else {
            throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
          }
        default:
          typeToKey(decoded.Type);
      }
    };
    var marshalPublicKey = (key, type) => {
      type = (type || "rsa").toLowerCase();
      typeToKey(type);
      return key.bytes;
    };
    var unmarshalPrivateKey = async (buf) => {
      const decoded = keysPBM.PrivateKey.decode(buf);
      const data = decoded.Data;
      switch (decoded.Type) {
        case keysPBM.KeyType.RSA:
          return supportedKeys.rsa.unmarshalRsaPrivateKey(data);
        case keysPBM.KeyType.Ed25519:
          return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
        case keysPBM.KeyType.Secp256k1:
          if (supportedKeys.secp256k1) {
            return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
          } else {
            throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
          }
        default:
          typeToKey(decoded.Type);
      }
    };
    var marshalPrivateKey = (key, type) => {
      type = (type || "rsa").toLowerCase();
      typeToKey(type);
      return key.bytes;
    };
    var importKey = async (encryptedKey, password) => {
      try {
        const key2 = await importer.import(encryptedKey, password);
        return unmarshalPrivateKey(key2);
      } catch (_3) {
      }
      const key = forge.pki.decryptRsaPrivateKey(encryptedKey, password);
      if (key === null) {
        throw errcode(new Error("Cannot read the key, most likely the password is wrong or not a RSA key"), "ERR_CANNOT_DECRYPT_PEM");
      }
      let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));
      der = uint8ArrayFromString(der.getBytes(), "ascii");
      return supportedKeys.rsa.unmarshalRsaPrivateKey(der);
    };
    module2.exports = {
      supportedKeys,
      keysPBM,
      keyStretcher: require_key_stretcher(),
      generateEphemeralKeyPair: require_ephemeral_keys(),
      generateKeyPair: generateKeyPair4,
      generateKeyPairFromSeed,
      unmarshalPublicKey,
      marshalPublicKey,
      unmarshalPrivateKey,
      marshalPrivateKey,
      import: importKey
    };
  }
});

// ../../node_modules/libp2p-crypto/src/pbkdf2.js
var require_pbkdf24 = __commonJS({
  "../../node_modules/libp2p-crypto/src/pbkdf2.js"(exports2, module2) {
    "use strict";
    var forgePbkdf2 = require_pbkdf23();
    var forgeUtil = require_util2();
    var errcode = require_err_code();
    var hashName = {
      sha1: "sha1",
      "sha2-256": "sha256",
      "sha2-512": "sha512"
    };
    function pbkdf22(password, salt, iterations, keySize, hash3) {
      const hasher = hashName[hash3];
      if (!hasher) {
        const types = Object.keys(hashName).join(" / ");
        throw errcode(new Error(`Hash '${hash3}' is unknown or not supported. Must be ${types}`), "ERR_UNSUPPORTED_HASH_TYPE");
      }
      const dek = forgePbkdf2(
        password,
        salt,
        iterations,
        keySize,
        hasher
      );
      return forgeUtil.encode64(dek);
    }
    module2.exports = pbkdf22;
  }
});

// ../../node_modules/libp2p-crypto/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/libp2p-crypto/src/index.js"(exports2) {
    "use strict";
    var hmac = require_index_browser();
    var aes2 = require_aes3();
    var keys = require_keys3();
    exports2.aes = aes2;
    exports2.hmac = hmac;
    exports2.keys = keys;
    exports2.randomBytes = require_random_bytes();
    exports2.pbkdf2 = require_pbkdf24();
  }
});

// ../../node_modules/arweave-mnemonic-keys/dist/arweaveMnemonicKeys.js
var require_arweaveMnemonicKeys = __commonJS({
  "../../node_modules/arweave-mnemonic-keys/dist/arweaveMnemonicKeys.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKeyFromMnemonic = exports2.generateMnemonic = void 0;
    var human_crypto_keys_1 = (init_es3(), __toCommonJS(es_exports));
    var libp2p_crypto_1 = __importDefault(require_src2());
    function generateMnemonic3() {
      return __awaiter(this, void 0, void 0, function* () {
        let keys = yield human_crypto_keys_1.generateKeyPair({ id: "rsa", modulusLength: 4096 }, { privateKeyFormat: "pkcs1-pem" });
        return keys.mnemonic;
      });
    }
    exports2.generateMnemonic = generateMnemonic3;
    function getKeyFromMnemonic2(mnemonic) {
      return __awaiter(this, void 0, void 0, function* () {
        let keyPair = yield human_crypto_keys_1.getKeyPairFromMnemonic(mnemonic, { id: "rsa", modulusLength: 4096 }, { privateKeyFormat: "pkcs1-pem" });
        let privateKey = (yield libp2p_crypto_1.default.keys.import(keyPair.privateKey, ""))._key;
        delete privateKey.alg;
        delete privateKey.key_ops;
        return privateKey;
      });
    }
    exports2.getKeyFromMnemonic = getKeyFromMnemonic2;
  }
});

// ../../node_modules/arweave-mnemonic-keys/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/arweave-mnemonic-keys/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m2, exports3) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2)) __createBinding(exports3, m2, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_arweaveMnemonicKeys(), exports2);
  }
});

// ../../node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "../../node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P3 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: " ",
          // non-breaking space
          suffix: ""
        }, ALPHABET2 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v3, b2) {
          var alphabet2, c2, caseChanged, e2, i2, isNum, len, str, x3 = this;
          if (!(x3 instanceof BigNumber2)) return new BigNumber2(v3, b2);
          if (b2 == null) {
            if (v3 && v3._isBigNumber === true) {
              x3.s = v3.s;
              if (!v3.c || v3.e > MAX_EXP) {
                x3.c = x3.e = null;
              } else if (v3.e < MIN_EXP) {
                x3.c = [x3.e = 0];
              } else {
                x3.e = v3.e;
                x3.c = v3.c.slice();
              }
              return;
            }
            if ((isNum = typeof v3 == "number") && v3 * 0 == 0) {
              x3.s = 1 / v3 < 0 ? (v3 = -v3, -1) : 1;
              if (v3 === ~~v3) {
                for (e2 = 0, i2 = v3; i2 >= 10; i2 /= 10, e2++) ;
                if (e2 > MAX_EXP) {
                  x3.c = x3.e = null;
                } else {
                  x3.e = e2;
                  x3.c = [v3];
                }
                return;
              }
              str = String(v3);
            } else {
              if (!isNumeric.test(str = String(v3))) return parseNumeric(x3, str, isNum);
              x3.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i2 = str.search(/e/i)) > 0) {
              if (e2 < 0) e2 = i2;
              e2 += +str.slice(i2 + 1);
              str = str.substring(0, i2);
            } else if (e2 < 0) {
              e2 = str.length;
            }
          } else {
            intCheck(b2, 2, ALPHABET2.length, "Base");
            if (b2 == 10 && alphabetHasNormalDecimalDigits) {
              x3 = new BigNumber2(v3);
              return round(x3, DECIMAL_PLACES + x3.e + 1, ROUNDING_MODE);
            }
            str = String(v3);
            if (isNum = typeof v3 == "number") {
              if (v3 * 0 != 0) return parseNumeric(x3, str, isNum, b2);
              x3.s = 1 / v3 < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v3);
              }
            } else {
              x3.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet2 = ALPHABET2.slice(0, b2);
            e2 = i2 = 0;
            for (len = str.length; i2 < len; i2++) {
              if (alphabet2.indexOf(c2 = str.charAt(i2)) < 0) {
                if (c2 == ".") {
                  if (i2 > e2) {
                    e2 = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i2 = -1;
                    e2 = 0;
                    continue;
                  }
                }
                return parseNumeric(x3, String(v3), isNum, b2);
              }
            }
            isNum = false;
            str = convertBase(str, b2, 10, x3.s);
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e2 = str.length;
          }
          for (i2 = 0; str.charCodeAt(i2) === 48; i2++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i2, ++len)) {
            len -= i2;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v3 > MAX_SAFE_INTEGER || v3 !== mathfloor(v3))) {
              throw Error(tooManyDigits + x3.s * v3);
            }
            if ((e2 = e2 - i2 - 1) > MAX_EXP) {
              x3.c = x3.e = null;
            } else if (e2 < MIN_EXP) {
              x3.c = [x3.e = 0];
            } else {
              x3.e = e2;
              x3.c = [];
              i2 = (e2 + 1) % LOG_BASE;
              if (e2 < 0) i2 += LOG_BASE;
              if (i2 < len) {
                if (i2) x3.c.push(+str.slice(0, i2));
                for (len -= LOG_BASE; i2 < len; ) {
                  x3.c.push(+str.slice(i2, i2 += LOG_BASE));
                }
                i2 = LOG_BASE - (str = str.slice(i2)).length;
              } else {
                i2 -= len;
              }
              for (; i2--; str += "0") ;
              x3.c.push(+str);
            }
          } else {
            x3.c = [x3.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p2, v3;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
                v3 = obj[p2];
                intCheck(v3, 0, MAX, p2);
                DECIMAL_PLACES = v3;
              }
              if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
                v3 = obj[p2];
                intCheck(v3, 0, 8, p2);
                ROUNDING_MODE = v3;
              }
              if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
                v3 = obj[p2];
                if (v3 && v3.pop) {
                  intCheck(v3[0], -MAX, 0, p2);
                  intCheck(v3[1], 0, MAX, p2);
                  TO_EXP_NEG = v3[0];
                  TO_EXP_POS = v3[1];
                } else {
                  intCheck(v3, -MAX, MAX, p2);
                  TO_EXP_NEG = -(TO_EXP_POS = v3 < 0 ? -v3 : v3);
                }
              }
              if (obj.hasOwnProperty(p2 = "RANGE")) {
                v3 = obj[p2];
                if (v3 && v3.pop) {
                  intCheck(v3[0], -MAX, -1, p2);
                  intCheck(v3[1], 1, MAX, p2);
                  MIN_EXP = v3[0];
                  MAX_EXP = v3[1];
                } else {
                  intCheck(v3, -MAX, MAX, p2);
                  if (v3) {
                    MIN_EXP = -(MAX_EXP = v3 < 0 ? -v3 : v3);
                  } else {
                    throw Error(bignumberError + p2 + " cannot be zero: " + v3);
                  }
                }
              }
              if (obj.hasOwnProperty(p2 = "CRYPTO")) {
                v3 = obj[p2];
                if (v3 === !!v3) {
                  if (v3) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v3;
                    } else {
                      CRYPTO = !v3;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v3;
                  }
                } else {
                  throw Error(bignumberError + p2 + " not true or false: " + v3);
                }
              }
              if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
                v3 = obj[p2];
                intCheck(v3, 0, 9, p2);
                MODULO_MODE = v3;
              }
              if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
                v3 = obj[p2];
                intCheck(v3, 0, MAX, p2);
                POW_PRECISION = v3;
              }
              if (obj.hasOwnProperty(p2 = "FORMAT")) {
                v3 = obj[p2];
                if (typeof v3 == "object") FORMAT = v3;
                else throw Error(bignumberError + p2 + " not an object: " + v3);
              }
              if (obj.hasOwnProperty(p2 = "ALPHABET")) {
                v3 = obj[p2];
                if (typeof v3 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v3)) {
                  alphabetHasNormalDecimalDigits = v3.slice(0, 10) == "0123456789";
                  ALPHABET2 = v3;
                } else {
                  throw Error(bignumberError + p2 + " invalid: " + v3);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET: ALPHABET2
          };
        };
        BigNumber2.isBigNumber = function(v3) {
          if (!v3 || v3._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i2, n2, c2 = v3.c, e2 = v3.e, s2 = v3.s;
          out: if ({}.toString.call(c2) == "[object Array]") {
            if ((s2 === 1 || s2 === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
              if (c2[0] === 0) {
                if (e2 === 0 && c2.length === 1) return true;
                break out;
              }
              i2 = (e2 + 1) % LOG_BASE;
              if (i2 < 1) i2 += LOG_BASE;
              if (String(c2[0]).length == i2) {
                for (i2 = 0; i2 < c2.length; i2++) {
                  n2 = c2[i2];
                  if (n2 < 0 || n2 >= BASE || n2 !== mathfloor(n2)) break out;
                }
                if (n2 !== 0) return true;
              }
            }
          } else if (c2 === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v3);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp2) {
            var a2, b2, e2, k2, v3, i2 = 0, c2 = [], rand = new BigNumber2(ONE);
            if (dp2 == null) dp2 = DECIMAL_PLACES;
            else intCheck(dp2, 0, MAX);
            k2 = mathceil(dp2 / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a2 = crypto.getRandomValues(new Uint32Array(k2 *= 2));
                for (; i2 < k2; ) {
                  v3 = a2[i2] * 131072 + (a2[i2 + 1] >>> 11);
                  if (v3 >= 9e15) {
                    b2 = crypto.getRandomValues(new Uint32Array(2));
                    a2[i2] = b2[0];
                    a2[i2 + 1] = b2[1];
                  } else {
                    c2.push(v3 % 1e14);
                    i2 += 2;
                  }
                }
                i2 = k2 / 2;
              } else if (crypto.randomBytes) {
                a2 = crypto.randomBytes(k2 *= 7);
                for (; i2 < k2; ) {
                  v3 = (a2[i2] & 31) * 281474976710656 + a2[i2 + 1] * 1099511627776 + a2[i2 + 2] * 4294967296 + a2[i2 + 3] * 16777216 + (a2[i2 + 4] << 16) + (a2[i2 + 5] << 8) + a2[i2 + 6];
                  if (v3 >= 9e15) {
                    crypto.randomBytes(7).copy(a2, i2);
                  } else {
                    c2.push(v3 % 1e14);
                    i2 += 7;
                  }
                }
                i2 = k2 / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i2 < k2; ) {
                v3 = random53bitInt();
                if (v3 < 9e15) c2[i2++] = v3 % 1e14;
              }
            }
            k2 = c2[--i2];
            dp2 %= LOG_BASE;
            if (k2 && dp2) {
              v3 = POWS_TEN[LOG_BASE - dp2];
              c2[i2] = mathfloor(k2 / v3) * v3;
            }
            for (; c2[i2] === 0; c2.pop(), i2--) ;
            if (i2 < 0) {
              c2 = [e2 = 0];
            } else {
              for (e2 = -1; c2[0] === 0; c2.splice(0, 1), e2 -= LOG_BASE) ;
              for (i2 = 1, v3 = c2[0]; v3 >= 10; v3 /= 10, i2++) ;
              if (i2 < LOG_BASE) e2 -= LOG_BASE - i2;
            }
            rand.e = e2;
            rand.c = c2;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i2 < args.length; ) sum = sum.plus(args[i2++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet2) {
            var j2, arr = [0], arrL, i2 = 0, len = str.length;
            for (; i2 < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet2.indexOf(str.charAt(i2++));
              for (j2 = 0; j2 < arr.length; j2++) {
                if (arr[j2] > baseOut - 1) {
                  if (arr[j2 + 1] == null) arr[j2 + 1] = 0;
                  arr[j2 + 1] += arr[j2] / baseOut | 0;
                  arr[j2] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign2, callerIsToString) {
            var alphabet2, d2, e2, k2, r2, x3, xc2, y2, i2 = str.indexOf("."), dp2 = DECIMAL_PLACES, rm2 = ROUNDING_MODE;
            if (i2 >= 0) {
              k2 = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y2 = new BigNumber2(baseIn);
              x3 = y2.pow(str.length - i2);
              POW_PRECISION = k2;
              y2.c = toBaseOut(
                toFixedPoint(coeffToString(x3.c), x3.e, "0"),
                10,
                baseOut,
                decimal
              );
              y2.e = y2.c.length;
            }
            xc2 = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET2, decimal) : (alphabet2 = decimal, ALPHABET2));
            e2 = k2 = xc2.length;
            for (; xc2[--k2] == 0; xc2.pop()) ;
            if (!xc2[0]) return alphabet2.charAt(0);
            if (i2 < 0) {
              --e2;
            } else {
              x3.c = xc2;
              x3.e = e2;
              x3.s = sign2;
              x3 = div(x3, y2, dp2, rm2, baseOut);
              xc2 = x3.c;
              r2 = x3.r;
              e2 = x3.e;
            }
            d2 = e2 + dp2 + 1;
            i2 = xc2[d2];
            k2 = baseOut / 2;
            r2 = r2 || d2 < 0 || xc2[d2 + 1] != null;
            r2 = rm2 < 4 ? (i2 != null || r2) && (rm2 == 0 || rm2 == (x3.s < 0 ? 3 : 2)) : i2 > k2 || i2 == k2 && (rm2 == 4 || r2 || rm2 == 6 && xc2[d2 - 1] & 1 || rm2 == (x3.s < 0 ? 8 : 7));
            if (d2 < 1 || !xc2[0]) {
              str = r2 ? toFixedPoint(alphabet2.charAt(1), -dp2, alphabet2.charAt(0)) : alphabet2.charAt(0);
            } else {
              xc2.length = d2;
              if (r2) {
                for (--baseOut; ++xc2[--d2] > baseOut; ) {
                  xc2[d2] = 0;
                  if (!d2) {
                    ++e2;
                    xc2 = [1].concat(xc2);
                  }
                }
              }
              for (k2 = xc2.length; !xc2[--k2]; ) ;
              for (i2 = 0, str = ""; i2 <= k2; str += alphabet2.charAt(xc2[i2++])) ;
              str = toFixedPoint(str, e2, alphabet2.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x3, k2, base3) {
            var m2, temp, xlo, xhi, carry = 0, i2 = x3.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
            for (x3 = x3.slice(); i2--; ) {
              xlo = x3[i2] % SQRT_BASE;
              xhi = x3[i2] / SQRT_BASE | 0;
              m2 = khi * xlo + xhi * klo;
              temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base3 | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
              x3[i2] = temp % base3;
            }
            if (carry) x3 = [carry].concat(x3);
            return x3;
          }
          function compare2(a2, b2, aL, bL) {
            var i2, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i2 = cmp = 0; i2 < aL; i2++) {
                if (a2[i2] != b2[i2]) {
                  cmp = a2[i2] > b2[i2] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a2, b2, aL, base3) {
            var i2 = 0;
            for (; aL--; ) {
              a2[aL] -= i2;
              i2 = a2[aL] < b2[aL] ? 1 : 0;
              a2[aL] = i2 * base3 + a2[aL] - b2[aL];
            }
            for (; !a2[0] && a2.length > 1; a2.splice(0, 1)) ;
          }
          return function(x3, y2, dp2, rm2, base3) {
            var cmp, e2, i2, more, n2, prod, prodL, q2, qc2, rem, remL, rem0, xi2, xL, yc0, yL, yz, s2 = x3.s == y2.s ? 1 : -1, xc2 = x3.c, yc2 = y2.c;
            if (!xc2 || !xc2[0] || !yc2 || !yc2[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x3.s || !y2.s || (xc2 ? yc2 && xc2[0] == yc2[0] : !yc2) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc2 && xc2[0] == 0 || !yc2 ? s2 * 0 : s2 / 0
                )
              );
            }
            q2 = new BigNumber2(s2);
            qc2 = q2.c = [];
            e2 = x3.e - y2.e;
            s2 = dp2 + e2 + 1;
            if (!base3) {
              base3 = BASE;
              e2 = bitFloor(x3.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
              s2 = s2 / LOG_BASE | 0;
            }
            for (i2 = 0; yc2[i2] == (xc2[i2] || 0); i2++) ;
            if (yc2[i2] > (xc2[i2] || 0)) e2--;
            if (s2 < 0) {
              qc2.push(1);
              more = true;
            } else {
              xL = xc2.length;
              yL = yc2.length;
              i2 = 0;
              s2 += 2;
              n2 = mathfloor(base3 / (yc2[0] + 1));
              if (n2 > 1) {
                yc2 = multiply(yc2, n2, base3);
                xc2 = multiply(xc2, n2, base3);
                yL = yc2.length;
                xL = xc2.length;
              }
              xi2 = yL;
              rem = xc2.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc2.slice();
              yz = [0].concat(yz);
              yc0 = yc2[0];
              if (yc2[1] >= base3 / 2) yc0++;
              do {
                n2 = 0;
                cmp = compare2(yc2, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base3 + (rem[1] || 0);
                  n2 = mathfloor(rem0 / yc0);
                  if (n2 > 1) {
                    if (n2 >= base3) n2 = base3 - 1;
                    prod = multiply(yc2, n2, base3);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n2--;
                      subtract(prod, yL < prodL ? yz : yc2, prodL, base3);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n2 == 0) {
                      cmp = n2 = 1;
                    }
                    prod = yc2.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base3);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc2, rem, yL, remL) < 1) {
                      n2++;
                      subtract(rem, yL < remL ? yz : yc2, remL, base3);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n2++;
                  rem = [0];
                }
                qc2[i2++] = n2;
                if (rem[0]) {
                  rem[remL++] = xc2[xi2] || 0;
                } else {
                  rem = [xc2[xi2]];
                  remL = 1;
                }
              } while ((xi2++ < xL || rem[0] != null) && s2--);
              more = rem[0] != null;
              if (!qc2[0]) qc2.splice(0, 1);
            }
            if (base3 == BASE) {
              for (i2 = 1, s2 = qc2[0]; s2 >= 10; s2 /= 10, i2++) ;
              round(q2, dp2 + (q2.e = i2 + e2 * LOG_BASE - 1) + 1, rm2, more);
            } else {
              q2.e = e2;
              q2.r = +more;
            }
            return q2;
          };
        }();
        function format(n2, i2, rm2, id2) {
          var c02, e2, ne, len, str;
          if (rm2 == null) rm2 = ROUNDING_MODE;
          else intCheck(rm2, 0, 8);
          if (!n2.c) return n2.toString();
          c02 = n2.c[0];
          ne = n2.e;
          if (i2 == null) {
            str = coeffToString(n2.c);
            str = id2 == 1 || id2 == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n2 = round(new BigNumber2(n2), i2, rm2);
            e2 = n2.e;
            str = coeffToString(n2.c);
            len = str.length;
            if (id2 == 1 || id2 == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
              for (; len < i2; str += "0", len++) ;
              str = toExponential(str, e2);
            } else {
              i2 -= ne;
              str = toFixedPoint(str, e2, "0");
              if (e2 + 1 > len) {
                if (--i2 > 0) for (str += "."; i2--; str += "0") ;
              } else {
                i2 += e2 - len;
                if (i2 > 0) {
                  if (e2 + 1 == len) str += ".";
                  for (; i2--; str += "0") ;
                }
              }
            }
          }
          return n2.s < 0 && c02 ? "-" + str : str;
        }
        function maxOrMin(args, n2) {
          var k2, y2, i2 = 1, x3 = new BigNumber2(args[0]);
          for (; i2 < args.length; i2++) {
            y2 = new BigNumber2(args[i2]);
            if (!y2.s || (k2 = compare(x3, y2)) === n2 || k2 === 0 && x3.s === n2) {
              x3 = y2;
            }
          }
          return x3;
        }
        function normalise(n2, c2, e2) {
          var i2 = 1, j2 = c2.length;
          for (; !c2[--j2]; c2.pop()) ;
          for (j2 = c2[0]; j2 >= 10; j2 /= 10, i2++) ;
          if ((e2 = i2 + e2 * LOG_BASE - 1) > MAX_EXP) {
            n2.c = n2.e = null;
          } else if (e2 < MIN_EXP) {
            n2.c = [n2.e = 0];
          } else {
            n2.e = e2;
            n2.c = c2;
          }
          return n2;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x3, str, isNum, b2) {
            var base3, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s2)) {
              x3.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s2 = s2.replace(basePrefix, function(m2, p12, p2) {
                  base3 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b2 || b2 == base3 ? p12 : m2;
                });
                if (b2) {
                  base3 = b2;
                  s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s2) return new BigNumber2(s2, base3);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
              }
              x3.s = null;
            }
            x3.c = x3.e = null;
          };
        }();
        function round(x3, sd2, rm2, r2) {
          var d2, i2, j2, k2, n2, ni2, rd2, xc2 = x3.c, pows10 = POWS_TEN;
          if (xc2) {
            out: {
              for (d2 = 1, k2 = xc2[0]; k2 >= 10; k2 /= 10, d2++) ;
              i2 = sd2 - d2;
              if (i2 < 0) {
                i2 += LOG_BASE;
                j2 = sd2;
                n2 = xc2[ni2 = 0];
                rd2 = mathfloor(n2 / pows10[d2 - j2 - 1] % 10);
              } else {
                ni2 = mathceil((i2 + 1) / LOG_BASE);
                if (ni2 >= xc2.length) {
                  if (r2) {
                    for (; xc2.length <= ni2; xc2.push(0)) ;
                    n2 = rd2 = 0;
                    d2 = 1;
                    i2 %= LOG_BASE;
                    j2 = i2 - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n2 = k2 = xc2[ni2];
                  for (d2 = 1; k2 >= 10; k2 /= 10, d2++) ;
                  i2 %= LOG_BASE;
                  j2 = i2 - LOG_BASE + d2;
                  rd2 = j2 < 0 ? 0 : mathfloor(n2 / pows10[d2 - j2 - 1] % 10);
                }
              }
              r2 = r2 || sd2 < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc2[ni2 + 1] != null || (j2 < 0 ? n2 : n2 % pows10[d2 - j2 - 1]);
              r2 = rm2 < 4 ? (rd2 || r2) && (rm2 == 0 || rm2 == (x3.s < 0 ? 3 : 2)) : rd2 > 5 || rd2 == 5 && (rm2 == 4 || r2 || rm2 == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i2 > 0 ? j2 > 0 ? n2 / pows10[d2 - j2] : 0 : xc2[ni2 - 1]) % 10 & 1 || rm2 == (x3.s < 0 ? 8 : 7));
              if (sd2 < 1 || !xc2[0]) {
                xc2.length = 0;
                if (r2) {
                  sd2 -= x3.e + 1;
                  xc2[0] = pows10[(LOG_BASE - sd2 % LOG_BASE) % LOG_BASE];
                  x3.e = -sd2 || 0;
                } else {
                  xc2[0] = x3.e = 0;
                }
                return x3;
              }
              if (i2 == 0) {
                xc2.length = ni2;
                k2 = 1;
                ni2--;
              } else {
                xc2.length = ni2 + 1;
                k2 = pows10[LOG_BASE - i2];
                xc2[ni2] = j2 > 0 ? mathfloor(n2 / pows10[d2 - j2] % pows10[j2]) * k2 : 0;
              }
              if (r2) {
                for (; ; ) {
                  if (ni2 == 0) {
                    for (i2 = 1, j2 = xc2[0]; j2 >= 10; j2 /= 10, i2++) ;
                    j2 = xc2[0] += k2;
                    for (k2 = 1; j2 >= 10; j2 /= 10, k2++) ;
                    if (i2 != k2) {
                      x3.e++;
                      if (xc2[0] == BASE) xc2[0] = 1;
                    }
                    break;
                  } else {
                    xc2[ni2] += k2;
                    if (xc2[ni2] != BASE) break;
                    xc2[ni2--] = 0;
                    k2 = 1;
                  }
                }
              }
              for (i2 = xc2.length; xc2[--i2] === 0; xc2.pop()) ;
            }
            if (x3.e > MAX_EXP) {
              x3.c = x3.e = null;
            } else if (x3.e < MIN_EXP) {
              x3.c = [x3.e = 0];
            }
          }
          return x3;
        }
        function valueOf(n2) {
          var str, e2 = n2.e;
          if (e2 === null) return n2.toString();
          str = coeffToString(n2.c);
          str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
          return n2.s < 0 ? "-" + str : str;
        }
        P3.absoluteValue = P3.abs = function() {
          var x3 = new BigNumber2(this);
          if (x3.s < 0) x3.s = 1;
          return x3;
        };
        P3.comparedTo = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2));
        };
        P3.decimalPlaces = P3.dp = function(dp2, rm2) {
          var c2, n2, v3, x3 = this;
          if (dp2 != null) {
            intCheck(dp2, 0, MAX);
            if (rm2 == null) rm2 = ROUNDING_MODE;
            else intCheck(rm2, 0, 8);
            return round(new BigNumber2(x3), dp2 + x3.e + 1, rm2);
          }
          if (!(c2 = x3.c)) return null;
          n2 = ((v3 = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v3 = c2[v3]) for (; v3 % 10 == 0; v3 /= 10, n2--) ;
          if (n2 < 0) n2 = 0;
          return n2;
        };
        P3.dividedBy = P3.div = function(y2, b2) {
          return div(this, new BigNumber2(y2, b2), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P3.dividedToIntegerBy = P3.idiv = function(y2, b2) {
          return div(this, new BigNumber2(y2, b2), 0, 1);
        };
        P3.exponentiatedBy = P3.pow = function(n2, m2) {
          var half, isModExp, i2, k2, more, nIsBig, nIsNeg, nIsOdd, y2, x3 = this;
          n2 = new BigNumber2(n2);
          if (n2.c && !n2.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n2));
          }
          if (m2 != null) m2 = new BigNumber2(m2);
          nIsBig = n2.e > 14;
          if (!x3.c || !x3.c[0] || x3.c[0] == 1 && !x3.e && x3.c.length == 1 || !n2.c || !n2.c[0]) {
            y2 = new BigNumber2(Math.pow(+valueOf(x3), nIsBig ? n2.s * (2 - isOdd(n2)) : +valueOf(n2)));
            return m2 ? y2.mod(m2) : y2;
          }
          nIsNeg = n2.s < 0;
          if (m2) {
            if (m2.c ? !m2.c[0] : !m2.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x3.isInteger() && m2.isInteger();
            if (isModExp) x3 = x3.mod(m2);
          } else if (n2.e > 9 && (x3.e > 0 || x3.e < -1 || (x3.e == 0 ? x3.c[0] > 1 || nIsBig && x3.c[1] >= 24e7 : x3.c[0] < 8e13 || nIsBig && x3.c[0] <= 9999975e7))) {
            k2 = x3.s < 0 && isOdd(n2) ? -0 : 0;
            if (x3.e > -1) k2 = 1 / k2;
            return new BigNumber2(nIsNeg ? 1 / k2 : k2);
          } else if (POW_PRECISION) {
            k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n2.s = 1;
            nIsOdd = isOdd(n2);
          } else {
            i2 = Math.abs(+valueOf(n2));
            nIsOdd = i2 % 2;
          }
          y2 = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y2 = y2.times(x3);
              if (!y2.c) break;
              if (k2) {
                if (y2.c.length > k2) y2.c.length = k2;
              } else if (isModExp) {
                y2 = y2.mod(m2);
              }
            }
            if (i2) {
              i2 = mathfloor(i2 / 2);
              if (i2 === 0) break;
              nIsOdd = i2 % 2;
            } else {
              n2 = n2.times(half);
              round(n2, n2.e + 1, 1);
              if (n2.e > 14) {
                nIsOdd = isOdd(n2);
              } else {
                i2 = +valueOf(n2);
                if (i2 === 0) break;
                nIsOdd = i2 % 2;
              }
            }
            x3 = x3.times(x3);
            if (k2) {
              if (x3.c && x3.c.length > k2) x3.c.length = k2;
            } else if (isModExp) {
              x3 = x3.mod(m2);
            }
          }
          if (isModExp) return y2;
          if (nIsNeg) y2 = ONE.div(y2);
          return m2 ? y2.mod(m2) : k2 ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
        };
        P3.integerValue = function(rm2) {
          var n2 = new BigNumber2(this);
          if (rm2 == null) rm2 = ROUNDING_MODE;
          else intCheck(rm2, 0, 8);
          return round(n2, n2.e + 1, rm2);
        };
        P3.isEqualTo = P3.eq = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2)) === 0;
        };
        P3.isFinite = function() {
          return !!this.c;
        };
        P3.isGreaterThan = P3.gt = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2)) > 0;
        };
        P3.isGreaterThanOrEqualTo = P3.gte = function(y2, b2) {
          return (b2 = compare(this, new BigNumber2(y2, b2))) === 1 || b2 === 0;
        };
        P3.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P3.isLessThan = P3.lt = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2)) < 0;
        };
        P3.isLessThanOrEqualTo = P3.lte = function(y2, b2) {
          return (b2 = compare(this, new BigNumber2(y2, b2))) === -1 || b2 === 0;
        };
        P3.isNaN = function() {
          return !this.s;
        };
        P3.isNegative = function() {
          return this.s < 0;
        };
        P3.isPositive = function() {
          return this.s > 0;
        };
        P3.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P3.minus = function(y2, b2) {
          var i2, j2, t2, xLTy, x3 = this, a2 = x3.s;
          y2 = new BigNumber2(y2, b2);
          b2 = y2.s;
          if (!a2 || !b2) return new BigNumber2(NaN);
          if (a2 != b2) {
            y2.s = -b2;
            return x3.plus(y2);
          }
          var xe = x3.e / LOG_BASE, ye = y2.e / LOG_BASE, xc2 = x3.c, yc2 = y2.c;
          if (!xe || !ye) {
            if (!xc2 || !yc2) return xc2 ? (y2.s = -b2, y2) : new BigNumber2(yc2 ? x3 : NaN);
            if (!xc2[0] || !yc2[0]) {
              return yc2[0] ? (y2.s = -b2, y2) : new BigNumber2(xc2[0] ? x3 : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc2 = xc2.slice();
          if (a2 = xe - ye) {
            if (xLTy = a2 < 0) {
              a2 = -a2;
              t2 = xc2;
            } else {
              ye = xe;
              t2 = yc2;
            }
            t2.reverse();
            for (b2 = a2; b2--; t2.push(0)) ;
            t2.reverse();
          } else {
            j2 = (xLTy = (a2 = xc2.length) < (b2 = yc2.length)) ? a2 : b2;
            for (a2 = b2 = 0; b2 < j2; b2++) {
              if (xc2[b2] != yc2[b2]) {
                xLTy = xc2[b2] < yc2[b2];
                break;
              }
            }
          }
          if (xLTy) {
            t2 = xc2;
            xc2 = yc2;
            yc2 = t2;
            y2.s = -y2.s;
          }
          b2 = (j2 = yc2.length) - (i2 = xc2.length);
          if (b2 > 0) for (; b2--; xc2[i2++] = 0) ;
          b2 = BASE - 1;
          for (; j2 > a2; ) {
            if (xc2[--j2] < yc2[j2]) {
              for (i2 = j2; i2 && !xc2[--i2]; xc2[i2] = b2) ;
              --xc2[i2];
              xc2[j2] += BASE;
            }
            xc2[j2] -= yc2[j2];
          }
          for (; xc2[0] == 0; xc2.splice(0, 1), --ye) ;
          if (!xc2[0]) {
            y2.s = ROUNDING_MODE == 3 ? -1 : 1;
            y2.c = [y2.e = 0];
            return y2;
          }
          return normalise(y2, xc2, ye);
        };
        P3.modulo = P3.mod = function(y2, b2) {
          var q2, s2, x3 = this;
          y2 = new BigNumber2(y2, b2);
          if (!x3.c || !y2.s || y2.c && !y2.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y2.c || x3.c && !x3.c[0]) {
            return new BigNumber2(x3);
          }
          if (MODULO_MODE == 9) {
            s2 = y2.s;
            y2.s = 1;
            q2 = div(x3, y2, 0, 3);
            y2.s = s2;
            q2.s *= s2;
          } else {
            q2 = div(x3, y2, 0, MODULO_MODE);
          }
          y2 = x3.minus(q2.times(y2));
          if (!y2.c[0] && MODULO_MODE == 1) y2.s = x3.s;
          return y2;
        };
        P3.multipliedBy = P3.times = function(y2, b2) {
          var c2, e2, i2, j2, k2, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc2, base3, sqrtBase, x3 = this, xc2 = x3.c, yc2 = (y2 = new BigNumber2(y2, b2)).c;
          if (!xc2 || !yc2 || !xc2[0] || !yc2[0]) {
            if (!x3.s || !y2.s || xc2 && !xc2[0] && !yc2 || yc2 && !yc2[0] && !xc2) {
              y2.c = y2.e = y2.s = null;
            } else {
              y2.s *= x3.s;
              if (!xc2 || !yc2) {
                y2.c = y2.e = null;
              } else {
                y2.c = [0];
                y2.e = 0;
              }
            }
            return y2;
          }
          e2 = bitFloor(x3.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
          y2.s *= x3.s;
          xcL = xc2.length;
          ycL = yc2.length;
          if (xcL < ycL) {
            zc2 = xc2;
            xc2 = yc2;
            yc2 = zc2;
            i2 = xcL;
            xcL = ycL;
            ycL = i2;
          }
          for (i2 = xcL + ycL, zc2 = []; i2--; zc2.push(0)) ;
          base3 = BASE;
          sqrtBase = SQRT_BASE;
          for (i2 = ycL; --i2 >= 0; ) {
            c2 = 0;
            ylo = yc2[i2] % sqrtBase;
            yhi = yc2[i2] / sqrtBase | 0;
            for (k2 = xcL, j2 = i2 + k2; j2 > i2; ) {
              xlo = xc2[--k2] % sqrtBase;
              xhi = xc2[k2] / sqrtBase | 0;
              m2 = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc2[j2] + c2;
              c2 = (xlo / base3 | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
              zc2[j2--] = xlo % base3;
            }
            zc2[j2] = c2;
          }
          if (c2) {
            ++e2;
          } else {
            zc2.splice(0, 1);
          }
          return normalise(y2, zc2, e2);
        };
        P3.negated = function() {
          var x3 = new BigNumber2(this);
          x3.s = -x3.s || null;
          return x3;
        };
        P3.plus = function(y2, b2) {
          var t2, x3 = this, a2 = x3.s;
          y2 = new BigNumber2(y2, b2);
          b2 = y2.s;
          if (!a2 || !b2) return new BigNumber2(NaN);
          if (a2 != b2) {
            y2.s = -b2;
            return x3.minus(y2);
          }
          var xe = x3.e / LOG_BASE, ye = y2.e / LOG_BASE, xc2 = x3.c, yc2 = y2.c;
          if (!xe || !ye) {
            if (!xc2 || !yc2) return new BigNumber2(a2 / 0);
            if (!xc2[0] || !yc2[0]) return yc2[0] ? y2 : new BigNumber2(xc2[0] ? x3 : a2 * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc2 = xc2.slice();
          if (a2 = xe - ye) {
            if (a2 > 0) {
              ye = xe;
              t2 = yc2;
            } else {
              a2 = -a2;
              t2 = xc2;
            }
            t2.reverse();
            for (; a2--; t2.push(0)) ;
            t2.reverse();
          }
          a2 = xc2.length;
          b2 = yc2.length;
          if (a2 - b2 < 0) {
            t2 = yc2;
            yc2 = xc2;
            xc2 = t2;
            b2 = a2;
          }
          for (a2 = 0; b2; ) {
            a2 = (xc2[--b2] = xc2[b2] + yc2[b2] + a2) / BASE | 0;
            xc2[b2] = BASE === xc2[b2] ? 0 : xc2[b2] % BASE;
          }
          if (a2) {
            xc2 = [a2].concat(xc2);
            ++ye;
          }
          return normalise(y2, xc2, ye);
        };
        P3.precision = P3.sd = function(sd2, rm2) {
          var c2, n2, v3, x3 = this;
          if (sd2 != null && sd2 !== !!sd2) {
            intCheck(sd2, 1, MAX);
            if (rm2 == null) rm2 = ROUNDING_MODE;
            else intCheck(rm2, 0, 8);
            return round(new BigNumber2(x3), sd2, rm2);
          }
          if (!(c2 = x3.c)) return null;
          v3 = c2.length - 1;
          n2 = v3 * LOG_BASE + 1;
          if (v3 = c2[v3]) {
            for (; v3 % 10 == 0; v3 /= 10, n2--) ;
            for (v3 = c2[0]; v3 >= 10; v3 /= 10, n2++) ;
          }
          if (sd2 && x3.e + 1 > n2) n2 = x3.e + 1;
          return n2;
        };
        P3.shiftedBy = function(k2) {
          intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k2);
        };
        P3.squareRoot = P3.sqrt = function() {
          var m2, n2, r2, rep, t2, x3 = this, c2 = x3.c, s2 = x3.s, e2 = x3.e, dp2 = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s2 !== 1 || !c2 || !c2[0]) {
            return new BigNumber2(!s2 || s2 < 0 && (!c2 || c2[0]) ? NaN : c2 ? x3 : 1 / 0);
          }
          s2 = Math.sqrt(+valueOf(x3));
          if (s2 == 0 || s2 == 1 / 0) {
            n2 = coeffToString(c2);
            if ((n2.length + e2) % 2 == 0) n2 += "0";
            s2 = Math.sqrt(+n2);
            e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
            if (s2 == 1 / 0) {
              n2 = "5e" + e2;
            } else {
              n2 = s2.toExponential();
              n2 = n2.slice(0, n2.indexOf("e") + 1) + e2;
            }
            r2 = new BigNumber2(n2);
          } else {
            r2 = new BigNumber2(s2 + "");
          }
          if (r2.c[0]) {
            e2 = r2.e;
            s2 = e2 + dp2;
            if (s2 < 3) s2 = 0;
            for (; ; ) {
              t2 = r2;
              r2 = half.times(t2.plus(div(x3, t2, dp2, 1)));
              if (coeffToString(t2.c).slice(0, s2) === (n2 = coeffToString(r2.c)).slice(0, s2)) {
                if (r2.e < e2) --s2;
                n2 = n2.slice(s2 - 3, s2 + 1);
                if (n2 == "9999" || !rep && n2 == "4999") {
                  if (!rep) {
                    round(t2, t2.e + DECIMAL_PLACES + 2, 0);
                    if (t2.times(t2).eq(x3)) {
                      r2 = t2;
                      break;
                    }
                  }
                  dp2 += 4;
                  s2 += 4;
                  rep = 1;
                } else {
                  if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
                    round(r2, r2.e + DECIMAL_PLACES + 2, 1);
                    m2 = !r2.times(r2).eq(x3);
                  }
                  break;
                }
              }
            }
          }
          return round(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
        };
        P3.toExponential = function(dp2, rm2) {
          if (dp2 != null) {
            intCheck(dp2, 0, MAX);
            dp2++;
          }
          return format(this, dp2, rm2, 1);
        };
        P3.toFixed = function(dp2, rm2) {
          if (dp2 != null) {
            intCheck(dp2, 0, MAX);
            dp2 = dp2 + this.e + 1;
          }
          return format(this, dp2, rm2);
        };
        P3.toFormat = function(dp2, rm2, format2) {
          var str, x3 = this;
          if (format2 == null) {
            if (dp2 != null && rm2 && typeof rm2 == "object") {
              format2 = rm2;
              rm2 = null;
            } else if (dp2 && typeof dp2 == "object") {
              format2 = dp2;
              dp2 = rm2 = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x3.toFixed(dp2, rm2);
          if (x3.c) {
            var i2, arr = str.split("."), g12 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x3.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i2 = g12;
              g12 = g2;
              g2 = i2;
              len -= i2;
            }
            if (g12 > 0 && len > 0) {
              i2 = len % g12 || g12;
              intPart = intDigits.substr(0, i2);
              for (; i2 < len; i2 += g12) intPart += groupSeparator + intDigits.substr(i2, g12);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i2);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P3.toFraction = function(md2) {
          var d2, d02, d12, d22, e2, exp, n2, n02, n12, q2, r2, s2, x3 = this, xc2 = x3.c;
          if (md2 != null) {
            n2 = new BigNumber2(md2);
            if (!n2.isInteger() && (n2.c || n2.s !== 1) || n2.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n2.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n2));
            }
          }
          if (!xc2) return new BigNumber2(x3);
          d2 = new BigNumber2(ONE);
          n12 = d02 = new BigNumber2(ONE);
          d12 = n02 = new BigNumber2(ONE);
          s2 = coeffToString(xc2);
          e2 = d2.e = s2.length - x3.e - 1;
          d2.c[0] = POWS_TEN[(exp = e2 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md2 = !md2 || n2.comparedTo(d2) > 0 ? e2 > 0 ? d2 : n12 : n2;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n2 = new BigNumber2(s2);
          n02.c[0] = 0;
          for (; ; ) {
            q2 = div(n2, d2, 0, 1);
            d22 = d02.plus(q2.times(d12));
            if (d22.comparedTo(md2) == 1) break;
            d02 = d12;
            d12 = d22;
            n12 = n02.plus(q2.times(d22 = n12));
            n02 = d22;
            d2 = n2.minus(q2.times(d22 = d2));
            n2 = d22;
          }
          d22 = div(md2.minus(d02), d12, 0, 1);
          n02 = n02.plus(d22.times(n12));
          d02 = d02.plus(d22.times(d12));
          n02.s = n12.s = x3.s;
          e2 = e2 * 2;
          r2 = div(n12, d12, e2, ROUNDING_MODE).minus(x3).abs().comparedTo(
            div(n02, d02, e2, ROUNDING_MODE).minus(x3).abs()
          ) < 1 ? [n12, d12] : [n02, d02];
          MAX_EXP = exp;
          return r2;
        };
        P3.toNumber = function() {
          return +valueOf(this);
        };
        P3.toPrecision = function(sd2, rm2) {
          if (sd2 != null) intCheck(sd2, 1, MAX);
          return format(this, sd2, rm2, 2);
        };
        P3.toString = function(b2) {
          var str, n2 = this, s2 = n2.s, e2 = n2.e;
          if (e2 === null) {
            if (s2) {
              str = "Infinity";
              if (s2 < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b2 == null) {
              str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n2.c), e2) : toFixedPoint(coeffToString(n2.c), e2, "0");
            } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
              n2 = round(new BigNumber2(n2), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n2.c), n2.e, "0");
            } else {
              intCheck(b2, 2, ALPHABET2.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n2.c), e2, "0"), 10, b2, s2, true);
            }
            if (s2 < 0 && n2.c[0]) str = "-" + str;
          }
          return str;
        };
        P3.valueOf = P3.toJSON = function() {
          return valueOf(this);
        };
        P3._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n2) {
        var i2 = n2 | 0;
        return n2 > 0 || n2 === i2 ? i2 : i2 - 1;
      }
      function coeffToString(a2) {
        var s2, z3, i2 = 1, j2 = a2.length, r2 = a2[0] + "";
        for (; i2 < j2; ) {
          s2 = a2[i2++] + "";
          z3 = LOG_BASE - s2.length;
          for (; z3--; s2 = "0" + s2) ;
          r2 += s2;
        }
        for (j2 = r2.length; r2.charCodeAt(--j2) === 48; ) ;
        return r2.slice(0, j2 + 1 || 1);
      }
      function compare(x3, y2) {
        var a2, b2, xc2 = x3.c, yc2 = y2.c, i2 = x3.s, j2 = y2.s, k2 = x3.e, l2 = y2.e;
        if (!i2 || !j2) return null;
        a2 = xc2 && !xc2[0];
        b2 = yc2 && !yc2[0];
        if (a2 || b2) return a2 ? b2 ? 0 : -j2 : i2;
        if (i2 != j2) return i2;
        a2 = i2 < 0;
        b2 = k2 == l2;
        if (!xc2 || !yc2) return b2 ? 0 : !xc2 ^ a2 ? 1 : -1;
        if (!b2) return k2 > l2 ^ a2 ? 1 : -1;
        j2 = (k2 = xc2.length) < (l2 = yc2.length) ? k2 : l2;
        for (i2 = 0; i2 < j2; i2++) if (xc2[i2] != yc2[i2]) return xc2[i2] > yc2[i2] ^ a2 ? 1 : -1;
        return k2 == l2 ? 0 : k2 > l2 ^ a2 ? 1 : -1;
      }
      function intCheck(n2, min, max, name2) {
        if (n2 < min || n2 > max || n2 !== mathfloor(n2)) {
          throw Error(bignumberError + (name2 || "Argument") + (typeof n2 == "number" ? n2 < min || n2 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n2));
        }
      }
      function isOdd(n2) {
        var k2 = n2.c.length - 1;
        return bitFloor(n2.e / LOG_BASE) == k2 && n2.c[k2] % 2 != 0;
      }
      function toExponential(str, e2) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
      }
      function toFixedPoint(str, e2, z3) {
        var len, zs2;
        if (e2 < 0) {
          for (zs2 = z3 + "."; ++e2; zs2 += z3) ;
          str = zs2 + str;
        } else {
          len = str.length;
          if (++e2 > len) {
            for (zs2 = z3, e2 -= len; --e2; zs2 += z3) ;
            str += zs2;
          } else if (e2 < len) {
            str = str.slice(0, e2) + "." + str.slice(e2);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports2);
  }
});

// ../../node_modules/arweave/web/ar.js
var require_ar = __commonJS({
  "../../node_modules/arweave/web/ar.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bignumber_js_1 = require_bignumber();
    var Ar3 = class {
      constructor() {
        /**
         * Method to take a string value and return a bignumber object.
         *
         * @protected
         * @type {Function}
         * @memberof Arweave
         */
        __publicField(this, "BigNum");
        this.BigNum = (value, decimals) => {
          let instance = bignumber_js_1.BigNumber.clone({ DECIMAL_PLACES: decimals });
          return new instance(value);
        };
      }
      winstonToAr(winstonString, { formatted = false, decimals = 12, trim: trim2 = true } = {}) {
        let number = this.stringToBigNum(winstonString, decimals).shiftedBy(-12);
        return formatted ? number.toFormat(decimals) : number.toFixed(decimals);
      }
      arToWinston(arString, { formatted = false } = {}) {
        let number = this.stringToBigNum(arString).shiftedBy(12);
        return formatted ? number.toFormat() : number.toFixed(0);
      }
      compare(winstonStringA, winstonStringB) {
        let a2 = this.stringToBigNum(winstonStringA);
        let b2 = this.stringToBigNum(winstonStringB);
        return a2.comparedTo(b2);
      }
      isEqual(winstonStringA, winstonStringB) {
        return this.compare(winstonStringA, winstonStringB) === 0;
      }
      isLessThan(winstonStringA, winstonStringB) {
        let a2 = this.stringToBigNum(winstonStringA);
        let b2 = this.stringToBigNum(winstonStringB);
        return a2.isLessThan(b2);
      }
      isGreaterThan(winstonStringA, winstonStringB) {
        let a2 = this.stringToBigNum(winstonStringA);
        let b2 = this.stringToBigNum(winstonStringB);
        return a2.isGreaterThan(b2);
      }
      add(winstonStringA, winstonStringB) {
        let a2 = this.stringToBigNum(winstonStringA);
        let b2 = this.stringToBigNum(winstonStringB);
        return a2.plus(winstonStringB).toFixed(0);
      }
      sub(winstonStringA, winstonStringB) {
        let a2 = this.stringToBigNum(winstonStringA);
        let b2 = this.stringToBigNum(winstonStringB);
        return a2.minus(winstonStringB).toFixed(0);
      }
      stringToBigNum(stringValue, decimalPlaces = 12) {
        return this.BigNum(stringValue, decimalPlaces);
      }
    };
    exports2.default = Ar3;
  }
});

// ../../node_modules/arweave/web/lib/api.js
var require_api2 = __commonJS({
  "../../node_modules/arweave/web/lib/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Api = class {
      constructor(config) {
        __publicField(this, "METHOD_GET", "GET");
        __publicField(this, "METHOD_POST", "POST");
        __publicField(this, "config");
        this.applyConfig(config);
      }
      applyConfig(config) {
        this.config = this.mergeDefaults(config);
      }
      getConfig() {
        return this.config;
      }
      mergeDefaults(config) {
        const protocol = config.protocol || "http";
        const port = config.port || (protocol === "https" ? 443 : 80);
        return {
          host: config.host || "127.0.0.1",
          protocol,
          port,
          timeout: config.timeout || 2e4,
          logging: config.logging || false,
          logger: config.logger || console.log,
          network: config.network
        };
      }
      async get(endpoint, config) {
        return await this.request(endpoint, { ...config, method: this.METHOD_GET });
      }
      async post(endpoint, body, config) {
        var _a2;
        const headers = new Headers((config == null ? void 0 : config.headers) || {});
        if (!((_a2 = headers.get("content-type")) == null ? void 0 : _a2.includes("application/json"))) {
          headers.append("content-type", "application/json");
        }
        headers.append("accept", "application/json, text/plain, */*");
        return await this.request(endpoint, {
          ...config,
          method: this.METHOD_POST,
          body: typeof body !== "string" ? JSON.stringify(body) : body,
          headers
        });
      }
      async request(endpoint, init) {
        var _a2;
        const headers = new Headers((init == null ? void 0 : init.headers) || {});
        const baseURL = `${this.config.protocol}://${this.config.host}:${this.config.port}`;
        const responseType = init == null ? void 0 : init.responseType;
        init == null ? true : delete init.responseType;
        if (endpoint.startsWith("/")) {
          endpoint = endpoint.slice(1);
        }
        if (this.config.network) {
          headers.append("x-network", this.config.network);
        }
        if (this.config.logging) {
          this.config.logger(`Requesting: ${baseURL}/${endpoint}`);
        }
        let res = await fetch(`${baseURL}/${endpoint}`, {
          ...init || {},
          headers
        });
        if (this.config.logging) {
          this.config.logger(`Response:   ${res.url} - ${res.status}`);
        }
        const contentType = res.headers.get("content-type");
        const charset = (_a2 = contentType == null ? void 0 : contentType.match(/charset=([^()<>@,;:\"/[\]?.=\s]*)/i)) == null ? void 0 : _a2[1];
        const response = res;
        const decodeText = async () => {
          if (charset) {
            try {
              response.data = new TextDecoder(charset).decode(await res.arrayBuffer());
            } catch (e2) {
              response.data = await res.text();
            }
          } else {
            response.data = await res.text();
          }
        };
        if (responseType === "arraybuffer") {
          response.data = await res.arrayBuffer();
        } else if (responseType === "text") {
          await decodeText();
        } else if (responseType === "webstream") {
          response.data = addAsyncIterator(res.body);
        } else {
          try {
            let test2 = await res.clone().json();
            if (typeof test2 !== "object") {
              await decodeText();
            } else {
              response.data = await res.json();
            }
            test2 = null;
          } catch {
            await decodeText();
          }
        }
        return response;
      }
    };
    exports2.default = Api;
    var addAsyncIterator = (body) => {
      const bodyWithIter = body;
      if (typeof bodyWithIter[Symbol.asyncIterator] === "undefined") {
        bodyWithIter[Symbol.asyncIterator] = webIiterator(body);
      }
      return bodyWithIter;
    };
    var webIiterator = function(stream) {
      return async function* iteratorGenerator() {
        const reader = stream.getReader();
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done)
              return;
            yield value;
          }
        } finally {
          reader.releaseLock();
        }
      };
    };
  }
});

// ../../node_modules/arweave/web/lib/utils.js
var require_utils5 = __commonJS({
  "../../node_modules/arweave/web/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatBuffers = concatBuffers;
    exports2.b64UrlToString = b64UrlToString;
    exports2.bufferToString = bufferToString;
    exports2.stringToBuffer = stringToBuffer;
    exports2.stringToB64Url = stringToB64Url;
    exports2.b64UrlToBuffer = b64UrlToBuffer;
    exports2.bufferTob64 = bufferTob64;
    exports2.bufferTob64Url = bufferTob64Url;
    exports2.b64UrlEncode = b64UrlEncode2;
    exports2.b64UrlDecode = b64UrlDecode2;
    var B64js2 = require_base64_js();
    function concatBuffers(buffers) {
      let total_length = 0;
      for (let i2 = 0; i2 < buffers.length; i2++) {
        total_length += buffers[i2].byteLength;
      }
      let temp = new Uint8Array(total_length);
      let offset = 0;
      temp.set(new Uint8Array(buffers[0]), offset);
      offset += buffers[0].byteLength;
      for (let i2 = 1; i2 < buffers.length; i2++) {
        temp.set(new Uint8Array(buffers[i2]), offset);
        offset += buffers[i2].byteLength;
      }
      return temp;
    }
    function b64UrlToString(b64UrlString) {
      let buffer = b64UrlToBuffer(b64UrlString);
      return bufferToString(buffer);
    }
    function bufferToString(buffer) {
      return new TextDecoder("utf-8", { fatal: true }).decode(buffer);
    }
    function stringToBuffer(string2) {
      return new TextEncoder().encode(string2);
    }
    function stringToB64Url(string2) {
      return bufferTob64Url(stringToBuffer(string2));
    }
    function b64UrlToBuffer(b64UrlString) {
      return new Uint8Array(B64js2.toByteArray(b64UrlDecode2(b64UrlString)));
    }
    function bufferTob64(buffer) {
      return B64js2.fromByteArray(new Uint8Array(buffer));
    }
    function bufferTob64Url(buffer) {
      return b64UrlEncode2(bufferTob64(buffer));
    }
    function b64UrlEncode2(b64UrlString) {
      try {
        return b64UrlString.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      } catch (error) {
        throw new Error("Failed to encode string", { cause: error });
      }
    }
    function b64UrlDecode2(b64UrlString) {
      try {
        b64UrlString = b64UrlString.replace(/\-/g, "+").replace(/\_/g, "/");
        let padding;
        b64UrlString.length % 4 == 0 ? padding = 0 : padding = 4 - b64UrlString.length % 4;
        return b64UrlString.concat("=".repeat(padding));
      } catch (error) {
        throw new Error("Failed to decode string", { cause: error });
      }
    }
  }
});

// ../../node_modules/arweave/web/lib/crypto/webcrypto-driver.js
var require_webcrypto_driver = __commonJS({
  "../../node_modules/arweave/web/lib/crypto/webcrypto-driver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ArweaveUtils = require_utils5();
    var WebCryptoDriver = class {
      constructor() {
        __publicField(this, "keyLength", 4096);
        __publicField(this, "publicExponent", 65537);
        __publicField(this, "hashAlgorithm", "sha256");
        __publicField(this, "driver");
        if (!this.detectWebCrypto()) {
          throw new Error("SubtleCrypto not available!");
        }
        this.driver = crypto.subtle;
      }
      async generateJWK() {
        let cryptoKey = await this.driver.generateKey({
          name: "RSA-PSS",
          modulusLength: 4096,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: {
            name: "SHA-256"
          }
        }, true, ["sign"]);
        let jwk = await this.driver.exportKey("jwk", cryptoKey.privateKey);
        return {
          kty: jwk.kty,
          e: jwk.e,
          n: jwk.n,
          d: jwk.d,
          p: jwk.p,
          q: jwk.q,
          dp: jwk.dp,
          dq: jwk.dq,
          qi: jwk.qi
        };
      }
      async sign(jwk, data, { saltLength } = {}) {
        let signature = await this.driver.sign({
          name: "RSA-PSS",
          saltLength: 32
        }, await this.jwkToCryptoKey(jwk), data);
        return new Uint8Array(signature);
      }
      async hash(data, algorithm = "SHA-256") {
        let digest2 = await this.driver.digest(algorithm, data);
        return new Uint8Array(digest2);
      }
      async verify(publicModulus, data, signature) {
        const publicKey = {
          kty: "RSA",
          e: "AQAB",
          n: publicModulus
        };
        const key = await this.jwkToPublicCryptoKey(publicKey);
        const digest2 = await this.driver.digest("SHA-256", data);
        const salt0 = await this.driver.verify({
          name: "RSA-PSS",
          saltLength: 0
        }, key, signature, data);
        const salt32 = await this.driver.verify({
          name: "RSA-PSS",
          saltLength: 32
        }, key, signature, data);
        const saltLengthN = Math.ceil((key.algorithm.modulusLength - 1) / 8) - digest2.byteLength - 2;
        const saltN = await this.driver.verify({
          name: "RSA-PSS",
          saltLength: saltLengthN
        }, key, signature, data);
        const result = salt0 || salt32 || saltN;
        if (!result) {
          const details = {
            algorithm: key.algorithm.name,
            modulusLength: key.algorithm.modulusLength,
            keyUsages: key.usages,
            saltLengthsAttempted: `0, 32, ${saltLengthN}`
          };
          console.warn("Transaction Verification Failed! \n", `Details: ${JSON.stringify(details, null, 2)} 
`, "N.B. ArweaveJS is only guaranteed to verify txs created using ArweaveJS.");
        }
        return result;
      }
      async jwkToCryptoKey(jwk) {
        return this.driver.importKey("jwk", jwk, {
          name: "RSA-PSS",
          hash: {
            name: "SHA-256"
          }
        }, false, ["sign"]);
      }
      async jwkToPublicCryptoKey(publicJwk) {
        return this.driver.importKey("jwk", publicJwk, {
          name: "RSA-PSS",
          hash: {
            name: "SHA-256"
          }
        }, false, ["verify"]);
      }
      detectWebCrypto() {
        if (typeof crypto === "undefined") {
          return false;
        }
        const subtle = crypto == null ? void 0 : crypto.subtle;
        if (subtle === void 0) {
          return false;
        }
        const names = [
          "generateKey",
          "importKey",
          "exportKey",
          "digest",
          "sign"
        ];
        return names.every((name2) => typeof subtle[name2] === "function");
      }
      async encrypt(data, key, salt) {
        const initialKey = await this.driver.importKey("raw", typeof key == "string" ? ArweaveUtils.stringToBuffer(key) : key, {
          name: "PBKDF2",
          length: 32
        }, false, ["deriveKey"]);
        const derivedkey = await this.driver.deriveKey({
          name: "PBKDF2",
          salt: salt ? ArweaveUtils.stringToBuffer(salt) : ArweaveUtils.stringToBuffer("salt"),
          iterations: 1e5,
          hash: "SHA-256"
        }, initialKey, {
          name: "AES-CBC",
          length: 256
        }, false, ["encrypt", "decrypt"]);
        const iv2 = new Uint8Array(16);
        crypto.getRandomValues(iv2);
        const encryptedData = await this.driver.encrypt({
          name: "AES-CBC",
          iv: iv2
        }, derivedkey, data);
        return ArweaveUtils.concatBuffers([iv2, encryptedData]);
      }
      async decrypt(encrypted, key, salt) {
        const initialKey = await this.driver.importKey("raw", typeof key == "string" ? ArweaveUtils.stringToBuffer(key) : key, {
          name: "PBKDF2",
          length: 32
        }, false, ["deriveKey"]);
        const derivedkey = await this.driver.deriveKey({
          name: "PBKDF2",
          salt: salt ? ArweaveUtils.stringToBuffer(salt) : ArweaveUtils.stringToBuffer("salt"),
          iterations: 1e5,
          hash: "SHA-256"
        }, initialKey, {
          name: "AES-CBC",
          length: 256
        }, false, ["encrypt", "decrypt"]);
        const iv2 = encrypted.slice(0, 16);
        const data = await this.driver.decrypt({
          name: "AES-CBC",
          iv: iv2
        }, derivedkey, encrypted.slice(16));
        return ArweaveUtils.concatBuffers([data]);
      }
    };
    exports2.default = WebCryptoDriver;
  }
});

// ../../node_modules/arweave/web/network.js
var require_network = __commonJS({
  "../../node_modules/arweave/web/network.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Network = class {
      constructor(api) {
        __publicField(this, "api");
        this.api = api;
      }
      getInfo() {
        return this.api.get(`info`).then((response) => {
          return response.data;
        });
      }
      getPeers() {
        return this.api.get(`peers`).then((response) => {
          return response.data;
        });
      }
    };
    exports2.default = Network;
  }
});

// ../../node_modules/arweave/web/lib/error.js
var require_error = __commonJS({
  "../../node_modules/arweave/web/lib/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getError = getError;
    var ArweaveError = class extends Error {
      constructor(type, optional = {}) {
        var __super = (...args) => {
          super(...args);
          __publicField(this, "type");
          __publicField(this, "response");
          return this;
        };
        if (optional.message) {
          __super(optional.message);
        } else {
          __super();
        }
        this.type = type;
        this.response = optional.response;
      }
      getType() {
        return this.type;
      }
    };
    exports2.default = ArweaveError;
    function getError(resp) {
      let data = resp.data;
      if (typeof resp.data === "string") {
        try {
          data = JSON.parse(resp.data);
        } catch (e2) {
        }
      }
      if (resp.data instanceof ArrayBuffer || resp.data instanceof Uint8Array) {
        try {
          data = JSON.parse(data.toString());
        } catch (e2) {
        }
      }
      return data ? data.error || data : resp.statusText || "unknown";
    }
  }
});

// ../../node_modules/arweave/web/lib/deepHash.js
var require_deepHash = __commonJS({
  "../../node_modules/arweave/web/lib/deepHash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = deepHash;
    var common_1 = require_common3();
    async function deepHash(data) {
      if (Array.isArray(data)) {
        const tag2 = common_1.default.utils.concatBuffers([
          common_1.default.utils.stringToBuffer("list"),
          common_1.default.utils.stringToBuffer(data.length.toString())
        ]);
        return await deepHashChunks(data, await common_1.default.crypto.hash(tag2, "SHA-384"));
      }
      const tag = common_1.default.utils.concatBuffers([
        common_1.default.utils.stringToBuffer("blob"),
        common_1.default.utils.stringToBuffer(data.byteLength.toString())
      ]);
      const taggedHash = common_1.default.utils.concatBuffers([
        await common_1.default.crypto.hash(tag, "SHA-384"),
        await common_1.default.crypto.hash(data, "SHA-384")
      ]);
      return await common_1.default.crypto.hash(taggedHash, "SHA-384");
    }
    async function deepHashChunks(chunks, acc) {
      if (chunks.length < 1) {
        return acc;
      }
      const hashPair = common_1.default.utils.concatBuffers([
        acc,
        await deepHash(chunks[0])
      ]);
      const newAcc = await common_1.default.crypto.hash(hashPair, "SHA-384");
      return await deepHashChunks(chunks.slice(1), newAcc);
    }
  }
});

// ../../node_modules/arweave/web/lib/merkle.js
var require_merkle = __commonJS({
  "../../node_modules/arweave/web/lib/merkle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.arrayCompare = exports2.MIN_CHUNK_SIZE = exports2.MAX_CHUNK_SIZE = void 0;
    exports2.chunkData = chunkData;
    exports2.generateLeaves = generateLeaves;
    exports2.computeRootHash = computeRootHash;
    exports2.generateTree = generateTree;
    exports2.generateTransactionChunks = generateTransactionChunks;
    exports2.buildLayers = buildLayers;
    exports2.generateProofs = generateProofs;
    exports2.arrayFlatten = arrayFlatten;
    exports2.intToBuffer = intToBuffer;
    exports2.bufferToInt = bufferToInt;
    exports2.validatePath = validatePath;
    exports2.debug = debug;
    var common_1 = require_common3();
    var utils_1 = require_utils5();
    exports2.MAX_CHUNK_SIZE = 256 * 1024;
    exports2.MIN_CHUNK_SIZE = 32 * 1024;
    var NOTE_SIZE = 32;
    var HASH_SIZE = 32;
    async function chunkData(data) {
      let chunks = [];
      let rest = data;
      let cursor = 0;
      while (rest.byteLength >= exports2.MAX_CHUNK_SIZE) {
        let chunkSize = exports2.MAX_CHUNK_SIZE;
        let nextChunkSize = rest.byteLength - exports2.MAX_CHUNK_SIZE;
        if (nextChunkSize > 0 && nextChunkSize < exports2.MIN_CHUNK_SIZE) {
          chunkSize = Math.ceil(rest.byteLength / 2);
        }
        const chunk = rest.slice(0, chunkSize);
        const dataHash = await common_1.default.crypto.hash(chunk);
        cursor += chunk.byteLength;
        chunks.push({
          dataHash,
          minByteRange: cursor - chunk.byteLength,
          maxByteRange: cursor
        });
        rest = rest.slice(chunkSize);
      }
      chunks.push({
        dataHash: await common_1.default.crypto.hash(rest),
        minByteRange: cursor,
        maxByteRange: cursor + rest.byteLength
      });
      return chunks;
    }
    async function generateLeaves(chunks) {
      return Promise.all(chunks.map(async ({ dataHash, minByteRange, maxByteRange }) => {
        return {
          type: "leaf",
          id: await hash3(await Promise.all([hash3(dataHash), hash3(intToBuffer(maxByteRange))])),
          dataHash,
          minByteRange,
          maxByteRange
        };
      }));
    }
    async function computeRootHash(data) {
      const rootNode = await generateTree(data);
      return rootNode.id;
    }
    async function generateTree(data) {
      const rootNode = await buildLayers(await generateLeaves(await chunkData(data)));
      return rootNode;
    }
    async function generateTransactionChunks(data) {
      const chunks = await chunkData(data);
      const leaves = await generateLeaves(chunks);
      const root = await buildLayers(leaves);
      const proofs = await generateProofs(root);
      const lastChunk = chunks.slice(-1)[0];
      if (lastChunk.maxByteRange - lastChunk.minByteRange === 0) {
        chunks.splice(chunks.length - 1, 1);
        proofs.splice(proofs.length - 1, 1);
      }
      return {
        data_root: root.id,
        chunks,
        proofs
      };
    }
    async function buildLayers(nodes, level = 0) {
      if (nodes.length < 2) {
        const root = nodes[0];
        return root;
      }
      const nextLayer = [];
      for (let i2 = 0; i2 < nodes.length; i2 += 2) {
        nextLayer.push(await hashBranch(nodes[i2], nodes[i2 + 1]));
      }
      return buildLayers(nextLayer, level + 1);
    }
    function generateProofs(root) {
      const proofs = resolveBranchProofs(root);
      if (!Array.isArray(proofs)) {
        return [proofs];
      }
      return arrayFlatten(proofs);
    }
    function resolveBranchProofs(node, proof = new Uint8Array(), depth = 0) {
      if (node.type == "leaf") {
        return {
          offset: node.maxByteRange - 1,
          proof: (0, utils_1.concatBuffers)([
            proof,
            node.dataHash,
            intToBuffer(node.maxByteRange)
          ])
        };
      }
      if (node.type == "branch") {
        const partialProof = (0, utils_1.concatBuffers)([
          proof,
          node.leftChild.id,
          node.rightChild.id,
          intToBuffer(node.byteRange)
        ]);
        return [
          resolveBranchProofs(node.leftChild, partialProof, depth + 1),
          resolveBranchProofs(node.rightChild, partialProof, depth + 1)
        ];
      }
      throw new Error(`Unexpected node type`);
    }
    function arrayFlatten(input) {
      const flat = [];
      input.forEach((item) => {
        if (Array.isArray(item)) {
          flat.push(...arrayFlatten(item));
        } else {
          flat.push(item);
        }
      });
      return flat;
    }
    async function hashBranch(left, right) {
      if (!right) {
        return left;
      }
      let branch = {
        type: "branch",
        id: await hash3([
          await hash3(left.id),
          await hash3(right.id),
          await hash3(intToBuffer(left.maxByteRange))
        ]),
        byteRange: left.maxByteRange,
        maxByteRange: right.maxByteRange,
        leftChild: left,
        rightChild: right
      };
      return branch;
    }
    async function hash3(data) {
      if (Array.isArray(data)) {
        data = common_1.default.utils.concatBuffers(data);
      }
      return new Uint8Array(await common_1.default.crypto.hash(data));
    }
    function intToBuffer(note) {
      const buffer = new Uint8Array(NOTE_SIZE);
      for (var i2 = buffer.length - 1; i2 >= 0; i2--) {
        var byte = note % 256;
        buffer[i2] = byte;
        note = (note - byte) / 256;
      }
      return buffer;
    }
    function bufferToInt(buffer) {
      let value = 0;
      for (var i2 = 0; i2 < buffer.length; i2++) {
        value *= 256;
        value += buffer[i2];
      }
      return value;
    }
    var arrayCompare = (a2, b2) => a2.every((value, index) => b2[index] === value);
    exports2.arrayCompare = arrayCompare;
    async function validatePath(id2, dest, leftBound, rightBound, path) {
      if (rightBound <= 0) {
        return false;
      }
      if (dest >= rightBound) {
        return validatePath(id2, 0, rightBound - 1, rightBound, path);
      }
      if (dest < 0) {
        return validatePath(id2, 0, 0, rightBound, path);
      }
      if (path.length == HASH_SIZE + NOTE_SIZE) {
        const pathData = path.slice(0, HASH_SIZE);
        const endOffsetBuffer = path.slice(pathData.length, pathData.length + NOTE_SIZE);
        const pathDataHash = await hash3([
          await hash3(pathData),
          await hash3(endOffsetBuffer)
        ]);
        let result = (0, exports2.arrayCompare)(id2, pathDataHash);
        if (result) {
          return {
            offset: rightBound - 1,
            leftBound,
            rightBound,
            chunkSize: rightBound - leftBound
          };
        }
        return false;
      }
      const left = path.slice(0, HASH_SIZE);
      const right = path.slice(left.length, left.length + HASH_SIZE);
      const offsetBuffer = path.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
      const offset = bufferToInt(offsetBuffer);
      const remainder = path.slice(left.length + right.length + offsetBuffer.length);
      const pathHash = await hash3([
        await hash3(left),
        await hash3(right),
        await hash3(offsetBuffer)
      ]);
      if ((0, exports2.arrayCompare)(id2, pathHash)) {
        if (dest < offset) {
          return await validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder);
        }
        return await validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder);
      }
      return false;
    }
    async function debug(proof, output = "") {
      if (proof.byteLength < 1) {
        return output;
      }
      const left = proof.slice(0, HASH_SIZE);
      const right = proof.slice(left.length, left.length + HASH_SIZE);
      const offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
      const offset = bufferToInt(offsetBuffer);
      const remainder = proof.slice(left.length + right.length + offsetBuffer.length);
      const pathHash = await hash3([
        await hash3(left),
        await hash3(right),
        await hash3(offsetBuffer)
      ]);
      const updatedOutput = `${output}
${JSON.stringify(Buffer.from(left))},${JSON.stringify(Buffer.from(right))},${offset} => ${JSON.stringify(pathHash)}`;
      return debug(remainder, updatedOutput);
    }
  }
});

// ../../node_modules/arweave/web/lib/transaction.js
var require_transaction = __commonJS({
  "../../node_modules/arweave/web/lib/transaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tag = void 0;
    var ArweaveUtils = require_utils5();
    var deepHash_1 = require_deepHash();
    var merkle_1 = require_merkle();
    var BaseObject = class {
      get(field, options) {
        if (!Object.getOwnPropertyNames(this).includes(field)) {
          throw new Error(`Field "${field}" is not a property of the Arweave Transaction class.`);
        }
        if (this[field] instanceof Uint8Array) {
          if (options && options.decode && options.string) {
            return ArweaveUtils.bufferToString(this[field]);
          }
          if (options && options.decode && !options.string) {
            return this[field];
          }
          return ArweaveUtils.bufferTob64Url(this[field]);
        }
        if (this[field] instanceof Array) {
          if ((options == null ? void 0 : options.decode) !== void 0 || (options == null ? void 0 : options.string) !== void 0) {
            if (field === "tags") {
              console.warn(`Did you mean to use 'transaction["tags"]' ?`);
            }
            throw new Error(`Cannot decode or stringify an array.`);
          }
          return this[field];
        }
        if (options && options.decode == true) {
          if (options && options.string) {
            return ArweaveUtils.b64UrlToString(this[field]);
          }
          return ArweaveUtils.b64UrlToBuffer(this[field]);
        }
        return this[field];
      }
    };
    var Tag = class extends BaseObject {
      constructor(name2, value, decode8 = false) {
        super();
        __publicField(this, "name");
        __publicField(this, "value");
        this.name = name2;
        this.value = value;
      }
    };
    exports2.Tag = Tag;
    var Transaction = class extends BaseObject {
      constructor(attributes = {}) {
        super();
        __publicField(this, "format", 2);
        __publicField(this, "id", "");
        __publicField(this, "last_tx", "");
        __publicField(this, "owner", "");
        __publicField(this, "tags", []);
        __publicField(this, "target", "");
        __publicField(this, "quantity", "0");
        __publicField(this, "data_size", "0");
        __publicField(this, "data", new Uint8Array());
        __publicField(this, "data_root", "");
        __publicField(this, "reward", "0");
        __publicField(this, "signature", "");
        // Computed when needed.
        __publicField(this, "chunks");
        Object.assign(this, attributes);
        if (typeof this.data === "string") {
          this.data = ArweaveUtils.b64UrlToBuffer(this.data);
        }
        if (attributes.tags) {
          this.tags = attributes.tags.map((tag) => {
            return new Tag(tag.name, tag.value);
          });
        }
      }
      addTag(name2, value) {
        this.tags.push(new Tag(ArweaveUtils.stringToB64Url(name2), ArweaveUtils.stringToB64Url(value)));
      }
      toJSON() {
        return {
          format: this.format,
          id: this.id,
          last_tx: this.last_tx,
          owner: this.owner,
          tags: this.tags,
          target: this.target,
          quantity: this.quantity,
          data: ArweaveUtils.bufferTob64Url(this.data),
          data_size: this.data_size,
          data_root: this.data_root,
          data_tree: this.data_tree,
          reward: this.reward,
          signature: this.signature
        };
      }
      setOwner(owner) {
        this.owner = owner;
      }
      setSignature({ id: id2, owner, reward, tags, signature }) {
        this.id = id2;
        this.owner = owner;
        if (reward)
          this.reward = reward;
        if (tags)
          this.tags = tags;
        this.signature = signature;
      }
      async prepareChunks(data) {
        if (!this.chunks && data.byteLength > 0) {
          this.chunks = await (0, merkle_1.generateTransactionChunks)(data);
          this.data_root = ArweaveUtils.bufferTob64Url(this.chunks.data_root);
        }
        if (!this.chunks && data.byteLength === 0) {
          this.chunks = {
            chunks: [],
            data_root: new Uint8Array(),
            proofs: []
          };
          this.data_root = "";
        }
      }
      // Returns a chunk in a format suitable for posting to /chunk.
      // Similar to `prepareChunks()` this does not operate `this.data`,
      // instead using the data passed in.
      getChunk(idx, data) {
        if (!this.chunks) {
          throw new Error(`Chunks have not been prepared`);
        }
        const proof = this.chunks.proofs[idx];
        const chunk = this.chunks.chunks[idx];
        return {
          data_root: this.data_root,
          data_size: this.data_size,
          data_path: ArweaveUtils.bufferTob64Url(proof.proof),
          offset: proof.offset.toString(),
          chunk: ArweaveUtils.bufferTob64Url(data.slice(chunk.minByteRange, chunk.maxByteRange))
        };
      }
      async getSignatureData() {
        switch (this.format) {
          case 1:
            let tags = this.tags.reduce((accumulator, tag) => {
              return ArweaveUtils.concatBuffers([
                accumulator,
                tag.get("name", { decode: true, string: false }),
                tag.get("value", { decode: true, string: false })
              ]);
            }, new Uint8Array());
            return ArweaveUtils.concatBuffers([
              this.get("owner", { decode: true, string: false }),
              this.get("target", { decode: true, string: false }),
              this.get("data", { decode: true, string: false }),
              ArweaveUtils.stringToBuffer(this.quantity),
              ArweaveUtils.stringToBuffer(this.reward),
              this.get("last_tx", { decode: true, string: false }),
              tags
            ]);
          case 2:
            if (!this.data_root) {
              await this.prepareChunks(this.data);
            }
            const tagList = this.tags.map((tag) => [
              tag.get("name", { decode: true, string: false }),
              tag.get("value", { decode: true, string: false })
            ]);
            return await (0, deepHash_1.default)([
              ArweaveUtils.stringToBuffer(this.format.toString()),
              this.get("owner", { decode: true, string: false }),
              this.get("target", { decode: true, string: false }),
              ArweaveUtils.stringToBuffer(this.quantity),
              ArweaveUtils.stringToBuffer(this.reward),
              this.get("last_tx", { decode: true, string: false }),
              tagList,
              ArweaveUtils.stringToBuffer(this.data_size),
              this.get("data_root", { decode: true, string: false })
            ]);
          default:
            throw new Error(`Unexpected transaction format: ${this.format}`);
        }
      }
    };
    exports2.default = Transaction;
  }
});

// ../../node_modules/arweave/web/lib/transaction-uploader.js
var require_transaction_uploader = __commonJS({
  "../../node_modules/arweave/web/lib/transaction-uploader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionUploader = void 0;
    var transaction_1 = require_transaction();
    var ArweaveUtils = require_utils5();
    var error_1 = require_error();
    var merkle_1 = require_merkle();
    var MAX_CHUNKS_IN_BODY = 1;
    var FATAL_CHUNK_UPLOAD_ERRORS = [
      "invalid_json",
      "chunk_too_big",
      "data_path_too_big",
      "offset_too_big",
      "data_size_too_big",
      "chunk_proof_ratio_not_attractive",
      "invalid_proof"
    ];
    var ERROR_DELAY = 1e3 * 40;
    var TransactionUploader = class _TransactionUploader {
      constructor(api, transaction) {
        __publicField(this, "api");
        __publicField(this, "chunkIndex", 0);
        __publicField(this, "txPosted", false);
        __publicField(this, "transaction");
        __publicField(this, "lastRequestTimeEnd", 0);
        __publicField(this, "totalErrors", 0);
        // Not serialized.
        __publicField(this, "data");
        __publicField(this, "lastResponseStatus", 0);
        __publicField(this, "lastResponseError", "");
        this.api = api;
        if (!transaction.id) {
          throw new Error(`Transaction is not signed`);
        }
        if (!transaction.chunks) {
          throw new Error(`Transaction chunks not prepared`);
        }
        this.data = transaction.data;
        this.transaction = new transaction_1.default(Object.assign({}, transaction, { data: new Uint8Array(0) }));
      }
      get isComplete() {
        return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
      }
      get totalChunks() {
        return this.transaction.chunks.chunks.length;
      }
      get uploadedChunks() {
        return this.chunkIndex;
      }
      get pctComplete() {
        return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
      }
      /**
       * Uploads the next part of the transaction.
       * On the first call this posts the transaction
       * itself and on any subsequent calls uploads the
       * next chunk until it completes.
       */
      async uploadChunk(chunkIndex_) {
        if (this.isComplete) {
          throw new Error(`Upload is already complete`);
        }
        if (this.lastResponseError !== "") {
          this.totalErrors++;
        } else {
          this.totalErrors = 0;
        }
        if (this.totalErrors === 100) {
          throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
        }
        let delay = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);
        if (delay > 0) {
          delay = delay - delay * Math.random() * 0.3;
          await new Promise((res) => setTimeout(res, delay));
        }
        this.lastResponseError = "";
        if (!this.txPosted) {
          await this.postTransaction();
          return;
        }
        if (chunkIndex_) {
          this.chunkIndex = chunkIndex_;
        }
        const chunk = this.transaction.getChunk(chunkIndex_ || this.chunkIndex, this.data);
        const chunkOk = await (0, merkle_1.validatePath)(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));
        if (!chunkOk) {
          throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
        }
        const resp = await this.api.post(`chunk`, this.transaction.getChunk(this.chunkIndex, this.data)).catch((e2) => {
          console.error(e2.message);
          return { status: -1, data: { error: e2.message } };
        });
        this.lastRequestTimeEnd = Date.now();
        this.lastResponseStatus = resp.status;
        if (this.lastResponseStatus == 200) {
          this.chunkIndex++;
        } else {
          this.lastResponseError = (0, error_1.getError)(resp);
          if (FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {
            throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
          }
        }
      }
      /**
       * Reconstructs an upload from its serialized state and data.
       * Checks if data matches the expected data_root.
       *
       * @param serialized
       * @param data
       */
      static async fromSerialized(api, serialized, data) {
        if (!serialized || typeof serialized.chunkIndex !== "number" || typeof serialized.transaction !== "object") {
          throw new Error(`Serialized object does not match expected format.`);
        }
        var transaction = new transaction_1.default(serialized.transaction);
        if (!transaction.chunks) {
          await transaction.prepareChunks(data);
        }
        const upload = new _TransactionUploader(api, transaction);
        upload.chunkIndex = serialized.chunkIndex;
        upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;
        upload.lastResponseError = serialized.lastResponseError;
        upload.lastResponseStatus = serialized.lastResponseStatus;
        upload.txPosted = serialized.txPosted;
        upload.data = data;
        if (upload.transaction.data_root !== serialized.transaction.data_root) {
          throw new Error(`Data mismatch: Uploader doesn't match provided data.`);
        }
        return upload;
      }
      /**
       * Reconstruct an upload from the tx metadata, ie /tx/<id>.
       *
       * @param api
       * @param id
       * @param data
       */
      static async fromTransactionId(api, id2) {
        const resp = await api.get(`tx/${id2}`);
        if (resp.status !== 200) {
          throw new Error(`Tx ${id2} not found: ${resp.status}`);
        }
        const transaction = resp.data;
        transaction.data = new Uint8Array(0);
        const serialized = {
          txPosted: true,
          chunkIndex: 0,
          lastResponseError: "",
          lastRequestTimeEnd: 0,
          lastResponseStatus: 0,
          transaction
        };
        return serialized;
      }
      toJSON() {
        return {
          chunkIndex: this.chunkIndex,
          transaction: this.transaction,
          lastRequestTimeEnd: this.lastRequestTimeEnd,
          lastResponseStatus: this.lastResponseStatus,
          lastResponseError: this.lastResponseError,
          txPosted: this.txPosted
        };
      }
      // POST to /tx
      async postTransaction() {
        const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;
        if (uploadInBody) {
          this.transaction.data = this.data;
          const resp2 = await this.api.post(`tx`, this.transaction).catch((e2) => {
            console.error(e2);
            return { status: -1, data: { error: e2.message } };
          });
          this.lastRequestTimeEnd = Date.now();
          this.lastResponseStatus = resp2.status;
          this.transaction.data = new Uint8Array(0);
          if (resp2.status >= 200 && resp2.status < 300) {
            this.txPosted = true;
            this.chunkIndex = MAX_CHUNKS_IN_BODY;
            return;
          }
          this.lastResponseError = (0, error_1.getError)(resp2);
          throw new Error(`Unable to upload transaction: ${resp2.status}, ${this.lastResponseError}`);
        }
        const resp = await this.api.post(`tx`, this.transaction);
        this.lastRequestTimeEnd = Date.now();
        this.lastResponseStatus = resp.status;
        if (!(resp.status >= 200 && resp.status < 300)) {
          this.lastResponseError = (0, error_1.getError)(resp);
          throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);
        }
        this.txPosted = true;
      }
    };
    exports2.TransactionUploader = TransactionUploader;
  }
});

// ../../node_modules/arconnect/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  default: () => index_es_default
});
var index_es_default;
var init_index_es = __esm({
  "../../node_modules/arconnect/index.es.js"() {
    index_es_default = {};
  }
});

// ../../node_modules/arweave/web/transactions.js
var require_transactions = __commonJS({
  "../../node_modules/arweave/web/transactions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var error_1 = require_error();
    var transaction_1 = require_transaction();
    var ArweaveUtils = require_utils5();
    var transaction_uploader_1 = require_transaction_uploader();
    init_index_es();
    var Transactions = class {
      constructor(api, crypto2, chunks) {
        __publicField(this, "api");
        __publicField(this, "crypto");
        __publicField(this, "chunks");
        this.api = api;
        this.crypto = crypto2;
        this.chunks = chunks;
      }
      async getTransactionAnchor() {
        const res = await this.api.get(`tx_anchor`);
        if (!res.data.match(/^[a-z0-9_-]{43,}/i) || !res.ok) {
          throw new Error(`Could not getTransactionAnchor. Received: ${res.data}. Status: ${res.status}, ${res.statusText}`);
        }
        return res.data;
      }
      async getPrice(byteSize, targetAddress) {
        let endpoint = targetAddress ? `price/${byteSize}/${targetAddress}` : `price/${byteSize}`;
        const res = await this.api.get(endpoint);
        if (!/^\d+$/.test(res.data) || !res.ok) {
          throw new Error(`Could not getPrice. Received: ${res.data}. Status: ${res.status}, ${res.statusText}`);
        }
        return res.data;
      }
      async get(id2) {
        const response = await this.api.get(`tx/${id2}`);
        if (response.status == 200) {
          const data_size = parseInt(response.data.data_size);
          if (response.data.format >= 2 && data_size > 0 && data_size <= 1024 * 1024 * 12) {
            const data = await this.getData(id2);
            return new transaction_1.default({
              ...response.data,
              data
            });
          }
          return new transaction_1.default({
            ...response.data,
            format: response.data.format || 1
          });
        }
        if (response.status == 404) {
          throw new error_1.default(
            "TX_NOT_FOUND"
            /* ArweaveErrorType.TX_NOT_FOUND */
          );
        }
        if (response.status == 410) {
          throw new error_1.default(
            "TX_FAILED"
            /* ArweaveErrorType.TX_FAILED */
          );
        }
        throw new error_1.default(
          "TX_INVALID"
          /* ArweaveErrorType.TX_INVALID */
        );
      }
      fromRaw(attributes) {
        return new transaction_1.default(attributes);
      }
      /** @deprecated use GQL https://gql-guide.arweave.net */
      async search(tagName, tagValue) {
        return this.api.post(`arql`, {
          op: "equals",
          expr1: tagName,
          expr2: tagValue
        }).then((response) => {
          if (!response.data) {
            return [];
          }
          return response.data;
        });
      }
      getStatus(id2) {
        return this.api.get(`tx/${id2}/status`).then((response) => {
          if (response.status == 200) {
            return {
              status: 200,
              confirmed: response.data
            };
          }
          return {
            status: response.status,
            confirmed: null
          };
        });
      }
      async getData(id2, options) {
        let data = void 0;
        try {
          data = await this.chunks.downloadChunkedData(id2);
        } catch (error) {
          console.error(`Error while trying to download chunked data for ${id2}`);
          console.error(error);
        }
        if (!data) {
          console.warn(`Falling back to gateway cache for ${id2}`);
          try {
            const { data: resData, ok, status, statusText } = await this.api.get(`/${id2}`, { responseType: "arraybuffer" });
            if (!ok) {
              throw new Error(`Bad http status code`, {
                cause: { status, statusText }
              });
            }
            data = resData;
          } catch (error) {
            console.error(`Error while trying to download contiguous data from gateway cache for ${id2}`);
            console.error(error);
          }
        }
        if (!data) {
          throw new Error(`${id2} data was not found!`);
        }
        if (options && options.decode && !options.string) {
          return data;
        }
        if (options && options.decode && options.string) {
          return ArweaveUtils.bufferToString(data);
        }
        return ArweaveUtils.bufferTob64Url(data);
      }
      async sign(transaction, jwk, options) {
        const isJwk = (obj) => {
          let valid = true;
          ["n", "e", "d", "p", "q", "dp", "dq", "qi"].map((key) => !(key in obj) && (valid = false));
          return valid;
        };
        const validJwk = typeof jwk === "object" && isJwk(jwk);
        const externalWallet = typeof arweaveWallet === "object";
        if (!validJwk && !externalWallet) {
          throw new Error(`No valid JWK or external wallet found to sign transaction.`);
        } else if (validJwk) {
          transaction.setOwner(jwk.n);
          let dataToSign = await transaction.getSignatureData();
          let rawSignature = await this.crypto.sign(jwk, dataToSign, options);
          let id2 = await this.crypto.hash(rawSignature);
          transaction.setSignature({
            id: ArweaveUtils.bufferTob64Url(id2),
            owner: jwk.n,
            signature: ArweaveUtils.bufferTob64Url(rawSignature)
          });
        } else if (externalWallet) {
          try {
            const existingPermissions = await arweaveWallet.getPermissions();
            if (!existingPermissions.includes("SIGN_TRANSACTION"))
              await arweaveWallet.connect(["SIGN_TRANSACTION"]);
          } catch {
          }
          const signedTransaction = await arweaveWallet.sign(transaction, options);
          transaction.setSignature({
            id: signedTransaction.id,
            owner: signedTransaction.owner,
            reward: signedTransaction.reward,
            tags: signedTransaction.tags,
            signature: signedTransaction.signature
          });
        } else {
          throw new Error(`An error occurred while signing. Check wallet is valid`);
        }
      }
      async verify(transaction) {
        const signaturePayload = await transaction.getSignatureData();
        const rawSignature = transaction.get("signature", {
          decode: true,
          string: false
        });
        const expectedId = ArweaveUtils.bufferTob64Url(await this.crypto.hash(rawSignature));
        if (transaction.id !== expectedId) {
          throw new Error(`Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.`);
        }
        return this.crypto.verify(transaction.owner, signaturePayload, rawSignature);
      }
      async post(transaction) {
        if (typeof transaction === "string") {
          transaction = new transaction_1.default(JSON.parse(transaction));
        } else if (typeof transaction.readInt32BE === "function") {
          transaction = new transaction_1.default(JSON.parse(transaction.toString()));
        } else if (typeof transaction === "object" && !(transaction instanceof transaction_1.default)) {
          transaction = new transaction_1.default(transaction);
        }
        if (!(transaction instanceof transaction_1.default)) {
          throw new Error(`Must be Transaction object`);
        }
        if (!transaction.chunks) {
          await transaction.prepareChunks(transaction.data);
        }
        const uploader = await this.getUploader(transaction, transaction.data);
        try {
          while (!uploader.isComplete) {
            await uploader.uploadChunk();
          }
        } catch (e2) {
          if (uploader.lastResponseStatus > 0) {
            return {
              status: uploader.lastResponseStatus,
              statusText: uploader.lastResponseError,
              data: {
                error: uploader.lastResponseError
              }
            };
          }
          throw e2;
        }
        return {
          status: 200,
          statusText: "OK",
          data: {}
        };
      }
      /**
       * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress
       * and the ability to resume.
       *
       * Usage example:
       *
       * ```
       * const uploader = arweave.transactions.getUploader(transaction);
       * while (!uploader.isComplete) {
       *   await uploader.uploadChunk();
       *   console.log(`${uploader.pctComplete}%`);
       * }
       * ```
       *
       * @param upload a Transaction object, a previously save progress object, or a transaction id.
       * @param data the data of the transaction. Required when resuming an upload.
       */
      async getUploader(upload, data) {
        let uploader;
        if (data instanceof ArrayBuffer) {
          data = new Uint8Array(data);
        }
        if (upload instanceof transaction_1.default) {
          if (!data) {
            data = upload.data;
          }
          if (!(data instanceof Uint8Array)) {
            throw new Error("Data format is invalid");
          }
          if (!upload.chunks) {
            await upload.prepareChunks(data);
          }
          uploader = new transaction_uploader_1.TransactionUploader(this.api, upload);
          if (!uploader.data || uploader.data.length === 0) {
            uploader.data = data;
          }
        } else {
          if (typeof upload === "string") {
            upload = await transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload);
          }
          if (!data || !(data instanceof Uint8Array)) {
            throw new Error(`Must provide data when resuming upload`);
          }
          uploader = await transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);
        }
        return uploader;
      }
      /**
       * Async generator version of uploader
       *
       * Usage example:
       *
       * ```
       * for await (const uploader of arweave.transactions.upload(tx)) {
       *  console.log(`${uploader.pctComplete}%`);
       * }
       * ```
       *
       * @param upload a Transaction object, a previously save uploader, or a transaction id.
       * @param data the data of the transaction. Required when resuming an upload.
       */
      async *upload(upload, data) {
        const uploader = await this.getUploader(upload, data);
        while (!uploader.isComplete) {
          await uploader.uploadChunk();
          yield uploader;
        }
        return uploader;
      }
    };
    exports2.default = Transactions;
  }
});

// ../../node_modules/arweave/web/wallets.js
var require_wallets = __commonJS({
  "../../node_modules/arweave/web/wallets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ArweaveUtils = require_utils5();
    init_index_es();
    var Wallets = class {
      constructor(api, crypto2) {
        __publicField(this, "api");
        __publicField(this, "crypto");
        this.api = api;
        this.crypto = crypto2;
      }
      /**
       * Get the wallet balance for the given address.
       *
       * @param {string} address - The arweave address to get the balance for.
       *
       * @returns {Promise<string>} - Promise which resolves with a winston string balance.
       */
      getBalance(address) {
        return this.api.get(`wallet/${address}/balance`).then((response) => {
          return response.data;
        });
      }
      /**
       * Get the last transaction ID for the given wallet address.
       *
       * @param {string} address - The arweave address to get the transaction for.
       *
       * @returns {Promise<string>} - Promise which resolves with a transaction ID.
       */
      getLastTransactionID(address) {
        return this.api.get(`wallet/${address}/last_tx`).then((response) => {
          return response.data;
        });
      }
      generate() {
        return this.crypto.generateJWK();
      }
      async jwkToAddress(jwk) {
        if (!jwk || jwk === "use_wallet") {
          return this.getAddress();
        } else {
          return this.getAddress(jwk);
        }
      }
      async getAddress(jwk) {
        if (!jwk || jwk === "use_wallet") {
          try {
            await arweaveWallet.connect(["ACCESS_ADDRESS"]);
          } catch {
          }
          return arweaveWallet.getActiveAddress();
        } else {
          return this.ownerToAddress(jwk.n);
        }
      }
      async ownerToAddress(owner) {
        return ArweaveUtils.bufferTob64Url(await this.crypto.hash(ArweaveUtils.b64UrlToBuffer(owner)));
      }
    };
    exports2.default = Wallets;
  }
});

// ../../node_modules/arweave/web/silo.js
var require_silo = __commonJS({
  "../../node_modules/arweave/web/silo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SiloResource = void 0;
    var ArweaveUtils = require_utils5();
    var Silo = class {
      constructor(api, crypto2, transactions) {
        __publicField(this, "api");
        __publicField(this, "crypto");
        __publicField(this, "transactions");
        this.api = api;
        this.crypto = crypto2;
        this.transactions = transactions;
      }
      async get(siloURI) {
        if (!siloURI) {
          throw new Error(`No Silo URI specified`);
        }
        const resource = await this.parseUri(siloURI);
        const ids = await this.transactions.search("Silo-Name", resource.getAccessKey());
        if (ids.length == 0) {
          throw new Error(`No data could be found for the Silo URI: ${siloURI}`);
        }
        const transaction = await this.transactions.get(ids[0]);
        if (!transaction) {
          throw new Error(`No data could be found for the Silo URI: ${siloURI}`);
        }
        const encrypted = transaction.get("data", { decode: true, string: false });
        return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
      }
      async readTransactionData(transaction, siloURI) {
        if (!siloURI) {
          throw new Error(`No Silo URI specified`);
        }
        const resource = await this.parseUri(siloURI);
        const encrypted = transaction.get("data", { decode: true, string: false });
        return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
      }
      async parseUri(siloURI) {
        const parsed = siloURI.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
        if (!parsed) {
          throw new Error(`Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'`);
        }
        const siloName = parsed[1];
        const hashIterations = Math.pow(2, parseInt(parsed[2]));
        const digest2 = await this.hash(ArweaveUtils.stringToBuffer(siloName), hashIterations);
        const accessKey = ArweaveUtils.bufferTob64(digest2.slice(0, 15));
        const encryptionkey = await this.hash(digest2.slice(16, 31), 1);
        return new SiloResource(siloURI, accessKey, encryptionkey);
      }
      async hash(input, iterations) {
        let digest2 = await this.crypto.hash(input);
        for (let count = 0; count < iterations - 1; count++) {
          digest2 = await this.crypto.hash(digest2);
        }
        return digest2;
      }
    };
    exports2.default = Silo;
    var SiloResource = class {
      constructor(uri, accessKey, encryptionKey) {
        __publicField(this, "uri");
        __publicField(this, "accessKey");
        __publicField(this, "encryptionKey");
        this.uri = uri;
        this.accessKey = accessKey;
        this.encryptionKey = encryptionKey;
      }
      getUri() {
        return this.uri;
      }
      getAccessKey() {
        return this.accessKey;
      }
      getEncryptionKey() {
        return this.encryptionKey;
      }
    };
    exports2.SiloResource = SiloResource;
  }
});

// ../../node_modules/arweave/web/chunks.js
var require_chunks = __commonJS({
  "../../node_modules/arweave/web/chunks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var error_1 = require_error();
    var ArweaveUtils = require_utils5();
    var Chunks = class {
      constructor(api) {
        __publicField(this, "api");
        this.api = api;
      }
      async getTransactionOffset(id2) {
        const resp = await this.api.get(`tx/${id2}/offset`);
        if (resp.status === 200) {
          return resp.data;
        }
        throw new Error(`Unable to get transaction offset: ${(0, error_1.getError)(resp)}`);
      }
      async getChunk(offset) {
        const resp = await this.api.get(`chunk/${offset}`);
        if (resp.status === 200) {
          return resp.data;
        }
        throw new Error(`Unable to get chunk: ${(0, error_1.getError)(resp)}`);
      }
      async getChunkData(offset) {
        const chunk = await this.getChunk(offset);
        const buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);
        return buf;
      }
      firstChunkOffset(offsetResponse) {
        return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;
      }
      async downloadChunkedData(id2) {
        const offsetResponse = await this.getTransactionOffset(id2);
        const size = parseInt(offsetResponse.size);
        const endOffset = parseInt(offsetResponse.offset);
        const startOffset = endOffset - size + 1;
        const data = new Uint8Array(size);
        let byte = 0;
        while (byte < size) {
          if (this.api.config.logging) {
            console.log(`[chunk] ${byte}/${size}`);
          }
          let chunkData;
          try {
            chunkData = await this.getChunkData(startOffset + byte);
          } catch (error) {
            console.error(`[chunk] Failed to fetch chunk at offset ${startOffset + byte}`);
            console.error(`[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node`);
          }
          if (chunkData) {
            data.set(chunkData, byte);
            byte += chunkData.length;
          } else {
            throw new Error(`Couldn't complete data download at ${byte}/${size}`);
          }
        }
        return data;
      }
    };
    exports2.default = Chunks;
  }
});

// ../../node_modules/arweave/web/blocks.js
var require_blocks = __commonJS({
  "../../node_modules/arweave/web/blocks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var error_1 = require_error();
    init_index_es();
    var _Blocks = class _Blocks {
      constructor(api, network) {
        __publicField(this, "api");
        __publicField(this, "network");
        this.api = api;
        this.network = network;
      }
      /**
       * Gets a block by its "indep_hash"
       */
      async get(indepHash) {
        const response = await this.api.get(`${_Blocks.HASH_ENDPOINT}${indepHash}`);
        if (response.status === 200) {
          return response.data;
        } else {
          if (response.status === 404) {
            throw new error_1.default(
              "BLOCK_NOT_FOUND"
              /* ArweaveErrorType.BLOCK_NOT_FOUND */
            );
          } else {
            throw new Error(`Error while loading block data: ${response}`);
          }
        }
      }
      /**
       * Gets a block by its "height"
       */
      async getByHeight(height) {
        const response = await this.api.get(`${_Blocks.HEIGHT_ENDPOINT}${height}`);
        if (response.status === 200) {
          return response.data;
        } else {
          if (response.status === 404) {
            throw new error_1.default(
              "BLOCK_NOT_FOUND"
              /* ArweaveErrorType.BLOCK_NOT_FOUND */
            );
          } else {
            throw new Error(`Error while loading block data: ${response}`);
          }
        }
      }
      /**
       * Gets current block data (ie. block with indep_hash = Network.getInfo().current)
       */
      async getCurrent() {
        const { current } = await this.network.getInfo();
        return await this.get(current);
      }
    };
    __publicField(_Blocks, "HASH_ENDPOINT", "block/hash/");
    __publicField(_Blocks, "HEIGHT_ENDPOINT", "block/height/");
    var Blocks = _Blocks;
    exports2.default = Blocks;
  }
});

// ../../node_modules/arweave/web/common.js
var require_common3 = __commonJS({
  "../../node_modules/arweave/web/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ar_1 = require_ar();
    var api_1 = require_api2();
    var node_driver_1 = require_webcrypto_driver();
    var network_1 = require_network();
    var transactions_1 = require_transactions();
    var wallets_1 = require_wallets();
    var transaction_1 = require_transaction();
    var ArweaveUtils = require_utils5();
    var silo_1 = require_silo();
    var chunks_1 = require_chunks();
    var blocks_1 = require_blocks();
    var _Arweave = class _Arweave {
      constructor(apiConfig) {
        __publicField(this, "api");
        __publicField(this, "wallets");
        __publicField(this, "transactions");
        __publicField(this, "network");
        __publicField(this, "blocks");
        __publicField(this, "ar");
        __publicField(this, "silo");
        __publicField(this, "chunks");
        this.api = new api_1.default(apiConfig);
        this.wallets = new wallets_1.default(this.api, _Arweave.crypto);
        this.chunks = new chunks_1.default(this.api);
        this.transactions = new transactions_1.default(this.api, _Arweave.crypto, this.chunks);
        this.silo = new silo_1.default(this.api, this.crypto, this.transactions);
        this.network = new network_1.default(this.api);
        this.blocks = new blocks_1.default(this.api, this.network);
        this.ar = new ar_1.default();
      }
      /** @deprecated */
      get crypto() {
        return _Arweave.crypto;
      }
      /** @deprecated */
      get utils() {
        return _Arweave.utils;
      }
      getConfig() {
        return {
          api: this.api.getConfig(),
          crypto: null
        };
      }
      async createTransaction(attributes, jwk) {
        const transaction = {};
        Object.assign(transaction, attributes);
        if (!attributes.data && !(attributes.target && attributes.quantity)) {
          throw new Error(`A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.`);
        }
        if (attributes.owner == void 0) {
          if (jwk && jwk !== "use_wallet") {
            transaction.owner = jwk.n;
          }
        }
        if (attributes.last_tx == void 0) {
          transaction.last_tx = await this.transactions.getTransactionAnchor();
        }
        if (typeof attributes.data === "string") {
          attributes.data = ArweaveUtils.stringToBuffer(attributes.data);
        }
        if (attributes.data instanceof ArrayBuffer) {
          attributes.data = new Uint8Array(attributes.data);
        }
        if (attributes.data && !(attributes.data instanceof Uint8Array)) {
          throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
        }
        if (attributes.reward == void 0) {
          const length2 = attributes.data ? attributes.data.byteLength : 0;
          transaction.reward = await this.transactions.getPrice(length2, transaction.target);
        }
        transaction.data_root = "";
        transaction.data_size = attributes.data ? attributes.data.byteLength.toString() : "0";
        transaction.data = attributes.data || new Uint8Array(0);
        const createdTransaction = new transaction_1.default(transaction);
        await createdTransaction.getSignatureData();
        return createdTransaction;
      }
      async createSiloTransaction(attributes, jwk, siloUri) {
        const transaction = {};
        Object.assign(transaction, attributes);
        if (!attributes.data) {
          throw new Error(`Silo transactions must have a 'data' value`);
        }
        if (!siloUri) {
          throw new Error(`No Silo URI specified.`);
        }
        if (attributes.target || attributes.quantity) {
          throw new Error(`Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.`);
        }
        if (attributes.owner == void 0) {
          if (!jwk || !jwk.n) {
            throw new Error(`A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.`);
          }
          transaction.owner = jwk.n;
        }
        if (attributes.last_tx == void 0) {
          transaction.last_tx = await this.transactions.getTransactionAnchor();
        }
        const siloResource = await this.silo.parseUri(siloUri);
        if (typeof attributes.data == "string") {
          const encrypted = await this.crypto.encrypt(ArweaveUtils.stringToBuffer(attributes.data), siloResource.getEncryptionKey());
          transaction.reward = await this.transactions.getPrice(encrypted.byteLength);
          transaction.data = ArweaveUtils.bufferTob64Url(encrypted);
        }
        if (attributes.data instanceof Uint8Array) {
          const encrypted = await this.crypto.encrypt(attributes.data, siloResource.getEncryptionKey());
          transaction.reward = await this.transactions.getPrice(encrypted.byteLength);
          transaction.data = ArweaveUtils.bufferTob64Url(encrypted);
        }
        const siloTransaction = new transaction_1.default(transaction);
        siloTransaction.addTag("Silo-Name", siloResource.getAccessKey());
        siloTransaction.addTag("Silo-Version", `0.1.0`);
        return siloTransaction;
      }
      arql(query) {
        return this.api.post("/arql", query).then((response) => response.data || []);
      }
    };
    __publicField(_Arweave, "init");
    __publicField(_Arweave, "crypto", new node_driver_1.default());
    __publicField(_Arweave, "utils", ArweaveUtils);
    var Arweave = _Arweave;
    exports2.default = Arweave;
  }
});

// ../../node_modules/arweave/web/net-config.js
var require_net_config = __commonJS({
  "../../node_modules/arweave/web/net-config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultConfig = void 0;
    var isLocal = (protocol, hostname) => {
      const regexLocalIp = /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/;
      const split = hostname.split(".");
      const tld = split[split.length - 1];
      const localStrings = ["localhost", "[::1]"];
      return localStrings.includes(hostname) || protocol == "file" || localStrings.includes(tld) || !!hostname.match(regexLocalIp) || !!tld.match(regexLocalIp);
    };
    var isIpAdress = (host) => {
      const isIpv6 = host.charAt(0) === "[";
      const regexMatchIpv4 = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;
      return !!host.match(regexMatchIpv4) || isIpv6;
    };
    var getDefaultConfig = (protocol, host) => {
      if (isLocal(protocol, host)) {
        return {
          protocol: "https",
          host: "arweave.net",
          port: 443
        };
      }
      if (!isIpAdress(host)) {
        let split = host.split(".");
        if (split.length >= 3) {
          split.shift();
          const parentDomain = split.join(".");
          return {
            protocol,
            host: parentDomain
          };
        }
      }
      return {
        protocol,
        host
      };
    };
    exports2.getDefaultConfig = getDefaultConfig;
  }
});

// ../../node_modules/arweave/web/index.js
var require_web = __commonJS({
  "../../node_modules/arweave/web/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m2, exports3) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2)) __createBinding(exports3, m2, p2);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var common_1 = require_common3();
    var net_config_1 = require_net_config();
    common_1.default.init = function(apiConfig = {}) {
      const defaults2 = {
        host: "arweave.net",
        port: 443,
        protocol: "https"
      };
      if (typeof location !== "object" || !location.protocol || !location.hostname) {
        return new common_1.default({
          ...apiConfig,
          ...defaults2
        });
      }
      const locationProtocol = location.protocol.replace(":", "");
      const locationHost = location.hostname;
      const locationPort = location.port ? parseInt(location.port) : locationProtocol == "https" ? 443 : 80;
      const defaultConfig = (0, net_config_1.getDefaultConfig)(locationProtocol, locationHost);
      const protocol = apiConfig.protocol || defaultConfig.protocol;
      const host = apiConfig.host || defaultConfig.host;
      const port = apiConfig.port || defaultConfig.port || locationPort;
      return new common_1.default({
        ...apiConfig,
        host,
        protocol,
        port
      });
    };
    if (typeof globalThis === "object") {
      globalThis.Arweave = common_1.default;
    } else if (typeof self === "object") {
      self.Arweave = common_1.default;
    }
    __exportStar(require_common3(), exports2);
    exports2.default = common_1.default;
  }
});

// browser-external:util
var require_util4 = __commonJS({
  "browser-external:util"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0) cache[arg] = fn2(arg);
    return cache[arg];
  };
}
var init_emotion_memoize_esm = __esm({
  "../../node_modules/@emotion/memoize/dist/emotion-memoize.esm.js"() {
  }
});

// ../../node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var emotion_is_prop_valid_esm_exports = {};
__export(emotion_is_prop_valid_esm_exports, {
  default: () => isPropValid
});
var reactPropsRegex, isPropValid;
var init_emotion_is_prop_valid_esm = __esm({
  "../../node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js"() {
    init_emotion_memoize_esm();
    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    isPropValid = memoize(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
      /* Z+1 */
    );
  }
});

// ../../node_modules/arweave-wallet-kit/dist/index.es.js
var ke = __toESM(require_react());
var import_react = __toESM(require_react());

// ../../node_modules/@auth0/auth0-spa-js/dist/auth0-spa-js.production.esm.js
function e(e2, t2) {
  var i2 = {};
  for (var o2 in e2) Object.prototype.hasOwnProperty.call(e2, o2) && t2.indexOf(o2) < 0 && (i2[o2] = e2[o2]);
  if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
    var n2 = 0;
    for (o2 = Object.getOwnPropertySymbols(e2); n2 < o2.length; n2++) t2.indexOf(o2[n2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, o2[n2]) && (i2[o2[n2]] = e2[o2[n2]]);
  }
  return i2;
}
var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function i(e2) {
  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
function o(e2, t2) {
  return e2(t2 = { exports: {} }, t2.exports), t2.exports;
}
var n = o(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true });
  var i2 = function() {
    function e3() {
      var e4 = this;
      this.locked = /* @__PURE__ */ new Map(), this.addToLocked = function(t3, i3) {
        var o2 = e4.locked.get(t3);
        void 0 === o2 ? void 0 === i3 ? e4.locked.set(t3, []) : e4.locked.set(t3, [i3]) : void 0 !== i3 && (o2.unshift(i3), e4.locked.set(t3, o2));
      }, this.isLocked = function(t3) {
        return e4.locked.has(t3);
      }, this.lock = function(t3) {
        return new Promise(function(i3, o2) {
          e4.isLocked(t3) ? e4.addToLocked(t3, i3) : (e4.addToLocked(t3), i3());
        });
      }, this.unlock = function(t3) {
        var i3 = e4.locked.get(t3);
        if (void 0 !== i3 && 0 !== i3.length) {
          var o2 = i3.pop();
          e4.locked.set(t3, i3), void 0 !== o2 && setTimeout(o2, 0);
        } else e4.locked.delete(t3);
      };
    }
    return e3.getInstance = function() {
      return void 0 === e3.instance && (e3.instance = new e3()), e3.instance;
    }, e3;
  }();
  t2.default = function() {
    return i2.getInstance();
  };
});
i(n);
var a = i(o(function(e2, i2) {
  var o2 = t && t.__awaiter || function(e3, t2, i3, o3) {
    return new (i3 || (i3 = Promise))(function(n2, a3) {
      function r3(e4) {
        try {
          c3(o3.next(e4));
        } catch (e5) {
          a3(e5);
        }
      }
      function s3(e4) {
        try {
          c3(o3.throw(e4));
        } catch (e5) {
          a3(e5);
        }
      }
      function c3(e4) {
        e4.done ? n2(e4.value) : new i3(function(t3) {
          t3(e4.value);
        }).then(r3, s3);
      }
      c3((o3 = o3.apply(e3, t2 || [])).next());
    });
  }, a2 = t && t.__generator || function(e3, t2) {
    var i3, o3, n2, a3, r3 = { label: 0, sent: function() {
      if (1 & n2[0]) throw n2[1];
      return n2[1];
    }, trys: [], ops: [] };
    return a3 = { next: s3(0), throw: s3(1), return: s3(2) }, "function" == typeof Symbol && (a3[Symbol.iterator] = function() {
      return this;
    }), a3;
    function s3(a4) {
      return function(s4) {
        return function(a5) {
          if (i3) throw new TypeError("Generator is already executing.");
          for (; r3; ) try {
            if (i3 = 1, o3 && (n2 = 2 & a5[0] ? o3.return : a5[0] ? o3.throw || ((n2 = o3.return) && n2.call(o3), 0) : o3.next) && !(n2 = n2.call(o3, a5[1])).done) return n2;
            switch (o3 = 0, n2 && (a5 = [2 & a5[0], n2.value]), a5[0]) {
              case 0:
              case 1:
                n2 = a5;
                break;
              case 4:
                return r3.label++, { value: a5[1], done: false };
              case 5:
                r3.label++, o3 = a5[1], a5 = [0];
                continue;
              case 7:
                a5 = r3.ops.pop(), r3.trys.pop();
                continue;
              default:
                if (!(n2 = r3.trys, (n2 = n2.length > 0 && n2[n2.length - 1]) || 6 !== a5[0] && 2 !== a5[0])) {
                  r3 = 0;
                  continue;
                }
                if (3 === a5[0] && (!n2 || a5[1] > n2[0] && a5[1] < n2[3])) {
                  r3.label = a5[1];
                  break;
                }
                if (6 === a5[0] && r3.label < n2[1]) {
                  r3.label = n2[1], n2 = a5;
                  break;
                }
                if (n2 && r3.label < n2[2]) {
                  r3.label = n2[2], r3.ops.push(a5);
                  break;
                }
                n2[2] && r3.ops.pop(), r3.trys.pop();
                continue;
            }
            a5 = t2.call(e3, r3);
          } catch (e4) {
            a5 = [6, e4], o3 = 0;
          } finally {
            i3 = n2 = 0;
          }
          if (5 & a5[0]) throw a5[1];
          return { value: a5[0] ? a5[1] : void 0, done: true };
        }([a4, s4]);
      };
    }
  }, r2 = t;
  Object.defineProperty(i2, "__esModule", { value: true });
  var s2 = "browser-tabs-lock-key", c2 = { key: function(e3) {
    return o2(r2, void 0, void 0, function() {
      return a2(this, function(e4) {
        throw new Error("Unsupported");
      });
    });
  }, getItem: function(e3) {
    return o2(r2, void 0, void 0, function() {
      return a2(this, function(e4) {
        throw new Error("Unsupported");
      });
    });
  }, clear: function() {
    return o2(r2, void 0, void 0, function() {
      return a2(this, function(e3) {
        return [2, window.localStorage.clear()];
      });
    });
  }, removeItem: function(e3) {
    return o2(r2, void 0, void 0, function() {
      return a2(this, function(e4) {
        throw new Error("Unsupported");
      });
    });
  }, setItem: function(e3, t2) {
    return o2(r2, void 0, void 0, function() {
      return a2(this, function(e4) {
        throw new Error("Unsupported");
      });
    });
  }, keySync: function(e3) {
    return window.localStorage.key(e3);
  }, getItemSync: function(e3) {
    return window.localStorage.getItem(e3);
  }, clearSync: function() {
    return window.localStorage.clear();
  }, removeItemSync: function(e3) {
    return window.localStorage.removeItem(e3);
  }, setItemSync: function(e3, t2) {
    return window.localStorage.setItem(e3, t2);
  } };
  function d2(e3) {
    return new Promise(function(t2) {
      return setTimeout(t2, e3);
    });
  }
  function u2(e3) {
    for (var t2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", i3 = "", o3 = 0; o3 < e3; o3++) {
      i3 += t2[Math.floor(Math.random() * t2.length)];
    }
    return i3;
  }
  var l2 = function() {
    function e3(t2) {
      this.acquiredIatSet = /* @__PURE__ */ new Set(), this.storageHandler = void 0, this.id = Date.now().toString() + u2(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), this.storageHandler = t2, void 0 === e3.waiters && (e3.waiters = []);
    }
    return e3.prototype.acquireLock = function(t2, i3) {
      return void 0 === i3 && (i3 = 5e3), o2(this, void 0, void 0, function() {
        var o3, n2, r3, l3, h2, p2, m2;
        return a2(this, function(a3) {
          switch (a3.label) {
            case 0:
              o3 = Date.now() + u2(4), n2 = Date.now() + i3, r3 = s2 + "-" + t2, l3 = void 0 === this.storageHandler ? c2 : this.storageHandler, a3.label = 1;
            case 1:
              return Date.now() < n2 ? [4, d2(30)] : [3, 8];
            case 2:
              return a3.sent(), null !== l3.getItemSync(r3) ? [3, 5] : (h2 = this.id + "-" + t2 + "-" + o3, [4, d2(Math.floor(25 * Math.random()))]);
            case 3:
              return a3.sent(), l3.setItemSync(r3, JSON.stringify({ id: this.id, iat: o3, timeoutKey: h2, timeAcquired: Date.now(), timeRefreshed: Date.now() })), [4, d2(30)];
            case 4:
              return a3.sent(), null !== (p2 = l3.getItemSync(r3)) && (m2 = JSON.parse(p2)).id === this.id && m2.iat === o3 ? (this.acquiredIatSet.add(o3), this.refreshLockWhileAcquired(r3, o3), [2, true]) : [3, 7];
            case 5:
              return e3.lockCorrector(void 0 === this.storageHandler ? c2 : this.storageHandler), [4, this.waitForSomethingToChange(n2)];
            case 6:
              a3.sent(), a3.label = 7;
            case 7:
              return o3 = Date.now() + u2(4), [3, 1];
            case 8:
              return [2, false];
          }
        });
      });
    }, e3.prototype.refreshLockWhileAcquired = function(e4, t2) {
      return o2(this, void 0, void 0, function() {
        var i3 = this;
        return a2(this, function(r3) {
          return setTimeout(function() {
            return o2(i3, void 0, void 0, function() {
              var i4, o3, r4;
              return a2(this, function(a3) {
                switch (a3.label) {
                  case 0:
                    return [4, n.default().lock(t2)];
                  case 1:
                    return a3.sent(), this.acquiredIatSet.has(t2) ? (i4 = void 0 === this.storageHandler ? c2 : this.storageHandler, null === (o3 = i4.getItemSync(e4)) ? (n.default().unlock(t2), [2]) : ((r4 = JSON.parse(o3)).timeRefreshed = Date.now(), i4.setItemSync(e4, JSON.stringify(r4)), n.default().unlock(t2), this.refreshLockWhileAcquired(e4, t2), [2])) : (n.default().unlock(t2), [2]);
                }
              });
            });
          }, 1e3), [2];
        });
      });
    }, e3.prototype.waitForSomethingToChange = function(t2) {
      return o2(this, void 0, void 0, function() {
        return a2(this, function(i3) {
          switch (i3.label) {
            case 0:
              return [4, new Promise(function(i4) {
                var o3 = false, n2 = Date.now(), a3 = false;
                function r3() {
                  if (a3 || (window.removeEventListener("storage", r3), e3.removeFromWaiting(r3), clearTimeout(s3), a3 = true), !o3) {
                    o3 = true;
                    var t3 = 50 - (Date.now() - n2);
                    t3 > 0 ? setTimeout(i4, t3) : i4(null);
                  }
                }
                window.addEventListener("storage", r3), e3.addToWaiting(r3);
                var s3 = setTimeout(r3, Math.max(0, t2 - Date.now()));
              })];
            case 1:
              return i3.sent(), [2];
          }
        });
      });
    }, e3.addToWaiting = function(t2) {
      this.removeFromWaiting(t2), void 0 !== e3.waiters && e3.waiters.push(t2);
    }, e3.removeFromWaiting = function(t2) {
      void 0 !== e3.waiters && (e3.waiters = e3.waiters.filter(function(e4) {
        return e4 !== t2;
      }));
    }, e3.notifyWaiters = function() {
      void 0 !== e3.waiters && e3.waiters.slice().forEach(function(e4) {
        return e4();
      });
    }, e3.prototype.releaseLock = function(e4) {
      return o2(this, void 0, void 0, function() {
        return a2(this, function(t2) {
          switch (t2.label) {
            case 0:
              return [4, this.releaseLock__private__(e4)];
            case 1:
              return [2, t2.sent()];
          }
        });
      });
    }, e3.prototype.releaseLock__private__ = function(t2) {
      return o2(this, void 0, void 0, function() {
        var i3, o3, r3, d3;
        return a2(this, function(a3) {
          switch (a3.label) {
            case 0:
              return i3 = void 0 === this.storageHandler ? c2 : this.storageHandler, o3 = s2 + "-" + t2, null === (r3 = i3.getItemSync(o3)) ? [2] : (d3 = JSON.parse(r3)).id !== this.id ? [3, 2] : [4, n.default().lock(d3.iat)];
            case 1:
              a3.sent(), this.acquiredIatSet.delete(d3.iat), i3.removeItemSync(o3), n.default().unlock(d3.iat), e3.notifyWaiters(), a3.label = 2;
            case 2:
              return [2];
          }
        });
      });
    }, e3.lockCorrector = function(t2) {
      for (var i3 = Date.now() - 5e3, o3 = t2, n2 = [], a3 = 0; ; ) {
        var r3 = o3.keySync(a3);
        if (null === r3) break;
        n2.push(r3), a3++;
      }
      for (var c3 = false, d3 = 0; d3 < n2.length; d3++) {
        var u3 = n2[d3];
        if (u3.includes(s2)) {
          var l3 = o3.getItemSync(u3);
          if (null !== l3) {
            var h2 = JSON.parse(l3);
            (void 0 === h2.timeRefreshed && h2.timeAcquired < i3 || void 0 !== h2.timeRefreshed && h2.timeRefreshed < i3) && (o3.removeItemSync(u3), c3 = true);
          }
        }
      }
      c3 && e3.notifyWaiters();
    }, e3.waiters = void 0, e3;
  }();
  i2.default = l2;
}));
var r = { timeoutInSeconds: 60 };
var s = { name: "auth0-spa-js", version: "2.1.3" };
var c = () => Date.now();
var d = class _d2 extends Error {
  constructor(e2, t2) {
    super(t2), this.error = e2, this.error_description = t2, Object.setPrototypeOf(this, _d2.prototype);
  }
  static fromPayload({ error: e2, error_description: t2 }) {
    return new _d2(e2, t2);
  }
};
var u = class _u2 extends d {
  constructor(e2, t2, i2, o2 = null) {
    super(e2, t2), this.state = i2, this.appState = o2, Object.setPrototypeOf(this, _u2.prototype);
  }
};
var l = class _l2 extends d {
  constructor() {
    super("timeout", "Timeout"), Object.setPrototypeOf(this, _l2.prototype);
  }
};
var h = class _h2 extends l {
  constructor(e2) {
    super(), this.popup = e2, Object.setPrototypeOf(this, _h2.prototype);
  }
};
var p = class _p2 extends d {
  constructor(e2) {
    super("cancelled", "Popup closed"), this.popup = e2, Object.setPrototypeOf(this, _p2.prototype);
  }
};
var m = class _m2 extends d {
  constructor(e2, t2, i2) {
    super(e2, t2), this.mfa_token = i2, Object.setPrototypeOf(this, _m2.prototype);
  }
};
var f = class _f2 extends d {
  constructor(e2, t2) {
    super("missing_refresh_token", `Missing Refresh Token (audience: '${g(e2, ["default"])}', scope: '${g(t2)}')`), this.audience = e2, this.scope = t2, Object.setPrototypeOf(this, _f2.prototype);
  }
};
function g(e2, t2 = []) {
  return e2 && !t2.includes(e2) ? e2 : "";
}
var w = () => window.crypto;
var y = () => {
  const e2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.";
  let t2 = "";
  return Array.from(w().getRandomValues(new Uint8Array(43))).forEach((i2) => t2 += e2[i2 % e2.length]), t2;
};
var k = (e2) => btoa(e2);
var v = (t2) => {
  var { clientId: i2 } = t2, o2 = e(t2, ["clientId"]);
  return new URLSearchParams(((e2) => Object.keys(e2).filter((t3) => void 0 !== e2[t3]).reduce((t3, i3) => Object.assign(Object.assign({}, t3), { [i3]: e2[i3] }), {}))(Object.assign({ client_id: i2 }, o2))).toString();
};
var b = (e2) => ((e3) => decodeURIComponent(atob(e3).split("").map((e4) => "%" + ("00" + e4.charCodeAt(0).toString(16)).slice(-2)).join("")))(e2.replace(/_/g, "/").replace(/-/g, "+"));
var _ = async (e2, t2) => {
  const i2 = await fetch(e2, t2);
  return { ok: i2.ok, json: await i2.json() };
};
var I = async (e2, t2, i2) => {
  const o2 = new AbortController();
  let n2;
  return t2.signal = o2.signal, Promise.race([_(e2, t2), new Promise((e3, t3) => {
    n2 = setTimeout(() => {
      o2.abort(), t3(new Error("Timeout when executing 'fetch'"));
    }, i2);
  })]).finally(() => {
    clearTimeout(n2);
  });
};
var S = async (e2, t2, i2, o2, n2, a2, r2) => {
  return s2 = { auth: { audience: t2, scope: i2 }, timeout: n2, fetchUrl: e2, fetchOptions: o2, useFormData: r2 }, c2 = a2, new Promise(function(e3, t3) {
    const i3 = new MessageChannel();
    i3.port1.onmessage = function(o3) {
      o3.data.error ? t3(new Error(o3.data.error)) : e3(o3.data), i3.port1.close();
    }, c2.postMessage(s2, [i3.port2]);
  });
  var s2, c2;
};
var O = async (e2, t2, i2, o2, n2, a2, r2 = 1e4) => n2 ? S(e2, t2, i2, o2, r2, n2, a2) : I(e2, o2, r2);
async function T(t2, i2) {
  var { baseUrl: o2, timeout: n2, audience: a2, scope: r2, auth0Client: c2, useFormData: u2 } = t2, l2 = e(t2, ["baseUrl", "timeout", "audience", "scope", "auth0Client", "useFormData"]);
  const h2 = u2 ? v(l2) : JSON.stringify(l2);
  return await async function(t3, i3, o3, n3, a3, r3, s2) {
    let c3, u3 = null;
    for (let e2 = 0; e2 < 3; e2++) try {
      c3 = await O(t3, o3, n3, a3, r3, s2, i3), u3 = null;
      break;
    } catch (e3) {
      u3 = e3;
    }
    if (u3) throw u3;
    const l3 = c3.json, { error: h3, error_description: p2 } = l3, g2 = e(l3, ["error", "error_description"]), { ok: w3 } = c3;
    if (!w3) {
      const e2 = p2 || `HTTP error. Unable to fetch ${t3}`;
      if ("mfa_required" === h3) throw new m(h3, e2, g2.mfa_token);
      if ("missing_refresh_token" === h3) throw new f(o3, n3);
      throw new d(h3 || "request_error", e2);
    }
    return g2;
  }(`${o2}/oauth/token`, n2, a2 || "default", r2, { method: "POST", body: h2, headers: { "Content-Type": u2 ? "application/x-www-form-urlencoded" : "application/json", "Auth0-Client": btoa(JSON.stringify(c2 || s)) } }, i2, u2);
}
var j = (...e2) => {
  return (t2 = e2.filter(Boolean).join(" ").trim().split(/\s+/), Array.from(new Set(t2))).join(" ");
  var t2;
};
var C = class _C {
  constructor(e2, t2 = "@@auth0spajs@@", i2) {
    this.prefix = t2, this.suffix = i2, this.clientId = e2.clientId, this.scope = e2.scope, this.audience = e2.audience;
  }
  toKey() {
    return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join("::");
  }
  static fromKey(e2) {
    const [t2, i2, o2, n2] = e2.split("::");
    return new _C({ clientId: i2, scope: n2, audience: o2 }, t2);
  }
  static fromCacheEntry(e2) {
    const { scope: t2, audience: i2, client_id: o2 } = e2;
    return new _C({ scope: t2, audience: i2, clientId: o2 });
  }
};
var z = class {
  set(e2, t2) {
    localStorage.setItem(e2, JSON.stringify(t2));
  }
  get(e2) {
    const t2 = window.localStorage.getItem(e2);
    if (t2) try {
      return JSON.parse(t2);
    } catch (e3) {
      return;
    }
  }
  remove(e2) {
    localStorage.removeItem(e2);
  }
  allKeys() {
    return Object.keys(window.localStorage).filter((e2) => e2.startsWith("@@auth0spajs@@"));
  }
};
var P = class {
  constructor() {
    this.enclosedCache = /* @__PURE__ */ function() {
      let e2 = {};
      return { set(t2, i2) {
        e2[t2] = i2;
      }, get(t2) {
        const i2 = e2[t2];
        if (i2) return i2;
      }, remove(t2) {
        delete e2[t2];
      }, allKeys: () => Object.keys(e2) };
    }();
  }
};
var x = class {
  constructor(e2, t2, i2) {
    this.cache = e2, this.keyManifest = t2, this.nowProvider = i2 || c;
  }
  async setIdToken(e2, t2, i2) {
    var o2;
    const n2 = this.getIdTokenCacheKey(e2);
    await this.cache.set(n2, { id_token: t2, decodedToken: i2 }), await (null === (o2 = this.keyManifest) || void 0 === o2 ? void 0 : o2.add(n2));
  }
  async getIdToken(e2) {
    const t2 = await this.cache.get(this.getIdTokenCacheKey(e2.clientId));
    if (!t2 && e2.scope && e2.audience) {
      const t3 = await this.get(e2);
      if (!t3) return;
      if (!t3.id_token || !t3.decodedToken) return;
      return { id_token: t3.id_token, decodedToken: t3.decodedToken };
    }
    if (t2) return { id_token: t2.id_token, decodedToken: t2.decodedToken };
  }
  async get(e2, t2 = 0) {
    var i2;
    let o2 = await this.cache.get(e2.toKey());
    if (!o2) {
      const t3 = await this.getCacheKeys();
      if (!t3) return;
      const i3 = this.matchExistingCacheKey(e2, t3);
      i3 && (o2 = await this.cache.get(i3));
    }
    if (!o2) return;
    const n2 = await this.nowProvider(), a2 = Math.floor(n2 / 1e3);
    return o2.expiresAt - t2 < a2 ? o2.body.refresh_token ? (o2.body = { refresh_token: o2.body.refresh_token }, await this.cache.set(e2.toKey(), o2), o2.body) : (await this.cache.remove(e2.toKey()), void await (null === (i2 = this.keyManifest) || void 0 === i2 ? void 0 : i2.remove(e2.toKey()))) : o2.body;
  }
  async set(e2) {
    var t2;
    const i2 = new C({ clientId: e2.client_id, scope: e2.scope, audience: e2.audience }), o2 = await this.wrapCacheEntry(e2);
    await this.cache.set(i2.toKey(), o2), await (null === (t2 = this.keyManifest) || void 0 === t2 ? void 0 : t2.add(i2.toKey()));
  }
  async clear(e2) {
    var t2;
    const i2 = await this.getCacheKeys();
    i2 && (await i2.filter((t3) => !e2 || t3.includes(e2)).reduce(async (e3, t3) => {
      await e3, await this.cache.remove(t3);
    }, Promise.resolve()), await (null === (t2 = this.keyManifest) || void 0 === t2 ? void 0 : t2.clear()));
  }
  async wrapCacheEntry(e2) {
    const t2 = await this.nowProvider();
    return { body: e2, expiresAt: Math.floor(t2 / 1e3) + e2.expires_in };
  }
  async getCacheKeys() {
    var e2;
    return this.keyManifest ? null === (e2 = await this.keyManifest.get()) || void 0 === e2 ? void 0 : e2.keys : this.cache.allKeys ? this.cache.allKeys() : void 0;
  }
  getIdTokenCacheKey(e2) {
    return new C({ clientId: e2 }, "@@auth0spajs@@", "@@user@@").toKey();
  }
  matchExistingCacheKey(e2, t2) {
    return t2.filter((t3) => {
      var i2;
      const o2 = C.fromKey(t3), n2 = new Set(o2.scope && o2.scope.split(" ")), a2 = (null === (i2 = e2.scope) || void 0 === i2 ? void 0 : i2.split(" ")) || [], r2 = o2.scope && a2.reduce((e3, t4) => e3 && n2.has(t4), true);
      return "@@auth0spajs@@" === o2.prefix && o2.clientId === e2.clientId && o2.audience === e2.audience && r2;
    })[0];
  }
};
var Z = class {
  constructor(e2, t2, i2) {
    this.storage = e2, this.clientId = t2, this.cookieDomain = i2, this.storageKey = `a0.spajs.txs.${this.clientId}`;
  }
  create(e2) {
    this.storage.save(this.storageKey, e2, { daysUntilExpire: 1, cookieDomain: this.cookieDomain });
  }
  get() {
    return this.storage.get(this.storageKey);
  }
  remove() {
    this.storage.remove(this.storageKey, { cookieDomain: this.cookieDomain });
  }
};
var K = (e2) => "number" == typeof e2;
var W = ["iss", "aud", "exp", "nbf", "iat", "jti", "azp", "nonce", "auth_time", "at_hash", "c_hash", "acr", "amr", "sub_jwk", "cnf", "sip_from_tag", "sip_date", "sip_callid", "sip_cseq_num", "sip_via_branch", "orig", "dest", "mky", "events", "toe", "txn", "rph", "sid", "vot", "vtm"];
var E = (e2) => {
  if (!e2.id_token) throw new Error("ID token is required but missing");
  const t2 = ((e3) => {
    const t3 = e3.split("."), [i3, o3, n3] = t3;
    if (3 !== t3.length || !i3 || !o3 || !n3) throw new Error("ID token could not be decoded");
    const a2 = JSON.parse(b(o3)), r2 = { __raw: e3 }, s2 = {};
    return Object.keys(a2).forEach((e4) => {
      r2[e4] = a2[e4], W.includes(e4) || (s2[e4] = a2[e4]);
    }), { encoded: { header: i3, payload: o3, signature: n3 }, header: JSON.parse(b(i3)), claims: r2, user: s2 };
  })(e2.id_token);
  if (!t2.claims.iss) throw new Error("Issuer (iss) claim must be a string present in the ID token");
  if (t2.claims.iss !== e2.iss) throw new Error(`Issuer (iss) claim mismatch in the ID token; expected "${e2.iss}", found "${t2.claims.iss}"`);
  if (!t2.user.sub) throw new Error("Subject (sub) claim must be a string present in the ID token");
  if ("RS256" !== t2.header.alg) throw new Error(`Signature algorithm of "${t2.header.alg}" is not supported. Expected the ID token to be signed with "RS256".`);
  if (!t2.claims.aud || "string" != typeof t2.claims.aud && !Array.isArray(t2.claims.aud)) throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token");
  if (Array.isArray(t2.claims.aud)) {
    if (!t2.claims.aud.includes(e2.aud)) throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${e2.aud}" but was not one of "${t2.claims.aud.join(", ")}"`);
    if (t2.claims.aud.length > 1) {
      if (!t2.claims.azp) throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");
      if (t2.claims.azp !== e2.aud) throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected "${e2.aud}", found "${t2.claims.azp}"`);
    }
  } else if (t2.claims.aud !== e2.aud) throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${e2.aud}" but found "${t2.claims.aud}"`);
  if (e2.nonce) {
    if (!t2.claims.nonce) throw new Error("Nonce (nonce) claim must be a string present in the ID token");
    if (t2.claims.nonce !== e2.nonce) throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected "${e2.nonce}", found "${t2.claims.nonce}"`);
  }
  if (e2.max_age && !K(t2.claims.auth_time)) throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");
  if (null == t2.claims.exp || !K(t2.claims.exp)) throw new Error("Expiration Time (exp) claim must be a number present in the ID token");
  if (!K(t2.claims.iat)) throw new Error("Issued At (iat) claim must be a number present in the ID token");
  const i2 = e2.leeway || 60, o2 = new Date(e2.now || Date.now()), n2 = /* @__PURE__ */ new Date(0);
  if (n2.setUTCSeconds(t2.claims.exp + i2), o2 > n2) throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${o2}) is after expiration time (${n2})`);
  if (null != t2.claims.nbf && K(t2.claims.nbf)) {
    const e3 = /* @__PURE__ */ new Date(0);
    if (e3.setUTCSeconds(t2.claims.nbf - i2), o2 < e3) throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${o2}) is before ${e3}`);
  }
  if (null != t2.claims.auth_time && K(t2.claims.auth_time)) {
    const n3 = /* @__PURE__ */ new Date(0);
    if (n3.setUTCSeconds(parseInt(t2.claims.auth_time) + e2.max_age + i2), o2 > n3) throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${o2}) is after last auth at ${n3}`);
  }
  if (e2.organization) {
    const i3 = e2.organization.trim();
    if (i3.startsWith("org_")) {
      const e3 = i3;
      if (!t2.claims.org_id) throw new Error("Organization ID (org_id) claim must be a string present in the ID token");
      if (e3 !== t2.claims.org_id) throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected "${e3}", found "${t2.claims.org_id}"`);
    } else {
      const e3 = i3.toLowerCase();
      if (!t2.claims.org_name) throw new Error("Organization Name (org_name) claim must be a string present in the ID token");
      if (e3 !== t2.claims.org_name) throw new Error(`Organization Name (org_name) claim mismatch in the ID token; expected "${e3}", found "${t2.claims.org_name}"`);
    }
  }
  return t2;
};
var R = o(function(e2, i2) {
  var o2 = t && t.__assign || function() {
    return o2 = Object.assign || function(e3) {
      for (var t2, i3 = 1, o3 = arguments.length; i3 < o3; i3++) for (var n3 in t2 = arguments[i3]) Object.prototype.hasOwnProperty.call(t2, n3) && (e3[n3] = t2[n3]);
      return e3;
    }, o2.apply(this, arguments);
  };
  function n2(e3, t2) {
    if (!t2) return "";
    var i3 = "; " + e3;
    return true === t2 ? i3 : i3 + "=" + t2;
  }
  function a2(e3, t2, i3) {
    return encodeURIComponent(e3).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\(/g, "%28").replace(/\)/g, "%29") + "=" + encodeURIComponent(t2).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function(e4) {
      if ("number" == typeof e4.expires) {
        var t3 = /* @__PURE__ */ new Date();
        t3.setMilliseconds(t3.getMilliseconds() + 864e5 * e4.expires), e4.expires = t3;
      }
      return n2("Expires", e4.expires ? e4.expires.toUTCString() : "") + n2("Domain", e4.domain) + n2("Path", e4.path) + n2("Secure", e4.secure) + n2("SameSite", e4.sameSite);
    }(i3);
  }
  function r2(e3) {
    for (var t2 = {}, i3 = e3 ? e3.split("; ") : [], o3 = /(%[\dA-F]{2})+/gi, n3 = 0; n3 < i3.length; n3++) {
      var a3 = i3[n3].split("="), r3 = a3.slice(1).join("=");
      '"' === r3.charAt(0) && (r3 = r3.slice(1, -1));
      try {
        t2[a3[0].replace(o3, decodeURIComponent)] = r3.replace(o3, decodeURIComponent);
      } catch (e4) {
      }
    }
    return t2;
  }
  function s2() {
    return r2(document.cookie);
  }
  function c2(e3, t2, i3) {
    document.cookie = a2(e3, t2, o2({ path: "/" }, i3));
  }
  i2.__esModule = true, i2.encode = a2, i2.parse = r2, i2.getAll = s2, i2.get = function(e3) {
    return s2()[e3];
  }, i2.set = c2, i2.remove = function(e3, t2) {
    c2(e3, "", o2(o2({}, t2), { expires: -1 }));
  };
});
i(R), R.encode, R.parse, R.getAll;
var U = R.get;
var L = R.set;
var D = R.remove;
var X = { get(e2) {
  const t2 = U(e2);
  if (void 0 !== t2) return JSON.parse(t2);
}, save(e2, t2, i2) {
  let o2 = {};
  "https:" === window.location.protocol && (o2 = { secure: true, sameSite: "none" }), (null == i2 ? void 0 : i2.daysUntilExpire) && (o2.expires = i2.daysUntilExpire), (null == i2 ? void 0 : i2.cookieDomain) && (o2.domain = i2.cookieDomain), L(e2, JSON.stringify(t2), o2);
}, remove(e2, t2) {
  let i2 = {};
  (null == t2 ? void 0 : t2.cookieDomain) && (i2.domain = t2.cookieDomain), D(e2, i2);
} };
var N = { get(e2) {
  const t2 = X.get(e2);
  return t2 || X.get(`_legacy_${e2}`);
}, save(e2, t2, i2) {
  let o2 = {};
  "https:" === window.location.protocol && (o2 = { secure: true }), (null == i2 ? void 0 : i2.daysUntilExpire) && (o2.expires = i2.daysUntilExpire), (null == i2 ? void 0 : i2.cookieDomain) && (o2.domain = i2.cookieDomain), L(`_legacy_${e2}`, JSON.stringify(t2), o2), X.save(e2, t2, i2);
}, remove(e2, t2) {
  let i2 = {};
  (null == t2 ? void 0 : t2.cookieDomain) && (i2.domain = t2.cookieDomain), D(e2, i2), X.remove(e2, t2), X.remove(`_legacy_${e2}`, t2);
} };
var J = { get(e2) {
  if ("undefined" == typeof sessionStorage) return;
  const t2 = sessionStorage.getItem(e2);
  return null != t2 ? JSON.parse(t2) : void 0;
}, save(e2, t2) {
  sessionStorage.setItem(e2, JSON.stringify(t2));
}, remove(e2) {
  sessionStorage.removeItem(e2);
} };
function F(e2, t2, i2) {
  var o2 = void 0 === t2 ? null : t2, n2 = function(e3, t3) {
    var i3 = atob(e3);
    if (t3) {
      for (var o3 = new Uint8Array(i3.length), n3 = 0, a3 = i3.length; n3 < a3; ++n3) o3[n3] = i3.charCodeAt(n3);
      return String.fromCharCode.apply(null, new Uint16Array(o3.buffer));
    }
    return i3;
  }(e2, void 0 !== i2 && i2), a2 = n2.indexOf("\n", 10) + 1, r2 = n2.substring(a2) + (o2 ? "//# sourceMappingURL=" + o2 : ""), s2 = new Blob([r2], { type: "application/javascript" });
  return URL.createObjectURL(s2);
}
var H;
var Y;
var G;
var V;
var M = (H = "Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9ImZ1bmN0aW9uIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO2NvbnN0IHM9ZT0+e3ZhcntjbGllbnRJZDp0fT1lLHI9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fTtmb3IodmFyIHMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxzKSYmdC5pbmRleE9mKHMpPDAmJihyW3NdPWVbc10pO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbz0wO2ZvcihzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bzxzLmxlbmd0aDtvKyspdC5pbmRleE9mKHNbb10pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHNbb10pJiYocltzW29dXT1lW3Nbb11dKX1yZXR1cm4gcn0oZSxbImNsaWVudElkIl0pO3JldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKChlPT5PYmplY3Qua2V5cyhlKS5maWx0ZXIoKHQ9PnZvaWQgMCE9PWVbdF0pKS5yZWR1Y2UoKCh0LHIpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tyXTplW3JdfSkpLHt9KSkoT2JqZWN0LmFzc2lnbih7Y2xpZW50X2lkOnR9LHIpKSkudG9TdHJpbmcoKX07bGV0IG89e307Y29uc3Qgbj0oZSx0KT0+YCR7ZX18JHt0fWA7YWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKGFzeW5jKHtkYXRhOnt0aW1lb3V0OmUsYXV0aDpyLGZldGNoVXJsOmksZmV0Y2hPcHRpb25zOmMsdXNlRm9ybURhdGE6YX0scG9ydHM6W3BdfSk9PntsZXQgZjtjb25zdHthdWRpZW5jZTp1LHNjb3BlOmx9PXJ8fHt9O3RyeXtjb25zdCByPWE/KGU9Pntjb25zdCB0PW5ldyBVUkxTZWFyY2hQYXJhbXMoZSkscj17fTtyZXR1cm4gdC5mb3JFYWNoKCgoZSx0KT0+e3JbdF09ZX0pKSxyfSkoYy5ib2R5KTpKU09OLnBhcnNlKGMuYm9keSk7aWYoIXIucmVmcmVzaF90b2tlbiYmInJlZnJlc2hfdG9rZW4iPT09ci5ncmFudF90eXBlKXtjb25zdCBlPSgoZSx0KT0+b1tuKGUsdCldKSh1LGwpO2lmKCFlKXRocm93IG5ldyB0KHUsbCk7Yy5ib2R5PWE/cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKTpKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKX1sZXQgaCxnOyJmdW5jdGlvbiI9PXR5cGVvZiBBYm9ydENvbnRyb2xsZXImJihoPW5ldyBBYm9ydENvbnRyb2xsZXIsYy5zaWduYWw9aC5zaWduYWwpO3RyeXtnPWF3YWl0IFByb21pc2UucmFjZShbKGQ9ZSxuZXcgUHJvbWlzZSgoZT0+c2V0VGltZW91dChlLGQpKSkpLGZldGNoKGksT2JqZWN0LmFzc2lnbih7fSxjKSldKX1jYXRjaChlKXtyZXR1cm4gdm9pZCBwLnBvc3RNZXNzYWdlKHtlcnJvcjplLm1lc3NhZ2V9KX1pZighZylyZXR1cm4gaCYmaC5hYm9ydCgpLHZvaWQgcC5wb3N0TWVzc2FnZSh7ZXJyb3I6IlRpbWVvdXQgd2hlbiBleGVjdXRpbmcgJ2ZldGNoJyJ9KTtmPWF3YWl0IGcuanNvbigpLGYucmVmcmVzaF90b2tlbj8oKChlLHQscik9PntvW24odCxyKV09ZX0pKGYucmVmcmVzaF90b2tlbix1LGwpLGRlbGV0ZSBmLnJlZnJlc2hfdG9rZW4pOigoZSx0KT0+e2RlbGV0ZSBvW24oZSx0KV19KSh1LGwpLHAucG9zdE1lc3NhZ2Uoe29rOmcub2ssanNvbjpmfSl9Y2F0Y2goZSl7cC5wb3N0TWVzc2FnZSh7b2s6ITEsanNvbjp7ZXJyb3I6ZS5lcnJvcixlcnJvcl9kZXNjcmlwdGlvbjplLm1lc3NhZ2V9fSl9dmFyIGR9KSl9KCk7Cgo=", Y = null, G = false, function(e2) {
  return V = V || F(H, Y, G), new Worker(V, e2);
});
var A = {};
var B = class {
  constructor(e2, t2) {
    this.cache = e2, this.clientId = t2, this.manifestKey = this.createManifestKeyFrom(this.clientId);
  }
  async add(e2) {
    var t2;
    const i2 = new Set((null === (t2 = await this.cache.get(this.manifestKey)) || void 0 === t2 ? void 0 : t2.keys) || []);
    i2.add(e2), await this.cache.set(this.manifestKey, { keys: [...i2] });
  }
  async remove(e2) {
    const t2 = await this.cache.get(this.manifestKey);
    if (t2) {
      const i2 = new Set(t2.keys);
      return i2.delete(e2), i2.size > 0 ? await this.cache.set(this.manifestKey, { keys: [...i2] }) : await this.cache.remove(this.manifestKey);
    }
  }
  get() {
    return this.cache.get(this.manifestKey);
  }
  clear() {
    return this.cache.remove(this.manifestKey);
  }
  createManifestKeyFrom(e2) {
    return `@@auth0spajs@@::${e2}`;
  }
};
var $ = { memory: () => new P().enclosedCache, localstorage: () => new z() };
var q = (e2) => $[e2];
var Q = (t2) => {
  const { openUrl: i2, onRedirect: o2 } = t2, n2 = e(t2, ["openUrl", "onRedirect"]);
  return Object.assign(Object.assign({}, n2), { openUrl: false === i2 || i2 ? i2 : o2 });
};
var ee = new a();
var te = class {
  constructor(e2) {
    let t2, i2;
    if (this.userCache = new P().enclosedCache, this.defaultOptions = { authorizationParams: { scope: "openid profile email" }, useRefreshTokensFallback: false, useFormData: true }, this._releaseLockOnPageHide = async () => {
      await ee.releaseLock("auth0.lock.getTokenSilently"), window.removeEventListener("pagehide", this._releaseLockOnPageHide);
    }, this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), e2), { authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), e2.authorizationParams) }), "undefined" != typeof window && (() => {
      if (!w()) throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`.");
      if (void 0 === w().subtle) throw new Error("\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\n    ");
    })(), e2.cache && e2.cacheLocation && console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`."), e2.cache) i2 = e2.cache;
    else {
      if (t2 = e2.cacheLocation || "memory", !q(t2)) throw new Error(`Invalid cache location "${t2}"`);
      i2 = q(t2)();
    }
    this.httpTimeoutMs = e2.httpTimeoutInSeconds ? 1e3 * e2.httpTimeoutInSeconds : 1e4, this.cookieStorage = false === e2.legacySameSiteCookie ? X : N, this.orgHintCookieName = `auth0.${this.options.clientId}.organization_hint`, this.isAuthenticatedCookieName = ((e3) => `auth0.${e3}.is.authenticated`)(this.options.clientId), this.sessionCheckExpiryDays = e2.sessionCheckExpiryDays || 1;
    const o2 = e2.useCookiesForTransactions ? this.cookieStorage : J;
    var n2;
    this.scope = j("openid", this.options.authorizationParams.scope, this.options.useRefreshTokens ? "offline_access" : ""), this.transactionManager = new Z(o2, this.options.clientId, this.options.cookieDomain), this.nowProvider = this.options.nowProvider || c, this.cacheManager = new x(i2, i2.allKeys ? void 0 : new B(i2, this.options.clientId), this.nowProvider), this.domainUrl = (n2 = this.options.domain, /^https?:\/\//.test(n2) ? n2 : `https://${n2}`), this.tokenIssuer = ((e3, t3) => e3 ? e3.startsWith("https://") ? e3 : `https://${e3}/` : `${t3}/`)(this.options.issuer, this.domainUrl), "undefined" != typeof window && window.Worker && this.options.useRefreshTokens && "memory" === t2 && (this.options.workerUrl ? this.worker = new Worker(this.options.workerUrl) : this.worker = new M());
  }
  _url(e2) {
    const t2 = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || s)));
    return `${this.domainUrl}${e2}&auth0Client=${t2}`;
  }
  _authorizeUrl(e2) {
    return this._url(`/authorize?${v(e2)}`);
  }
  async _verifyIdToken(e2, t2, i2) {
    const o2 = await this.nowProvider();
    return E({ iss: this.tokenIssuer, aud: this.options.clientId, id_token: e2, nonce: t2, organization: i2, leeway: this.options.leeway, max_age: (n2 = this.options.authorizationParams.max_age, "string" != typeof n2 ? n2 : parseInt(n2, 10) || void 0), now: o2 });
    var n2;
  }
  _processOrgHint(e2) {
    e2 ? this.cookieStorage.save(this.orgHintCookieName, e2, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }) : this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain });
  }
  async _prepareAuthorizeUrl(e2, t2, i2) {
    const o2 = k(y()), n2 = k(y()), a2 = y(), r2 = ((e3) => {
      const t3 = new Uint8Array(e3);
      return ((e4) => {
        const t4 = { "+": "-", "/": "_", "=": "" };
        return e4.replace(/[+/=]/g, (e5) => t4[e5]);
      })(window.btoa(String.fromCharCode(...Array.from(t3))));
    })(await (async (e3) => {
      const t3 = w().subtle.digest({ name: "SHA-256" }, new TextEncoder().encode(e3));
      return await t3;
    })(a2)), s2 = ((e3, t3, i3, o3, n3, a3, r3, s3) => Object.assign(Object.assign(Object.assign({ client_id: e3.clientId }, e3.authorizationParams), i3), { scope: j(t3, i3.scope), response_type: "code", response_mode: s3 || "query", state: o3, nonce: n3, redirect_uri: r3 || e3.authorizationParams.redirect_uri, code_challenge: a3, code_challenge_method: "S256" }))(this.options, this.scope, e2, o2, n2, r2, e2.redirect_uri || this.options.authorizationParams.redirect_uri || i2, null == t2 ? void 0 : t2.response_mode), c2 = this._authorizeUrl(s2);
    return { nonce: n2, code_verifier: a2, scope: s2.scope, audience: s2.audience || "default", redirect_uri: s2.redirect_uri, state: o2, url: c2 };
  }
  async loginWithPopup(e2, t2) {
    var i2;
    if (e2 = e2 || {}, !(t2 = t2 || {}).popup && (t2.popup = ((e3) => {
      const t3 = window.screenX + (window.innerWidth - 400) / 2, i3 = window.screenY + (window.innerHeight - 600) / 2;
      return window.open(e3, "auth0:authorize:popup", `left=${t3},top=${i3},width=400,height=600,resizable,scrollbars=yes,status=1`);
    })(""), !t2.popup)) throw new Error("Unable to open a popup for loginWithPopup - window.open returned `null`");
    const o2 = await this._prepareAuthorizeUrl(e2.authorizationParams || {}, { response_mode: "web_message" }, window.location.origin);
    t2.popup.location.href = o2.url;
    const n2 = await ((e3) => new Promise((t3, i3) => {
      let o3;
      const n3 = setInterval(() => {
        e3.popup && e3.popup.closed && (clearInterval(n3), clearTimeout(a3), window.removeEventListener("message", o3, false), i3(new p(e3.popup)));
      }, 1e3), a3 = setTimeout(() => {
        clearInterval(n3), i3(new h(e3.popup)), window.removeEventListener("message", o3, false);
      }, 1e3 * (e3.timeoutInSeconds || 60));
      o3 = function(r2) {
        if (r2.data && "authorization_response" === r2.data.type) {
          if (clearTimeout(a3), clearInterval(n3), window.removeEventListener("message", o3, false), e3.popup.close(), r2.data.response.error) return i3(d.fromPayload(r2.data.response));
          t3(r2.data.response);
        }
      }, window.addEventListener("message", o3);
    }))(Object.assign(Object.assign({}, t2), { timeoutInSeconds: t2.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || 60 }));
    if (o2.state !== n2.state) throw new d("state_mismatch", "Invalid state");
    const a2 = (null === (i2 = e2.authorizationParams) || void 0 === i2 ? void 0 : i2.organization) || this.options.authorizationParams.organization;
    await this._requestToken({ audience: o2.audience, scope: o2.scope, code_verifier: o2.code_verifier, grant_type: "authorization_code", code: n2.code, redirect_uri: o2.redirect_uri }, { nonceIn: o2.nonce, organization: a2 });
  }
  async getUser() {
    var e2;
    const t2 = await this._getIdTokenFromCache();
    return null === (e2 = null == t2 ? void 0 : t2.decodedToken) || void 0 === e2 ? void 0 : e2.user;
  }
  async getIdTokenClaims() {
    var e2;
    const t2 = await this._getIdTokenFromCache();
    return null === (e2 = null == t2 ? void 0 : t2.decodedToken) || void 0 === e2 ? void 0 : e2.claims;
  }
  async loginWithRedirect(t2 = {}) {
    var i2;
    const o2 = Q(t2), { openUrl: n2, fragment: a2, appState: r2 } = o2, s2 = e(o2, ["openUrl", "fragment", "appState"]), c2 = (null === (i2 = s2.authorizationParams) || void 0 === i2 ? void 0 : i2.organization) || this.options.authorizationParams.organization, d2 = await this._prepareAuthorizeUrl(s2.authorizationParams || {}), { url: u2 } = d2, l2 = e(d2, ["url"]);
    this.transactionManager.create(Object.assign(Object.assign(Object.assign({}, l2), { appState: r2 }), c2 && { organization: c2 }));
    const h2 = a2 ? `${u2}#${a2}` : u2;
    n2 ? await n2(h2) : window.location.assign(h2);
  }
  async handleRedirectCallback(e2 = window.location.href) {
    const t2 = e2.split("?").slice(1);
    if (0 === t2.length) throw new Error("There are no query params available for parsing.");
    const { state: i2, code: o2, error: n2, error_description: a2 } = ((e3) => {
      e3.indexOf("#") > -1 && (e3 = e3.substring(0, e3.indexOf("#")));
      const t3 = new URLSearchParams(e3);
      return { state: t3.get("state"), code: t3.get("code") || void 0, error: t3.get("error") || void 0, error_description: t3.get("error_description") || void 0 };
    })(t2.join("")), r2 = this.transactionManager.get();
    if (!r2) throw new d("missing_transaction", "Invalid state");
    if (this.transactionManager.remove(), n2) throw new u(n2, a2 || n2, i2, r2.appState);
    if (!r2.code_verifier || r2.state && r2.state !== i2) throw new d("state_mismatch", "Invalid state");
    const s2 = r2.organization, c2 = r2.nonce, l2 = r2.redirect_uri;
    return await this._requestToken(Object.assign({ audience: r2.audience, scope: r2.scope, code_verifier: r2.code_verifier, grant_type: "authorization_code", code: o2 }, l2 ? { redirect_uri: l2 } : {}), { nonceIn: c2, organization: s2 }), { appState: r2.appState };
  }
  async checkSession(e2) {
    if (!this.cookieStorage.get(this.isAuthenticatedCookieName)) {
      if (!this.cookieStorage.get("auth0.is.authenticated")) return;
      this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove("auth0.is.authenticated");
    }
    try {
      await this.getTokenSilently(e2);
    } catch (e3) {
    }
  }
  async getTokenSilently(e2 = {}) {
    var t2;
    const i2 = Object.assign(Object.assign({ cacheMode: "on" }, e2), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e2.authorizationParams), { scope: j(this.scope, null === (t2 = e2.authorizationParams) || void 0 === t2 ? void 0 : t2.scope) }) }), o2 = await ((e3, t3) => {
      let i3 = A[t3];
      return i3 || (i3 = e3().finally(() => {
        delete A[t3], i3 = null;
      }), A[t3] = i3), i3;
    })(() => this._getTokenSilently(i2), `${this.options.clientId}::${i2.authorizationParams.audience}::${i2.authorizationParams.scope}`);
    return e2.detailedResponse ? o2 : null == o2 ? void 0 : o2.access_token;
  }
  async _getTokenSilently(t2) {
    const { cacheMode: i2 } = t2, o2 = e(t2, ["cacheMode"]);
    if ("off" !== i2) {
      const e2 = await this._getEntryFromCache({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || "default", clientId: this.options.clientId });
      if (e2) return e2;
    }
    if ("cache-only" !== i2) {
      if (!await (async (e2, t3 = 3) => {
        for (let i3 = 0; i3 < t3; i3++) if (await e2()) return true;
        return false;
      })(() => ee.acquireLock("auth0.lock.getTokenSilently", 5e3), 10)) throw new l();
      try {
        if (window.addEventListener("pagehide", this._releaseLockOnPageHide), "off" !== i2) {
          const e3 = await this._getEntryFromCache({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || "default", clientId: this.options.clientId });
          if (e3) return e3;
        }
        const e2 = this.options.useRefreshTokens ? await this._getTokenUsingRefreshToken(o2) : await this._getTokenFromIFrame(o2), { id_token: t3, access_token: n2, oauthTokenScope: a2, expires_in: r2 } = e2;
        return Object.assign(Object.assign({ id_token: t3, access_token: n2 }, a2 ? { scope: a2 } : null), { expires_in: r2 });
      } finally {
        await ee.releaseLock("auth0.lock.getTokenSilently"), window.removeEventListener("pagehide", this._releaseLockOnPageHide);
      }
    }
  }
  async getTokenWithPopup(e2 = {}, t2 = {}) {
    var i2;
    const o2 = Object.assign(Object.assign({}, e2), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e2.authorizationParams), { scope: j(this.scope, null === (i2 = e2.authorizationParams) || void 0 === i2 ? void 0 : i2.scope) }) });
    t2 = Object.assign(Object.assign({}, r), t2), await this.loginWithPopup(o2, t2);
    return (await this.cacheManager.get(new C({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || "default", clientId: this.options.clientId }))).access_token;
  }
  async isAuthenticated() {
    return !!await this.getUser();
  }
  _buildLogoutUrl(t2) {
    null !== t2.clientId ? t2.clientId = t2.clientId || this.options.clientId : delete t2.clientId;
    const i2 = t2.logoutParams || {}, { federated: o2 } = i2, n2 = e(i2, ["federated"]), a2 = o2 ? "&federated" : "";
    return this._url(`/v2/logout?${v(Object.assign({ clientId: t2.clientId }, n2))}`) + a2;
  }
  async logout(t2 = {}) {
    const i2 = Q(t2), { openUrl: o2 } = i2, n2 = e(i2, ["openUrl"]);
    null === t2.clientId ? await this.cacheManager.clear() : await this.cacheManager.clear(t2.clientId || this.options.clientId), this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove(this.isAuthenticatedCookieName, { cookieDomain: this.options.cookieDomain }), this.userCache.remove("@@user@@");
    const a2 = this._buildLogoutUrl(n2);
    o2 ? await o2(a2) : false !== o2 && window.location.assign(a2);
  }
  async _getTokenFromIFrame(e2) {
    const t2 = Object.assign(Object.assign({}, e2.authorizationParams), { prompt: "none" }), i2 = this.cookieStorage.get(this.orgHintCookieName);
    i2 && !t2.organization && (t2.organization = i2);
    const { url: o2, state: n2, nonce: a2, code_verifier: r2, redirect_uri: s2, scope: c2, audience: u2 } = await this._prepareAuthorizeUrl(t2, { response_mode: "web_message" }, window.location.origin);
    try {
      if (window.crossOriginIsolated) throw new d("login_required", "The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.");
      const i3 = e2.timeoutInSeconds || this.options.authorizeTimeoutInSeconds, h2 = await ((e3, t3, i4 = 60) => new Promise((o3, n3) => {
        const a3 = window.document.createElement("iframe");
        a3.setAttribute("width", "0"), a3.setAttribute("height", "0"), a3.style.display = "none";
        const r3 = () => {
          window.document.body.contains(a3) && (window.document.body.removeChild(a3), window.removeEventListener("message", s3, false));
        };
        let s3;
        const c3 = setTimeout(() => {
          n3(new l()), r3();
        }, 1e3 * i4);
        s3 = function(e4) {
          if (e4.origin != t3) return;
          if (!e4.data || "authorization_response" !== e4.data.type) return;
          const i5 = e4.source;
          i5 && i5.close(), e4.data.response.error ? n3(d.fromPayload(e4.data.response)) : o3(e4.data.response), clearTimeout(c3), window.removeEventListener("message", s3, false), setTimeout(r3, 2e3);
        }, window.addEventListener("message", s3, false), window.document.body.appendChild(a3), a3.setAttribute("src", e3);
      }))(o2, this.domainUrl, i3);
      if (n2 !== h2.state) throw new d("state_mismatch", "Invalid state");
      const p2 = await this._requestToken(Object.assign(Object.assign({}, e2.authorizationParams), { code_verifier: r2, code: h2.code, grant_type: "authorization_code", redirect_uri: s2, timeout: e2.authorizationParams.timeout || this.httpTimeoutMs }), { nonceIn: a2, organization: t2.organization });
      return Object.assign(Object.assign({}, p2), { scope: c2, oauthTokenScope: p2.scope, audience: u2 });
    } catch (e3) {
      throw "login_required" === e3.error && this.logout({ openUrl: false }), e3;
    }
  }
  async _getTokenUsingRefreshToken(e2) {
    const t2 = await this.cacheManager.get(new C({ scope: e2.authorizationParams.scope, audience: e2.authorizationParams.audience || "default", clientId: this.options.clientId }));
    if (!(t2 && t2.refresh_token || this.worker)) {
      if (this.options.useRefreshTokensFallback) return await this._getTokenFromIFrame(e2);
      throw new f(e2.authorizationParams.audience || "default", e2.authorizationParams.scope);
    }
    const i2 = e2.authorizationParams.redirect_uri || this.options.authorizationParams.redirect_uri || window.location.origin, o2 = "number" == typeof e2.timeoutInSeconds ? 1e3 * e2.timeoutInSeconds : null;
    try {
      const n2 = await this._requestToken(Object.assign(Object.assign(Object.assign({}, e2.authorizationParams), { grant_type: "refresh_token", refresh_token: t2 && t2.refresh_token, redirect_uri: i2 }), o2 && { timeout: o2 }));
      return Object.assign(Object.assign({}, n2), { scope: e2.authorizationParams.scope, oauthTokenScope: n2.scope, audience: e2.authorizationParams.audience || "default" });
    } catch (t3) {
      if ((t3.message.indexOf("Missing Refresh Token") > -1 || t3.message && t3.message.indexOf("invalid refresh token") > -1) && this.options.useRefreshTokensFallback) return await this._getTokenFromIFrame(e2);
      throw t3;
    }
  }
  async _saveEntryInCache(t2) {
    const { id_token: i2, decodedToken: o2 } = t2, n2 = e(t2, ["id_token", "decodedToken"]);
    this.userCache.set("@@user@@", { id_token: i2, decodedToken: o2 }), await this.cacheManager.setIdToken(this.options.clientId, t2.id_token, t2.decodedToken), await this.cacheManager.set(n2);
  }
  async _getIdTokenFromCache() {
    const e2 = this.options.authorizationParams.audience || "default", t2 = await this.cacheManager.getIdToken(new C({ clientId: this.options.clientId, audience: e2, scope: this.scope })), i2 = this.userCache.get("@@user@@");
    return t2 && t2.id_token === (null == i2 ? void 0 : i2.id_token) ? i2 : (this.userCache.set("@@user@@", t2), t2);
  }
  async _getEntryFromCache({ scope: e2, audience: t2, clientId: i2 }) {
    const o2 = await this.cacheManager.get(new C({ scope: e2, audience: t2, clientId: i2 }), 60);
    if (o2 && o2.access_token) {
      const { access_token: e3, oauthTokenScope: t3, expires_in: i3 } = o2, n2 = await this._getIdTokenFromCache();
      return n2 && Object.assign(Object.assign({ id_token: n2.id_token, access_token: e3 }, t3 ? { scope: t3 } : null), { expires_in: i3 });
    }
  }
  async _requestToken(e2, t2) {
    const { nonceIn: i2, organization: o2 } = t2 || {}, n2 = await T(Object.assign({ baseUrl: this.domainUrl, client_id: this.options.clientId, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData, timeout: this.httpTimeoutMs }, e2), this.worker), a2 = await this._verifyIdToken(n2.id_token, i2, o2);
    return await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, n2), { decodedToken: a2, scope: e2.scope, audience: e2.audience || "default" }), n2.scope ? { oauthTokenScope: n2.scope } : null), { client_id: this.options.clientId })), this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this._processOrgHint(o2 || a2.claims.org_id), Object.assign(Object.assign({}, n2), { decodedToken: a2 });
  }
};
async function oe(e2) {
  const t2 = new te(e2);
  return await t2.checkSession(), t2;
}

// ../../node_modules/@othent/kms/dist/index.mjs
var import_extend = __toESM(require_extend(), 1);

// ../../node_modules/axios/lib/helpers/bind.js
function bind(fn2, thisArg) {
  return function wrap() {
    return fn2.apply(thisArg, arguments);
  };
}

// ../../node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn2, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn2.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys[i2];
      fn2.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i2 = keys.length;
  let _key;
  while (i2-- > 0) {
    _key = keys[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
var extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i2 = thing.length;
  if (!isNumber(i2)) return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn2) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn2.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p12, p2) {
      return p12.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    let ret;
    if ((ret = reducer(descriptor, name2, obj)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define3 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define3(arrayOrString) : define3(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet2 = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length2 } = alphabet2;
  while (size--) {
    str += alphabet2[Math.random() * length2 | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

// ../../node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code2, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code2, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code2, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// ../../node_modules/axios/lib/helpers/null.js
var null_default = null;

// ../../node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el2, index) {
          !(utils_default.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el2, key) {
      const result = !(utils_default.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// ../../node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// ../../node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// ../../node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn2) {
    utils_default.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn2(h2);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// ../../node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// ../../node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// ../../node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// ../../node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// ../../node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// ../../node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// ../../node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// ../../node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// ../../node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name2) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i2;
  const len = keys.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name2 = path[index++];
    if (name2 === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index >= path.length;
    name2 = !name2 && utils_default.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils_default.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index);
    if (result && utils_default.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// ../../node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError_default.from(e2, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// ../../node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i2 = line.indexOf(":");
    key = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// ../../node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w3, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher2) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher2 || matchHeaderValue(this, this[key], key, matcher2)));
    }
    return false;
  }
  delete(header, matcher2) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher2 || matchHeaderValue(self2, self2[key], key, matcher2))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher2) {
    const keys = Object.keys(this);
    let i2 = keys.length;
    let deleted = false;
    while (i2--) {
      const key = keys[i2];
      if (!matcher2 || matchHeaderValue(this, this[key], key, matcher2, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// ../../node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn2) {
    data = fn2.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// ../../node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// ../../node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// ../../node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// ../../node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// ../../node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// ../../node_modules/axios/lib/helpers/throttle.js
function throttle(fn2, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn2.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// ../../node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn2) => (...args) => utils_default.asap(() => fn2(...args));

// ../../node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// ../../node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name2, value, expires, path, domain, secure) {
      const cookie = [name2 + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name2) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// ../../node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// ../../node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// ../../node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// ../../node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, prop, caseless) {
    if (!utils_default.isUndefined(b2)) {
      return getMergedValue(a2, b2, prop, caseless);
    } else if (!utils_default.isUndefined(a2)) {
      return getMergedValue(void 0, a2, prop, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils_default.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils_default.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils_default.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), prop, true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// ../../node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// ../../node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// ../../node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length: length2 } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length2) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// ../../node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};

// ../../node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = (fn2, ...args) => {
  try {
    return !!fn2(...args);
  } catch (e2) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_3, config) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length2 = utils_default.toFiniteNumber(headers.getContentLength());
  return length2 == null ? getBodyLength(body) : length2;
};
var fetch_default = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default.from(err, err && err.code, config, request);
  }
});

// ../../node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn2, value) => {
  if (fn2) {
    try {
      Object.defineProperty(fn2, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn2, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length: length2 } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length2; i2++) {
      nameOrAdapter = adapters[i2];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i2] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// ../../node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// ../../node_modules/axios/lib/env/data.js
var VERSION = "1.7.9";

// ../../node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i2 = keys.length;
  while (i2-- > 0) {
    const opt = keys[i2];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// ../../node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// ../../node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// ../../node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// ../../node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// ../../node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// ../../node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// ../../node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// ../../node_modules/@othent/kms/dist/index.mjs
var B64js = __toESM(require_base64_js(), 1);
var import_arweave_mnemonic_keys = __toESM(require_dist(), 1);

// ../../node_modules/warp-arbundles/build/web/esm/bundle.js
var xr = Object.create;
var it = Object.defineProperty;
var mr = Object.getOwnPropertyDescriptor;
var Br = Object.getOwnPropertyNames;
var Er = Object.getPrototypeOf;
var br = Object.prototype.hasOwnProperty;
var T2 = (e2, t2) => () => (t2 || e2((t2 = { exports: {} }).exports, t2), t2.exports);
var Ar = (e2, t2) => {
  for (var r2 in t2) it(e2, r2, { get: t2[r2], enumerable: true });
};
var Tr = (e2, t2, r2, n2) => {
  if (t2 && typeof t2 == "object" || typeof t2 == "function") for (let i2 of Br(t2)) !br.call(e2, i2) && i2 !== r2 && it(e2, i2, { get: () => t2[i2], enumerable: !(n2 = mr(t2, i2)) || n2.enumerable });
  return e2;
};
var C2 = (e2, t2, r2) => (r2 = e2 != null ? xr(Er(e2)) : {}, Tr(t2 || !e2 || !e2.__esModule ? it(r2, "default", { value: e2, enumerable: true }) : r2, e2));
var Rt = T2((st2) => {
  "use strict";
  Object.defineProperty(st2, "__esModule", { value: true });
  function Ir2(e2) {
    var t2 = 4, r2 = e2.length, n2 = r2 % t2;
    if (!n2) return e2;
    var i2 = r2, o2 = t2 - n2, s2 = r2 + o2, u2 = Buffer.alloc(s2);
    for (u2.write(e2); o2--; ) u2.write("=", i2++);
    return u2.toString();
  }
  st2.default = Ir2;
});
var Dt = T2((ht2) => {
  "use strict";
  Object.defineProperty(ht2, "__esModule", { value: true });
  var Sr2 = Rt();
  function Ct2(e2, t2) {
    return t2 === void 0 && (t2 = "utf8"), Buffer.isBuffer(e2) ? at(e2.toString("base64")) : at(Buffer.from(e2, t2).toString("base64"));
  }
  function Ur2(e2, t2) {
    return t2 === void 0 && (t2 = "utf8"), Buffer.from(ut2(e2), "base64").toString(t2);
  }
  function ut2(e2) {
    return e2 = e2.toString(), Sr2.default(e2).replace(/\-/g, "+").replace(/_/g, "/");
  }
  function at(e2) {
    return e2.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function Fr2(e2) {
    return Buffer.from(ut2(e2), "base64");
  }
  var O2 = Ct2;
  O2.encode = Ct2;
  O2.decode = Ur2;
  O2.toBase64 = ut2;
  O2.fromBase64 = at;
  O2.toBuffer = Fr2;
  ht2.default = O2;
});
var z2 = T2((me, V2) => {
  V2.exports = Dt().default;
  V2.exports.default = V2.exports;
});
var ct = T2((J2) => {
  "use strict";
  J2.byteLength = _r2;
  J2.toByteArray = Cr2;
  J2.fromByteArray = Nr2;
  var b2 = [], m2 = [], Lr3 = typeof Uint8Array < "u" ? Uint8Array : Array, ft = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (D2 = 0, Pt2 = ft.length; D2 < Pt2; ++D2) b2[D2] = ft[D2], m2[ft.charCodeAt(D2)] = D2;
  var D2, Pt2;
  m2["-".charCodeAt(0)] = 62;
  m2["_".charCodeAt(0)] = 63;
  function Nt2(e2) {
    var t2 = e2.length;
    if (t2 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var r2 = e2.indexOf("=");
    r2 === -1 && (r2 = t2);
    var n2 = r2 === t2 ? 0 : 4 - r2 % 4;
    return [r2, n2];
  }
  function _r2(e2) {
    var t2 = Nt2(e2), r2 = t2[0], n2 = t2[1];
    return (r2 + n2) * 3 / 4 - n2;
  }
  function Rr2(e2, t2, r2) {
    return (t2 + r2) * 3 / 4 - r2;
  }
  function Cr2(e2) {
    var t2, r2 = Nt2(e2), n2 = r2[0], i2 = r2[1], o2 = new Lr3(Rr2(e2, n2, i2)), s2 = 0, u2 = i2 > 0 ? n2 - 4 : n2, h2;
    for (h2 = 0; h2 < u2; h2 += 4) t2 = m2[e2.charCodeAt(h2)] << 18 | m2[e2.charCodeAt(h2 + 1)] << 12 | m2[e2.charCodeAt(h2 + 2)] << 6 | m2[e2.charCodeAt(h2 + 3)], o2[s2++] = t2 >> 16 & 255, o2[s2++] = t2 >> 8 & 255, o2[s2++] = t2 & 255;
    return i2 === 2 && (t2 = m2[e2.charCodeAt(h2)] << 2 | m2[e2.charCodeAt(h2 + 1)] >> 4, o2[s2++] = t2 & 255), i2 === 1 && (t2 = m2[e2.charCodeAt(h2)] << 10 | m2[e2.charCodeAt(h2 + 1)] << 4 | m2[e2.charCodeAt(h2 + 2)] >> 2, o2[s2++] = t2 >> 8 & 255, o2[s2++] = t2 & 255), o2;
  }
  function Dr2(e2) {
    return b2[e2 >> 18 & 63] + b2[e2 >> 12 & 63] + b2[e2 >> 6 & 63] + b2[e2 & 63];
  }
  function Pr(e2, t2, r2) {
    for (var n2, i2 = [], o2 = t2; o2 < r2; o2 += 3) n2 = (e2[o2] << 16 & 16711680) + (e2[o2 + 1] << 8 & 65280) + (e2[o2 + 2] & 255), i2.push(Dr2(n2));
    return i2.join("");
  }
  function Nr2(e2) {
    for (var t2, r2 = e2.length, n2 = r2 % 3, i2 = [], o2 = 16383, s2 = 0, u2 = r2 - n2; s2 < u2; s2 += o2) i2.push(Pr(e2, s2, s2 + o2 > u2 ? u2 : s2 + o2));
    return n2 === 1 ? (t2 = e2[r2 - 1], i2.push(b2[t2 >> 2] + b2[t2 << 4 & 63] + "==")) : n2 === 2 && (t2 = (e2[r2 - 2] << 8) + e2[r2 - 1], i2.push(b2[t2 >> 10] + b2[t2 >> 4 & 63] + b2[t2 << 2 & 63] + "=")), i2.join("");
  }
});
var pt = T2((g2) => {
  "use strict";
  Object.defineProperty(g2, "__esModule", { value: true });
  g2.b64UrlDecode = g2.b64UrlEncode = g2.bufferTob64Url = g2.bufferTob64 = g2.b64UrlToBuffer = g2.stringToB64Url = g2.stringToBuffer = g2.bufferToString = g2.b64UrlToString = g2.concatBuffers = void 0;
  var kt2 = ct();
  function kr2(e2) {
    let t2 = 0;
    for (let i2 = 0; i2 < e2.length; i2++) t2 += e2[i2].byteLength;
    let r2 = new Uint8Array(t2), n2 = 0;
    r2.set(new Uint8Array(e2[0]), n2), n2 += e2[0].byteLength;
    for (let i2 = 1; i2 < e2.length; i2++) r2.set(new Uint8Array(e2[i2]), n2), n2 += e2[i2].byteLength;
    return r2;
  }
  g2.concatBuffers = kr2;
  function Mr2(e2) {
    let t2 = $t2(e2);
    return Mt2(t2);
  }
  g2.b64UrlToString = Mr2;
  function Mt2(e2) {
    return new TextDecoder("utf-8", { fatal: true }).decode(e2);
  }
  g2.bufferToString = Mt2;
  function Ot2(e2) {
    return new TextEncoder().encode(e2);
  }
  g2.stringToBuffer = Ot2;
  function Or2(e2) {
    return Ht2(Ot2(e2));
  }
  g2.stringToB64Url = Or2;
  function $t2(e2) {
    return new Uint8Array(kt2.toByteArray(qt2(e2)));
  }
  g2.b64UrlToBuffer = $t2;
  function Kt2(e2) {
    return kt2.fromByteArray(new Uint8Array(e2));
  }
  g2.bufferTob64 = Kt2;
  function Ht2(e2) {
    return jt2(Kt2(e2));
  }
  g2.bufferTob64Url = Ht2;
  function jt2(e2) {
    return e2.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  }
  g2.b64UrlEncode = jt2;
  function qt2(e2) {
    e2 = e2.replace(/\-/g, "+").replace(/\_/g, "/");
    let t2;
    return e2.length % 4 == 0 ? t2 = 0 : t2 = 4 - e2.length % 4, e2.concat("=".repeat(t2));
  }
  g2.b64UrlDecode = qt2;
});
var Yt = T2((gt2) => {
  "use strict";
  Object.defineProperty(gt2, "__esModule", { value: true });
  var F2 = pt(), lt2 = class {
    constructor() {
      __publicField(this, "keyLength", 4096);
      __publicField(this, "publicExponent", 65537);
      __publicField(this, "hashAlgorithm", "sha256");
      __publicField(this, "driver");
      if (!this.detectWebCrypto()) throw new Error("SubtleCrypto not available!");
      this.driver = crypto.subtle;
    }
    async generateJWK() {
      let t2 = await this.driver.generateKey({ name: "RSA-PSS", modulusLength: 4096, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: "SHA-256" } }, true, ["sign"]), r2 = await this.driver.exportKey("jwk", t2.privateKey);
      return { kty: r2.kty, e: r2.e, n: r2.n, d: r2.d, p: r2.p, q: r2.q, dp: r2.dp, dq: r2.dq, qi: r2.qi };
    }
    async sign(t2, r2, { saltLength: n2 } = {}) {
      let i2 = await this.driver.sign({ name: "RSA-PSS", saltLength: 32 }, await this.jwkToCryptoKey(t2), r2);
      return new Uint8Array(i2);
    }
    async hash(t2, r2 = "SHA-256") {
      let n2 = await this.driver.digest(r2, t2);
      return new Uint8Array(n2);
    }
    async verify(t2, r2, n2) {
      let i2 = { kty: "RSA", e: "AQAB", n: t2 }, o2 = await this.jwkToPublicCryptoKey(i2), s2 = await this.driver.digest("SHA-256", r2), u2 = await this.driver.verify({ name: "RSA-PSS", saltLength: 0 }, o2, n2, r2), h2 = await this.driver.verify({ name: "RSA-PSS", saltLength: 32 }, o2, n2, r2), p2 = await this.driver.verify({ name: "RSA-PSS", saltLength: Math.ceil((o2.algorithm.modulusLength - 1) / 8) - s2.byteLength - 2 }, o2, n2, r2);
      return u2 || h2 || p2;
    }
    async jwkToCryptoKey(t2) {
      return this.driver.importKey("jwk", t2, { name: "RSA-PSS", hash: { name: "SHA-256" } }, false, ["sign"]);
    }
    async jwkToPublicCryptoKey(t2) {
      return this.driver.importKey("jwk", t2, { name: "RSA-PSS", hash: { name: "SHA-256" } }, false, ["verify"]);
    }
    detectWebCrypto() {
      if (typeof crypto > "u") return false;
      let t2 = crypto == null ? void 0 : crypto.subtle;
      return t2 === void 0 ? false : ["generateKey", "importKey", "exportKey", "digest", "sign"].every((n2) => typeof t2[n2] == "function");
    }
    async encrypt(t2, r2, n2) {
      let i2 = await this.driver.importKey("raw", typeof r2 == "string" ? F2.stringToBuffer(r2) : r2, { name: "PBKDF2", length: 32 }, false, ["deriveKey"]), o2 = await this.driver.deriveKey({ name: "PBKDF2", salt: n2 ? F2.stringToBuffer(n2) : F2.stringToBuffer("salt"), iterations: 1e5, hash: "SHA-256" }, i2, { name: "AES-CBC", length: 256 }, false, ["encrypt", "decrypt"]), s2 = new Uint8Array(16);
      crypto.getRandomValues(s2);
      let u2 = await this.driver.encrypt({ name: "AES-CBC", iv: s2 }, o2, t2);
      return F2.concatBuffers([s2, u2]);
    }
    async decrypt(t2, r2, n2) {
      let i2 = await this.driver.importKey("raw", typeof r2 == "string" ? F2.stringToBuffer(r2) : r2, { name: "PBKDF2", length: 32 }, false, ["deriveKey"]), o2 = await this.driver.deriveKey({ name: "PBKDF2", salt: n2 ? F2.stringToBuffer(n2) : F2.stringToBuffer("salt"), iterations: 1e5, hash: "SHA-256" }, i2, { name: "AES-CBC", length: 256 }, false, ["encrypt", "decrypt"]), s2 = t2.slice(0, 16), u2 = await this.driver.decrypt({ name: "AES-CBC", iv: s2 }, o2, t2.slice(16));
      return F2.concatBuffers([u2]);
    }
  };
  gt2.default = lt2;
});
var zt = T2((mt2) => {
  mt2.read = function(e2, t2, r2, n2, i2) {
    var o2, s2, u2 = i2 * 8 - n2 - 1, h2 = (1 << u2) - 1, p2 = h2 >> 1, f2 = -7, c2 = r2 ? i2 - 1 : 0, U2 = r2 ? -1 : 1, l2 = e2[t2 + c2];
    for (c2 += U2, o2 = l2 & (1 << -f2) - 1, l2 >>= -f2, f2 += u2; f2 > 0; o2 = o2 * 256 + e2[t2 + c2], c2 += U2, f2 -= 8) ;
    for (s2 = o2 & (1 << -f2) - 1, o2 >>= -f2, f2 += n2; f2 > 0; s2 = s2 * 256 + e2[t2 + c2], c2 += U2, f2 -= 8) ;
    if (o2 === 0) o2 = 1 - p2;
    else {
      if (o2 === h2) return s2 ? NaN : (l2 ? -1 : 1) * (1 / 0);
      s2 = s2 + Math.pow(2, n2), o2 = o2 - p2;
    }
    return (l2 ? -1 : 1) * s2 * Math.pow(2, o2 - n2);
  };
  mt2.write = function(e2, t2, r2, n2, i2, o2) {
    var s2, u2, h2, p2 = o2 * 8 - i2 - 1, f2 = (1 << p2) - 1, c2 = f2 >> 1, U2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, l2 = n2 ? 0 : o2 - 1, R2 = n2 ? 1 : -1, G2 = t2 < 0 || t2 === 0 && 1 / t2 < 0 ? 1 : 0;
    for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (u2 = isNaN(t2) ? 1 : 0, s2 = f2) : (s2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (h2 = Math.pow(2, -s2)) < 1 && (s2--, h2 *= 2), s2 + c2 >= 1 ? t2 += U2 / h2 : t2 += U2 * Math.pow(2, 1 - c2), t2 * h2 >= 2 && (s2++, h2 /= 2), s2 + c2 >= f2 ? (u2 = 0, s2 = f2) : s2 + c2 >= 1 ? (u2 = (t2 * h2 - 1) * Math.pow(2, i2), s2 = s2 + c2) : (u2 = t2 * Math.pow(2, c2 - 1) * Math.pow(2, i2), s2 = 0)); i2 >= 8; e2[r2 + l2] = u2 & 255, l2 += R2, u2 /= 256, i2 -= 8) ;
    for (s2 = s2 << i2 | u2, p2 += i2; p2 > 0; e2[r2 + l2] = s2 & 255, l2 += R2, s2 /= 256, p2 -= 8) ;
    e2[r2 + l2 - R2] |= G2 * 128;
  };
});
var nt = T2((q2) => {
  "use strict";
  var Bt2 = ct(), H2 = zt(), Jt2 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  q2.Buffer = a2;
  q2.SlowBuffer = Vr2;
  q2.INSPECT_MAX_BYTES = 50;
  var rt = 2147483647;
  q2.kMaxLength = rt;
  a2.TYPED_ARRAY_SUPPORT = qr2();
  !a2.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function qr2() {
    try {
      let e2 = new Uint8Array(1), t2 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(t2, Uint8Array.prototype), Object.setPrototypeOf(e2, t2), e2.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(a2.prototype, "parent", { enumerable: true, get: function() {
    if (a2.isBuffer(this)) return this.buffer;
  } });
  Object.defineProperty(a2.prototype, "offset", { enumerable: true, get: function() {
    if (a2.isBuffer(this)) return this.byteOffset;
  } });
  function S2(e2) {
    if (e2 > rt) throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
    let t2 = new Uint8Array(e2);
    return Object.setPrototypeOf(t2, a2.prototype), t2;
  }
  function a2(e2, t2, r2) {
    if (typeof e2 == "number") {
      if (typeof t2 == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
      return Tt2(e2);
    }
    return tr2(e2, t2, r2);
  }
  a2.poolSize = 8192;
  function tr2(e2, t2, r2) {
    if (typeof e2 == "string") return Yr2(e2, t2);
    if (ArrayBuffer.isView(e2)) return vr2(e2);
    if (e2 == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
    if (A2(e2, ArrayBuffer) || e2 && A2(e2.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (A2(e2, SharedArrayBuffer) || e2 && A2(e2.buffer, SharedArrayBuffer))) return bt2(e2, t2, r2);
    if (typeof e2 == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    let n2 = e2.valueOf && e2.valueOf();
    if (n2 != null && n2 !== e2) return a2.from(n2, t2, r2);
    let i2 = Wr2(e2);
    if (i2) return i2;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e2[Symbol.toPrimitive] == "function") return a2.from(e2[Symbol.toPrimitive]("string"), t2, r2);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
  }
  a2.from = function(e2, t2, r2) {
    return tr2(e2, t2, r2);
  };
  Object.setPrototypeOf(a2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(a2, Uint8Array);
  function rr2(e2) {
    if (typeof e2 != "number") throw new TypeError('"size" argument must be of type number');
    if (e2 < 0) throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
  }
  function Gr2(e2, t2, r2) {
    return rr2(e2), e2 <= 0 ? S2(e2) : t2 !== void 0 ? typeof r2 == "string" ? S2(e2).fill(t2, r2) : S2(e2).fill(t2) : S2(e2);
  }
  a2.alloc = function(e2, t2, r2) {
    return Gr2(e2, t2, r2);
  };
  function Tt2(e2) {
    return rr2(e2), S2(e2 < 0 ? 0 : It2(e2) | 0);
  }
  a2.allocUnsafe = function(e2) {
    return Tt2(e2);
  };
  a2.allocUnsafeSlow = function(e2) {
    return Tt2(e2);
  };
  function Yr2(e2, t2) {
    if ((typeof t2 != "string" || t2 === "") && (t2 = "utf8"), !a2.isEncoding(t2)) throw new TypeError("Unknown encoding: " + t2);
    let r2 = er2(e2, t2) | 0, n2 = S2(r2), i2 = n2.write(e2, t2);
    return i2 !== r2 && (n2 = n2.slice(0, i2)), n2;
  }
  function Et2(e2) {
    let t2 = e2.length < 0 ? 0 : It2(e2.length) | 0, r2 = S2(t2);
    for (let n2 = 0; n2 < t2; n2 += 1) r2[n2] = e2[n2] & 255;
    return r2;
  }
  function vr2(e2) {
    if (A2(e2, Uint8Array)) {
      let t2 = new Uint8Array(e2);
      return bt2(t2.buffer, t2.byteOffset, t2.byteLength);
    }
    return Et2(e2);
  }
  function bt2(e2, t2, r2) {
    if (t2 < 0 || e2.byteLength < t2) throw new RangeError('"offset" is outside of buffer bounds');
    if (e2.byteLength < t2 + (r2 || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let n2;
    return t2 === void 0 && r2 === void 0 ? n2 = new Uint8Array(e2) : r2 === void 0 ? n2 = new Uint8Array(e2, t2) : n2 = new Uint8Array(e2, t2, r2), Object.setPrototypeOf(n2, a2.prototype), n2;
  }
  function Wr2(e2) {
    if (a2.isBuffer(e2)) {
      let t2 = It2(e2.length) | 0, r2 = S2(t2);
      return r2.length === 0 || e2.copy(r2, 0, 0, t2), r2;
    }
    if (e2.length !== void 0) return typeof e2.length != "number" || Ut2(e2.length) ? S2(0) : Et2(e2);
    if (e2.type === "Buffer" && Array.isArray(e2.data)) return Et2(e2.data);
  }
  function It2(e2) {
    if (e2 >= rt) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + rt.toString(16) + " bytes");
    return e2 | 0;
  }
  function Vr2(e2) {
    return +e2 != e2 && (e2 = 0), a2.alloc(+e2);
  }
  a2.isBuffer = function(t2) {
    return t2 != null && t2._isBuffer === true && t2 !== a2.prototype;
  };
  a2.compare = function(t2, r2) {
    if (A2(t2, Uint8Array) && (t2 = a2.from(t2, t2.offset, t2.byteLength)), A2(r2, Uint8Array) && (r2 = a2.from(r2, r2.offset, r2.byteLength)), !a2.isBuffer(t2) || !a2.isBuffer(r2)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (t2 === r2) return 0;
    let n2 = t2.length, i2 = r2.length;
    for (let o2 = 0, s2 = Math.min(n2, i2); o2 < s2; ++o2) if (t2[o2] !== r2[o2]) {
      n2 = t2[o2], i2 = r2[o2];
      break;
    }
    return n2 < i2 ? -1 : i2 < n2 ? 1 : 0;
  };
  a2.isEncoding = function(t2) {
    switch (String(t2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  a2.concat = function(t2, r2) {
    if (!Array.isArray(t2)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (t2.length === 0) return a2.alloc(0);
    let n2;
    if (r2 === void 0) for (r2 = 0, n2 = 0; n2 < t2.length; ++n2) r2 += t2[n2].length;
    let i2 = a2.allocUnsafe(r2), o2 = 0;
    for (n2 = 0; n2 < t2.length; ++n2) {
      let s2 = t2[n2];
      if (A2(s2, Uint8Array)) o2 + s2.length > i2.length ? (a2.isBuffer(s2) || (s2 = a2.from(s2)), s2.copy(i2, o2)) : Uint8Array.prototype.set.call(i2, s2, o2);
      else if (a2.isBuffer(s2)) s2.copy(i2, o2);
      else throw new TypeError('"list" argument must be an Array of Buffers');
      o2 += s2.length;
    }
    return i2;
  };
  function er2(e2, t2) {
    if (a2.isBuffer(e2)) return e2.length;
    if (ArrayBuffer.isView(e2) || A2(e2, ArrayBuffer)) return e2.byteLength;
    if (typeof e2 != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e2);
    let r2 = e2.length, n2 = arguments.length > 2 && arguments[2] === true;
    if (!n2 && r2 === 0) return 0;
    let i2 = false;
    for (; ; ) switch (t2) {
      case "ascii":
      case "latin1":
      case "binary":
        return r2;
      case "utf8":
      case "utf-8":
        return At2(e2).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return r2 * 2;
      case "hex":
        return r2 >>> 1;
      case "base64":
        return cr2(e2).length;
      default:
        if (i2) return n2 ? -1 : At2(e2).length;
        t2 = ("" + t2).toLowerCase(), i2 = true;
    }
  }
  a2.byteLength = er2;
  function zr2(e2, t2, r2) {
    let n2 = false;
    if ((t2 === void 0 || t2 < 0) && (t2 = 0), t2 > this.length || ((r2 === void 0 || r2 > this.length) && (r2 = this.length), r2 <= 0) || (r2 >>>= 0, t2 >>>= 0, r2 <= t2)) return "";
    for (e2 || (e2 = "utf8"); ; ) switch (e2) {
      case "hex":
        return oe2(this, t2, r2);
      case "utf8":
      case "utf-8":
        return ir2(this, t2, r2);
      case "ascii":
        return ne(this, t2, r2);
      case "latin1":
      case "binary":
        return ie(this, t2, r2);
      case "base64":
        return re(this, t2, r2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return se(this, t2, r2);
      default:
        if (n2) throw new TypeError("Unknown encoding: " + e2);
        e2 = (e2 + "").toLowerCase(), n2 = true;
    }
  }
  a2.prototype._isBuffer = true;
  function k2(e2, t2, r2) {
    let n2 = e2[t2];
    e2[t2] = e2[r2], e2[r2] = n2;
  }
  a2.prototype.swap16 = function() {
    let t2 = this.length;
    if (t2 % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let r2 = 0; r2 < t2; r2 += 2) k2(this, r2, r2 + 1);
    return this;
  };
  a2.prototype.swap32 = function() {
    let t2 = this.length;
    if (t2 % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let r2 = 0; r2 < t2; r2 += 4) k2(this, r2, r2 + 3), k2(this, r2 + 1, r2 + 2);
    return this;
  };
  a2.prototype.swap64 = function() {
    let t2 = this.length;
    if (t2 % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let r2 = 0; r2 < t2; r2 += 8) k2(this, r2, r2 + 7), k2(this, r2 + 1, r2 + 6), k2(this, r2 + 2, r2 + 5), k2(this, r2 + 3, r2 + 4);
    return this;
  };
  a2.prototype.toString = function() {
    let t2 = this.length;
    return t2 === 0 ? "" : arguments.length === 0 ? ir2(this, 0, t2) : zr2.apply(this, arguments);
  };
  a2.prototype.toLocaleString = a2.prototype.toString;
  a2.prototype.equals = function(t2) {
    if (!a2.isBuffer(t2)) throw new TypeError("Argument must be a Buffer");
    return this === t2 ? true : a2.compare(this, t2) === 0;
  };
  a2.prototype.inspect = function() {
    let t2 = "", r2 = q2.INSPECT_MAX_BYTES;
    return t2 = this.toString("hex", 0, r2).replace(/(.{2})/g, "$1 ").trim(), this.length > r2 && (t2 += " ... "), "<Buffer " + t2 + ">";
  };
  Jt2 && (a2.prototype[Jt2] = a2.prototype.inspect);
  a2.prototype.compare = function(t2, r2, n2, i2, o2) {
    if (A2(t2, Uint8Array) && (t2 = a2.from(t2, t2.offset, t2.byteLength)), !a2.isBuffer(t2)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t2);
    if (r2 === void 0 && (r2 = 0), n2 === void 0 && (n2 = t2 ? t2.length : 0), i2 === void 0 && (i2 = 0), o2 === void 0 && (o2 = this.length), r2 < 0 || n2 > t2.length || i2 < 0 || o2 > this.length) throw new RangeError("out of range index");
    if (i2 >= o2 && r2 >= n2) return 0;
    if (i2 >= o2) return -1;
    if (r2 >= n2) return 1;
    if (r2 >>>= 0, n2 >>>= 0, i2 >>>= 0, o2 >>>= 0, this === t2) return 0;
    let s2 = o2 - i2, u2 = n2 - r2, h2 = Math.min(s2, u2), p2 = this.slice(i2, o2), f2 = t2.slice(r2, n2);
    for (let c2 = 0; c2 < h2; ++c2) if (p2[c2] !== f2[c2]) {
      s2 = p2[c2], u2 = f2[c2];
      break;
    }
    return s2 < u2 ? -1 : u2 < s2 ? 1 : 0;
  };
  function nr2(e2, t2, r2, n2, i2) {
    if (e2.length === 0) return -1;
    if (typeof r2 == "string" ? (n2 = r2, r2 = 0) : r2 > 2147483647 ? r2 = 2147483647 : r2 < -2147483648 && (r2 = -2147483648), r2 = +r2, Ut2(r2) && (r2 = i2 ? 0 : e2.length - 1), r2 < 0 && (r2 = e2.length + r2), r2 >= e2.length) {
      if (i2) return -1;
      r2 = e2.length - 1;
    } else if (r2 < 0) if (i2) r2 = 0;
    else return -1;
    if (typeof t2 == "string" && (t2 = a2.from(t2, n2)), a2.isBuffer(t2)) return t2.length === 0 ? -1 : Xt2(e2, t2, r2, n2, i2);
    if (typeof t2 == "number") return t2 = t2 & 255, typeof Uint8Array.prototype.indexOf == "function" ? i2 ? Uint8Array.prototype.indexOf.call(e2, t2, r2) : Uint8Array.prototype.lastIndexOf.call(e2, t2, r2) : Xt2(e2, [t2], r2, n2, i2);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Xt2(e2, t2, r2, n2, i2) {
    let o2 = 1, s2 = e2.length, u2 = t2.length;
    if (n2 !== void 0 && (n2 = String(n2).toLowerCase(), n2 === "ucs2" || n2 === "ucs-2" || n2 === "utf16le" || n2 === "utf-16le")) {
      if (e2.length < 2 || t2.length < 2) return -1;
      o2 = 2, s2 /= 2, u2 /= 2, r2 /= 2;
    }
    function h2(f2, c2) {
      return o2 === 1 ? f2[c2] : f2.readUInt16BE(c2 * o2);
    }
    let p2;
    if (i2) {
      let f2 = -1;
      for (p2 = r2; p2 < s2; p2++) if (h2(e2, p2) === h2(t2, f2 === -1 ? 0 : p2 - f2)) {
        if (f2 === -1 && (f2 = p2), p2 - f2 + 1 === u2) return f2 * o2;
      } else f2 !== -1 && (p2 -= p2 - f2), f2 = -1;
    } else for (r2 + u2 > s2 && (r2 = s2 - u2), p2 = r2; p2 >= 0; p2--) {
      let f2 = true;
      for (let c2 = 0; c2 < u2; c2++) if (h2(e2, p2 + c2) !== h2(t2, c2)) {
        f2 = false;
        break;
      }
      if (f2) return p2;
    }
    return -1;
  }
  a2.prototype.includes = function(t2, r2, n2) {
    return this.indexOf(t2, r2, n2) !== -1;
  };
  a2.prototype.indexOf = function(t2, r2, n2) {
    return nr2(this, t2, r2, n2, true);
  };
  a2.prototype.lastIndexOf = function(t2, r2, n2) {
    return nr2(this, t2, r2, n2, false);
  };
  function Jr(e2, t2, r2, n2) {
    r2 = Number(r2) || 0;
    let i2 = e2.length - r2;
    n2 ? (n2 = Number(n2), n2 > i2 && (n2 = i2)) : n2 = i2;
    let o2 = t2.length;
    n2 > o2 / 2 && (n2 = o2 / 2);
    let s2;
    for (s2 = 0; s2 < n2; ++s2) {
      let u2 = parseInt(t2.substr(s2 * 2, 2), 16);
      if (Ut2(u2)) return s2;
      e2[r2 + s2] = u2;
    }
    return s2;
  }
  function Xr(e2, t2, r2, n2) {
    return et(At2(t2, e2.length - r2), e2, r2, n2);
  }
  function Zr(e2, t2, r2, n2) {
    return et(fe(t2), e2, r2, n2);
  }
  function Qr(e2, t2, r2, n2) {
    return et(cr2(t2), e2, r2, n2);
  }
  function te2(e2, t2, r2, n2) {
    return et(ce(t2, e2.length - r2), e2, r2, n2);
  }
  a2.prototype.write = function(t2, r2, n2, i2) {
    if (r2 === void 0) i2 = "utf8", n2 = this.length, r2 = 0;
    else if (n2 === void 0 && typeof r2 == "string") i2 = r2, n2 = this.length, r2 = 0;
    else if (isFinite(r2)) r2 = r2 >>> 0, isFinite(n2) ? (n2 = n2 >>> 0, i2 === void 0 && (i2 = "utf8")) : (i2 = n2, n2 = void 0);
    else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let o2 = this.length - r2;
    if ((n2 === void 0 || n2 > o2) && (n2 = o2), t2.length > 0 && (n2 < 0 || r2 < 0) || r2 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    i2 || (i2 = "utf8");
    let s2 = false;
    for (; ; ) switch (i2) {
      case "hex":
        return Jr(this, t2, r2, n2);
      case "utf8":
      case "utf-8":
        return Xr(this, t2, r2, n2);
      case "ascii":
      case "latin1":
      case "binary":
        return Zr(this, t2, r2, n2);
      case "base64":
        return Qr(this, t2, r2, n2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return te2(this, t2, r2, n2);
      default:
        if (s2) throw new TypeError("Unknown encoding: " + i2);
        i2 = ("" + i2).toLowerCase(), s2 = true;
    }
  };
  a2.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function re(e2, t2, r2) {
    return t2 === 0 && r2 === e2.length ? Bt2.fromByteArray(e2) : Bt2.fromByteArray(e2.slice(t2, r2));
  }
  function ir2(e2, t2, r2) {
    r2 = Math.min(e2.length, r2);
    let n2 = [], i2 = t2;
    for (; i2 < r2; ) {
      let o2 = e2[i2], s2 = null, u2 = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
      if (i2 + u2 <= r2) {
        let h2, p2, f2, c2;
        switch (u2) {
          case 1:
            o2 < 128 && (s2 = o2);
            break;
          case 2:
            h2 = e2[i2 + 1], (h2 & 192) === 128 && (c2 = (o2 & 31) << 6 | h2 & 63, c2 > 127 && (s2 = c2));
            break;
          case 3:
            h2 = e2[i2 + 1], p2 = e2[i2 + 2], (h2 & 192) === 128 && (p2 & 192) === 128 && (c2 = (o2 & 15) << 12 | (h2 & 63) << 6 | p2 & 63, c2 > 2047 && (c2 < 55296 || c2 > 57343) && (s2 = c2));
            break;
          case 4:
            h2 = e2[i2 + 1], p2 = e2[i2 + 2], f2 = e2[i2 + 3], (h2 & 192) === 128 && (p2 & 192) === 128 && (f2 & 192) === 128 && (c2 = (o2 & 15) << 18 | (h2 & 63) << 12 | (p2 & 63) << 6 | f2 & 63, c2 > 65535 && c2 < 1114112 && (s2 = c2));
        }
      }
      s2 === null ? (s2 = 65533, u2 = 1) : s2 > 65535 && (s2 -= 65536, n2.push(s2 >>> 10 & 1023 | 55296), s2 = 56320 | s2 & 1023), n2.push(s2), i2 += u2;
    }
    return ee2(n2);
  }
  var Zt2 = 4096;
  function ee2(e2) {
    let t2 = e2.length;
    if (t2 <= Zt2) return String.fromCharCode.apply(String, e2);
    let r2 = "", n2 = 0;
    for (; n2 < t2; ) r2 += String.fromCharCode.apply(String, e2.slice(n2, n2 += Zt2));
    return r2;
  }
  function ne(e2, t2, r2) {
    let n2 = "";
    r2 = Math.min(e2.length, r2);
    for (let i2 = t2; i2 < r2; ++i2) n2 += String.fromCharCode(e2[i2] & 127);
    return n2;
  }
  function ie(e2, t2, r2) {
    let n2 = "";
    r2 = Math.min(e2.length, r2);
    for (let i2 = t2; i2 < r2; ++i2) n2 += String.fromCharCode(e2[i2]);
    return n2;
  }
  function oe2(e2, t2, r2) {
    let n2 = e2.length;
    (!t2 || t2 < 0) && (t2 = 0), (!r2 || r2 < 0 || r2 > n2) && (r2 = n2);
    let i2 = "";
    for (let o2 = t2; o2 < r2; ++o2) i2 += pe2[e2[o2]];
    return i2;
  }
  function se(e2, t2, r2) {
    let n2 = e2.slice(t2, r2), i2 = "";
    for (let o2 = 0; o2 < n2.length - 1; o2 += 2) i2 += String.fromCharCode(n2[o2] + n2[o2 + 1] * 256);
    return i2;
  }
  a2.prototype.slice = function(t2, r2) {
    let n2 = this.length;
    t2 = ~~t2, r2 = r2 === void 0 ? n2 : ~~r2, t2 < 0 ? (t2 += n2, t2 < 0 && (t2 = 0)) : t2 > n2 && (t2 = n2), r2 < 0 ? (r2 += n2, r2 < 0 && (r2 = 0)) : r2 > n2 && (r2 = n2), r2 < t2 && (r2 = t2);
    let i2 = this.subarray(t2, r2);
    return Object.setPrototypeOf(i2, a2.prototype), i2;
  };
  function y2(e2, t2, r2) {
    if (e2 % 1 !== 0 || e2 < 0) throw new RangeError("offset is not uint");
    if (e2 + t2 > r2) throw new RangeError("Trying to access beyond buffer length");
  }
  a2.prototype.readUintLE = a2.prototype.readUIntLE = function(t2, r2, n2) {
    t2 = t2 >>> 0, r2 = r2 >>> 0, n2 || y2(t2, r2, this.length);
    let i2 = this[t2], o2 = 1, s2 = 0;
    for (; ++s2 < r2 && (o2 *= 256); ) i2 += this[t2 + s2] * o2;
    return i2;
  };
  a2.prototype.readUintBE = a2.prototype.readUIntBE = function(t2, r2, n2) {
    t2 = t2 >>> 0, r2 = r2 >>> 0, n2 || y2(t2, r2, this.length);
    let i2 = this[t2 + --r2], o2 = 1;
    for (; r2 > 0 && (o2 *= 256); ) i2 += this[t2 + --r2] * o2;
    return i2;
  };
  a2.prototype.readUint8 = a2.prototype.readUInt8 = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y2(t2, 1, this.length), this[t2];
  };
  a2.prototype.readUint16LE = a2.prototype.readUInt16LE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y2(t2, 2, this.length), this[t2] | this[t2 + 1] << 8;
  };
  a2.prototype.readUint16BE = a2.prototype.readUInt16BE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y2(t2, 2, this.length), this[t2] << 8 | this[t2 + 1];
  };
  a2.prototype.readUint32LE = a2.prototype.readUInt32LE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y2(t2, 4, this.length), (this[t2] | this[t2 + 1] << 8 | this[t2 + 2] << 16) + this[t2 + 3] * 16777216;
  };
  a2.prototype.readUint32BE = a2.prototype.readUInt32BE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y2(t2, 4, this.length), this[t2] * 16777216 + (this[t2 + 1] << 16 | this[t2 + 2] << 8 | this[t2 + 3]);
  };
  a2.prototype.readBigUInt64LE = L2(function(t2) {
    t2 = t2 >>> 0, j2(t2, "offset");
    let r2 = this[t2], n2 = this[t2 + 7];
    (r2 === void 0 || n2 === void 0) && W2(t2, this.length - 8);
    let i2 = r2 + this[++t2] * 2 ** 8 + this[++t2] * 2 ** 16 + this[++t2] * 2 ** 24, o2 = this[++t2] + this[++t2] * 2 ** 8 + this[++t2] * 2 ** 16 + n2 * 2 ** 24;
    return BigInt(i2) + (BigInt(o2) << BigInt(32));
  });
  a2.prototype.readBigUInt64BE = L2(function(t2) {
    t2 = t2 >>> 0, j2(t2, "offset");
    let r2 = this[t2], n2 = this[t2 + 7];
    (r2 === void 0 || n2 === void 0) && W2(t2, this.length - 8);
    let i2 = r2 * 2 ** 24 + this[++t2] * 2 ** 16 + this[++t2] * 2 ** 8 + this[++t2], o2 = this[++t2] * 2 ** 24 + this[++t2] * 2 ** 16 + this[++t2] * 2 ** 8 + n2;
    return (BigInt(i2) << BigInt(32)) + BigInt(o2);
  });
  a2.prototype.readIntLE = function(t2, r2, n2) {
    t2 = t2 >>> 0, r2 = r2 >>> 0, n2 || y2(t2, r2, this.length);
    let i2 = this[t2], o2 = 1, s2 = 0;
    for (; ++s2 < r2 && (o2 *= 256); ) i2 += this[t2 + s2] * o2;
    return o2 *= 128, i2 >= o2 && (i2 -= Math.pow(2, 8 * r2)), i2;
  };
  a2.prototype.readIntBE = function(t2, r2, n2) {
    t2 = t2 >>> 0, r2 = r2 >>> 0, n2 || y2(t2, r2, this.length);
    let i2 = r2, o2 = 1, s2 = this[t2 + --i2];
    for (; i2 > 0 && (o2 *= 256); ) s2 += this[t2 + --i2] * o2;
    return o2 *= 128, s2 >= o2 && (s2 -= Math.pow(2, 8 * r2)), s2;
  };
  a2.prototype.readInt8 = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y2(t2, 1, this.length), this[t2] & 128 ? (255 - this[t2] + 1) * -1 : this[t2];
  };
  a2.prototype.readInt16LE = function(t2, r2) {
    t2 = t2 >>> 0, r2 || y2(t2, 2, this.length);
    let n2 = this[t2] | this[t2 + 1] << 8;
    return n2 & 32768 ? n2 | 4294901760 : n2;
  };
  a2.prototype.readInt16BE = function(t2, r2) {
    t2 = t2 >>> 0, r2 || y2(t2, 2, this.length);
    let n2 = this[t2 + 1] | this[t2] << 8;
    return n2 & 32768 ? n2 | 4294901760 : n2;
  };
  a2.prototype.readInt32LE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y2(t2, 4, this.length), this[t2] | this[t2 + 1] << 8 | this[t2 + 2] << 16 | this[t2 + 3] << 24;
  };
  a2.prototype.readInt32BE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y2(t2, 4, this.length), this[t2] << 24 | this[t2 + 1] << 16 | this[t2 + 2] << 8 | this[t2 + 3];
  };
  a2.prototype.readBigInt64LE = L2(function(t2) {
    t2 = t2 >>> 0, j2(t2, "offset");
    let r2 = this[t2], n2 = this[t2 + 7];
    (r2 === void 0 || n2 === void 0) && W2(t2, this.length - 8);
    let i2 = this[t2 + 4] + this[t2 + 5] * 2 ** 8 + this[t2 + 6] * 2 ** 16 + (n2 << 24);
    return (BigInt(i2) << BigInt(32)) + BigInt(r2 + this[++t2] * 2 ** 8 + this[++t2] * 2 ** 16 + this[++t2] * 2 ** 24);
  });
  a2.prototype.readBigInt64BE = L2(function(t2) {
    t2 = t2 >>> 0, j2(t2, "offset");
    let r2 = this[t2], n2 = this[t2 + 7];
    (r2 === void 0 || n2 === void 0) && W2(t2, this.length - 8);
    let i2 = (r2 << 24) + this[++t2] * 2 ** 16 + this[++t2] * 2 ** 8 + this[++t2];
    return (BigInt(i2) << BigInt(32)) + BigInt(this[++t2] * 2 ** 24 + this[++t2] * 2 ** 16 + this[++t2] * 2 ** 8 + n2);
  });
  a2.prototype.readFloatLE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y2(t2, 4, this.length), H2.read(this, t2, true, 23, 4);
  };
  a2.prototype.readFloatBE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y2(t2, 4, this.length), H2.read(this, t2, false, 23, 4);
  };
  a2.prototype.readDoubleLE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y2(t2, 8, this.length), H2.read(this, t2, true, 52, 8);
  };
  a2.prototype.readDoubleBE = function(t2, r2) {
    return t2 = t2 >>> 0, r2 || y2(t2, 8, this.length), H2.read(this, t2, false, 52, 8);
  };
  function d2(e2, t2, r2, n2, i2, o2) {
    if (!a2.isBuffer(e2)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t2 > i2 || t2 < o2) throw new RangeError('"value" argument is out of bounds');
    if (r2 + n2 > e2.length) throw new RangeError("Index out of range");
  }
  a2.prototype.writeUintLE = a2.prototype.writeUIntLE = function(t2, r2, n2, i2) {
    if (t2 = +t2, r2 = r2 >>> 0, n2 = n2 >>> 0, !i2) {
      let u2 = Math.pow(2, 8 * n2) - 1;
      d2(this, t2, r2, n2, u2, 0);
    }
    let o2 = 1, s2 = 0;
    for (this[r2] = t2 & 255; ++s2 < n2 && (o2 *= 256); ) this[r2 + s2] = t2 / o2 & 255;
    return r2 + n2;
  };
  a2.prototype.writeUintBE = a2.prototype.writeUIntBE = function(t2, r2, n2, i2) {
    if (t2 = +t2, r2 = r2 >>> 0, n2 = n2 >>> 0, !i2) {
      let u2 = Math.pow(2, 8 * n2) - 1;
      d2(this, t2, r2, n2, u2, 0);
    }
    let o2 = n2 - 1, s2 = 1;
    for (this[r2 + o2] = t2 & 255; --o2 >= 0 && (s2 *= 256); ) this[r2 + o2] = t2 / s2 & 255;
    return r2 + n2;
  };
  a2.prototype.writeUint8 = a2.prototype.writeUInt8 = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 1, 255, 0), this[r2] = t2 & 255, r2 + 1;
  };
  a2.prototype.writeUint16LE = a2.prototype.writeUInt16LE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 2, 65535, 0), this[r2] = t2 & 255, this[r2 + 1] = t2 >>> 8, r2 + 2;
  };
  a2.prototype.writeUint16BE = a2.prototype.writeUInt16BE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 2, 65535, 0), this[r2] = t2 >>> 8, this[r2 + 1] = t2 & 255, r2 + 2;
  };
  a2.prototype.writeUint32LE = a2.prototype.writeUInt32LE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 4, 4294967295, 0), this[r2 + 3] = t2 >>> 24, this[r2 + 2] = t2 >>> 16, this[r2 + 1] = t2 >>> 8, this[r2] = t2 & 255, r2 + 4;
  };
  a2.prototype.writeUint32BE = a2.prototype.writeUInt32BE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 4, 4294967295, 0), this[r2] = t2 >>> 24, this[r2 + 1] = t2 >>> 16, this[r2 + 2] = t2 >>> 8, this[r2 + 3] = t2 & 255, r2 + 4;
  };
  function or3(e2, t2, r2, n2, i2) {
    fr(t2, n2, i2, e2, r2, 7);
    let o2 = Number(t2 & BigInt(4294967295));
    e2[r2++] = o2, o2 = o2 >> 8, e2[r2++] = o2, o2 = o2 >> 8, e2[r2++] = o2, o2 = o2 >> 8, e2[r2++] = o2;
    let s2 = Number(t2 >> BigInt(32) & BigInt(4294967295));
    return e2[r2++] = s2, s2 = s2 >> 8, e2[r2++] = s2, s2 = s2 >> 8, e2[r2++] = s2, s2 = s2 >> 8, e2[r2++] = s2, r2;
  }
  function sr2(e2, t2, r2, n2, i2) {
    fr(t2, n2, i2, e2, r2, 7);
    let o2 = Number(t2 & BigInt(4294967295));
    e2[r2 + 7] = o2, o2 = o2 >> 8, e2[r2 + 6] = o2, o2 = o2 >> 8, e2[r2 + 5] = o2, o2 = o2 >> 8, e2[r2 + 4] = o2;
    let s2 = Number(t2 >> BigInt(32) & BigInt(4294967295));
    return e2[r2 + 3] = s2, s2 = s2 >> 8, e2[r2 + 2] = s2, s2 = s2 >> 8, e2[r2 + 1] = s2, s2 = s2 >> 8, e2[r2] = s2, r2 + 8;
  }
  a2.prototype.writeBigUInt64LE = L2(function(t2, r2 = 0) {
    return or3(this, t2, r2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  a2.prototype.writeBigUInt64BE = L2(function(t2, r2 = 0) {
    return sr2(this, t2, r2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  a2.prototype.writeIntLE = function(t2, r2, n2, i2) {
    if (t2 = +t2, r2 = r2 >>> 0, !i2) {
      let h2 = Math.pow(2, 8 * n2 - 1);
      d2(this, t2, r2, n2, h2 - 1, -h2);
    }
    let o2 = 0, s2 = 1, u2 = 0;
    for (this[r2] = t2 & 255; ++o2 < n2 && (s2 *= 256); ) t2 < 0 && u2 === 0 && this[r2 + o2 - 1] !== 0 && (u2 = 1), this[r2 + o2] = (t2 / s2 >> 0) - u2 & 255;
    return r2 + n2;
  };
  a2.prototype.writeIntBE = function(t2, r2, n2, i2) {
    if (t2 = +t2, r2 = r2 >>> 0, !i2) {
      let h2 = Math.pow(2, 8 * n2 - 1);
      d2(this, t2, r2, n2, h2 - 1, -h2);
    }
    let o2 = n2 - 1, s2 = 1, u2 = 0;
    for (this[r2 + o2] = t2 & 255; --o2 >= 0 && (s2 *= 256); ) t2 < 0 && u2 === 0 && this[r2 + o2 + 1] !== 0 && (u2 = 1), this[r2 + o2] = (t2 / s2 >> 0) - u2 & 255;
    return r2 + n2;
  };
  a2.prototype.writeInt8 = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 1, 127, -128), t2 < 0 && (t2 = 255 + t2 + 1), this[r2] = t2 & 255, r2 + 1;
  };
  a2.prototype.writeInt16LE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 2, 32767, -32768), this[r2] = t2 & 255, this[r2 + 1] = t2 >>> 8, r2 + 2;
  };
  a2.prototype.writeInt16BE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 2, 32767, -32768), this[r2] = t2 >>> 8, this[r2 + 1] = t2 & 255, r2 + 2;
  };
  a2.prototype.writeInt32LE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 4, 2147483647, -2147483648), this[r2] = t2 & 255, this[r2 + 1] = t2 >>> 8, this[r2 + 2] = t2 >>> 16, this[r2 + 3] = t2 >>> 24, r2 + 4;
  };
  a2.prototype.writeInt32BE = function(t2, r2, n2) {
    return t2 = +t2, r2 = r2 >>> 0, n2 || d2(this, t2, r2, 4, 2147483647, -2147483648), t2 < 0 && (t2 = 4294967295 + t2 + 1), this[r2] = t2 >>> 24, this[r2 + 1] = t2 >>> 16, this[r2 + 2] = t2 >>> 8, this[r2 + 3] = t2 & 255, r2 + 4;
  };
  a2.prototype.writeBigInt64LE = L2(function(t2, r2 = 0) {
    return or3(this, t2, r2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  a2.prototype.writeBigInt64BE = L2(function(t2, r2 = 0) {
    return sr2(this, t2, r2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ar2(e2, t2, r2, n2, i2, o2) {
    if (r2 + n2 > e2.length) throw new RangeError("Index out of range");
    if (r2 < 0) throw new RangeError("Index out of range");
  }
  function ur2(e2, t2, r2, n2, i2) {
    return t2 = +t2, r2 = r2 >>> 0, i2 || ar2(e2, t2, r2, 4, 34028234663852886e22, -34028234663852886e22), H2.write(e2, t2, r2, n2, 23, 4), r2 + 4;
  }
  a2.prototype.writeFloatLE = function(t2, r2, n2) {
    return ur2(this, t2, r2, true, n2);
  };
  a2.prototype.writeFloatBE = function(t2, r2, n2) {
    return ur2(this, t2, r2, false, n2);
  };
  function hr2(e2, t2, r2, n2, i2) {
    return t2 = +t2, r2 = r2 >>> 0, i2 || ar2(e2, t2, r2, 8, 17976931348623157e292, -17976931348623157e292), H2.write(e2, t2, r2, n2, 52, 8), r2 + 8;
  }
  a2.prototype.writeDoubleLE = function(t2, r2, n2) {
    return hr2(this, t2, r2, true, n2);
  };
  a2.prototype.writeDoubleBE = function(t2, r2, n2) {
    return hr2(this, t2, r2, false, n2);
  };
  a2.prototype.copy = function(t2, r2, n2, i2) {
    if (!a2.isBuffer(t2)) throw new TypeError("argument should be a Buffer");
    if (n2 || (n2 = 0), !i2 && i2 !== 0 && (i2 = this.length), r2 >= t2.length && (r2 = t2.length), r2 || (r2 = 0), i2 > 0 && i2 < n2 && (i2 = n2), i2 === n2 || t2.length === 0 || this.length === 0) return 0;
    if (r2 < 0) throw new RangeError("targetStart out of bounds");
    if (n2 < 0 || n2 >= this.length) throw new RangeError("Index out of range");
    if (i2 < 0) throw new RangeError("sourceEnd out of bounds");
    i2 > this.length && (i2 = this.length), t2.length - r2 < i2 - n2 && (i2 = t2.length - r2 + n2);
    let o2 = i2 - n2;
    return this === t2 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r2, n2, i2) : Uint8Array.prototype.set.call(t2, this.subarray(n2, i2), r2), o2;
  };
  a2.prototype.fill = function(t2, r2, n2, i2) {
    if (typeof t2 == "string") {
      if (typeof r2 == "string" ? (i2 = r2, r2 = 0, n2 = this.length) : typeof n2 == "string" && (i2 = n2, n2 = this.length), i2 !== void 0 && typeof i2 != "string") throw new TypeError("encoding must be a string");
      if (typeof i2 == "string" && !a2.isEncoding(i2)) throw new TypeError("Unknown encoding: " + i2);
      if (t2.length === 1) {
        let s2 = t2.charCodeAt(0);
        (i2 === "utf8" && s2 < 128 || i2 === "latin1") && (t2 = s2);
      }
    } else typeof t2 == "number" ? t2 = t2 & 255 : typeof t2 == "boolean" && (t2 = Number(t2));
    if (r2 < 0 || this.length < r2 || this.length < n2) throw new RangeError("Out of range index");
    if (n2 <= r2) return this;
    r2 = r2 >>> 0, n2 = n2 === void 0 ? this.length : n2 >>> 0, t2 || (t2 = 0);
    let o2;
    if (typeof t2 == "number") for (o2 = r2; o2 < n2; ++o2) this[o2] = t2;
    else {
      let s2 = a2.isBuffer(t2) ? t2 : a2.from(t2, i2), u2 = s2.length;
      if (u2 === 0) throw new TypeError('The value "' + t2 + '" is invalid for argument "value"');
      for (o2 = 0; o2 < n2 - r2; ++o2) this[o2 + r2] = s2[o2 % u2];
    }
    return this;
  };
  var K2 = {};
  function St2(e2, t2, r2) {
    K2[e2] = class extends r2 {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: t2.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e2}]`, this.stack, delete this.name;
      }
      get code() {
        return e2;
      }
      set code(i2) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i2, writable: true });
      }
      toString() {
        return `${this.name} [${e2}]: ${this.message}`;
      }
    };
  }
  St2("ERR_BUFFER_OUT_OF_BOUNDS", function(e2) {
    return e2 ? `${e2} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  St2("ERR_INVALID_ARG_TYPE", function(e2, t2) {
    return `The "${e2}" argument must be of type number. Received type ${typeof t2}`;
  }, TypeError);
  St2("ERR_OUT_OF_RANGE", function(e2, t2, r2) {
    let n2 = `The value of "${e2}" is out of range.`, i2 = r2;
    return Number.isInteger(r2) && Math.abs(r2) > 2 ** 32 ? i2 = Qt2(String(r2)) : typeof r2 == "bigint" && (i2 = String(r2), (r2 > BigInt(2) ** BigInt(32) || r2 < -(BigInt(2) ** BigInt(32))) && (i2 = Qt2(i2)), i2 += "n"), n2 += ` It must be ${t2}. Received ${i2}`, n2;
  }, RangeError);
  function Qt2(e2) {
    let t2 = "", r2 = e2.length, n2 = e2[0] === "-" ? 1 : 0;
    for (; r2 >= n2 + 4; r2 -= 3) t2 = `_${e2.slice(r2 - 3, r2)}${t2}`;
    return `${e2.slice(0, r2)}${t2}`;
  }
  function ae(e2, t2, r2) {
    j2(t2, "offset"), (e2[t2] === void 0 || e2[t2 + r2] === void 0) && W2(t2, e2.length - (r2 + 1));
  }
  function fr(e2, t2, r2, n2, i2, o2) {
    if (e2 > r2 || e2 < t2) {
      let s2 = typeof t2 == "bigint" ? "n" : "", u2;
      throw o2 > 3 ? t2 === 0 || t2 === BigInt(0) ? u2 = `>= 0${s2} and < 2${s2} ** ${(o2 + 1) * 8}${s2}` : u2 = `>= -(2${s2} ** ${(o2 + 1) * 8 - 1}${s2}) and < 2 ** ${(o2 + 1) * 8 - 1}${s2}` : u2 = `>= ${t2}${s2} and <= ${r2}${s2}`, new K2.ERR_OUT_OF_RANGE("value", u2, e2);
    }
    ae(n2, i2, o2);
  }
  function j2(e2, t2) {
    if (typeof e2 != "number") throw new K2.ERR_INVALID_ARG_TYPE(t2, "number", e2);
  }
  function W2(e2, t2, r2) {
    throw Math.floor(e2) !== e2 ? (j2(e2, r2), new K2.ERR_OUT_OF_RANGE(r2 || "offset", "an integer", e2)) : t2 < 0 ? new K2.ERR_BUFFER_OUT_OF_BOUNDS() : new K2.ERR_OUT_OF_RANGE(r2 || "offset", `>= ${r2 ? 1 : 0} and <= ${t2}`, e2);
  }
  var ue = /[^+/0-9A-Za-z-_]/g;
  function he(e2) {
    if (e2 = e2.split("=")[0], e2 = e2.trim().replace(ue, ""), e2.length < 2) return "";
    for (; e2.length % 4 !== 0; ) e2 = e2 + "=";
    return e2;
  }
  function At2(e2, t2) {
    t2 = t2 || 1 / 0;
    let r2, n2 = e2.length, i2 = null, o2 = [];
    for (let s2 = 0; s2 < n2; ++s2) {
      if (r2 = e2.charCodeAt(s2), r2 > 55295 && r2 < 57344) {
        if (!i2) {
          if (r2 > 56319) {
            (t2 -= 3) > -1 && o2.push(239, 191, 189);
            continue;
          } else if (s2 + 1 === n2) {
            (t2 -= 3) > -1 && o2.push(239, 191, 189);
            continue;
          }
          i2 = r2;
          continue;
        }
        if (r2 < 56320) {
          (t2 -= 3) > -1 && o2.push(239, 191, 189), i2 = r2;
          continue;
        }
        r2 = (i2 - 55296 << 10 | r2 - 56320) + 65536;
      } else i2 && (t2 -= 3) > -1 && o2.push(239, 191, 189);
      if (i2 = null, r2 < 128) {
        if ((t2 -= 1) < 0) break;
        o2.push(r2);
      } else if (r2 < 2048) {
        if ((t2 -= 2) < 0) break;
        o2.push(r2 >> 6 | 192, r2 & 63 | 128);
      } else if (r2 < 65536) {
        if ((t2 -= 3) < 0) break;
        o2.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, r2 & 63 | 128);
      } else if (r2 < 1114112) {
        if ((t2 -= 4) < 0) break;
        o2.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, r2 & 63 | 128);
      } else throw new Error("Invalid code point");
    }
    return o2;
  }
  function fe(e2) {
    let t2 = [];
    for (let r2 = 0; r2 < e2.length; ++r2) t2.push(e2.charCodeAt(r2) & 255);
    return t2;
  }
  function ce(e2, t2) {
    let r2, n2, i2, o2 = [];
    for (let s2 = 0; s2 < e2.length && !((t2 -= 2) < 0); ++s2) r2 = e2.charCodeAt(s2), n2 = r2 >> 8, i2 = r2 % 256, o2.push(i2), o2.push(n2);
    return o2;
  }
  function cr2(e2) {
    return Bt2.toByteArray(he(e2));
  }
  function et(e2, t2, r2, n2) {
    let i2;
    for (i2 = 0; i2 < n2 && !(i2 + r2 >= t2.length || i2 >= e2.length); ++i2) t2[i2 + r2] = e2[i2];
    return i2;
  }
  function A2(e2, t2) {
    return e2 instanceof t2 || e2 != null && e2.constructor != null && e2.constructor.name != null && e2.constructor.name === t2.name;
  }
  function Ut2(e2) {
    return e2 !== e2;
  }
  var pe2 = function() {
    let e2 = "0123456789abcdef", t2 = new Array(256);
    for (let r2 = 0; r2 < 16; ++r2) {
      let n2 = r2 * 16;
      for (let i2 = 0; i2 < 16; ++i2) t2[n2 + i2] = e2[r2] + e2[i2];
    }
    return t2;
  }();
  function L2(e2) {
    return typeof BigInt > "u" ? le : e2;
  }
  function le() {
    throw new Error("BigInt not supported");
  }
});
var pr = T2((Je, Ft) => {
  typeof window < "u" ? (window.global = window, global.fetch = window.fetch, Ft.exports = { Buffer: nt().Buffer, Crypto: window.crypto }) : Ft.exports = { Buffer: nt().Buffer, Crypto: crypto };
});
var Lt = {};
Ar(Lt, { AVSCTap: () => $2, ArweaveSigner: () => N10, DataItem: () => _2, MAX_TAG_BYTES: () => tt, MIN_BINARY_SIZE: () => gr, SIG_CONFIG: () => P2, SignatureConfig: () => B2, Signer: () => ot, createData: () => ge, deserializeTags: () => Q2, indexToType: () => wt, serializeTags: () => dt, tagsExceedLimit: () => jr });
var ot = class {
  constructor() {
    __publicField(this, "signer");
    __publicField(this, "publicKey");
    __publicField(this, "signatureType");
    __publicField(this, "signatureLength");
    __publicField(this, "ownerLength");
    __publicField(this, "pem");
  }
  static verify(t2, r2, n2, i2) {
    throw new Error("You must implement verify method on child");
  }
};
var vt = C2(z2(), 1);
var w2 = C2(pt(), 1);
async function X2(e2) {
  if (Array.isArray(e2)) {
    let i2 = (0, w2.concatBuffers)([(0, w2.stringToBuffer)("list"), (0, w2.stringToBuffer)(e2.length.toString())]);
    return await Gt(e2, await x2().hash(i2, "SHA-384"));
  }
  let t2 = e2, r2 = (0, w2.concatBuffers)([(0, w2.stringToBuffer)("blob"), (0, w2.stringToBuffer)(t2.byteLength.toString())]), n2 = (0, w2.concatBuffers)([await x2().hash(r2, "SHA-384"), await x2().hash(t2, "SHA-384")]);
  return await x2().hash(n2, "SHA-384");
}
async function Gt(e2, t2) {
  if (e2.length < 1) return t2;
  let r2 = (0, w2.concatBuffers)([t2, await X2(e2[0])]), n2 = await x2().hash(r2, "SHA-384");
  return await Gt(e2.slice(1), n2);
}
var Z2 = C2(Yt(), 1);
var $r = Z2.default.default ? Z2.default.default : Z2.default;
var yt = class extends $r {
  getPublicKey(t2) {
    throw new Error("Unimplemented");
  }
};
var Kr;
function x2() {
  return Kr ?? (Kr = new yt());
}
var B2;
(function(e2) {
  e2[e2.ARWEAVE = 1] = "ARWEAVE", e2[e2.ED25519 = 2] = "ED25519", e2[e2.ETHEREUM = 3] = "ETHEREUM", e2[e2.SOLANA = 4] = "SOLANA", e2[e2.INJECTEDAPTOS = 5] = "INJECTEDAPTOS", e2[e2.MULTIAPTOS = 6] = "MULTIAPTOS", e2[e2.TYPEDETHEREUM = 7] = "TYPEDETHEREUM";
})(B2 || (B2 = {}));
var P2 = { [B2.ARWEAVE]: { sigLength: 512, pubLength: 512, sigName: "arweave" }, [B2.ED25519]: { sigLength: 64, pubLength: 32, sigName: "ed25519" }, [B2.ETHEREUM]: { sigLength: 65, pubLength: 65, sigName: "ethereum" }, [B2.SOLANA]: { sigLength: 64, pubLength: 32, sigName: "solana" }, [B2.INJECTEDAPTOS]: { sigLength: 64, pubLength: 32, sigName: "injectedAptos" }, [B2.MULTIAPTOS]: { sigLength: 64 * 32 + 4, pubLength: 32 * 32 + 1, sigName: "multiAptos" }, [B2.TYPEDETHEREUM]: { sigLength: 65, pubLength: 42, sigName: "typedEthereum" } };
var N10 = class {
  constructor(t2) {
    __publicField(this, "signatureType", 1);
    __publicField(this, "ownerLength", P2[1].pubLength);
    __publicField(this, "signatureLength", P2[1].sigLength);
    __publicField(this, "jwk");
    __publicField(this, "pk");
    this.pk = t2.n, this.jwk = t2;
  }
  get publicKey() {
    return vt.default.toBuffer(this.pk);
  }
  sign(t2) {
    return x2().sign(this.jwk, t2);
  }
  static async verify(t2, r2, n2) {
    return await x2().verify(t2, r2, n2);
  }
};
var wt = { 1: N10 };
var E2 = C2(z2(), 1);
async function v2(e2) {
  return X2([(0, w2.stringToBuffer)("dataitem"), (0, w2.stringToBuffer)("1"), (0, w2.stringToBuffer)(e2.signatureType.toString()), e2.rawOwner, e2.rawTarget, e2.rawAnchor, e2.rawTags, e2.rawData]);
}
async function Hr(e2, t2) {
  let r2 = await v2(e2), n2 = await t2.sign(r2), i2 = await x2().hash(n2);
  return { signature: Buffer.from(n2), id: Buffer.from(i2) };
}
async function Wt(e2, t2) {
  let { signature: r2, id: n2 } = await Hr(e2, t2);
  return e2.getRaw().set(r2, 2), n2;
}
var $2 = class {
  constructor(t2 = Buffer.alloc(tt), r2 = 0) {
    __publicField(this, "buf");
    __publicField(this, "pos");
    this.buf = t2, this.pos = r2;
  }
  writeTags(t2) {
    if (!Array.isArray(t2)) throw new Error("input must be array");
    let r2 = t2.length, n2;
    if (r2) for (this.writeLong(r2), n2 = 0; n2 < r2; n2++) {
      let i2 = t2[n2];
      if ((i2 == null ? void 0 : i2.name) === void 0 || (i2 == null ? void 0 : i2.value) === void 0) throw new Error(`Invalid tag format for ${i2}, expected {name:string, value: string}`);
      this.writeString(i2.name), this.writeString(i2.value);
    }
    this.writeLong(0);
  }
  toBuffer() {
    let t2 = Buffer.alloc(this.pos);
    if (this.pos > this.buf.length) throw new Error(`Too many tag bytes (${this.pos} > ${this.buf.length})`);
    return this.buf.copy(t2, 0, 0, this.pos), t2;
  }
  tagsExceedLimit() {
    return this.pos > this.buf.length;
  }
  writeLong(t2) {
    let r2 = this.buf, n2, i2;
    if (t2 >= -1073741824 && t2 < 1073741824) {
      i2 = t2 >= 0 ? t2 << 1 : ~t2 << 1 | 1;
      do
        r2[this.pos] = i2 & 127, i2 >>= 7;
      while (i2 && (r2[this.pos++] |= 128));
    } else {
      n2 = t2 >= 0 ? t2 * 2 : -t2 * 2 - 1;
      do
        r2[this.pos] = n2 & 127, n2 /= 128;
      while (n2 >= 1 && (r2[this.pos++] |= 128));
    }
    this.pos++, this.buf = r2;
  }
  writeString(t2) {
    let r2 = Buffer.byteLength(t2), n2 = this.buf;
    this.writeLong(r2);
    let i2 = this.pos;
    if (this.pos += r2, !(this.pos > n2.length)) {
      if (r2 > 64) this.buf.write(t2, this.pos - r2, r2, "utf8");
      else {
        let o2, s2, u2, h2;
        for (o2 = 0, s2 = r2; o2 < s2; o2++) u2 = t2.charCodeAt(o2), u2 < 128 ? n2[i2++] = u2 : u2 < 2048 ? (n2[i2++] = u2 >> 6 | 192, n2[i2++] = u2 & 63 | 128) : (u2 & 64512) === 55296 && ((h2 = t2.charCodeAt(o2 + 1)) & 64512) === 56320 ? (u2 = 65536 + ((u2 & 1023) << 10) + (h2 & 1023), o2++, n2[i2++] = u2 >> 18 | 240, n2[i2++] = u2 >> 12 & 63 | 128, n2[i2++] = u2 >> 6 & 63 | 128, n2[i2++] = u2 & 63 | 128) : (n2[i2++] = u2 >> 12 | 224, n2[i2++] = u2 >> 6 & 63 | 128, n2[i2++] = u2 & 63 | 128);
      }
      this.buf = n2;
    }
  }
  readLong() {
    let t2 = 0, r2 = 0, n2 = this.buf, i2, o2, s2, u2;
    do
      i2 = n2[this.pos++], o2 = i2 & 128, t2 |= (i2 & 127) << r2, r2 += 7;
    while (o2 && r2 < 28);
    if (o2) {
      s2 = t2, u2 = 268435456;
      do
        i2 = n2[this.pos++], s2 += (i2 & 127) * u2, u2 *= 128;
      while (i2 & 128);
      return (s2 % 2 ? -(s2 + 1) : s2) / 2;
    }
    return t2 >> 1 ^ -(t2 & 1);
  }
  skipLong() {
    let t2 = this.buf;
    for (; t2[this.pos++] & 128; ) ;
  }
  readTags() {
    let t2 = [], r2;
    for (; r2 = this.readLong(); ) for (r2 < 0 && (r2 = -r2, this.skipLong()); r2--; ) {
      let n2 = this.readString(), i2 = this.readString();
      t2.push({ name: n2, value: i2 });
    }
    return t2;
  }
  readString() {
    let t2 = this.readLong(), r2 = this.pos, n2 = this.buf;
    if (this.pos += t2, !(this.pos > n2.length)) return this.buf.slice(r2, r2 + t2).toString();
  }
};
function dt(e2) {
  let t2 = new $2();
  return t2.writeTags(e2), t2.toBuffer();
}
function jr(e2) {
  let t2 = new $2();
  return t2.writeTags(e2), t2.tagsExceedLimit();
}
function Q2(e2) {
  return new $2(e2).readTags();
}
function I2(e2) {
  let t2 = 0;
  for (let r2 = e2.length - 1; r2 >= 0; r2--) t2 = t2 * 256 + e2[r2];
  return t2;
}
function Vt(e2) {
  if (e2 > (2 ^ 32 - 1)) throw new Error("Short too long");
  let t2 = [0, 0];
  for (let r2 = 0; r2 < t2.length; r2++) {
    let n2 = e2 & 255;
    t2[r2] = n2, e2 = (e2 - n2) / 256;
  }
  return Uint8Array.from(t2);
}
function xt(e2) {
  let t2 = [0, 0, 0, 0, 0, 0, 0, 0];
  for (let r2 = 0; r2 < t2.length; r2++) {
    let n2 = e2 & 255;
    t2[r2] = n2, e2 = (e2 - n2) / 256;
  }
  return Uint8Array.from(t2);
}
var lr = C2(pr(), 1);
var M2 = C2(nt(), 1);
var tt = 4096;
var gr = 80;
var _2 = class {
  constructor(t2) {
    __publicField(this, "binary");
    __publicField(this, "_id");
    this.binary = t2;
  }
  static isDataItem(t2) {
    return t2.binary !== void 0;
  }
  get signatureType() {
    let t2 = I2(this.binary.subarray(0, 2));
    if ((B2 == null ? void 0 : B2[t2]) !== void 0) return t2;
    throw new Error("Unknown signature type: " + t2);
  }
  async isValid() {
    return _2.verify(this.binary);
  }
  get id() {
    return (async () => E2.default.encode(await this.rawId))();
  }
  set id(t2) {
    this._id = E2.default.toBuffer(t2);
  }
  get rawId() {
    return (async () => M2.Buffer.from(await lr.Crypto.subtle.digest("SHA-256", this.rawSignature)))();
  }
  set rawId(t2) {
    this._id = t2;
  }
  get rawSignature() {
    return this.binary.subarray(2, 2 + this.signatureLength);
  }
  get signature() {
    return E2.default.encode(this.rawSignature);
  }
  set rawOwner(t2) {
    if (t2.byteLength != this.ownerLength) throw new Error(`Expected raw owner (pubkey) to be ${this.ownerLength} bytes, got ${t2.byteLength} bytes.`);
    this.binary.set(t2, 2 + this.signatureLength);
  }
  get rawOwner() {
    return this.binary.subarray(2 + this.signatureLength, 2 + this.signatureLength + this.ownerLength);
  }
  get signatureLength() {
    return P2[this.signatureType].sigLength;
  }
  get owner() {
    return E2.default.encode(this.rawOwner);
  }
  get ownerLength() {
    return P2[this.signatureType].pubLength;
  }
  get rawTarget() {
    let t2 = this.getTargetStart();
    return this.binary[t2] == 1 ? this.binary.subarray(t2 + 1, t2 + 33) : M2.Buffer.alloc(0);
  }
  get target() {
    return E2.default.encode(this.rawTarget);
  }
  get rawAnchor() {
    let t2 = this.getAnchorStart();
    return this.binary[t2] == 1 ? this.binary.subarray(t2 + 1, t2 + 33) : M2.Buffer.alloc(0);
  }
  get anchor() {
    return this.rawAnchor.toString();
  }
  get rawTags() {
    let t2 = this.getTagsStart(), r2 = I2(this.binary.subarray(t2 + 8, t2 + 16));
    return this.binary.subarray(t2 + 16, t2 + 16 + r2);
  }
  get tags() {
    let t2 = this.getTagsStart();
    if (I2(this.binary.subarray(t2, t2 + 8)) == 0) return [];
    let n2 = I2(this.binary.subarray(t2 + 8, t2 + 16));
    return Q2(M2.Buffer.from(this.binary.subarray(t2 + 16, t2 + 16 + n2)));
  }
  get tagsB64Url() {
    return this.tags.map((r2) => ({ name: E2.default.encode(r2.name), value: E2.default.encode(r2.value) }));
  }
  getStartOfData() {
    let t2 = this.getTagsStart(), r2 = this.binary.subarray(t2 + 8, t2 + 16), n2 = I2(r2);
    return t2 + 16 + n2;
  }
  get rawData() {
    let t2 = this.getTagsStart(), r2 = this.binary.subarray(t2 + 8, t2 + 16), n2 = I2(r2), i2 = t2 + 16 + n2;
    return this.binary.subarray(i2, this.binary.length);
  }
  get data() {
    return E2.default.encode(this.rawData);
  }
  getRaw() {
    return this.binary;
  }
  async sign(t2) {
    return this._id = await Wt(this, t2), this.rawId;
  }
  async setSignature(t2) {
    this.binary.set(t2, 2), this._id = M2.Buffer.from(await x2().hash(t2));
  }
  isSigned() {
    var _a2;
    return (((_a2 = this._id) == null ? void 0 : _a2.length) ?? 0) > 0;
  }
  toJSON() {
    return { signature: this.signature, owner: this.owner, target: this.target, tags: this.tags.map((t2) => ({ name: E2.default.encode(t2.name), value: E2.default.encode(t2.value) })), data: this.data };
  }
  static async verify(t2) {
    if (t2.byteLength < gr) return false;
    let r2 = new _2(t2), n2 = r2.signatureType, i2 = r2.getTagsStart(), o2 = I2(t2.subarray(i2, i2 + 8)), s2 = t2.subarray(i2 + 8, i2 + 16), u2 = I2(s2);
    if (u2 > tt) return false;
    if (o2 > 0) try {
      if (Q2(M2.Buffer.from(t2.subarray(i2 + 16, i2 + 16 + u2))).length !== o2) return false;
    } catch {
      return false;
    }
    let h2 = wt[n2], p2 = await v2(r2);
    return await h2.verify(r2.rawOwner, p2, r2.rawSignature);
  }
  async getSignatureData() {
    return v2(this);
  }
  getTagsStart() {
    let t2 = this.getTargetStart(), r2 = this.binary[t2] == 1, n2 = t2 + (r2 ? 33 : 1), i2 = this.binary[n2] == 1;
    return n2 += i2 ? 33 : 1, n2;
  }
  getTargetStart() {
    return 2 + this.signatureLength + this.ownerLength;
  }
  getAnchorStart() {
    let t2 = this.getTargetStart() + 1, r2 = this.binary[this.getTargetStart()] == 1;
    return t2 += r2 ? 32 : 0, t2;
  }
};
var yr = C2(z2(), 1);
function ge(e2, t2, r2) {
  var _a2, _b;
  let n2 = t2.publicKey, i2 = (r2 == null ? void 0 : r2.target) ? yr.default.toBuffer(r2.target) : null, o2 = 1 + ((i2 == null ? void 0 : i2.byteLength) ?? 0), s2 = (r2 == null ? void 0 : r2.anchor) ? Buffer.from(r2.anchor) : null, u2 = 1 + ((s2 == null ? void 0 : s2.byteLength) ?? 0), h2 = (((_a2 = r2 == null ? void 0 : r2.tags) == null ? void 0 : _a2.length) ?? 0) > 0 ? dt(r2.tags) : null, p2 = 16 + (h2 ? h2.byteLength : 0), f2 = Buffer.from(e2), c2 = f2.byteLength, U2 = 2 + t2.signatureLength + t2.ownerLength + o2 + u2 + p2 + c2, l2 = Buffer.alloc(U2);
  if (l2.set(Vt(t2.signatureType), 0), l2.set(new Uint8Array(t2.signatureLength).fill(0), 2), n2.byteLength !== t2.ownerLength) throw new Error(`Owner must be ${t2.ownerLength} bytes, but was incorrectly ${n2.byteLength}`);
  l2.set(n2, 2 + t2.signatureLength);
  let R2 = 2 + t2.signatureLength + t2.ownerLength;
  if (l2[R2] = i2 ? 1 : 0, i2) {
    if (i2.byteLength !== 32) throw new Error(`Target must be 32 bytes but was incorrectly ${i2.byteLength}`);
    l2.set(i2, R2 + 1);
  }
  let G2 = R2 + o2, Y2 = G2 + 1;
  if (l2[G2] = s2 ? 1 : 0, s2) {
    if (Y2 += s2.byteLength, s2.byteLength !== 32) throw new Error("Anchor must be 32 bytes");
    l2.set(s2, G2 + 1);
  }
  l2.set(xt(((_b = r2 == null ? void 0 : r2.tags) == null ? void 0 : _b.length) ?? 0), Y2);
  let wr2 = xt((h2 == null ? void 0 : h2.byteLength) ?? 0);
  l2.set(wr2, Y2 + 8), h2 && l2.set(h2, Y2 + 16);
  let dr2 = Y2 + p2;
  return l2.set(f2, dr2), new _2(l2);
}
var _t = { ...Lt };
globalThis.arbundles ?? (globalThis.arbundles = _t);

// ../../node_modules/@othent/kms/dist/index.mjs
var import_arweave = __toESM(require_web(), 1);
var import_buffer3 = __toESM(require_buffer2(), 1);
var import_buffer4 = __toESM(require_buffer2(), 1);
var DEFAULT_OTHENT_CONFIG = {
  debug: false,
  inject: false,
  auth0Domain: "auth.othent.io",
  auth0ClientId: "uXkRmJoIa0NfzYgYEDAgj6Rss4wR1tIc",
  auth0Strategy: "refresh-tokens",
  auth0Cache: "memory",
  auth0RefreshTokenExpirationMs: 1296e6,
  // 2 weeks
  auth0LogInMethod: "popup",
  auth0RedirectURI: null,
  auth0ReturnToURI: null,
  serverBaseURL: "https://kms-server.othent.io",
  autoConnect: "lazy",
  cookieKey: null,
  localStorageKey: null,
  throwErrors: true,
  tags: []
};
var DEFAULT_APP_INFO = {
  name: "",
  version: "",
  env: typeof location === "undefined" ? "production" : location.hostname === "localhost" ? "development" : "production"
};
var DEFAULT_GATEWAY_CONFIG = {
  host: "arweave.net",
  protocol: "https",
  port: 443
};
var DEFAULT_OTHENT_OPTIONS = {
  ...DEFAULT_OTHENT_CONFIG,
  appInfo: DEFAULT_APP_INFO,
  gatewayConfig: DEFAULT_GATEWAY_CONFIG,
  persistCookie: false,
  persistLocalStorage: false,
  auth0Cache: "memory"
};
var DEFAULT_DISPATCH_NODE = "https://turbo.ardrive.io";
var DEFAULT_COOKIE_KEY = "othentUserDetails";
var CLIENT_NAME = "Othent KMS";
var CLIENT_VERSION = "2.1.1";
var ANALYTICS_TAGS = [
  {
    name: "Client",
    value: CLIENT_NAME
  },
  {
    name: "Client-Version",
    value: CLIENT_VERSION
  }
];
var EventListenersHandler = class {
  constructor(options) {
    this.listeners = /* @__PURE__ */ new Set();
    this.initializedListeners = /* @__PURE__ */ new Set();
    this.lastEmittedUpdateId = "";
    this.lastEmittedParams = null;
    this.options = {
      diffParams: false,
      replyOnListen: false
    };
    this.options = {
      ...this.options,
      ...options
    };
  }
  getUpdateId(parameters) {
    const serializer = (_3, value) => {
      return value && value === "oject" && !Array.isArray(value) ? Object.entries(value).sort((a2, b2) => a2[0].localeCompare(b2[0])) : value;
    };
    const { getUpdateIdTransform } = this.options;
    const transformedParameters = getUpdateIdTransform ? getUpdateIdTransform(parameters) : parameters;
    return JSON.stringify(transformedParameters, serializer);
  }
  get hasListeners() {
    return this.listeners.size > 0;
  }
  add(listener) {
    this.listeners.add(listener);
    if (this.options.replyOnListen && this.lastEmittedParams)
      this.emit(...this.lastEmittedParams);
  }
  delete(listener) {
    this.listeners.add(listener);
  }
  emit(...parameters) {
    const { initializedListeners, lastEmittedUpdateId } = this;
    const updateId = this.getUpdateId(parameters);
    const updatedAlreadyEmitted = lastEmittedUpdateId === updateId;
    this.lastEmittedUpdateId = updateId;
    this.lastEmittedParams = parameters;
    this.listeners.forEach((listenerFn) => {
      if (updatedAlreadyEmitted && initializedListeners.has(listenerFn)) return;
      initializedListeners.add(listenerFn);
      try {
        listenerFn(...parameters);
      } catch (err) {
      }
    });
    return updatedAlreadyEmitted;
  }
};
function mergeOptions(options, defaults2) {
  return (0, import_extend.default)(true, {}, defaults2, options);
}
var DEFAULT_COOKIE_OPTIONS = {
  secure: true,
  domain: true,
  ttlHours: 360
};
var _CookieStorage = class _CookieStorage2 {
  // 2 weeks
  constructor(cookieOptions = DEFAULT_COOKIE_OPTIONS) {
    this.secureParam = null;
    this.domainParam = null;
    this.ttlMs = 1296e6;
    const { secureParam, domainParam, ttlMs } = this.parseCookieOptions(
      mergeOptions(cookieOptions, DEFAULT_COOKIE_OPTIONS)
    );
    this.secureParam = secureParam;
    this.domainParam = domainParam;
    this.ttlMs = ttlMs;
    return new Proxy(this, {
      get(target, prop) {
        return prop in target || typeof prop !== "string" ? target[prop] : target.getItem(prop);
      },
      ownKeys(target) {
        return document.cookie.split(_CookieStorage2.COOKIE_SEPARATOR).map(
          (cookieStr) => cookieStr.split(_CookieStorage2.COOKIE_VALUE_SEPARATOR)[0]
        );
      },
      getOwnPropertyDescriptor() {
        return {
          enumerable: true,
          configurable: true
        };
      }
    });
  }
  parseCookieOptions({
    secure,
    domain,
    ttlHours
  } = {}) {
    const secureParam = secure ? "secure" : secure === void 0 ? this.secureParam : null;
    const domainParam = domain ? `domain=${domain === true ? location.host : domain}` : domain === void 0 ? this.domainParam : null;
    const ttlMs = ttlHours ? ttlHours * 36e5 : ttlHours === void 0 ? this.ttlMs : 0;
    return {
      secureParam,
      domainParam,
      ttlMs
    };
  }
  getCookieParams(cookieOptions) {
    const { secureParam, domainParam, ttlMs } = this.parseCookieOptions(cookieOptions);
    const expirationDate = new Date(Date.now() + ttlMs);
    const expiresParam = `expires=${expirationDate.toUTCString()}`;
    const pathParam = "path=/";
    const cookieParams = [expiresParam, secureParam, domainParam, pathParam].filter(Boolean).join("; ");
    return cookieParams ? ` ${cookieParams};` : "";
  }
  get length() {
    return document.cookie ? document.cookie.split(_CookieStorage2.COOKIE_SEPARATOR).length : 0;
  }
  key(index) {
    const cookieStrAtIndex = document.cookie.split(_CookieStorage2.COOKIE_SEPARATOR)[index] || "";
    const cookieKey = cookieStrAtIndex.split(
      _CookieStorage2.COOKIE_VALUE_SEPARATOR
    )[0];
    return cookieKey || null;
  }
  getItem(name2) {
    const targetCookie = document.cookie.split(_CookieStorage2.COOKIE_SEPARATOR).find((item) => {
      return item.split(_CookieStorage2.COOKIE_VALUE_SEPARATOR)[0] === name2;
    });
    return targetCookie && targetCookie.split(_CookieStorage2.COOKIE_VALUE_SEPARATOR)[1] || null;
  }
  setItem(key, value, cookieOptions) {
    const serializedValue = typeof value === "string" ? value : JSON.stringify(value);
    const cookieParams = this.getCookieParams(cookieOptions);
    if (true) {
      const actionLabel = ((cookieOptions == null ? void 0 : cookieOptions.ttlHours) || 1) < 0 ? "Removing" : "Setting";
      console.info(`${actionLabel} cookie ${key}=<VALUE>;${cookieParams}`);
    }
    const cookieStr = `${key}=${serializedValue};${cookieParams}`;
    document.cookie = cookieStr;
    return cookieStr;
  }
  removeItem(key, cookieOptions) {
    return this.setItem(key, "", { ...cookieOptions, ttlHours: -1 });
  }
  clear() {
    document.cookie.split(_CookieStorage2.COOKIE_SEPARATOR).forEach((item) => {
      this.removeItem(item.split(_CookieStorage2.COOKIE_VALUE_SEPARATOR)[0]);
    });
  }
};
_CookieStorage.COOKIE_SEPARATOR = /\s*;\s*/;
_CookieStorage.COOKIE_VALUE_SEPARATOR = /\s*=\s*/;
var CookieStorage = _CookieStorage;
var cookieStorage = null;
function getCookieStorage() {
  if (!cookieStorage) {
    const hostname = typeof location === "undefined" ? "" : location.hostname;
    const isDevelopment = hostname === "localhost";
    cookieStorage = new CookieStorage({
      secure: !isDevelopment,
      domain: isDevelopment ? void 0 : hostname
    });
  }
  return cookieStorage;
}
async function getAnsProfile(address) {
  try {
    const response = await axios_default.get(
      "https://api.mem.tech/api/state/Tih8T1uESATJNzdwBIY3rpe25kWTzjw8uNiMRYe9I5M",
      {
        // Because this will return the whole contract's state, it could get quite large in the future. Therefore, we set
        // a timeout of 2 seconds to make sure this request doesn't slow down the SDK due to the big download size.
        timeout: 2e3
      }
    );
    const balances = response.data.balances || [];
    const balanceMatch = balances.find(
      (balance) => balance.address === address
    );
    const domain = balanceMatch ? balanceMatch.primary_domain || balanceMatch.ownedDomains[0].domain || null : null;
    return domain ? `${domain}.ar` : null;
  } catch (err) {
    console.warn(`Error resolving ANS domain for ${address} =
`, err);
    return null;
  }
}
var PROVIDER_LABELS = {
  apple: "Apple",
  auth0: "E-Mail",
  "google-oauth2": "Google",
  // TODO: Complete these values:
  "<Twitch>": "Twitch",
  twitter: "X",
  "<Meta>": "Meta",
  "<LinkedIn>": "LinkedIn",
  github: "GitHub"
};
var CRYPTO_OPERATION_BINARY_DATA_KEYS = [
  "wrappedSignKey",
  "wrappedEncryptDecryptKey",
  "data",
  "plaintext",
  "ciphertext"
];
function binaryDataTypeToUint8Array(buffer) {
  if (buffer instanceof Buffer || buffer instanceof DataView || ArrayBuffer.isView(buffer)) {
    return new Uint8Array(buffer.buffer);
  } else if (buffer instanceof ArrayBuffer) {
    return new Uint8Array(buffer);
  }
  throw new Error("Unknown buffer type.");
}
function binaryDataTypeTob64Url(buffer) {
  return uint8ArrayTob64Url(binaryDataTypeToUint8Array(buffer));
}
function binaryDataTypeOrStringTob64String(source) {
  return typeof source === "string" ? stringTob64Url(source) : binaryDataTypeTob64Url(source);
}
function binaryDataTypeOrStringToBinaryDataType(source) {
  return typeof source === "string" ? stringToUint8Array(source) : source;
}
function stringTob64Url(str) {
  return uint8ArrayTob64Url(stringToUint8Array(str));
}
function stringToUint8Array(str) {
  return new TextEncoder().encode(str);
}
function uint8ArrayTob64(buffer) {
  return B64js.fromByteArray(new Uint8Array(buffer));
}
function uint8ArrayTob64Url(buffer) {
  return b64UrlEncode(uint8ArrayTob64(buffer));
}
function b64ToUint8Array(str) {
  return B64js.toByteArray(b64UrlDecode(str));
}
function b64UrlEncode(str) {
  return str.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function b64UrlDecode(str) {
  const padding = str.length % 4 == 0 ? 0 : 4 - str.length % 4;
  return str.replace(/\-/g, "+").replace(/\_/g, "/").concat("=".repeat(padding));
}
async function hash2(data, algorithm = "SHA-256") {
  let digest2 = await crypto.subtle.digest(algorithm, data);
  return new Uint8Array(digest2);
}
function transactionInputReplacer(key, value) {
  if (!CRYPTO_OPERATION_BINARY_DATA_KEYS.includes(key)) return value;
  if (key === "data" && value.hasOwnProperty("path")) return value;
  return binaryDataTypeOrStringTob64String(value);
}
var OthentErrorID = ((OthentErrorID2) => {
  OthentErrorID2["Unexpected"] = "Unexpected";
  OthentErrorID2["Validation"] = "Validation";
  OthentErrorID2["UserCreation"] = "UserCreation";
  OthentErrorID2["Encryption"] = "Encryption";
  OthentErrorID2["Decryption"] = "Decryption";
  OthentErrorID2["Signing"] = "Signing";
  OthentErrorID2["PublicKey"] = "PublicKey";
  return OthentErrorID2;
})(OthentErrorID || {});
var OthentError = class extends Error {
  constructor(id2, developerMessage, error, fromServer = false) {
    super();
    this.name = id2;
    this.message = developerMessage || "";
    if (fromServer) {
      this.stack = `${id2} (from server): ${developerMessage}
`;
    } else {
      Error.captureStackTrace(this);
    }
    this.id = id2;
    this.developerMessage = developerMessage;
    if (error instanceof Error) {
      this.cause = error;
    } else if (typeof error === "string" || typeof error === "number") {
      this.cause = new Error(`${error}`);
    }
  }
};
function isErrorResponseData(data) {
  return typeof data === "object" && data.error === true && !!data.id && !!OthentErrorID[data.id];
}
function parseErrorResponse(error) {
  var _a2;
  if (isAxiosError2(error)) {
    const data = (_a2 = error.response) == null ? void 0 : _a2.data;
    if (!isErrorResponseData(data)) {
      return error;
    }
    const { id: id2, developerMessage, cause } = data;
    let causeError;
    if (cause) {
      causeError = new Error(cause.message);
      causeError.name = cause.name;
      causeError.stack = cause.stack;
    }
    return new OthentError(id2, developerMessage || "", causeError, true);
  }
  if (error instanceof Error) {
    return error;
  }
  return new Error("Unknown error");
}
function isPromise(obj) {
  return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
}
function pemToUint8Array(pem) {
  const pemBufferString = pem.replaceAll("\n", "").replace("-----BEGIN PUBLIC KEY-----", "").replace("-----END PUBLIC KEY-----", "");
  return b64ToUint8Array(pemBufferString);
}
var OthentAuth0Client = class _OthentAuth0Client {
  constructor({
    debug,
    domain,
    clientId,
    strategy,
    cache,
    loginMethod,
    redirectURI,
    returnToURI,
    refreshTokenExpirationMs,
    appInfo,
    initialUserDetails,
    cookieKey,
    localStorageKey
  }) {
    this.debug = false;
    this.overriddenPublicKey = null;
    this.auth0ClientPromise = Promise.resolve(null);
    this.authEventListenerHandler = new EventListenersHandler({
      diffParams: true,
      replyOnListen: true
    });
    this.userDetails = null;
    this.userDetailsExpirationTimeoutID = 0;
    this.cookieKey = null;
    this.localStorageKey = null;
    this.refreshTokenExpirationMs = +DEFAULT_OTHENT_CONFIG.auth0RefreshTokenExpirationMs;
    this.appInfo = DEFAULT_APP_INFO;
    this.isReady = false;
    this.isAuthenticated = false;
    this.debug = debug;
    this.loginMethod = loginMethod;
    this.redirectURI = redirectURI;
    this.returnToURI = returnToURI;
    this.auth0ClientPromise = oe({
      domain,
      clientId,
      useRefreshTokens: strategy === "refresh-tokens",
      cacheLocation: typeof cache === "string" ? cache : void 0,
      cache: typeof cache === "object" ? cache : void 0,
      authorizationParams: {
        redirect_uri: this.redirectURI
        // scope: "openid profile email offline_access"
        // audience
      }
    }).then((Auth0Client2) => {
      this.isReady = true;
      return Auth0Client2;
    });
    this.cookieKey = cookieKey;
    this.localStorageKey = localStorageKey;
    this.refreshTokenExpirationMs = refreshTokenExpirationMs;
    this.appInfo = appInfo;
    this.restoreUserDetails(initialUserDetails || null);
    this.handleStorage = this.handleStorage.bind(this);
  }
  static isIdTokenValidUser(idToken) {
    return !!(idToken && idToken.sub && idToken.owner && idToken.walletAddress && idToken.authSystem === "KMS");
  }
  async getUserDetails(idToken) {
    const { email = "", nickname = "", walletAddress } = idToken;
    const sub = idToken.sub || "";
    const authProvider = sub.split("|")[0];
    let walletAddressLabel = await getAnsProfile(walletAddress);
    if (!walletAddressLabel) {
      const providerLabel = PROVIDER_LABELS[authProvider] || "Unknown Provider";
      walletAddressLabel = `${providerLabel} (${email || (nickname ? `@${nickname}` : "")})`;
    }
    return {
      sub,
      name: idToken.name || "",
      givenName: idToken.given_name || "",
      middleName: idToken.middle_name || "",
      familyName: idToken.family_name || "",
      nickname: idToken.nickname || "",
      preferredUsername: idToken.preferred_username || "",
      profile: idToken.profile || "",
      picture: idToken.picture || "",
      website: idToken.website || "",
      locale: idToken.locale || "",
      updatedAt: idToken.updated_at || "",
      email,
      emailVerified: !!idToken.email_verified,
      owner: this.overriddenPublicKey || idToken.owner,
      walletAddress: idToken.walletAddress,
      walletAddressLabel,
      authSystem: idToken.authSystem,
      authProvider
    };
  }
  // Getters / Setters:
  getAuthEventListenerHandler() {
    return this.authEventListenerHandler;
  }
  setAppInfo(appInfo) {
    this.appInfo = appInfo;
  }
  // Storage listeners:
  initStorageSyncing() {
    if (!this.localStorageKey || typeof window === "undefined") return;
    window.addEventListener("storage", this.handleStorage);
  }
  stopStorageSyncing() {
    if (typeof window === "undefined") return;
    window.removeEventListener("storage", this.handleStorage);
  }
  handleStorage(event) {
    if (event.key !== this.localStorageKey) return;
    if (event.newValue) {
      this.restoreUserDetails();
    } else {
      this.logOut();
    }
  }
  persistUserDetails(userDetails) {
    const { cookieKey, localStorageKey } = this;
    if (cookieKey) {
      const cookieStorage2 = getCookieStorage();
      if (userDetails) {
        cookieStorage2.setItem(cookieKey, JSON.stringify(userDetails), {
          ttlHours: this.refreshTokenExpirationMs / 36e5
        });
      } else if (cookieStorage2.getItem(cookieKey) !== null) {
        cookieStorage2.removeItem(cookieKey);
      }
    }
    if (localStorageKey) {
      if (userDetails) {
        const now = /* @__PURE__ */ new Date();
        const serializedUserDetails = JSON.stringify({
          userDetails,
          createdAt: now.toUTCString(),
          expiredBy: new Date(
            now.getTime() + this.refreshTokenExpirationMs
          ).toUTCString()
        });
        localStorage.setItem(localStorageKey, serializedUserDetails);
      } else {
        this.clearStoredUserDetails();
      }
    }
  }
  // `userDetails` setters:
  setUserDetails(userDetails, updateAuth = true) {
    if (typeof window !== "undefined") {
      window.clearTimeout(this.userDetailsExpirationTimeoutID);
      if (userDetails) {
        this.userDetailsExpirationTimeoutID = window.setTimeout(
          this.logOut,
          this.refreshTokenExpirationMs
        );
      }
    }
    const updatedAlreadyEmitted = this.authEventListenerHandler.emit(
      userDetails,
      updateAuth ? !!userDetails : this.isAuthenticated
    );
    if (!updatedAlreadyEmitted) {
      this.userDetails = userDetails;
    }
    if (updateAuth) {
      this.isAuthenticated = !!userDetails;
      this.persistUserDetails(userDetails);
    }
    return userDetails;
  }
  restoreUserDetails(userDetails) {
    let initialUserDetails = userDetails || null;
    if (!initialUserDetails && this.localStorageKey) {
      try {
        const storedUserDetails = JSON.parse(
          localStorage.getItem(this.localStorageKey) || "null"
        );
        if (storedUserDetails) {
          const expiredBy = new Date(storedUserDetails.expiredBy).getTime();
          if (!isNaN(expiredBy) && expiredBy > Date.now()) {
            initialUserDetails = storedUserDetails.userDetails;
          } else {
            this.clearStoredUserDetails();
          }
        }
      } catch (err) {
      }
    }
    this.setUserDetails(initialUserDetails, false);
  }
  clearStoredUserDetails() {
    Object.keys(localStorage).forEach((key) => {
      if (key.startsWith("othent")) localStorage.removeItem(key);
    });
  }
  async updateUserDetails(idToken) {
    const nextUserDetails = idToken && _OthentAuth0Client.isIdTokenValidUser(idToken) ? await this.getUserDetails(idToken) : null;
    return this.setUserDetails(nextUserDetails);
  }
  getAuthorizationParams(authorizationParamsOrData = {}) {
    const { authorizationParams, data } = authorizationParamsOrData.hasOwnProperty("path") ? {
      authorizationParams: null,
      data: authorizationParamsOrData
    } : {
      authorizationParams: authorizationParamsOrData,
      data: null
    };
    const { appInfo } = this;
    const transactionInput = {
      othentFunction: "KMS",
      othentSDKVersion: CLIENT_NAME,
      othentAPIVersion: CLIENT_VERSION,
      appName: appInfo.name,
      appVersion: appInfo.version,
      appEnv: appInfo.env
    };
    if (data) {
      transactionInput.data = data;
    }
    return {
      ...authorizationParams,
      transaction_input: JSON.stringify(
        transactionInput,
        transactionInputReplacer
      )
    };
  }
  // Wrappers around Auth0's native client with some additional functionality:
  async getTokenSilently(data) {
    const auth0Client = await this.auth0ClientPromise;
    if (!auth0Client) throw new Error("Missing Auth0 Client");
    const authorizationParams = this.getAuthorizationParams(data);
    if (this.debug) {
      try {
        const parsedTransactionInput = JSON.parse(
          authorizationParams.transaction_input
        );
        if (Object.keys(authorizationParams).length === 1 && Object.keys(authorizationParams)[0] === "transaction_input") {
          console.log(
            "getTokenSilently().transaction_input =",
            parsedTransactionInput
          );
        } else {
          console.log("getTokenSilently() =", {
            ...authorizationParams,
            transaction_input: parsedTransactionInput
          });
        }
      } catch (err) {
        console.error("Error logging/parsing `authorizationParams`:", err);
      }
    }
    try {
      const getTokenSilentlyResponse = await auth0Client.getTokenSilently({
        detailedResponse: true,
        authorizationParams,
        cacheMode: "off"
        // Forces the client to get a new token, as we actually include data in them, it cannot be done any other way.
      });
      const idToken = await auth0Client.getUser();
      if (!idToken) throw new Error("Could not get the user's details");
      const userDetails = await this.updateUserDetails(idToken);
      return {
        ...getTokenSilentlyResponse,
        idToken,
        userDetails
      };
    } catch (err) {
      throw err;
    }
  }
  async logIn() {
    const auth0Client = await this.auth0ClientPromise;
    if (!auth0Client) throw new Error("Missing Auth0 Client");
    if (this.debug) console.log("logIn()");
    const isAuthenticated = await auth0Client.isAuthenticated();
    if (isAuthenticated) {
      throw new Error("Already logged in");
    }
    const authorizationParams = this.getAuthorizationParams({
      redirect_uri: this.redirectURI
      // TODO: This doesn't seem to change anything. It could be used to remember the last provider the user used.
      // connection: "auth0",
    });
    if (this.loginMethod === "popup") {
      await auth0Client.loginWithPopup(
        {
          authorizationParams
        },
        {
          // { popup: <POPUP> } // This might be useful to provide an already-created popup in platforms like iOS.
        }
      );
    } else {
      auth0Client.loginWithRedirect({
        authorizationParams
        // openUrl(url) { }, // This might be useful to control the redirect in mobile platforms.
      });
      throw new Error("Redirecting...");
    }
    return this.getTokenSilently();
  }
  async handleRedirectCallback(callbackUrlWithParams) {
    if (this.debug)
      console.log(`handleRedirectCallback(${callbackUrlWithParams})`);
    const auth0Client = await this.auth0ClientPromise;
    if (!auth0Client) throw new Error("Missing Auth0 Client");
    await auth0Client.handleRedirectCallback(callbackUrlWithParams);
    const idToken = await auth0Client.getUser() || null;
    const userDetails = await this.updateUserDetails(idToken);
    return { idToken, userDetails };
  }
  async logOut() {
    this.setUserDetails(null);
    const auth0Client = await this.auth0ClientPromise;
    if (!auth0Client) throw new Error("Missing Auth0 Client");
    return auth0Client.logout({
      logoutParams: {
        returnTo: this.returnToURI
      }
    }).catch((err) => {
      console.warn(err instanceof Error ? err.message : err);
      if (typeof location !== "undefined") location.reload();
    });
  }
  async encodeToken(data) {
    const accessToken = await this.getTokenSilently(data);
    return accessToken.id_token;
  }
  // Getters for cached user data:
  getCachedUserDetails() {
    return this.userDetails;
  }
  getCachedUserPublicKey() {
    var _a2;
    return ((_a2 = this.userDetails) == null ? void 0 : _a2.owner) || null;
  }
  getCachedUserSub() {
    var _a2;
    return ((_a2 = this.userDetails) == null ? void 0 : _a2.sub) || null;
  }
  getCachedUserAddress() {
    var _a2;
    return ((_a2 = this.userDetails) == null ? void 0 : _a2.walletAddress) || null;
  }
  getCachedUserAddressLabel() {
    var _a2;
    return ((_a2 = this.userDetails) == null ? void 0 : _a2.walletAddressLabel) || null;
  }
  getCachedUserEmail() {
    var _a2;
    return ((_a2 = this.userDetails) == null ? void 0 : _a2.email) || null;
  }
  // DEVELOPMENT:
  async overridePublicKey(publicKeyPEM) {
    this.overriddenPublicKey = uint8ArrayTob64Url(
      pemToUint8Array(publicKeyPEM)
    );
  }
};
async function createUser(api, auth0, options) {
  const encodedData = await auth0.encodeToken({
    path: "/create-user",
    ...options
  });
  let idTokenWithData = null;
  try {
    const createUserResponse = await api.post(
      "/create-user",
      { encodedData }
    );
    idTokenWithData = createUserResponse.data.idTokenWithData;
  } catch (err) {
    throw parseErrorResponse(err);
  }
  if (!idTokenWithData) {
    throw new Error("Error creating user on server.");
  }
  return idTokenWithData;
}
function isLegacyBufferObject(legacyBufferData) {
  return !!legacyBufferData && typeof legacyBufferData === "object" && legacyBufferData.type === "Buffer" && Array.isArray(legacyBufferData.data);
}
function normalizeBufferDataWithNull(data) {
  if (data === null || data === void 0) return null;
  if (typeof data === "string") {
    return b64ToUint8Array(data);
  }
  if (isLegacyBufferObject(data)) {
    return new Uint8Array(data.data);
  }
  return new Uint8Array(Object.values(data));
}
async function decrypt(api, auth0, ciphertext) {
  const encodedData = await auth0.encodeToken({
    path: "/decrypt",
    ciphertext
  });
  let decryptedData = null;
  try {
    const decryptResponse = await api.post("/decrypt", {
      encodedData
    });
    decryptedData = normalizeBufferDataWithNull(
      decryptResponse.data.decryptedData
    );
  } catch (err) {
    throw parseErrorResponse(err);
  }
  if (decryptedData === null) {
    throw new Error("Error decrypting on server.");
  }
  return decryptedData;
}
async function encrypt(api, auth0, plaintext) {
  const encodedData = await auth0.encodeToken({
    path: "/encrypt",
    plaintext
  });
  let encryptedData = null;
  try {
    const encryptResponse = await api.post("/encrypt", {
      encodedData
    });
    encryptedData = normalizeBufferDataWithNull(
      encryptResponse.data.encryptedData
    );
  } catch (err) {
    throw parseErrorResponse(err);
  }
  if (encryptedData === null) {
    throw new Error("Error encrypting on server.");
  }
  return encryptedData;
}
async function sign(api, auth0, data) {
  const encodedData = await auth0.encodeToken({
    path: "/sign",
    data
  });
  let signature = null;
  try {
    const signResponse = await api.post("/sign", {
      encodedData
    });
    signature = normalizeBufferDataWithNull(signResponse.data.signature);
  } catch (err) {
    throw parseErrorResponse(err);
  }
  if (signature === null) {
    throw new Error("Error signing data on server.");
  }
  return signature;
}
async function serverInfo(api, auth0, options) {
  const encodedData = (options == null ? void 0 : options.includeToken) ? await auth0.encodeToken() : null;
  let serverInfo2 = null;
  try {
    const serverInfoResponse = encodedData ? await api.post("/", {
      encodedData
    }) : await api.get(
      "/"
      /* HOME */
    );
    serverInfo2 = serverInfoResponse.data;
  } catch (err) {
    throw parseErrorResponse(err);
  }
  if (!serverInfo2) {
    throw new Error("Error requesting the API status.");
  }
  return serverInfo2;
}
var OthentKMSClient = class {
  constructor(baseURL, auth0) {
    this.api = axios_default.create({ baseURL });
    this.auth0 = auth0;
  }
  async serverInfo(options) {
    return serverInfo(this.api, this.auth0, options);
  }
  async createUser(options) {
    return createUser(this.api, this.auth0, options);
  }
  async decrypt(ciphertext) {
    return decrypt(this.api, this.auth0, ciphertext);
  }
  async encrypt(plaintext) {
    return encrypt(this.api, this.auth0, plaintext);
  }
  async sign(data) {
    return sign(this.api, this.auth0, data);
  }
  getSignerSignFn() {
    return async (data) => {
      const signatureBuffer = await this.sign(data);
      return signatureBuffer;
    };
  }
};
function padString(input) {
  let segmentLength = 4;
  let stringLength = input.length;
  let diff = stringLength % segmentLength;
  if (!diff) {
    return input;
  }
  let position = stringLength;
  let padLength = segmentLength - diff;
  let paddedStringLength = stringLength + padLength;
  let buffer = import_buffer4.Buffer.alloc(paddedStringLength);
  buffer.write(input);
  while (padLength--) {
    buffer.write("=", position++);
  }
  return buffer.toString();
}
function encode8(input, encoding = "utf8") {
  if (import_buffer4.Buffer.isBuffer(input)) {
    return fromBase64(input.toString("base64"));
  }
  return fromBase64(import_buffer4.Buffer.from(input, encoding).toString("base64"));
}
function decode7(base64url22, encoding = "utf8") {
  return import_buffer4.Buffer.from(toBase64(base64url22), "base64").toString(encoding);
}
function toBase64(base64url22) {
  base64url22 = base64url22.toString();
  return padString(base64url22).replace(/\-/g, "+").replace(/_/g, "/");
}
function fromBase64(base642) {
  return base642.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBuffer(base64url22) {
  return import_buffer4.Buffer.from(toBase64(base64url22), "base64");
}
var base64url2 = encode8;
base64url2.encode = encode8;
base64url2.decode = decode7;
base64url2.toBase64 = toBase64;
base64url2.fromBase64 = fromBase64;
base64url2.toBuffer = toBuffer;
function initArweave(apiConfig) {
  const ArweaveClass = import_arweave.default.hasOwnProperty("default") ? import_arweave.default.default : import_arweave.default;
  return ArweaveClass.init(apiConfig);
}
var _Othent = class _Othent2 {
  /**
   * Instantiate `Othent`.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/constructor|constructor() docs}
   */
  constructor(options = DEFAULT_OTHENT_OPTIONS) {
    this.errorEventListenerHandler = new EventListenersHandler();
    this.tokens = /* @__PURE__ */ new Set();
    this.walletName = CLIENT_NAME;
    this.walletVersion = CLIENT_VERSION;
    this.config = DEFAULT_OTHENT_CONFIG;
    this.appInfo = DEFAULT_APP_INFO;
    this.gatewayConfig = DEFAULT_GATEWAY_CONFIG;
    if (!globalThis.Buffer) {
      globalThis.Buffer = import_buffer3.Buffer;
      console.warn(
        "`globalThis.Buffer` has been polyfilled for you. Note this could have side-effect and affect other libraries."
      );
    }
    const crypto2 = globalThis.crypto || null;
    if (!crypto2) {
      throw new Error(
        "A Crypto module is needed for Othent to work. If your environment doesn't natively provide one, you should polyfill it."
      );
    }
    this.crypto = crypto2;
    let {
      appInfo,
      gatewayConfig,
      persistCookie,
      persistLocalStorage,
      initialUserDetails,
      auth0Cache = DEFAULT_OTHENT_CONFIG.auth0Cache,
      auth0RedirectURI,
      auth0ReturnToURI,
      ...configOptions
    } = options;
    const defaultRedirectURI = typeof location === "undefined" ? null : location.origin;
    this.config = {
      ...mergeOptions(configOptions, DEFAULT_OTHENT_CONFIG),
      cookieKey: typeof persistCookie === "string" ? persistCookie : persistCookie ? DEFAULT_COOKIE_KEY : null,
      localStorageKey: typeof persistLocalStorage === "string" ? persistLocalStorage : persistLocalStorage ? DEFAULT_COOKIE_KEY : null,
      auth0Cache: typeof auth0Cache === "object" ? "custom" : auth0Cache,
      auth0RedirectURI: auth0RedirectURI || defaultRedirectURI,
      auth0ReturnToURI: auth0ReturnToURI || defaultRedirectURI
    };
    this.setAppInfo(appInfo);
    this.setGatewayConfig(gatewayConfig);
    const { config } = this;
    const { cookieKey, localStorageKey } = config;
    if (typeof cookieKey === "string" && !cookieKey.startsWith("othent")) {
      throw new Error(
        '`persistCookie` / `cookieKey` must start with "othent".'
      );
    }
    if (typeof localStorageKey === "string" && !localStorageKey.startsWith("othent")) {
      throw new Error(
        '`persistLocalStorage` / `localStorageKey` must start with "othent".'
      );
    }
    if (!config.auth0RedirectURI) {
      throw new Error("`auth0RedirectURI` is required.");
    }
    if (!config.auth0ReturnToURI) {
      throw new Error("`auth0ReturnToURI` is required.");
    }
    if (config.autoConnect === "eager" && config.auth0LogInMethod === "popup" && config.auth0Strategy === "refresh-tokens" && auth0Cache === "memory") {
      throw new Error(
        'The browser cannot open the authentication modal automatically before an user interaction. Use `autoConnect = "lazy"` or change any of these other options: `auth0LogInMethod`, `auth0Strategy` or `auth0Cache`.'
      );
    }
    this.auth0 = new OthentAuth0Client({
      debug: config.debug,
      domain: config.auth0Domain,
      clientId: config.auth0ClientId,
      strategy: config.auth0Strategy,
      cache: auth0Cache,
      loginMethod: config.auth0LogInMethod,
      redirectURI: config.auth0RedirectURI,
      returnToURI: config.auth0ReturnToURI,
      refreshTokenExpirationMs: config.auth0RefreshTokenExpirationMs,
      appInfo: this.appInfo,
      initialUserDetails,
      cookieKey: config.cookieKey,
      localStorageKey: config.localStorageKey
    });
    if (config.autoConnect === "eager") {
      if (typeof location === "undefined") {
        this.connect();
      } else {
        const url = new URL(location.href);
        const { searchParams } = url;
        if (!searchParams.has("code") && !searchParams.has("state")) {
          this.connect();
        }
      }
    }
    if (config.inject) {
      globalThis.arweaveWallet = this;
    }
    if (!config.throwErrors) {
      const walletMethods = [
        "connect",
        "disconnect",
        "getActiveAddress",
        "getActivePublicKey",
        "getAllAddresses",
        "getWalletNames",
        "getUserDetails",
        "getSyncActiveAddress",
        "getSyncActivePublicKey",
        "getSyncAllAddresses",
        "getSyncWalletNames",
        "getSyncUserDetails",
        "sign",
        "dispatch",
        "encrypt",
        "decrypt",
        "signature",
        "signDataItem",
        "signMessage",
        "verifyMessage",
        "privateHash",
        "getArweaveConfig",
        "getPermissions"
      ];
      walletMethods.forEach((walletMethod) => {
        let fn2 = this[walletMethod];
        if (typeof fn2 !== "function") return;
        fn2 = fn2.bind(this);
        this[walletMethod] = (...args) => {
          try {
            let result = fn2(...args);
            if (isPromise(result)) {
              result = result.catch((err) => {
                this.onError(err);
                return null;
              });
            }
            return result;
          } catch (err) {
            this.onError(err);
          }
          return null;
        };
      });
    }
    this.api = new OthentKMSClient(this.config.serverBaseURL, this.auth0);
  }
  /**
   * @param appInfo Setter and validator for `appInfo`.
   *
   * @returns `Othent.appInfo`
   */
  setAppInfo(appInfo) {
    const nextAppInfo = {
      ...appInfo,
      env: appInfo.env || DEFAULT_APP_INFO.env
    };
    if (!nextAppInfo.name || !nextAppInfo.version || !nextAppInfo.env) {
      throw new Error(
        "Incomplete `appInfo`: `name`, `version` and `env` are required."
      );
    }
    if (this.auth0) this.auth0.setAppInfo(nextAppInfo);
    return this.appInfo = nextAppInfo;
  }
  /**
   * @param appInfo Setter and validator for `gatewayConfig`.
   *
   * @returns `Othent.gatewayConfig`
   */
  setGatewayConfig(gatewayConfig) {
    const nextGatewayConfig = gatewayConfig || DEFAULT_GATEWAY_CONFIG;
    if (!nextGatewayConfig.host || !nextGatewayConfig.port || !nextGatewayConfig.protocol) {
      throw new Error(
        "Incomplete `gatewayConfig`: `host`, `port` and `protocol` are required."
      );
    }
    return this.gatewayConfig = nextGatewayConfig;
  }
  /**
   * Start listening for `storage` events to sync user details across tabs. Only needed if `persistLocalStorage = true`.
   *
   * @returns A cleanup function that must be called whenever Othent needs to stop listening for `storage` events (e.g.
   * to be used in React's `useEffects`'s cleanup function).
   *
   * @see {@link https://docs.othent.io/js-sdk-api/start-tab-synching|startTabSynching() docs}
   */
  startTabSynching() {
    if (!this.config.localStorageKey) {
      console.warn(
        "Calling `Othent.startTabSynching()` is a NOOP unless the `persistLocalStorage` option is used."
      );
    }
    this.auth0.initStorageSyncing();
    return () => {
      this.auth0.stopStorageSyncing();
    };
  }
  // ERROR EVENT / ERROR HANDLING:
  onError(error) {
    if (!(error instanceof Error)) {
      console.warn("Unknown error type", error);
      return;
    }
    if (this.errorEventListenerHandler.hasListeners) {
      this.errorEventListenerHandler.emit(error);
    } else {
      console.warn(
        "Unhandled unthrown error:\n",
        error,
        '\nWhen using `throwErrors = false`, you must add at least one error event listener with `othent.addEventListener("error", () => { ... })`'
      );
    }
  }
  /**
   * Add an event listener for the specific error type.
   *
   * @param type `"auth"` or `error`.
   * @param listener Function of type `AuthListener` or `ErrorListener`.
   *
   * @returns A cleanup function that will remove the error listener when called.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/events|Events docs}
   */
  addEventListener(type, listener) {
    let eventListenerHandler = null;
    if (type === "auth") {
      eventListenerHandler = this.auth0.getAuthEventListenerHandler();
    } else if (type === "error") {
      if (this.config.throwErrors)
        throw new Error(
          "You can only listen for `error` events if `throwErrors = false`."
        );
      eventListenerHandler = this.errorEventListenerHandler;
    }
    if (!eventListenerHandler) throw new Error("Unknown event type");
    eventListenerHandler.add(listener);
    return () => {
      eventListenerHandler.delete(listener);
    };
  }
  /**
   * Remove an error listener of the specified error type.
   *
   * @param type `"auth"` or `error`.
   * @param listener Function of type `AuthListener` or `ErrorListener`.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/events|Events docs}
   */
  removeEventListener(type, listener) {
    let eventListenerHandler = null;
    if (type === "auth") {
      eventListenerHandler = this.auth0.getAuthEventListenerHandler();
    } else if (type === "error") {
      eventListenerHandler = this.errorEventListenerHandler;
    }
    if (!eventListenerHandler) throw new Error("Unknown event type");
    eventListenerHandler.delete(listener);
  }
  // AUTH LOADING:
  /**
   * @returns `true` if the user is authenticated; `false` otherwise.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/is-authenticated|isAuthenticated docs}
   */
  get isAuthenticated() {
    return this.auth0.isAuthenticated;
  }
  /**
   * Automatically checks if the user is authenticated. If they are not, and...
   *
   * - `autoConnect === "eager"`: Prompts them to sign in/up again. It throws an error if authentication fails.
   * - `autoConnect === "lazy"`: Authenticates them automatically, either from an existing session or by prompting them
   *   to sign in/up again. It throws an error if authentication fails.
   * - `autoConnect === "off"`: It throws an error.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/require-auth|requireAuth() docs}
   */
  requireAuth() {
    return this.requireUserDataOrThrow().then(() => {
    });
  }
  /**
   * Automatically checks if the user is authenticated. If they are not, and...
   *
   * - `autoConnect === "eager"`: Prompts them to sign in/up again. It throws an error if authentication fails.
   * - `autoConnect === "lazy"`: Authenticates them automatically, either from an existing session or by prompting them
   *   to sign in/up again. It throws an error if authentication fails.
   * - `autoConnect === "off"`: It throws an error.
   *
   * @returns `Promise<{ sub, publicKey }>` to get these 2 properties required in most Othent functions.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/require-auth|requireAuth() docs}
   */
  async requireUserDataOrThrow() {
    if (this.config.autoConnect !== "off" && !this.auth0.isAuthenticated) {
      await this.connect(void 0, void 0, this.gatewayConfig);
    }
    const { sub, owner } = this.auth0.getCachedUserDetails() || {};
    if (!sub || !owner) throw new Error("Missing cached user.");
    return {
      sub,
      publicKey: owner
    };
  }
  // CONNECT / DISCONNECT / USER CREATION:
  async completeConnectionOrCreateAuth0User(userDetails, hasIdToken) {
    if (userDetails && hasIdToken) return userDetails;
    const importOnly = false;
    if (!(userDetails == null ? void 0 : userDetails.walletAddress) && hasIdToken) {
      const idTokenWithData = await this.api.createUser({ importOnly });
      const userDetailsFromCreateUserResponse = await this.auth0.updateUserDetails(idTokenWithData);
      if (userDetailsFromCreateUserResponse)
        return userDetailsFromCreateUserResponse;
    }
    this.auth0.logOut();
    throw new Error("Unexpected authentication error");
  }
  /**
   * If and only if you set the [`auth0LogInMethod = "redirect"`](./constructor.md#auth0loginmethod-auth0loginmethod) option,
   * users will be redirected to Auth0 to authenticate and then back to your application. When they land back in your
   * application, you must call `completeConnectionAfterRedirect()` to complete the authentication process.
   *
   * By default, `callbackUriWithParams = location.href`, if you environment supports it. Otherwise, you'll have to manually
   * pass an URI with the `code` and `state` params provided by Auth0, which handles the redirect callback.
   *
   * See [Auth0's `handleRedirectCallback`](https://auth0.github.io/auth0-spa-js/classes/Auth0Client.html#handleRedirectCallback).
   *
   * @param callbackUriWithParams
   *
   * @returns A Promise with the `UserDetails` or `null` if the log in modal was closed, could not even be opened or
   * authentication failed.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/complete-connection-after-redirect|completeConnectionAfterRedirect() docs}
   */
  async completeConnectionAfterRedirect(callbackUriWithParams) {
    if (this.config.auth0LogInMethod !== "redirect") {
      console.warn(
        'Calling `Othent.completeConnectionAfterRedirect()` is a NOOP unless the `auth0LogInMethod` options is `"redirect"`.'
      );
    }
    const urlString = callbackUriWithParams || (typeof location === "undefined" ? "" : location.href);
    const urlObject = new URL(urlString.replace(/.+\.auth0:\/\//, "https://"));
    const { searchParams } = urlObject;
    if (!searchParams.has("code") || !searchParams.has("state") || !urlString)
      return null;
    let idToken = null;
    let userDetails = null;
    try {
      const urlStringData = await this.auth0.handleRedirectCallback(urlString);
      idToken = urlStringData.idToken;
      userDetails = urlStringData.userDetails;
    } catch (err) {
      console.warn(
        "The connection could not be completed. There was an error during the redirect flow:\n",
        err
      );
    } finally {
      if (typeof location !== "undefined" && typeof history !== "undefined") {
        searchParams.delete("code");
        searchParams.delete("state");
        history.replaceState(null, "", urlObject);
      }
    }
    return this.completeConnectionOrCreateAuth0User(userDetails, !!idToken);
  }
  /**
   * Prompts the user to sign in/up using Auth0's modal. This function cannot be called programmatically before the user
   * interacts with the page (e.g. by clicking on a button), as that will result in a `Unable to open a popup` error.
   *
   * @returns A Promise with the `UserDetails` or `null` if the log in modal was closed, could not even be opened or
   * authentication failed.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/connect|connect() docs}
   */
  async connect(permissions, appInfo, gateway) {
    if (permissions && permissions.toSorted().join("-") !== _Othent2.ALL_PERMISSIONS.join("-")) {
      throw new Error(
        "Othent implicitly has access to all available permissions. You should pass `permissions = undefined` or include all of them."
      );
    }
    if (appInfo) this.setAppInfo(appInfo);
    if (gateway) this.setGatewayConfig(gateway);
    let id_token = "";
    let userDetails = null;
    try {
      const response = await this.auth0.getTokenSilently();
      id_token = response.id_token;
      userDetails = response.userDetails;
    } catch (err) {
      if (!(err instanceof Error)) throw err;
      if (err.message !== "Login required" && !(err instanceof f)) {
        throw err;
      }
      console.warn(err.message);
    }
    if (!id_token) {
      try {
        const response = await this.auth0.logIn();
        id_token = response.id_token;
        userDetails = response.userDetails;
      } catch (err) {
        if (!(err instanceof Error)) throw err;
        if (err.message === "Redirecting...") await new Promise(() => {
        });
        if (err.message.startsWith("Unable to open a popup") || err instanceof p || err instanceof h) {
          if (err instanceof h) err.popup.close();
          console.warn(err.message);
          return null;
        }
        throw err;
      }
    }
    return this.completeConnectionOrCreateAuth0User(userDetails, !!id_token);
  }
  /**
   * Logs out the user (disconnect the user's wallet). This will require the user to log back in after called.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/disconnect|disconnect() docs}
   */
  async disconnect() {
    return this.auth0.logOut();
  }
  // GET DATA (ASYNC):
  /**
   * Returns the Arweave wallet address associated with the active (authenticated) user account.
   *
   * The wallet address is derived from the corresponding public key (see [`getActivePublicKey()`](get-active-public-key.md)).
   *
   * This function assumes (and requires) a user is authenticated.
   *
   * @returns A Promise with the active wallet address of the users wallet.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-active-address|getActiveAddress() docs}
   */
  getActiveAddress() {
    return Promise.resolve(this.getSyncActiveAddress());
  }
  /**
   * Returns the public key (`jwk.n` field) associated with the active (authenticated) user account.
   *
   * This function assumes (and requires) a user is authenticated.
   *
   * @returns A Promise with the owner (jwk.n field) of the users wallet.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-active-public-key|getActivePublicKey() docs}
   */
  getActivePublicKey() {
    return Promise.resolve(this.getSyncActivePublicKey());
  }
  /**
   * Returns an array of Arweave wallet addresses associated with the active (authenticated) user account.
   *
   * However, note that Othent does not currently support creating/storing more than one wallet associated to the same
   * account, so this function will always return exactly one wallet address.
   *
   * This function assumes (and requires) a user is authenticated.
   *
   * @returns A Promise with an array of all wallet addresses of the users wallet.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-all-addresses|getAllAddresses() docs}
   */
  getAllAddresses() {
    return Promise.resolve(this.getSyncAllAddresses());
  }
  /**
   * Similarly to ArConnect, each wallet in Othent has a nickname. This is either:
   *
   * - The user's [ANS](https://ans.gg) name.
   * - A platform + email identifying label (e.g. `Google (email@gmail.com)`, `Twitter (email@outlook.com)`...).
   *
   * To provide better UX, you can retrieve these names and display them to the user, so that they can easily recognize
   * which wallet they're using.
   *
   * However, note that Othent does not currently support creating/storing more than one wallet associated to the same
   * account, so this function will always return exactly one wallet address.
   *
   * This function assumes (and requires) a user is authenticated.
   *
   * @returns A Promise containing an object that maps each wallet addresses to their nickname.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-wallet-names|getWalletNames() docs}
   */
  getWalletNames() {
    return Promise.resolve(this.getSyncWalletNames());
  }
  /**
   * Returns an object with all the user details of the active (authenticated) user account.
   *
   * @returns A Promise containing all the user details of the active user, or `null` if the user is not authenticated.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-user-details|getUserDetails() docs}
   */
  getUserDetails() {
    return Promise.resolve(this.getSyncUserDetails());
  }
  // GET DATA (SYNC):
  /**
   * Get the active wallet address of the users wallet. This function assumes (and requires) a user is authenticated.
   *
   * @returns The active wallet address of the users wallet.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-sync-active-address|getSyncActiveAddress() docs}
   */
  getSyncActiveAddress() {
    return this.auth0.getCachedUserAddress() || "";
  }
  /**
   * Get the owner (jwk.n) field of the users wallet. This function assumes (and requires) a user is authenticated.
   *
   * @returns The owner (jwk.n) field of the users wallet.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-sync-active-public-key|getSyncActivePublicKey() docs}
   */
  getSyncActivePublicKey() {
    return this.auth0.getCachedUserPublicKey() || "";
  }
  /**
   * Get all addresses of the users wallet. This function assumes (and requires) a user is authenticated.
   *
   * @returns All wallet addresses of the users wallet.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-sync-all-addresses|getSyncAllAddresses() docs}
   */
  getSyncAllAddresses() {
    const address = this.auth0.getCachedUserAddress();
    return address ? [address] : [];
  }
  /**
   * Get the wallets (users) email. This function assumes (and requires) a user is authenticated.
   *
   * @returns The wallets (users) email.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-sync-wallet-names|getSyncWalletNames() docs}
   */
  getSyncWalletNames() {
    const address = this.auth0.getCachedUserAddress();
    const addressLabel = this.auth0.getCachedUserAddressLabel();
    return Promise.resolve(
      address && addressLabel ? {
        [address]: addressLabel
      } : {}
    );
  }
  /**
   * Get user details. This function assumes (and requires) a user is authenticated.
   *
   * @returns The user's details.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-sync-user-details|getSyncUserDetails() docs}
   */
  getSyncUserDetails() {
    return this.auth0.getCachedUserDetails();
  }
  addCommonTags(transactionOrTags = []) {
    const { appInfo } = this;
    if (Array.isArray(transactionOrTags)) {
      const appInfoTags = [
        { name: "App-Name", value: appInfo.name },
        { name: "App-Version", value: appInfo.version },
        { name: "App-Env", value: appInfo.env }
      ];
      return [
        ...transactionOrTags,
        ...this.config.tags,
        ...appInfoTags,
        ...ANALYTICS_TAGS
      ];
    }
    for (const { name: name2, value } of this.config.tags) {
      transactionOrTags.addTag(name2, value);
    }
    transactionOrTags.addTag("App-Name", appInfo.name);
    transactionOrTags.addTag("App-Version", appInfo.version);
    transactionOrTags.addTag("App-Env", appInfo.env);
    for (const { name: name2, value } of ANALYTICS_TAGS) {
      transactionOrTags.addTag(name2, value);
    }
  }
  /**
   * To submit a transaction to the Arweave Network, it first has to be signed using a private key. Othent creates a private
   * key / Arweave wallet for every account and stores it in Google KMS. The wallet associated with the active user account
   * is used to sign transactions using the `sign()` function.
   *
   * The `sign()` function is meant to replicate the behavior of the `transactions.sign()` function of
   * [`arweave-js`](https://github.com/arweaveTeam/arweave-js#sign-a-transaction), but instead of mutating the transaction
   * object, it returns a new and signed transaction instance.
   *
   * This function assumes (and requires) a user is authenticated and a valid arweave transaction.
   *
   * @param transaction The transaction to sign.
   *
   * @returns A Promise containing a new signed transaction.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/sign|sign() docs}
   * @see {@link https://docs.arweave.org/developers/arweave-node-server/http-api#transaction-format|Transaction Format docs}
   */
  async sign(transaction) {
    const { publicKey } = await this.requireUserDataOrThrow();
    const arweave = initArweave(this.gatewayConfig);
    const transactionTags = transaction.get("tags").map(
      (tag) => ({
        name: tag.get("name", { decode: true, string: true }),
        value: tag.get("value", { decode: true, string: true })
      })
    );
    const tags = this.addCommonTags(transactionTags);
    const transactionToSign = await arweave.createTransaction({
      format: transaction.format,
      owner: publicKey,
      reward: transaction.reward,
      // This value is added automatically when creating a transaction, so instead of propagating the one from the one
      // the user sends, we'll just leave it to the new `createTransaction` to fill this in:
      // last_tx: transaction.last_tx,
      // To transfer AR:
      target: transaction.target,
      quantity: transaction.quantity,
      // To send data:
      data: transaction.data,
      data_root: transaction.data_root,
      data_size: transaction.data_size
    });
    tags.forEach((tagData) => {
      transactionToSign.addTag(tagData.name, tagData.value);
    });
    const dataToSign = await transactionToSign.getSignatureData();
    const signatureBuffer = await this.api.sign(dataToSign);
    const id2 = await hash2(signatureBuffer);
    transactionToSign.setSignature({
      id: uint8ArrayTob64Url(id2),
      owner: publicKey,
      signature: uint8ArrayTob64Url(signatureBuffer),
      tags: transactionToSign.tags,
      reward: transactionToSign.reward
    });
    return transactionToSign;
  }
  /**
   * The `dispatch()` function allows you to quickly sign and send a transaction to the network in a bundled format. It is
   * best for smaller datas and contract interactions. If the bundled transaction cannot be submitted, it will fall back to a
   * base layer transaction. The function returns the [result](dispatch.md#dispatch-result) of the API call.
   *
   * This function assumes (and requires) a user is authenticated and a valid arweave transaction.
   *
   * @param transaction The transaction to sign and dispatch.
   *
   * @returns The signed version of the transaction.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/dispatch|dispatch() docs}
   */
  async dispatch(transaction, options) {
    var _a2;
    const transactionTags = transaction.get("tags").map(
      (tag) => ({
        name: tag.get("name", { decode: true, string: true }),
        value: tag.get("value", { decode: true, string: true })
      })
    );
    const signedDataItemBuffer = await this.signDataItem({
      // Not used for now as `transaction.last_tx` is not 32 bytes, as required by `DataItem`:
      // anchor: transaction.last_tx,
      target: transaction.target,
      data: transaction.data,
      tags: transactionTags
    });
    const url = `${(options == null ? void 0 : options.node) || DEFAULT_DISPATCH_NODE}/tx`;
    try {
      const res = await axios_default.post(
        url,
        signedDataItemBuffer,
        {
          headers: {
            "Content-Type": "application/octet-stream"
          },
          maxBodyLength: Infinity,
          maxContentLength: Infinity,
          responseType: "json"
        }
      );
      if (res.status >= 400) {
        throw new Error(`${res.status} - ${JSON.stringify(res.data)}`);
      }
      return {
        ...res.data,
        type: "BUNDLED"
      };
    } catch (err) {
      console.warn(`Error dispatching transaction to ${url} =
`, err);
      const signedTransaction = await this.sign(transaction);
      const arweave = (_a2 = options == null ? void 0 : options.arweave) != null ? _a2 : initArweave(this.gatewayConfig);
      const uploader = await arweave.transactions.getUploader(signedTransaction);
      while (!uploader.isComplete) {
        await uploader.uploadChunk();
      }
      return {
        id: signedTransaction.id,
        signature: signedTransaction.signature,
        owner: signedTransaction.owner,
        type: "BASE"
      };
    }
  }
  // ENCRYPT/DECRYPT:
  /**
   * Encrypt data with the users JWK.
   *
   * This function assumes (and requires) a user is authenticate.
   *
   * @param plaintext The data in string format to sign.
   *
   * @returns The encrypted data.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/encrypt|encrypt() docs}
   */
  async encrypt(plaintext) {
    await this.requireUserDataOrThrow();
    const ciphertextBuffer = await this.api.encrypt(plaintext);
    return ciphertextBuffer;
  }
  /**
   * Decrypt data with the users JWK.
   *
   * This function assumes (and requires) a user is authenticated.
   *
   * @param ciphertext The data to decrypt.
   *
   * @returns The decrypted data.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/decrypt|decrypt() docs}
   */
  async decrypt(ciphertext) {
    await this.requireUserDataOrThrow();
    const plaintextBuffer = await this.api.decrypt(ciphertext);
    return plaintextBuffer;
  }
  // SIGN:
  /**
   * Generate a signature. This function assumes (and requires) a user is authenticated.
   *
   * @deprecated Use `sign`, `signDataItems` or `signMessage` instead.
   *
   * @param data The data to sign.
   *
   * @returns The {@linkcode Buffer} format of the signature.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/signature|signature() docs}
   */
  async signature(data) {
    await this.requireUserDataOrThrow();
    const signatureBuffer = await this.api.sign(data);
    return signatureBuffer;
  }
  /**
   * The signDataItem() function allows you to create and sign a data item object, compatible with arbundles. These data
   * items can then be submitted to an ANS-104 compatible bundler.
   *
   * @param dataItem The data to sign.
   *
   * @returns The signed data item.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/sign-data-item|signDataItem() docs}
   */
  async signDataItem(dataItem) {
    const { publicKey } = await this.requireUserDataOrThrow();
    const { data, tags, ...options } = dataItem;
    const signer = {
      publicKey: toBuffer(publicKey),
      signatureType: 1,
      signatureLength: 512,
      ownerLength: 512,
      sign: this.api.getSignerSignFn()
      // Note we don't provide `verify` as it's not used anyway:
      // verify: () => true,
    };
    const opts = {
      ...options,
      tags: this.addCommonTags(tags)
    };
    const dataItemInstance = ge(data, signer, opts);
    await dataItemInstance.sign(signer);
    return dataItemInstance.getRaw().buffer;
  }
  /**
   * Sign the given message. This function assumes (and requires) a user is authenticated.
   *
   * @param message The message to sign.
   *
   * @returns The signed version of the message.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/sign-message|signMessage() docs}
   */
  async signMessage(data, options) {
    await this.requireUserDataOrThrow();
    const hashAlgorithm = (options == null ? void 0 : options.hashAlgorithm) || "SHA-256";
    const hashArrayBuffer = await this.crypto.subtle.digest(
      hashAlgorithm,
      binaryDataTypeOrStringToBinaryDataType(data)
    );
    const signatureBuffer = await this.api.sign(hashArrayBuffer);
    return signatureBuffer;
  }
  /**
   * Verify the given message. This function assumes (and requires) a user is authenticated.
   *
   * @param signature The signature to verify.
   *
   * @returns The signed version of the message.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/verify-message|verifyMessage() docs}
   */
  async verifyMessage(data, signature, publicKey, options = { hashAlgorithm: "SHA-256" }) {
    if (!publicKey) {
      const requiredUserData = await this.requireUserDataOrThrow();
      publicKey || (publicKey = requiredUserData.publicKey);
    }
    const hashAlgorithm = (options == null ? void 0 : options.hashAlgorithm) || "SHA-256";
    const hashArrayBuffer = await this.crypto.subtle.digest(
      hashAlgorithm,
      binaryDataTypeOrStringToBinaryDataType(data)
    );
    const publicJWK = {
      e: "AQAB",
      ext: true,
      kty: "RSA",
      n: publicKey
    };
    const cryptoKey = await this.crypto.subtle.importKey(
      "jwk",
      publicJWK,
      {
        name: "RSA-PSS",
        hash: options.hashAlgorithm
      },
      false,
      ["verify"]
    );
    const result = await this.crypto.subtle.verify(
      { name: "RSA-PSS", saltLength: 32 },
      cryptoKey,
      binaryDataTypeOrStringToBinaryDataType(signature),
      hashArrayBuffer
    );
    return result;
  }
  /**
   * Create a deterministic secret based on the input data.
   *
   * @param data Input data to generate the hash from.
   * @param options Hash algorithm (default = `SHA-256`).
   *
   * @returns Hash `Uint8Array`.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/private-hash|privateHash() docs}
   */
  async privateHash(data, options) {
    return hash2(
      binaryDataTypeOrStringToBinaryDataType(data),
      options == null ? void 0 : options.hashAlgorithm
    );
  }
  // MISC.:
  /**
   * Get the Arweave config used by Othent.
   *
   * @returns Promise of Othent's `GatewayConfig`.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-arweave-config|getArweaveConfig() docs}
   */
  getArweaveConfig() {
    return Promise.resolve(this.gatewayConfig);
  }
  /**
   * Get the permissions Othent can use in the current site.
   *
   * @returns Promise of Othent's `PermissionType[]`.
   *
   * @see {@link https://docs.othent.io/js-sdk-api/get-permissions|getPermissions() docs}
   */
  getPermissions() {
    return Promise.resolve(_Othent2.ALL_PERMISSIONS);
  }
  /**
   * Mocked implementation to add tokens.
   * Othent doesn't currently support this feature and only tracks added tokens temporarily in memory.
   */
  addToken(id2, type, gateway) {
    console.warn(
      "Othent doesn't currently support this feature and only tracks added tokens temporarily in memory."
    );
    this.tokens.add(id2);
    return Promise.resolve();
  }
  /**
   * Mocked implementation to check if a token has been added.
   * Othent doesn't currently support this feature and only tracks added tokens temporarily in memory.
   */
  isTokenAdded(id2) {
    console.warn(
      "Othent doesn't currently support this feature and only tracks added tokens temporarily in memory."
    );
    return Promise.resolve(this.tokens.has(id2));
  }
  // DEVELOPMENT:
  __overridePublicKey(publicKeyPEM) {
    this.auth0.overridePublicKey(publicKeyPEM);
  }
  __getServerInfo(options) {
    return this.api.serverInfo(options);
  }
};
_Othent.walletName = CLIENT_NAME;
_Othent.walletVersion = CLIENT_VERSION;
_Othent.ALL_PERMISSIONS = [
  "ACCESS_ADDRESS",
  "ACCESS_ALL_ADDRESSES",
  "ACCESS_ARWEAVE_CONFIG",
  "ACCESS_PUBLIC_KEY",
  "DECRYPT",
  "DISPATCH",
  "ENCRYPT",
  "SIGN_TRANSACTION",
  "SIGNATURE"
];
var Othent = _Othent;

// ../../node_modules/arweave-wallet-kit/dist/index.es.js
(function() {
  "use strict";
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode(".b1cb9caz{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;font-family:var(--b1cb9caz-0),sans-serif;font-size:.9rem;font-weight:600;color:#fff;background-color:rgb(var(--b1cb9caz-1));border-radius:var(--b1cb9caz-2);padding:.3rem .8rem;text-align:center;border:none;outline:none;text-transform:uppercase;cursor:pointer;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;gap:.4rem;white-space:nowrap;-webkit-tap-highlight-color:transparent;-webkit-transition:all .18s ease-in-out;transition:all .18s ease-in-out}.b1cb9caz:hover:not(:active):not(:disabled){-webkit-transform:translate3d(0px,-1.4px,0px);-ms-transform:translate3d(0px,-1.4px,0px);transform:translate3d(0,-1.4px,0);box-shadow:var(--b1cb9caz-3)}.b1cb9caz:disabled{opacity:.7;cursor:not-allowed}.b1cb9caz svg{font-size:1em;width:1em;height:1em}.w14emrir{border-radius:var(--w14emrir-0);text-transform:none;padding:.3rem;background-color:var(--w14emrir-1)}.czh4f0e{line-height:2.6rem;padding:0 .9rem}.pwkn5es{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:rgb(var(--pwkn5es-0),.2);height:2.6rem;border-radius:var(--pwkn5es-1);padding:0 .3rem 0 .6rem;gap:.25rem}.bdt02oh{padding:0 .5rem}.e3hlv71{font-size:1.5rem!important}.a1jsmwxp{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:var(--a1jsmwxp-0);object-fit:cover;width:1.7rem;height:1.7rem;margin-right:.4rem}.as6ir6f{font-size:1rem!important;color:#fff}.av7js2i{position:relative;border-radius:var(--av7js2i-0);width:1.7rem;height:1.7rem;margin-right:.4rem;background:linear-gradient(to right,#4776e6,#8e54e9);background-size:cover}.av7js2i .as6ir6f{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.bbvkbel{position:fixed;top:0;left:0;right:0;bottom:0;width:100vw;height:100vh;z-index:90000;background-color:#0006}.m1767o4q{height:100vh;left:0;position:fixed;top:0;width:100vw;z-index:100000}.mzdiz37{height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width:720px){.mzdiz37{-webkit-align-items:flex-end;-webkit-box-align:flex-end;-ms-flex-align:flex-end;align-items:flex-end}}.m69h97z{position:relative;left:0;top:100%;z-index:100000;font-family:var(--m69h97z-0),sans-serif;overflow:hidden;-webkit-transition-property:width;transition-property:width}.m69h97z *::selection{background-color:#000000bf;color:#fff}.m69h97z *::-moz-selection{background-color:#000000bf;color:#fff}@media screen and (min-width:1081px){.m69h97z{max-width:28vw}}@media screen and (min-width:721px) and (max-width:1080px){.m69h97z{max-width:50vw}}@media screen and (max-width:720px){.m69h97z{max-width:100vw}}.mh21eb7{-webkit-transition:background-color .23s ease-in-out;transition:background-color .23s ease-in-out;background-color:rgb(var(--mh21eb7-0));border-radius:var(--mh21eb7-1);width:100%}@media screen and (max-width:720px){.mh21eb7{border-bottom-left-radius:0;border-bottom-right-radius:0}}.k17wyawm{position:fixed;font-family:var(--k17wyawm-0),sans-serif;font-size:.8rem;font-weight:500;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default;text-align:center;margin:0;color:#ffffff80;left:50%;bottom:10px;-webkit-transform:translateX(-50%);-ms-transform:translateX(-50%);transform:translate(-50%)}@media screen and (max-width:720px){.k17wyawm{bottom:unset;top:10px}}.b7jc8fb{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:1.24rem;padding:.75rem 1rem;border-radius:var(--b7jc8fb-0);border-radius:15px;bottom:0;right:1.5rem;left:unset;top:unset;width:auto}@media screen and (max-width:720px){.b7jc8fb{left:1.5rem;gap:1rem}}.typmncv{font-size:1.05rem;font-weight:500;color:rgb(var(--typmncv-0));margin:0}.b14qolsb{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:.6rem}@media screen and (max-width:720px){.b14qolsb{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.b14qolsb .b1cb9caz{width:100%}}.c1jq17m8{background-color:transparent;color:rgb(var(--c1jq17m8-0))}.c1jq17m8:hover{background-color:rgba(var(--c1jq17m8-1),.05);color:rgb(var(--c1jq17m8-1));box-shadow:none!important}.p1jty3xq{font-size:var(--p1jty3xq-0);color:rgb(var(--p1jty3xq-1));margin:0;font-weight:600;-webkit-transition:color .23s ease-in-out;transition:color .23s ease-in-out}.t1sgzzc0{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;font-family:var(--t1sgzzc0-0),sans-serif;font-size:var(--t1sgzzc0-1);font-weight:600;color:rgb(var(--t1sgzzc0-2));cursor:var(--t1sgzzc0-3);-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:.34rem;margin:0;-webkit-transition:color .23s ease-in-out;transition:color .23s ease-in-out}.tb205ol{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;gap:.1rem}.wzg6vks{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;padding:0 20px}.a1vzc1qt{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:.8rem}.l1rbotc6{width:60%;height:60%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;object-fit:contain}.acuhj7u{position:relative;width:3.8rem;height:3.8rem;border-radius:var(--acuhj7u-0);background-color:rgb(var(--acuhj7u-1));-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-tap-highlight-color:transparent;cursor:var(--acuhj7u-2);-webkit-transition:-webkit-transform .125s ease;-webkit-transition:transform .125s ease;transition:transform .125s ease}.acuhj7u .l1rbotc6{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.acuhj7u:active{-webkit-transform:scale(var(--acuhj7u-3));-ms-transform:scale(var(--acuhj7u-3));transform:scale(var(--acuhj7u-3))}.a143ijem{-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1}.wv1c1ab{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;padding:10px 20px;border-top:1px solid rgb(var(--wv1c1ab-0));-webkit-transition:border-color .23s ease-in-out;transition:border-color .23s ease-in-out}.s9sva{color:currentColor;font-size:1em;width:1em;height:1em;-webkit-animation:rotate-s9sva .9s linear infinite;animation:rotate-s9sva .9s linear infinite}@-webkit-keyframes rotate-s9sva{0%{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes rotate-s9sva{0%{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg)}}.h1mmuqym{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;padding:20px}.c86k5gq{position:relative;width:1.4rem;height:1.4rem;border-radius:100%;background-color:rgb(var(--c86k5gq-0));cursor:pointer;-webkit-tap-highlight-color:transparent;-webkit-transition:opacity .23s ease-in-out,-webkit-transform .125s ease,background-color .23s ease-in-out;-webkit-transition:opacity .23s ease-in-out,transform .125s ease,background-color .23s ease-in-out;transition:opacity .23s ease-in-out,transform .125s ease,background-color .23s ease-in-out}.c86k5gq:hover{-webkit-transform:scale(1.14);-ms-transform:scale(1.14);transform:scale(1.14)}.c86k5gq:active{-webkit-transform:scale(.92);-ms-transform:scale(.92);transform:scale(.92)}.c86k5gq svg{font-size:1.1rem;width:1em;height:1em;position:absolute;top:50%;left:50%;color:rgb(var(--c86k5gq-1));-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.a1osnke6{position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;gap:1.1rem;padding-bottom:1.2rem;max-height:280px;overflow-y:auto}.c15u83h7{position:relative;height:280px}.w5r445t{position:absolute;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;top:45%;left:50%;width:70%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.w5r445t .acuhj7u{margin-bottom:.65rem}.w5r445t .t1sgzzc0{text-align:center;font-weight:700;margin-bottom:.1rem;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}.w5r445t .p1jty3xq{text-align:center}.w5r445t .b1cb9caz{margin-top:1rem}.bukrfi8{background-color:#fb552b33;color:#fb542b;padding:.44rem;border-radius:var(--bukrfi8-0);margin-top:.6rem}.c13sms3{display:block;margin:0 auto;margin-top:1rem;color:rgb(var(--c13sms3-0));width:1.25rem;height:1.25rem}.b1r2gdr0{font-size:1em;width:1em;height:1em;cursor:pointer;color:#007aff;-webkit-transform:scale(1.75);-ms-transform:scale(1.75);transform:scale(1.75);-webkit-tap-highlight-color:transparent;-webkit-transition:-webkit-transform .125s ease;-webkit-transition:transform .125s ease;transition:transform .125s ease}.b1r2gdr0:hover{-webkit-transform:scale(1.9);-ms-transform:scale(1.9);transform:scale(1.9)}.b1r2gdr0:active{-webkit-transform:scale(1.5);-ms-transform:scale(1.5);transform:scale(1.5)}.p1hjgol5{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:0 20px 20px}.p1hjgol5 .t1sgzzc0,.p1hjgol5 .p1jty3xq{text-align:center}.p1hjgol5 .t1sgzzc0 svg,.p1hjgol5 .p1jty3xq svg{font-size:.85em;width:1em;height:1em;cursor:pointer;-webkit-tap-highlight-color:transparent;-webkit-transition:all .125s ease-in-out;transition:all .125s ease-in-out}.p1hjgol5 .t1sgzzc0 svg:hover,.p1hjgol5 .p1jty3xq svg:hover{opacity:.85}.p1hjgol5 .t1sgzzc0 svg:active,.p1hjgol5 .p1jty3xq svg:active{-webkit-transform:scale(.9);-ms-transform:scale(.9);transform:scale(.9)}.p1hjgol5 .b1cb9caz{margin-top:1.5rem;width:100%;padding:.9rem 0;border-radius:var(--p1hjgol5-0);text-transform:none}.publs4f{position:relative;width:80px;height:80px;border-radius:var(--publs4f-0);margin-bottom:.475rem;background-color:rgb(var(--publs4f-1));background-size:cover;z-index:1;-webkit-var(--publs4f-2);-moz-var(--publs4f-2);-ms-var(--publs4f-2);var(--publs4f-2)}.alzinag{position:absolute;bottom:0;right:0;width:1.45rem;height:1.45rem;border-radius:100%;background-color:rgb(var(--alzinag-0));border:2px solid rgb(var(--alzinag-1))}.alzinag img{position:absolute;top:50%;left:50%;object-fit:contain;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:74%;height:74%;border-radius:100%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.p1qewrlg{position:absolute;font-size:45px;width:1em;height:1em;top:50%;left:50%;color:#fff;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}")), document.head.appendChild(e2);
    }
  } catch (t2) {
    console.error("vite-plugin-css-injected-by-js", t2);
  }
})();
var Sf = Object.defineProperty;
var Pf = (t2, e2, r2) => e2 in t2 ? Sf(t2, e2, { enumerable: true, configurable: true, writable: true, value: r2 }) : t2[e2] = r2;
var pe = (t2, e2, r2) => (Pf(t2, typeof e2 != "symbol" ? e2 + "" : e2, r2), r2);
var Li = (t2, e2, r2) => {
  if (!e2.has(t2))
    throw TypeError("Cannot " + r2);
};
var pt2 = (t2, e2, r2) => (Li(t2, e2, "read from private field"), r2 ? r2.call(t2) : e2.get(t2));
var Sr = (t2, e2, r2) => {
  if (e2.has(t2))
    throw TypeError("Cannot add the same private member more than once");
  e2 instanceof WeakSet ? e2.add(t2) : e2.set(t2, r2);
};
var Un = (t2, e2, r2, n2) => (Li(t2, e2, "write to private field"), n2 ? n2.call(t2, r2) : e2.set(t2, r2), r2);
var mt = (t2, e2, r2) => (Li(t2, e2, "access private method"), r2);
function Nf(t2, e2) {
  var r2 = {};
  for (var n2 in t2)
    Object.prototype.hasOwnProperty.call(t2, n2) && e2.indexOf(n2) < 0 && (r2[n2] = t2[n2]);
  if (t2 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i2 = 0, n2 = Object.getOwnPropertySymbols(t2); i2 < n2.length; i2++)
      e2.indexOf(n2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(t2, n2[i2]) && (r2[n2[i2]] = t2[n2[i2]]);
  return r2;
}
function Mt(t2, e2, r2, n2) {
  function i2(o2) {
    return o2 instanceof r2 ? o2 : new r2(function(s2) {
      s2(o2);
    });
  }
  return new (r2 || (r2 = Promise))(function(o2, s2) {
    function a2(d2) {
      try {
        p2(n2.next(d2));
      } catch (y2) {
        s2(y2);
      }
    }
    function f2(d2) {
      try {
        p2(n2.throw(d2));
      } catch (y2) {
        s2(y2);
      }
    }
    function p2(d2) {
      d2.done ? o2(d2.value) : i2(d2.value).then(a2, f2);
    }
    p2((n2 = n2.apply(t2, e2 || [])).next());
  });
}
var Zu = () => {
  for (var t2 = [], e2 = [], r2 = typeof Uint8Array < "u" ? Uint8Array : Array, n2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i2 = 0, o2 = n2.length; i2 < o2; ++i2)
    t2[i2] = n2[i2], e2[n2.charCodeAt(i2)] = i2;
  e2["-".charCodeAt(0)] = 62, e2["_".charCodeAt(0)] = 63;
  function s2(v3) {
    var w3 = v3.length;
    if (w3 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var I3 = v3.indexOf("=");
    I3 === -1 && (I3 = w3);
    var N11 = I3 === w3 ? 0 : 4 - I3 % 4;
    return [I3, N11];
  }
  function a2(v3, w3, I3) {
    return (w3 + I3) * 3 / 4 - I3;
  }
  function f2(v3) {
    var w3, I3 = s2(v3), N11 = I3[0], k2 = I3[1], M3 = new r2(a2(v3, N11, k2)), S2 = 0, Y2 = k2 > 0 ? N11 - 4 : N11, W2;
    for (W2 = 0; W2 < Y2; W2 += 4)
      w3 = e2[v3.charCodeAt(W2)] << 18 | e2[v3.charCodeAt(W2 + 1)] << 12 | e2[v3.charCodeAt(W2 + 2)] << 6 | e2[v3.charCodeAt(W2 + 3)], M3[S2++] = w3 >> 16 & 255, M3[S2++] = w3 >> 8 & 255, M3[S2++] = w3 & 255;
    return k2 === 2 && (w3 = e2[v3.charCodeAt(W2)] << 2 | e2[v3.charCodeAt(W2 + 1)] >> 4, M3[S2++] = w3 & 255), k2 === 1 && (w3 = e2[v3.charCodeAt(W2)] << 10 | e2[v3.charCodeAt(W2 + 1)] << 4 | e2[v3.charCodeAt(W2 + 2)] >> 2, M3[S2++] = w3 >> 8 & 255, M3[S2++] = w3 & 255), M3;
  }
  function p2(v3) {
    return t2[v3 >> 18 & 63] + t2[v3 >> 12 & 63] + t2[v3 >> 6 & 63] + t2[v3 & 63];
  }
  function d2(v3, w3, I3) {
    for (var N11, k2 = [], M3 = w3; M3 < I3; M3 += 3)
      N11 = (v3[M3] << 16 & 16711680) + (v3[M3 + 1] << 8 & 65280) + (v3[M3 + 2] & 255), k2.push(p2(N11));
    return k2.join("");
  }
  function y2(v3) {
    for (var w3, I3 = v3.length, N11 = I3 % 3, k2 = [], M3 = 16383, S2 = 0, Y2 = I3 - N11; S2 < Y2; S2 += M3)
      k2.push(d2(v3, S2, S2 + M3 > Y2 ? Y2 : S2 + M3));
    return N11 === 1 ? (w3 = v3[I3 - 1], k2.push(t2[w3 >> 2] + t2[w3 << 4 & 63] + "==")) : N11 === 2 && (w3 = (v3[I3 - 2] << 8) + v3[I3 - 1], k2.push(t2[w3 >> 10] + t2[w3 >> 4 & 63] + t2[w3 << 2 & 63] + "=")), k2.join("");
  }
  return { toByteArray: f2, fromByteArray: y2 };
};
function Uf(t2) {
  let e2 = Qu(t2);
  return new TextDecoder("utf-8", { fatal: true }).decode(e2);
}
function Ff(t2) {
  return new TextDecoder("utf-8", { fatal: true }).decode(t2);
}
function Ju(t2) {
  return new TextEncoder().encode(t2);
}
function jf(t2) {
  return tc(Ju(t2));
}
function Qu(t2) {
  return new Uint8Array(Zu().toByteArray(nc(t2)));
}
function ec(t2) {
  return Zu().fromByteArray(new Uint8Array(t2));
}
function tc(t2) {
  return rc(ec(t2));
}
function rc(t2) {
  return t2.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function nc(t2) {
  t2 = t2.replace(/\-/g, "+").replace(/\_/g, "/");
  let e2;
  return t2.length % 4 == 0 ? e2 = 0 : e2 = 4 - t2.length % 4, t2.concat("=".repeat(e2));
}
var ln = {
  b64UrlToString: Uf,
  bufferToString: Ff,
  stringToBuffer: Ju,
  stringToB64Url: jf,
  b64UrlToBuffer: Qu,
  bufferTob64: ec,
  bufferTob64Url: tc,
  b64UrlEncode: rc,
  b64UrlDecode: nc
};
var $f = class {
  get(e2, r2) {
    if (!Object.getOwnPropertyNames(this).includes(e2))
      throw new Error(`Field "${e2}" is not a property of the Arweave Transaction class.`);
    return this[e2] instanceof Uint8Array ? r2 && r2.decode && r2.string ? ln.bufferToString(this[e2]) : r2 && r2.decode && !r2.string ? this[e2] : ln.bufferTob64Url(this[e2]) : r2 && r2.decode == true ? r2 && r2.string ? ln.b64UrlToString(this[e2]) : ln.b64UrlToBuffer(this[e2]) : this[e2];
  }
};
var Vf = class extends $f {
  constructor(e2, r2, n2 = false) {
    super(), this.name = e2, this.value = r2;
  }
};
var Qs = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var ea = {};
var ta;
function ic() {
  if (ta)
    return ea;
  ta = 1;
  var t2;
  return function(e2) {
    (function(r2) {
      var n2 = typeof Qs == "object" ? Qs : typeof self == "object" ? self : typeof this == "object" ? this : Function("return this;")(), i2 = o2(e2);
      typeof n2.Reflect > "u" ? n2.Reflect = e2 : i2 = o2(n2.Reflect, i2), r2(i2);
      function o2(s2, a2) {
        return function(f2, p2) {
          typeof s2[f2] != "function" && Object.defineProperty(s2, f2, { configurable: true, writable: true, value: p2 }), a2 && a2(f2, p2);
        };
      }
    })(function(r2) {
      var n2 = Object.prototype.hasOwnProperty, i2 = typeof Symbol == "function", o2 = i2 && typeof Symbol.toPrimitive < "u" ? Symbol.toPrimitive : "@@toPrimitive", s2 = i2 && typeof Symbol.iterator < "u" ? Symbol.iterator : "@@iterator", a2 = typeof Object.create == "function", f2 = { __proto__: [] } instanceof Array, p2 = !a2 && !f2, d2 = {
        // create an object in dictionary mode (a.k.a. "slow" mode in v8)
        create: a2 ? function() {
          return Ae(/* @__PURE__ */ Object.create(null));
        } : f2 ? function() {
          return Ae({ __proto__: null });
        } : function() {
          return Ae({});
        },
        has: p2 ? function(U2, te2) {
          return n2.call(U2, te2);
        } : function(U2, te2) {
          return te2 in U2;
        },
        get: p2 ? function(U2, te2) {
          return n2.call(U2, te2) ? U2[te2] : void 0;
        } : function(U2, te2) {
          return U2[te2];
        }
      }, y2 = Object.getPrototypeOf(Function), v3 = typeof process == "object" && process.env && process.env.REFLECT_METADATA_USE_MAP_POLYFILL === "true", w3 = !v3 && typeof Map == "function" && typeof Map.prototype.entries == "function" ? Map : oe2(), I3 = !v3 && typeof Set == "function" && typeof Set.prototype.entries == "function" ? Set : de(), N11 = !v3 && typeof WeakMap == "function" ? WeakMap : Ee(), k2 = new N11();
      function M3(U2, te2, g2, u2) {
        if (re(g2)) {
          if (!R2(U2))
            throw new TypeError();
          if (!V2(te2))
            throw new TypeError();
          return O2(U2, te2);
        } else {
          if (!R2(U2))
            throw new TypeError();
          if (!ce(te2))
            throw new TypeError();
          if (!ce(u2) && !re(u2) && !ae(u2))
            throw new TypeError();
          return ae(u2) && (u2 = void 0), g2 = b2(g2), c2(U2, te2, g2, u2);
        }
      }
      r2("decorate", M3);
      function S2(U2, te2) {
        function g2(u2, h2) {
          if (!ce(u2))
            throw new TypeError();
          if (!re(h2) && !K2(h2))
            throw new TypeError();
          H2(U2, te2, u2, h2);
        }
        return g2;
      }
      r2("metadata", S2);
      function Y2(U2, te2, g2, u2) {
        if (!ce(g2))
          throw new TypeError();
        return re(u2) || (u2 = b2(u2)), H2(U2, te2, g2, u2);
      }
      r2("defineMetadata", Y2);
      function W2(U2, te2, g2) {
        if (!ce(te2))
          throw new TypeError();
        return re(g2) || (g2 = b2(g2)), _3(U2, te2, g2);
      }
      r2("hasMetadata", W2);
      function Q3(U2, te2, g2) {
        if (!ce(te2))
          throw new TypeError();
        return re(g2) || (g2 = b2(g2)), T3(U2, te2, g2);
      }
      r2("hasOwnMetadata", Q3);
      function X3(U2, te2, g2) {
        if (!ce(te2))
          throw new TypeError();
        return re(g2) || (g2 = b2(g2)), C3(U2, te2, g2);
      }
      r2("getMetadata", X3);
      function ne(U2, te2, g2) {
        if (!ce(te2))
          throw new TypeError();
        return re(g2) || (g2 = b2(g2)), L2(U2, te2, g2);
      }
      r2("getOwnMetadata", ne);
      function ue(U2, te2) {
        if (!ce(U2))
          throw new TypeError();
        return re(te2) || (te2 = b2(te2)), P3(U2, te2);
      }
      r2("getMetadataKeys", ue);
      function se(U2, te2) {
        if (!ce(U2))
          throw new TypeError();
        return re(te2) || (te2 = b2(te2)), l2(U2, te2);
      }
      r2("getOwnMetadataKeys", se);
      function ie(U2, te2, g2) {
        if (!ce(te2))
          throw new TypeError();
        re(g2) || (g2 = b2(g2));
        var u2 = m2(
          te2,
          g2,
          /*Create*/
          false
        );
        if (re(u2) || !u2.delete(U2))
          return false;
        if (u2.size > 0)
          return true;
        var h2 = k2.get(te2);
        return h2.delete(g2), h2.size > 0 || k2.delete(te2), true;
      }
      r2("deleteMetadata", ie);
      function O2(U2, te2) {
        for (var g2 = U2.length - 1; g2 >= 0; --g2) {
          var u2 = U2[g2], h2 = u2(te2);
          if (!re(h2) && !ae(h2)) {
            if (!V2(h2))
              throw new TypeError();
            te2 = h2;
          }
        }
        return te2;
      }
      function c2(U2, te2, g2, u2) {
        for (var h2 = U2.length - 1; h2 >= 0; --h2) {
          var A2 = U2[h2], B3 = A2(te2, g2, u2);
          if (!re(B3) && !ae(B3)) {
            if (!ce(B3))
              throw new TypeError();
            u2 = B3;
          }
        }
        return u2;
      }
      function m2(U2, te2, g2) {
        var u2 = k2.get(U2);
        if (re(u2)) {
          if (!g2)
            return;
          u2 = new w3(), k2.set(U2, u2);
        }
        var h2 = u2.get(te2);
        if (re(h2)) {
          if (!g2)
            return;
          h2 = new w3(), u2.set(te2, h2);
        }
        return h2;
      }
      function _3(U2, te2, g2) {
        var u2 = T3(U2, te2, g2);
        if (u2)
          return true;
        var h2 = ee2(te2);
        return ae(h2) ? false : _3(U2, h2, g2);
      }
      function T3(U2, te2, g2) {
        var u2 = m2(
          te2,
          g2,
          /*Create*/
          false
        );
        return re(u2) ? false : xe(u2.has(U2));
      }
      function C3(U2, te2, g2) {
        var u2 = T3(U2, te2, g2);
        if (u2)
          return L2(U2, te2, g2);
        var h2 = ee2(te2);
        if (!ae(h2))
          return C3(U2, h2, g2);
      }
      function L2(U2, te2, g2) {
        var u2 = m2(
          te2,
          g2,
          /*Create*/
          false
        );
        if (!re(u2))
          return u2.get(U2);
      }
      function H2(U2, te2, g2, u2) {
        var h2 = m2(
          g2,
          u2,
          /*Create*/
          true
        );
        h2.set(U2, te2);
      }
      function P3(U2, te2) {
        var g2 = l2(U2, te2), u2 = ee2(U2);
        if (u2 === null)
          return g2;
        var h2 = P3(u2, te2);
        if (h2.length <= 0)
          return g2;
        if (g2.length <= 0)
          return h2;
        for (var A2 = new I3(), B3 = [], z3 = 0, F2 = g2; z3 < F2.length; z3++) {
          var fe = F2[z3], we = A2.has(fe);
          we || (A2.add(fe), B3.push(fe));
        }
        for (var _e = 0, be = h2; _e < be.length; _e++) {
          var fe = be[_e], we = A2.has(fe);
          we || (A2.add(fe), B3.push(fe));
        }
        return B3;
      }
      function l2(U2, te2) {
        var g2 = [], u2 = m2(
          U2,
          te2,
          /*Create*/
          false
        );
        if (re(u2))
          return g2;
        for (var h2 = u2.keys(), A2 = J2(h2), B3 = 0; ; ) {
          var z3 = q2(A2);
          if (!z3)
            return g2.length = B3, g2;
          var F2 = j2(z3);
          try {
            g2[B3] = F2;
          } catch (fe) {
            try {
              Z3(A2);
            } finally {
              throw fe;
            }
          }
          B3++;
        }
      }
      function x3(U2) {
        if (U2 === null)
          return 1;
        switch (typeof U2) {
          case "undefined":
            return 0;
          case "boolean":
            return 2;
          case "string":
            return 3;
          case "symbol":
            return 4;
          case "number":
            return 5;
          case "object":
            return U2 === null ? 1 : 6;
          default:
            return 6;
        }
      }
      function re(U2) {
        return U2 === void 0;
      }
      function ae(U2) {
        return U2 === null;
      }
      function G2(U2) {
        return typeof U2 == "symbol";
      }
      function ce(U2) {
        return typeof U2 == "object" ? U2 !== null : typeof U2 == "function";
      }
      function me(U2, te2) {
        switch (x3(U2)) {
          case 0:
            return U2;
          case 1:
            return U2;
          case 2:
            return U2;
          case 3:
            return U2;
          case 4:
            return U2;
          case 5:
            return U2;
        }
        var g2 = te2 === 3 ? "string" : te2 === 5 ? "number" : "default", u2 = $3(U2, o2);
        if (u2 !== void 0) {
          var h2 = u2.call(U2, g2);
          if (ce(h2))
            throw new TypeError();
          return h2;
        }
        return ye(U2, g2 === "default" ? "number" : g2);
      }
      function ye(U2, te2) {
        if (te2 === "string") {
          var g2 = U2.toString;
          if (E3(g2)) {
            var u2 = g2.call(U2);
            if (!ce(u2))
              return u2;
          }
          var h2 = U2.valueOf;
          if (E3(h2)) {
            var u2 = h2.call(U2);
            if (!ce(u2))
              return u2;
          }
        } else {
          var h2 = U2.valueOf;
          if (E3(h2)) {
            var u2 = h2.call(U2);
            if (!ce(u2))
              return u2;
          }
          var A2 = U2.toString;
          if (E3(A2)) {
            var u2 = A2.call(U2);
            if (!ce(u2))
              return u2;
          }
        }
        throw new TypeError();
      }
      function xe(U2) {
        return !!U2;
      }
      function ve(U2) {
        return "" + U2;
      }
      function b2(U2) {
        var te2 = me(
          U2,
          3
          /* String */
        );
        return G2(te2) ? te2 : ve(te2);
      }
      function R2(U2) {
        return Array.isArray ? Array.isArray(U2) : U2 instanceof Object ? U2 instanceof Array : Object.prototype.toString.call(U2) === "[object Array]";
      }
      function E3(U2) {
        return typeof U2 == "function";
      }
      function V2(U2) {
        return typeof U2 == "function";
      }
      function K2(U2) {
        switch (x3(U2)) {
          case 3:
            return true;
          case 4:
            return true;
          default:
            return false;
        }
      }
      function $3(U2, te2) {
        var g2 = U2[te2];
        if (g2 != null) {
          if (!E3(g2))
            throw new TypeError();
          return g2;
        }
      }
      function J2(U2) {
        var te2 = $3(U2, s2);
        if (!E3(te2))
          throw new TypeError();
        var g2 = te2.call(U2);
        if (!ce(g2))
          throw new TypeError();
        return g2;
      }
      function j2(U2) {
        return U2.value;
      }
      function q2(U2) {
        var te2 = U2.next();
        return te2.done ? false : te2;
      }
      function Z3(U2) {
        var te2 = U2.return;
        te2 && te2.call(U2);
      }
      function ee2(U2) {
        var te2 = Object.getPrototypeOf(U2);
        if (typeof U2 != "function" || U2 === y2 || te2 !== y2)
          return te2;
        var g2 = U2.prototype, u2 = g2 && Object.getPrototypeOf(g2);
        if (u2 == null || u2 === Object.prototype)
          return te2;
        var h2 = u2.constructor;
        return typeof h2 != "function" || h2 === U2 ? te2 : h2;
      }
      function oe2() {
        var U2 = {}, te2 = [], g2 = (
          /** @class */
          function() {
            function B3(z3, F2, fe) {
              this._index = 0, this._keys = z3, this._values = F2, this._selector = fe;
            }
            return B3.prototype["@@iterator"] = function() {
              return this;
            }, B3.prototype[s2] = function() {
              return this;
            }, B3.prototype.next = function() {
              var z3 = this._index;
              if (z3 >= 0 && z3 < this._keys.length) {
                var F2 = this._selector(this._keys[z3], this._values[z3]);
                return z3 + 1 >= this._keys.length ? (this._index = -1, this._keys = te2, this._values = te2) : this._index++, { value: F2, done: false };
              }
              return { value: void 0, done: true };
            }, B3.prototype.throw = function(z3) {
              throw this._index >= 0 && (this._index = -1, this._keys = te2, this._values = te2), z3;
            }, B3.prototype.return = function(z3) {
              return this._index >= 0 && (this._index = -1, this._keys = te2, this._values = te2), { value: z3, done: true };
            }, B3;
          }()
        );
        return (
          /** @class */
          function() {
            function B3() {
              this._keys = [], this._values = [], this._cacheKey = U2, this._cacheIndex = -2;
            }
            return Object.defineProperty(B3.prototype, "size", {
              get: function() {
                return this._keys.length;
              },
              enumerable: true,
              configurable: true
            }), B3.prototype.has = function(z3) {
              return this._find(
                z3,
                /*insert*/
                false
              ) >= 0;
            }, B3.prototype.get = function(z3) {
              var F2 = this._find(
                z3,
                /*insert*/
                false
              );
              return F2 >= 0 ? this._values[F2] : void 0;
            }, B3.prototype.set = function(z3, F2) {
              var fe = this._find(
                z3,
                /*insert*/
                true
              );
              return this._values[fe] = F2, this;
            }, B3.prototype.delete = function(z3) {
              var F2 = this._find(
                z3,
                /*insert*/
                false
              );
              if (F2 >= 0) {
                for (var fe = this._keys.length, we = F2 + 1; we < fe; we++)
                  this._keys[we - 1] = this._keys[we], this._values[we - 1] = this._values[we];
                return this._keys.length--, this._values.length--, z3 === this._cacheKey && (this._cacheKey = U2, this._cacheIndex = -2), true;
              }
              return false;
            }, B3.prototype.clear = function() {
              this._keys.length = 0, this._values.length = 0, this._cacheKey = U2, this._cacheIndex = -2;
            }, B3.prototype.keys = function() {
              return new g2(this._keys, this._values, u2);
            }, B3.prototype.values = function() {
              return new g2(this._keys, this._values, h2);
            }, B3.prototype.entries = function() {
              return new g2(this._keys, this._values, A2);
            }, B3.prototype["@@iterator"] = function() {
              return this.entries();
            }, B3.prototype[s2] = function() {
              return this.entries();
            }, B3.prototype._find = function(z3, F2) {
              return this._cacheKey !== z3 && (this._cacheIndex = this._keys.indexOf(this._cacheKey = z3)), this._cacheIndex < 0 && F2 && (this._cacheIndex = this._keys.length, this._keys.push(z3), this._values.push(void 0)), this._cacheIndex;
            }, B3;
          }()
        );
        function u2(B3, z3) {
          return B3;
        }
        function h2(B3, z3) {
          return z3;
        }
        function A2(B3, z3) {
          return [B3, z3];
        }
      }
      function de() {
        return (
          /** @class */
          function() {
            function U2() {
              this._map = new w3();
            }
            return Object.defineProperty(U2.prototype, "size", {
              get: function() {
                return this._map.size;
              },
              enumerable: true,
              configurable: true
            }), U2.prototype.has = function(te2) {
              return this._map.has(te2);
            }, U2.prototype.add = function(te2) {
              return this._map.set(te2, te2), this;
            }, U2.prototype.delete = function(te2) {
              return this._map.delete(te2);
            }, U2.prototype.clear = function() {
              this._map.clear();
            }, U2.prototype.keys = function() {
              return this._map.keys();
            }, U2.prototype.values = function() {
              return this._map.values();
            }, U2.prototype.entries = function() {
              return this._map.entries();
            }, U2.prototype["@@iterator"] = function() {
              return this.keys();
            }, U2.prototype[s2] = function() {
              return this.keys();
            }, U2;
          }()
        );
      }
      function Ee() {
        var U2 = 16, te2 = d2.create(), g2 = u2();
        return (
          /** @class */
          function() {
            function F2() {
              this._key = u2();
            }
            return F2.prototype.has = function(fe) {
              var we = h2(
                fe,
                /*create*/
                false
              );
              return we !== void 0 ? d2.has(we, this._key) : false;
            }, F2.prototype.get = function(fe) {
              var we = h2(
                fe,
                /*create*/
                false
              );
              return we !== void 0 ? d2.get(we, this._key) : void 0;
            }, F2.prototype.set = function(fe, we) {
              var _e = h2(
                fe,
                /*create*/
                true
              );
              return _e[this._key] = we, this;
            }, F2.prototype.delete = function(fe) {
              var we = h2(
                fe,
                /*create*/
                false
              );
              return we !== void 0 ? delete we[this._key] : false;
            }, F2.prototype.clear = function() {
              this._key = u2();
            }, F2;
          }()
        );
        function u2() {
          var F2;
          do
            F2 = "@@WeakMap@@" + z3();
          while (d2.has(te2, F2));
          return te2[F2] = true, F2;
        }
        function h2(F2, fe) {
          if (!n2.call(F2, g2)) {
            if (!fe)
              return;
            Object.defineProperty(F2, g2, { value: d2.create() });
          }
          return F2[g2];
        }
        function A2(F2, fe) {
          for (var we = 0; we < fe; ++we)
            F2[we] = Math.random() * 255 | 0;
          return F2;
        }
        function B3(F2) {
          return typeof Uint8Array == "function" ? typeof crypto < "u" ? crypto.getRandomValues(new Uint8Array(F2)) : typeof msCrypto < "u" ? msCrypto.getRandomValues(new Uint8Array(F2)) : A2(new Uint8Array(F2), F2) : A2(new Array(F2), F2);
        }
        function z3() {
          var F2 = B3(U2);
          F2[6] = F2[6] & 79 | 64, F2[8] = F2[8] & 191 | 128;
          for (var fe = "", we = 0; we < U2; ++we) {
            var _e = F2[we];
            (we === 4 || we === 6 || we === 8) && (fe += "-"), _e < 16 && (fe += "0"), fe += _e.toString(16).toLowerCase();
          }
          return fe;
        }
      }
      function Ae(U2) {
        return U2.__ = void 0, delete U2.__, U2;
      }
    });
  }(t2 || (t2 = {})), ea;
}
var Mn;
function hi(t2) {
  if (typeof t2 != "function")
    throw new Error("This module should not be used in runtime. Instead, use a transformer during compilation.");
}
var ao = Symbol("assertions");
function qf(t2, e2) {
  let r2 = e2;
  for (const n2 of t2.slice(1))
    r2 = r2[n2.startsWith("[") ? parseInt(n2.replace("[", "").replace("]", "")) : n2];
  return r2;
}
function Wf(t2, e2, r2) {
  if (t2 === void 0)
    return "validation error";
  const n2 = qf(e2, r2);
  try {
    return t2 + ", found: " + require_util4().inspect(n2);
  } catch {
  }
  try {
    return t2 + ", found: " + JSON.stringify(n2);
  } catch {
  }
  return t2;
}
var $o = class extends Error {
  constructor(e2, r2) {
    super(Wf(e2.message, e2.path, r2)), this.name = "TypeGuardError", this.path = e2.path, this.reason = e2.reason, this.input = r2;
  }
};
function Hf(t2, e2 = {}) {
  return ic(), function(r2, n2, i2) {
    const o2 = Reflect.getOwnMetadata(ao, r2, n2) || [];
    Reflect.getOwnMetadata("design:returntype", r2, n2) === Promise ? o2[i2] = { assertion: t2, options: Object.assign({ async: true }, e2) } : o2[i2] = { assertion: t2, options: e2 }, Reflect.defineMetadata(ao, o2, r2, n2);
  };
}
function Kf(t2 = $o) {
  return ic(), function(e2) {
    for (const r2 of Object.getOwnPropertyNames(e2.prototype)) {
      const n2 = Reflect.getOwnMetadata(ao, e2.prototype, r2);
      if (n2) {
        const i2 = e2.prototype[r2];
        e2.prototype[r2] = function(...o2) {
          for (let s2 = 0; s2 < n2.length; s2++) {
            if (!n2[s2])
              continue;
            const a2 = n2[s2].assertion(o2[s2]);
            if (a2 !== null) {
              const f2 = new t2(a2, o2[s2]);
              if (n2[s2].options.async)
                return Promise.reject(f2);
              throw f2;
            }
          }
          return i2.apply(this, o2);
        };
      }
    }
  };
}
function uo(t2, e2 = Mn) {
  return hi(e2), e2(t2) === null;
}
function co(t2, e2 = Mn) {
  hi(e2);
  const r2 = e2(t2);
  if (r2 === null)
    return t2;
  throw new $o(r2, t2);
}
function ra(t2 = Mn) {
  return hi(t2), (e2) => uo(e2, t2);
}
function na(t2 = Mn) {
  return hi(t2), (e2) => co(e2, t2);
}
function zf(t2) {
  Mn = t2;
}
var mr2 = {
  is: uo,
  assertType: co,
  createIs: ra,
  createAssertType: na,
  equals: uo,
  createEquals: ra,
  assertEquals: co,
  createAssertEquals: na,
  AssertType: Hf,
  ValidateClass: Kf,
  TypeGuardError: $o,
  setDefaultGetErrorObject: zf
};
function Gf(t2) {
  return class extends t2 {
    constructor(...r2) {
      super(...r2), this.namespaces = {
        arweaveWallet: {
          walletName: "ArConnect",
          connect: () => this.address || this.connect(),
          disconnect: () => this.disconnect(),
          getActiveAddress: () => this.address,
          getActivePublicKey: () => this.getPublicKey(),
          getAllAddresses: () => {
            throw "not implemented";
          },
          getWalletNames: () => {
            throw "not implemented";
          },
          signature: () => {
            throw "deprecated, do not use";
          },
          sign: (n2, i2) => this.signTransaction(n2, i2),
          dispatch: (n2, i2) => this.dispatch(n2, i2),
          encrypt: (n2, i2) => Mt(this, void 0, void 0, function* () {
            const o2 = yield this.getPublicKey();
            return this.encrypt(n2, o2, i2);
          }),
          decrypt: (n2, i2) => this.decrypt(n2, i2),
          getPermissions: () => ["ACCESS_ADDRESS", "ACCESS_PUBLIC_KEY", "ACCESS_ALL_ADDRESSES", "SIGN_TRANSACTION", "ENCRYPT", "DECRYPT", "SIGNATURE", "ACCESS_ARWEAVE_CONFIG", "DISPATCH"],
          getArweaveConfig: () => this.getArweaveConfig()
        }
      };
    }
    postMessage(r2, n2, i2) {
      return super.postMessage(r2, n2, Object.assign(Object.assign({}, i2), { protocol: "arweave", version: "1.0.0" }));
    }
    getPublicKey() {
      return Mt(this, void 0, void 0, function* () {
        const r2 = yield this.postMessage("getPublicKey");
        if (!mr2.is(r2, (n2) => {
          function i2(o2) {
            return typeof o2 != "string" ? {} : null;
          }
          return i2(n2);
        }))
          throw "TypeError";
        return r2;
      });
    }
    getArweaveConfig() {
      return Mt(this, void 0, void 0, function* () {
        const r2 = yield this.postMessage("getArweaveConfig");
        if (!mr2.is(r2, (n2) => {
          function i2(M3) {
            return M3 !== void 0 ? {} : null;
          }
          function o2(M3) {
            return typeof M3 != "string" ? {} : null;
          }
          function s2(M3) {
            var S2 = [i2, o2];
            for (const W2 of S2) {
              var Y2 = W2(M3);
              if (!Y2)
                return null;
            }
            return {};
          }
          function a2(M3) {
            return typeof M3 != "number" ? {} : null;
          }
          function f2(M3) {
            var S2 = [i2, o2, a2];
            for (const W2 of S2) {
              var Y2 = W2(M3);
              if (!Y2)
                return null;
            }
            return {};
          }
          function p2(M3) {
            var S2 = [i2, a2];
            for (const W2 of S2) {
              var Y2 = W2(M3);
              if (!Y2)
                return null;
            }
            return {};
          }
          function d2(M3) {
            return M3 !== false ? {} : null;
          }
          function y2(M3) {
            return M3 !== true ? {} : null;
          }
          function v3(M3) {
            var S2 = [i2, d2, y2];
            for (const W2 of S2) {
              var Y2 = W2(M3);
              if (!Y2)
                return null;
            }
            return {};
          }
          function w3(M3) {
            if (typeof M3 != "object" || M3 === null || Array.isArray(M3))
              return {};
            if ("host" in M3) {
              var S2 = s2(M3.host);
              if (S2)
                return S2;
            }
            if ("protocol" in M3) {
              var S2 = s2(M3.protocol);
              if (S2)
                return S2;
            }
            if ("port" in M3) {
              var S2 = f2(M3.port);
              if (S2)
                return S2;
            }
            if ("timeout" in M3) {
              var S2 = p2(M3.timeout);
              if (S2)
                return S2;
            }
            if ("logging" in M3) {
              var S2 = v3(M3.logging);
              if (S2)
                return S2;
            }
            if ("network" in M3) {
              var S2 = s2(M3.network);
              if (S2)
                return S2;
            }
            return null;
          }
          function I3() {
            return null;
          }
          function N11(M3) {
            if (typeof M3 != "object" || M3 === null || Array.isArray(M3))
              return {};
            if ("logger" in M3) {
              var S2 = I3(M3.logger);
              if (S2)
                return S2;
            }
            return null;
          }
          function k2(M3) {
            var S2 = [w3, N11];
            for (const W2 of S2) {
              var Y2 = W2(M3);
              if (Y2)
                return Y2;
            }
            return null;
          }
          return k2(n2);
        }))
          throw "TypeError";
        return delete r2.logger, r2;
      });
    }
    signTransaction(r2, n2) {
      var i2;
      return Mt(this, void 0, void 0, function* () {
        const o2 = Nf(r2, ["data", "chunks"]), s2 = yield this.postMessage("signTransaction", [o2, n2]);
        if (!mr2.is(s2, (a2) => {
          function f2(k2) {
            return typeof k2 != "string" ? {} : null;
          }
          function p2(k2) {
            return k2 !== void 0 ? {} : null;
          }
          function d2(k2) {
            return k2 !== null ? {} : null;
          }
          function y2(k2) {
            var M3 = [p2, d2, f2];
            for (const Y2 of M3) {
              var S2 = Y2(k2);
              if (!S2)
                return null;
            }
            return {};
          }
          function v3(k2) {
            if (typeof k2 != "object" || k2 === null || Array.isArray(k2))
              return {};
            if ("name" in k2) {
              var M3 = f2(k2.name);
              if (M3)
                return M3;
            } else
              return {};
            if ("value" in k2) {
              var M3 = f2(k2.value);
              if (M3)
                return M3;
            } else
              return {};
            return null;
          }
          function w3(k2) {
            if (!Array.isArray(k2))
              return {};
            for (let S2 = 0; S2 < k2.length; S2++) {
              var M3 = v3(k2[S2]);
              if (M3)
                return M3;
            }
            return null;
          }
          function I3(k2) {
            var M3 = [p2, d2, w3];
            for (const Y2 of M3) {
              var S2 = Y2(k2);
              if (!S2)
                return null;
            }
            return {};
          }
          function N11(k2) {
            if (typeof k2 != "object" || k2 === null || Array.isArray(k2))
              return {};
            if ("id" in k2) {
              var M3 = f2(k2.id);
              if (M3)
                return M3;
            } else
              return {};
            if ("owner" in k2) {
              var M3 = y2(k2.owner);
              if (M3)
                return M3;
            }
            if ("tags" in k2) {
              var M3 = I3(k2.tags);
              if (M3)
                return M3;
            }
            if ("signature" in k2) {
              var M3 = f2(k2.signature);
              if (M3)
                return M3;
            } else
              return {};
            if ("reward" in k2) {
              var M3 = y2(k2.reward);
              if (M3)
                return M3;
            }
            return null;
          }
          return N11(a2);
        }))
          throw "TypeError";
        return r2.setSignature({
          id: s2.id,
          owner: s2.owner || r2.owner,
          tags: (i2 = s2.tags) === null || i2 === void 0 ? void 0 : i2.map((a2) => new Vf(a2.name, a2.value, true)),
          signature: s2.signature,
          reward: s2.reward || void 0
        }), r2;
      });
    }
    signDataItem(r2) {
      return Mt(this, void 0, void 0, function* () {
        const n2 = yield this.postMessage("signDataItem", [r2]);
        if (!ArrayBuffer.isView(n2))
          throw "TypeError";
        return n2.buffer;
      });
    }
    dispatch(r2, n2) {
      return Mt(this, void 0, void 0, function* () {
        const i2 = yield this.postMessage("dispatch", [r2, n2], { transfer: true });
        if (!mr2.is(i2, (o2) => {
          function s2(y2) {
            return typeof y2 != "string" ? {} : null;
          }
          function a2(y2) {
            return y2 !== "BASE" ? {} : null;
          }
          function f2(y2) {
            return y2 !== "BUNDLED" ? {} : null;
          }
          function p2(y2) {
            var v3 = [a2, f2];
            for (const I3 of v3) {
              var w3 = I3(y2);
              if (!w3)
                return null;
            }
            return {};
          }
          function d2(y2) {
            if (typeof y2 != "object" || y2 === null || Array.isArray(y2))
              return {};
            if ("id" in y2) {
              var v3 = s2(y2.id);
              if (v3)
                return v3;
            }
            if ("type" in y2) {
              var v3 = p2(y2.type);
              if (v3)
                return v3;
            }
            return null;
          }
          return d2(o2);
        }))
          throw "TypeError";
        return i2;
      });
    }
    signMessage(r2, n2) {
      return Mt(this, void 0, void 0, function* () {
        const i2 = yield this.postMessage("signMessage", [r2, n2]);
        if (!ArrayBuffer.isView(i2))
          throw "TypeError";
        const o2 = r2.constructor;
        return new o2(i2.buffer);
      });
    }
    verifyMessage(r2, n2, i2, o2) {
      return Mt(this, void 0, void 0, function* () {
        n2 = typeof n2 == "string" ? ln.b64UrlToBuffer(n2) : n2;
        const s2 = yield this.postMessage("verifyMessage", [r2, n2, i2, o2]);
        if (!mr2.is(s2, (a2) => {
          function f2(p2) {
            return typeof p2 != "boolean" ? {} : null;
          }
          return f2(a2);
        }))
          throw "TypeError";
        return s2;
      });
    }
    encrypt(r2, n2, i2) {
      return Mt(this, void 0, void 0, function* () {
        const o2 = yield this.postMessage("encrypt", [r2, n2, i2]);
        if (!ArrayBuffer.isView(o2))
          throw "TypeError";
        const s2 = r2.constructor;
        return new s2(o2.buffer);
      });
    }
    decrypt(r2, n2) {
      return Mt(this, void 0, void 0, function* () {
        const i2 = yield this.postMessage("decrypt", [r2, n2]);
        if (!ArrayBuffer.isView(i2))
          throw "TypeError";
        const o2 = r2.constructor;
        return new o2(i2.buffer);
      });
    }
    privateHash(r2, n2) {
      return Mt(this, void 0, void 0, function* () {
        const i2 = yield this.postMessage("privateHash", [r2, n2]);
        if (!ArrayBuffer.isView(i2))
          throw "TypeError";
        const o2 = r2.constructor;
        return new o2(i2.buffer);
      });
    }
  };
}
function Yf(t2) {
  return { all: t2 = t2 || /* @__PURE__ */ new Map(), on: function(e2, r2) {
    var n2 = t2.get(e2);
    n2 ? n2.push(r2) : t2.set(e2, [r2]);
  }, off: function(e2, r2) {
    var n2 = t2.get(e2);
    n2 && (r2 ? n2.splice(n2.indexOf(r2) >>> 0, 1) : t2.set(e2, []));
  }, emit: function(e2, r2) {
    var n2 = t2.get(e2);
    n2 && n2.slice().map(function(i2) {
      i2(r2);
    }), (n2 = t2.get("*")) && n2.slice().map(function(i2) {
      i2(e2, r2);
    });
  } };
}
var oc = class {
  constructor() {
    this.mittInstance = Yf();
  }
  emit(e2, r2) {
    this.mittInstance.emit(e2, r2);
  }
  on(e2, r2) {
    this.mittInstance.on(e2, r2);
  }
  off(e2, r2) {
    this.mittInstance.off(e2, r2);
  }
  once(e2, r2) {
    return new Promise((n2) => {
      const i2 = (o2) => {
        this.off(e2, i2), n2(o2), r2 && r2(o2);
      };
      this.on(e2, i2);
    });
  }
};
var Xf = class {
  constructor() {
    this._promiseController = [];
  }
  newMessagePromise(e2, r2) {
    e2.id = this._promiseController.length;
    const n2 = new Promise((i2, o2) => this._promiseController.push({ resolve: i2, reject: o2 }));
    return r2 != null && r2.timeout && setTimeout(() => this._promiseController[e2.id].reject("timeout"), r2.timeout), n2;
  }
  processResponse(e2) {
    const { id: r2, result: n2, error: i2 } = e2;
    if (r2 != null) {
      if (typeof r2 != "number" && typeof r2 != "string" || typeof r2 == "string" && isNaN(parseInt(r2)))
        throw "error";
      if (!this._promiseController[+r2])
        throw "received result to nonexistent request";
      return i2 != null ? this._promiseController[+r2].reject(i2) : this._promiseController[+r2].resolve(n2), true;
    }
  }
};
var ia = "400";
var oa = "600";
var Zf = class extends oc {
  constructor(e2, r2, n2) {
    if (super(), this._iframe = {}, this._showIframe = false, this._popup = {}, this._usePopup = true, this._requirePopup = false, this._keepPopup = false, this._promiseController = new Xf(), this._pending = [], this.listener = (i2) => {
      var o2, s2, a2, f2, p2, d2;
      if (i2.source !== this._popup.window && i2.source !== ((o2 = this._iframe) === null || o2 === void 0 ? void 0 : o2.window) || i2.origin !== ((s2 = this._url) === null || s2 === void 0 ? void 0 : s2.origin) || typeof i2.data != "object")
        return;
      const { method: y2, params: v3, id: w3, result: I3, error: N11, session: k2 } = i2.data;
      if (console.info(`WalletConnector:${i2.source === this._popup.window ? "popup" : "iframe"}`, i2.data), w3 != null && (this._pending = this._pending.filter((S2) => S2 != w3)), this._promiseController.processResponse(i2.data) || typeof y2 != "string")
        return;
      if (y2 === "ready") {
        i2.source === this._popup.window && ((f2 = (a2 = this._popup).resolve) === null || f2 === void 0 || f2.call(a2)), i2.source === this._iframe.window && ((d2 = (p2 = this._iframe).resolve) === null || d2 === void 0 || d2.call(p2));
        return;
      }
      if (y2 === "change")
        return;
      if (y2 === "showIframe") {
        if (typeof v3 != "boolean")
          return;
        this.showIframe = v3;
      }
      if (y2 === "usePopup") {
        if (typeof v3 != "boolean")
          return;
        this.setUsePopup(v3);
      }
      if (y2 === "keepPopup") {
        if (typeof v3 != "boolean")
          return;
        this.setRequirePopup(v3);
      }
      const M3 = { method: y2, params: v3, session: k2 };
      if (!mr2.is(M3, (S2) => {
        function Y2(se) {
          return typeof se != "string" ? {} : null;
        }
        function W2() {
          return null;
        }
        function Q3(se) {
          return se !== void 0 ? {} : null;
        }
        function X3(se) {
          return typeof se != "number" ? {} : null;
        }
        function ne(se) {
          var ie = [Q3, Y2, X3];
          for (const c2 of ie) {
            var O2 = c2(se);
            if (!O2)
              return null;
          }
          return {};
        }
        function ue(se) {
          if (typeof se != "object" || se === null || Array.isArray(se))
            return {};
          if ("method" in se) {
            var ie = Y2(se.method);
            if (ie)
              return ie;
          } else
            return {};
          if ("params" in se) {
            var ie = W2(se.params);
            if (ie)
              return ie;
          } else
            return {};
          if ("session" in se) {
            var ie = ne(se.session);
            if (ie)
              return ie;
          }
          return null;
        }
        return ue(S2);
      }))
        return console.warn("dropped");
      this.emit("message", M3);
    }, this._iframeParentNode = r2 == null ? void 0 : r2.iframeParentNode, this._url = e2, typeof window < "u") {
      const i2 = {
        origin: window.location.origin,
        session: Math.random().toString().slice(2)
      };
      r2 != null && r2.name && (i2.name = r2.name), r2 != null && r2.logo && (i2.logo = r2.logo), this._url.hash = new URLSearchParams(i2).toString(), window.addEventListener("message", this.listener), n2 && this.openIframe();
    }
  }
  get url() {
    var e2;
    return (e2 = this._url) === null || e2 === void 0 ? void 0 : e2.origin;
  }
  get showIframe() {
    return this._showIframe;
  }
  set showIframe(e2) {
    e2 !== this._showIframe && (this._showIframe = e2, this.deliverMessage({ method: "showIframe", params: e2 }), this.emit("builtin", { showIframe: e2 }), this._iframeNode && (this._iframeParentNode || (this._iframeNode.style.opacity = e2 ? "1" : "0", this._iframeNode.style.pointerEvents = e2 ? "" : "none", this._iframeNode.style.touchAction = e2 ? "" : "none", this._iframeNode.style.zIndex = e2 ? "1000000" : "-1000000", this._iframeNode.style.transform = e2 ? "" : "translate(0, 24px)", this._iframeNode.style.transition = e2 ? "opacity 0.36s cubic-bezier(0.22, 1, 0.36, 1), transform 0.36s cubic-bezier(0.22, 1, 0.36, 1)" : "opacity 0.1s ease, transform 0.1s ease, z-index 0s linear 0.1s")));
  }
  get usePopup() {
    return this._usePopup;
  }
  setUsePopup(e2) {
    e2 !== this._usePopup && (this._usePopup = e2, this.emit("builtin", { usePopup: e2 }));
  }
  get requirePopup() {
    return this._requirePopup;
  }
  setRequirePopup(e2) {
    e2 !== this._requirePopup && (this._requirePopup = e2, this.emit("builtin", { requirePopup: e2 }));
  }
  get keepPopup() {
    return this._keepPopup;
  }
  set keepPopup(e2) {
    this._keepPopup = e2, this.emit("builtin", { keepPopup: e2 }), e2 || this.closePopup(), e2 && this.openPopup(true);
  }
  destructor(e2) {
    this.closeIframe(), this.closePopup(true), window.removeEventListener("message", this.listener);
  }
  postMessage(e2, r2) {
    const n2 = this._promiseController.newMessagePromise(e2, r2).finally(() => this.completeRequest());
    return this.deliverMessage(e2), n2;
  }
  openIframe() {
    var e2;
    if (this._iframeEl)
      return;
    const r2 = new Promise((i2, o2) => this._iframe = { resolve: i2, reject: o2 });
    this._iframe.promise = r2;
    const n2 = Array.from(document.querySelectorAll("iframe")).find((i2) => {
      try {
        return new URL(i2.src).origin === this.url;
      } catch {
      }
    });
    if (n2)
      this._iframeEl = n2, this._iframe.window = this._iframeEl.contentWindow, this.postMessage({ method: "ready" });
    else {
      this._iframeNode = (e2 = this._iframeParentNode) !== null && e2 !== void 0 ? e2 : document.createElement("div"), this._iframeEl = document.createElement("iframe"), this._iframeEl.src = this._url.toString(), this._iframeEl.allow = "usb; hid; bluetooth; serial; camera; payment; web-share", this._iframeEl.setAttribute("allowTransparency", "true"), this._iframeEl.style.border = "none", this._iframeParentNode ? (this._iframeEl.style.backgroundColor = "transparent", this._iframeEl.style.width = "100%", this._iframeEl.style.height = "100%") : (this._iframeEl.width = ia, this._iframeEl.height = oa, this._iframeEl.style.borderRadius = "8px", this._iframeEl.style.maxWidth = "100%", this._iframeEl.style.maxHeight = "100%", this._iframeNode.style.position = "fixed", this._iframeNode.style.inset = "0", this._iframeNode.style.display = "flex", this._iframeNode.style.alignItems = "center", this._iframeNode.style.justifyContent = "center", this._iframeNode.style.background = "#00000088", this._iframeNode.style.opacity = "0", this._iframeNode.style.pointerEvents = "none", this._iframeNode.style.touchAction = "none", this._iframeNode.style.zIndex = "-1000000", this._iframeNode.style.transform = "translate(0, 24px)", this._iframeNode.style.transition = "opacity 0.1s ease, transform 0.1s ease, z-index 0s linear 0.1s"), this._iframeNode.appendChild(this._iframeEl);
      const i2 = () => {
        var o2;
        this._iframeParentNode || document.body.appendChild(this._iframeNode), this._iframe.window = (o2 = this._iframeEl) === null || o2 === void 0 ? void 0 : o2.contentWindow;
      };
      document.readyState === "complete" || document.readyState === "interactive" ? i2() : document.addEventListener("DOMContentLoaded", i2);
    }
  }
  closeIframe() {
    var e2, r2, n2, i2, o2;
    (e2 = this._iframeEl) === null || e2 === void 0 || e2.setAttribute("src", "about:blank"), (r2 = this._iframeEl) === null || r2 === void 0 || r2.remove(), (n2 = this._iframeNode) === null || n2 === void 0 || n2.remove(), this._iframeNode = void 0, this._iframeEl = void 0, (o2 = (i2 = this._iframe).reject) === null || o2 === void 0 || o2.call(i2), this._iframe = {};
  }
  openPopup(e2) {
    if (this._popup.window && !this._popup.window.closed) {
      this._popup.window.focus();
      return;
    }
    if (!this.usePopup && !e2)
      return;
    window.name = "parent";
    const r2 = window.open(this._url.toString(), "_blank", `location,resizable,scrollbars,width=${ia},height=${oa}`), n2 = new Promise((o2, s2) => this._popup = { window: r2, resolve: o2, reject: s2 });
    this._popup.promise = n2;
    const i2 = setInterval(() => {
      this._popup.window && !this._popup.window.closed || (this.keepPopup && (this.keepPopup = false), clearInterval(i2));
    }, 200);
  }
  closePopup(e2) {
    var r2, n2, i2;
    if (!this._popup.window || !((r2 = this._popup.window) === null || r2 === void 0) && r2.closed || (this.keepPopup || this.requirePopup) && !e2)
      return;
    const o2 = this._popup.window;
    o2.close(), o2.location.href = "about:blank";
    let s2 = 0;
    const a2 = setInterval(() => {
      s2 > 50 || !o2 || o2.closed ? clearInterval(a2) : s2++, o2.close();
    }, 100);
    (i2 = (n2 = this._popup).reject) === null || i2 === void 0 || i2.call(n2), this._popup = {};
  }
  completeRequest() {
    setTimeout(() => {
      this._pending.length || (this.closePopup(), this.showIframe = false);
    }, 100);
  }
  deliverMessage(e2, r2) {
    var n2, i2;
    if (!this._url)
      throw "Missing URL";
    console.info("WalletConnector:post", e2);
    const o2 = Object.assign(Object.assign({}, e2), { jsonrpc: "2.0" });
    o2.id != null && this._pending.push(o2.id), this.openIframe(), this._iframe.promise = (n2 = this._iframe.promise) === null || n2 === void 0 ? void 0 : n2.then(() => {
      var s2;
      return (s2 = this._iframe.window) === null || s2 === void 0 ? void 0 : s2.postMessage(o2, this._url.origin, r2 != null && r2.transfer ? [o2] : void 0);
    }).catch(() => {
    }), this.openPopup(), this._popup.promise = (i2 = this._popup.promise) === null || i2 === void 0 ? void 0 : i2.then(() => {
      var s2;
      return (s2 = this._popup.window) === null || s2 === void 0 ? void 0 : s2.postMessage(o2, this._url.origin, r2 != null && r2.transfer ? [o2] : void 0);
    }).catch(() => {
    });
  }
};
function sa(t2) {
  return typeof t2 == "object" ? t2 : (t2.includes("://") || (t2 = "https://" + t2), new URL(t2));
}
var aa;
var _r = [];
var hn = {};
var lo = {};
function Jf(t2) {
  t2.namespaces && (_r.find((e2) => e2 === t2) || _r.push(t2), Jn());
}
function Qf(t2) {
  if (!_r.find((e2) => e2 === t2))
    return Jn();
  _r.splice(_r.indexOf(t2), 1);
  for (const e2 in t2.namespaces)
    hn[e2] === t2 && (window[e2] = lo[e2], delete lo[e2], delete hn[e2]);
  Jn();
}
function Jn() {
  for (const t2 of _r)
    for (const e2 in t2.namespaces)
      hn[e2] && hn[e2] !== t2 || window[e2] !== t2.namespaces[e2] && (lo[e2] = window[e2], window[e2] = t2.namespaces[e2], hn[e2] = t2);
  window.clearInterval(aa), _r.length && (aa = setInterval(() => Jn(), 1e4));
}
var eh = "Window context missing. If you are using a server side rendering framework, make sure that the connector is excluded. If you want to use the connector outside the browser, use the node version of the module instead";
var Ct = class _Ct extends oc {
  constructor(e2, r2) {
    super(), this._session = 0, this._listener = (n2) => {
      const { method: i2, params: o2, session: s2 } = n2;
      if (!(s2 != null && this._session != s2) && !(!s2 && this._session)) {
        if (i2 === "connect") {
          if (!mr2.is(o2, (a2) => {
            function f2(p2) {
              return typeof p2 != "string" ? {} : null;
            }
            return f2(a2);
          }))
            return;
          this.setAddress(o2);
        }
        i2 === "disconnect" && this.disconnectEvent(false);
      }
    }, this._appInfo = e2, this._emitterPassthrough = (n2) => {
      const i2 = Object.entries(n2)[0];
      this.emit(i2[0], i2[1]);
    }, this.on("connect", () => Jf(this)), this.on("disconnect", () => Qf(this)), r2 && (this._url = sa(r2));
  }
  get address() {
    return this._address;
  }
  setAddress(e2) {
    e2 && e2 === this.address || (this._address = e2, e2 != null ? this.emit("connect", e2) : this.emit("disconnect", e2), this.emit("change", e2));
  }
  get connected() {
    return this._address != null;
  }
  get url() {
    var e2;
    return (e2 = this._bridge) === null || e2 === void 0 ? void 0 : e2.url;
  }
  get showIframe() {
    var e2;
    return ((e2 = this._bridge) === null || e2 === void 0 ? void 0 : e2.showIframe) || false;
  }
  get usePopup() {
    var e2;
    return ((e2 = this._bridge) === null || e2 === void 0 ? void 0 : e2.usePopup) || false;
  }
  get requirePopup() {
    var e2;
    return ((e2 = this._bridge) === null || e2 === void 0 ? void 0 : e2.requirePopup) || false;
  }
  get keepPopup() {
    var e2;
    return ((e2 = this._bridge) === null || e2 === void 0 ? void 0 : e2.keepPopup) || false;
  }
  set keepPopup(e2) {
    this._bridge && (this._bridge.keepPopup = e2);
  }
  setUrl(e2, r2) {
    var n2;
    if (typeof window > "u") {
      console.error(eh);
      return;
    }
    const i2 = this._bridge, o2 = sa(e2);
    if (this._url = o2, ((n2 = this._bridge) === null || n2 === void 0 ? void 0 : n2.url) !== o2.origin) {
      if (this.disconnect(), !_Ct._bridges[o2.origin])
        this._bridge = new Zf(o2, this._appInfo, r2), _Ct._bridges[o2.origin] = { bridge: this._bridge, sessions: [] };
      else {
        this._bridge = _Ct._bridges[o2.origin].bridge;
        const s2 = _Ct._bridges[o2.origin].sessions;
        for (let a2 = 0; a2 <= s2.length; a2++)
          if (s2.indexOf(a2) < 0) {
            this._session = a2;
            break;
          }
      }
      _Ct._bridges[o2.origin].sessions.push(this._session), this._bridge.on("message", this._listener), this._bridge.on("builtin", this._emitterPassthrough), this._bridge.showIframe !== (i2 == null ? void 0 : i2.showIframe) && this.emit("showIframe", this._bridge.showIframe), this._bridge.usePopup !== (i2 == null ? void 0 : i2.usePopup) && this.emit("usePopup", this._bridge.usePopup), this._bridge.requirePopup !== (i2 == null ? void 0 : i2.requirePopup) && this.emit("requirePopup", this._bridge.requirePopup), this._bridge.keepPopup !== (i2 == null ? void 0 : i2.keepPopup) && this.emit("keepPopup", this._bridge.keepPopup);
    }
  }
  connect(e2) {
    return Mt(this, void 0, void 0, function* () {
      if (!this._url)
        throw "Connect failed: URL missing";
      this._bridge || this.setUrl(this._url);
      const r2 = new Promise((n2, i2) => {
        this.once("change", (o2) => o2 ? n2(o2) : i2());
      }).finally(() => {
        var n2;
        return (n2 = this._bridge) === null || n2 === void 0 ? void 0 : n2.completeRequest();
      });
      return this._bridge.deliverMessage({ method: "connect", params: e2 }), r2;
    });
  }
  disconnect(e2) {
    return Mt(this, void 0, void 0, function* () {
      return this.disconnectEvent(true, e2);
    });
  }
  disconnectEvent(e2, r2) {
    return Mt(this, void 0, void 0, function* () {
      if (!this._bridge)
        return;
      const n2 = this._bridge, i2 = this._session, o2 = n2.url;
      if (this.setAddress(void 0), this._bridge = void 0, this._session = 0, e2)
        try {
          yield n2.postMessage({ method: "disconnect", params: [r2], session: i2 }, { timeout: 5e3 });
        } catch {
          console.warn("disconnect request failed");
        }
      n2.off("message", this._listener), n2.off("builtin", this._emitterPassthrough), _Ct._bridges[o2].sessions = _Ct._bridges[o2].sessions.filter((s2) => s2 != i2), setTimeout(() => {
        _Ct._bridges[o2].sessions.length || (_Ct._bridges[o2].bridge.destructor(), delete _Ct._bridges[o2]);
      }, 100);
    });
  }
  postMessage(e2, r2, n2) {
    return new Promise((i2, o2) => {
      if (!this._url)
        throw "Post message failed: URL missing";
      if (!this._bridge)
        throw "Post message failed: URL not loaded, call setUrl or connect first";
      this.once("disconnect", o2), this._bridge.postMessage({ method: e2, params: r2, session: this._session, protocol: n2 == null ? void 0 : n2.protocol, version: n2 == null ? void 0 : n2.version }, n2).then(i2).catch(o2);
    });
  }
};
Ct._bridges = {};
var gr2 = class _gr extends Ct {
  constructor(e2, r2) {
    var n2;
    if (super(e2, (n2 = sc(r2 == null ? void 0 : r2.state)) === null || n2 === void 0 ? void 0 : n2.url), this._subs = [], this._localStorageKey = "arweave-wallet-connector:URL", this.setUrl = (s2, a2) => {
      super.setUrl(s2, a2), this.updateState({ url: super.url });
    }, this.subscribe = (s2) => (this._subs.push(s2), s2(this._state.value), () => this._subs.filter((a2) => a2 !== s2)), this.setState = (s2) => {
      var a2;
      const f2 = (a2 = _gr._instance) !== null && a2 !== void 0 ? a2 : this;
      s2 && Array.isArray(s2) && (f2._setState = s2[1]), s2 && "set" in s2 && (f2._setState = s2.set);
      const p2 = th(s2);
      return f2._state = p2.state, Object.keys(p2.newProps).length && f2.updateState(p2.newProps), s2;
    }, this.updateState = (s2) => {
      s2 && (Object.assign(this._state.value, s2), this._setState && this._setState(Object.assign({}, this._state.value)), this._subs.forEach((a2) => a2(this._state.value)));
    }, this.setState(r2 == null ? void 0 : r2.state), _gr._instance)
      return _gr._instance;
    _gr._instance = new Proxy(this, {
      get: (s2, a2, f2) => a2 in s2._state.value ? s2._state.value[a2] : s2[a2],
      set: (s2, a2, f2, p2) => (a2 === "keepPopup" ? super.keepPopup = f2 : s2[a2] = f2, true)
    });
    let i2 = false;
    if (this.on("connect", (s2) => {
      const a2 = super.url;
      this.updateState({ address: s2, url: a2, connected: true }), this._localStorageKey && localStorage.setItem(this._localStorageKey, a2 ?? "");
    }), this.on("disconnect", () => {
      this.updateState({ address: void 0, connected: false }), this._localStorageKey && !i2 && localStorage.removeItem(this._localStorageKey);
    }), ["showIframe", "usePopup", "requirePopup", "keepPopup"].forEach((s2) => this.on(s2, (a2) => this.updateState({ [s2]: a2 }))), typeof window < "u" && (window.addEventListener("beforeunload", () => i2 = true), window.addEventListener("unload", () => i2 = true), (r2 == null ? void 0 : r2.localStorageKey) != null && (this._localStorageKey = r2.localStorageKey), this._localStorageKey)) {
      const s2 = localStorage.getItem(this._localStorageKey);
      s2 && this.setUrl(s2, true), localStorage.removeItem(this._localStorageKey);
    }
    return _gr._instance;
  }
};
function sc(t2) {
  if (t2) {
    if ("subscribe" in t2) {
      let e2;
      const r2 = t2.subscribe((n2) => e2 = n2);
      return r2 == null || r2(), e2;
    }
    return Array.isArray(t2) ? t2[0] : "value" in t2 ? t2.value : t2;
  }
}
function th(t2) {
  let e2;
  return t2 ? Array.isArray(t2) ? e2 = en({ value: t2[0] }) : "value" in t2 ? e2 = en(t2) : "subscribe" in t2 ? e2 = en({ value: sc(t2) }) : e2 = en({ value: t2 }) : e2 = en({ value: {} }), e2;
}
function en(t2) {
  var e2;
  (e2 = t2.value) !== null && e2 !== void 0 || (t2.value = {});
  const r2 = rh(t2.value);
  return { state: t2, newProps: r2.newProps };
}
function rh(t2 = {}) {
  const e2 = {
    url: void 0,
    address: void 0,
    connected: false,
    showIframe: false,
    usePopup: false,
    requirePopup: false,
    keepPopup: false
  }, r2 = {};
  for (const n2 in e2)
    t2[n2] == null && (r2[n2] = e2[n2], t2[n2] = e2[n2]);
  return { state: t2, newProps: r2 };
}
var ua = Gf(gr2);
function Vo(t2, e2) {
  for (const r2 of t2)
    if (!e2.includes(r2))
      return false;
  return true;
}
function ac(t2, e2 = 13) {
  return t2.substring(0, e2) + "..." + t2.substring(t2.length - e2, t2.length);
}
var uc = (t2) => `${t2.r}, ${t2.g}, ${t2.b}`;
async function vt2(t2, e2 = []) {
  return window != null && window.arweaveWallet ? await window.arweaveWallet[t2](...e2) : new Promise(
    (r2, n2) => window.addEventListener("arweaveWalletLoaded", async () => {
      try {
        r2(await window.arweaveWallet[t2](...e2));
      } catch (i2) {
        n2(i2);
      }
    })
  );
}
var qo = class {
  constructor() {
    pe(this, "id", "browserwallet");
    pe(this, "name", "Browser Wallet");
    pe(this, "description", "Any browser wallet with an injected API");
    pe(this, "theme", "121,212,131");
    pe(this, "logo", "KKiSlNKc5K59MXzUPz5qjtCLsl6_ckjAOg9MyAzaUs0");
  }
  async isAvailable() {
    return typeof window > "u" || !window ? (console.error(
      `[Arweave Wallet Kit] "${this.id}" strategy is unavailable. Window is undefined`
    ), false) : window.arweaveWallet ? true : new Promise((e2) => {
      const r2 = () => e2(true);
      window.addEventListener("arweaveWalletLoaded", r2), setTimeout(() => {
        window.removeEventListener("arweaveWalletLoaded", r2), window.arweaveWallet || console.error(
          `[Arweave Wallet Kit] "${this.id}" strategy is unavailable. window.arweaveWallet is undefined`
        ), e2(!!window.arweaveWallet);
      }, 7e3);
    });
  }
  async sync() {
  }
  async connect(e2, r2, n2) {
    return await vt2("connect", [e2, r2, n2]);
  }
  async disconnect() {
    return await vt2("disconnect");
  }
  async getActiveAddress() {
    return await vt2("getActiveAddress");
  }
  async getAllAddresses() {
    return await vt2("getAllAddresses");
  }
  async getPermissions() {
    return await vt2("getPermissions");
  }
  async getWalletNames() {
    return await vt2("getWalletNames");
  }
  async sign(e2, r2) {
    const n2 = await vt2("sign", [
      e2,
      r2
    ]);
    return e2.setSignature({
      id: n2.id,
      owner: n2.owner,
      reward: n2.reward,
      tags: n2.tags,
      signature: n2.signature
    }), e2;
  }
  async signDataItem(e2) {
    return await vt2("signDataItem", [e2]);
  }
  async encrypt(e2, r2) {
    return await vt2("encrypt", [e2, r2]);
  }
  async decrypt(e2, r2) {
    return await vt2("decrypt", [e2, r2]);
  }
  async getArweaveConfig() {
    return await vt2("getArweaveConfig");
  }
  async signature(e2, r2) {
    return await vt2("signature", [e2, r2]);
  }
  async getActivePublicKey() {
    return await vt2("getActivePublicKey");
  }
  async addToken(e2) {
    throw new Error("Not implemented");
  }
  async dispatch(e2) {
    return await vt2("dispatch", [e2]);
  }
  addAddressEvent(e2) {
    const r2 = (n2) => e2(n2.detail.address);
    return addEventListener("walletSwitch", r2), r2;
  }
  removeAddressEvent(e2) {
    removeEventListener("walletSwitch", e2);
  }
};
var Jt;
var nh = class extends qo {
  constructor() {
    super();
    pe(this, "id", "webwallet");
    pe(this, "name", "Arweave.app");
    pe(this, "description", "Web based wallet software");
    pe(this, "theme", "24, 24, 24");
    pe(this, "logo", "qVms-k8Ox-eKFJN5QFvrPQvT9ryqQXaFcYbr-fJbgLY");
    pe(this, "url", "https://arweave.app");
    Sr(this, Jt, new ua());
  }
  async isAvailable() {
    return true;
  }
  async resumeSession() {
    pt2(this, Jt).setUrl("arweave.app"), await pt2(this, Jt).connect();
  }
  async connect(r2, n2, i2) {
    i2 && console.warn(
      "[Arweave Wallet Kit] Arweave.app does not support custom gateway connection yet."
    ), Un(this, Jt, new ua(n2)), await this.resumeSession();
  }
  addAddressEvent(r2) {
    return pt2(this, Jt).on("connect", r2), r2;
  }
  removeAddressEvent(r2) {
    pt2(this, Jt).off("connect", r2);
  }
  async signDataItem(r2) {
    return await pt2(this, Jt).signDataItem(
      r2
    );
  }
};
Jt = /* @__PURE__ */ new WeakMap();
var ih = class extends qo {
  constructor() {
    super();
    pe(this, "id", "arconnect");
    pe(this, "name", "ArConnect");
    pe(this, "description", "Non-custodial Arweave wallet for your favorite browser");
    pe(this, "theme", "171, 154, 255");
    pe(this, "logo", "tQUcL4wlNj_NED2VjUGUhfCTJ6pDN9P0e3CbnHo3vUE");
    pe(this, "url", "https://arconnect.io");
  }
  async isAvailable() {
    return await super.isAvailable() ? window.arweaveWallet.walletName === "ArConnect" : false;
  }
  async addToken(r2) {
    return await vt2("addToken", [r2]);
  }
  async batchSignDataItem(r2) {
    return await vt2("batchSignDataItem", [r2]);
  }
};
var Qt;
var Vr;
var wr;
var ut;
var gt;
var oh = class {
  constructor() {
    Sr(this, ut);
    pe(this, "id", "othent");
    pe(this, "name", "Othent");
    pe(this, "description", "Othent JS SDK to manage Arweave wallets backed by Auth0 and Google Key Management Service.");
    pe(this, "theme", "35, 117, 239");
    pe(this, "logo", "33nBIUNlGK4MnWtJZQy9EzkVJaAd7WoydIKfkJoMvDs");
    pe(this, "url", "https://othent.io");
    Sr(this, Qt, null);
    Sr(this, Vr, null);
    Sr(this, wr, []);
  }
  __overrideOthentOptions(e2) {
    Un(this, Vr, e2);
  }
  async isAvailable() {
    try {
      return !!mt(this, ut, gt).call(this);
    } catch {
      return false;
    }
  }
  async connect(e2, r2, n2) {
    const i2 = mt(this, ut, gt).call(this);
    return e2 && console.warn(
      "[Arweave Wallet Kit] Othent implicitly requires all permissions. Your `permissions` parameter will be ignored."
    ), i2.connect(
      void 0,
      r2 ? { ...i2.appInfo, ...r2 } : void 0,
      n2
    ).then(() => {
    });
  }
  async disconnect() {
    return mt(this, ut, gt).call(this).disconnect();
  }
  async getActiveAddress() {
    return mt(this, ut, gt).call(this).getActiveAddress();
  }
  async getActivePublicKey() {
    return mt(this, ut, gt).call(this).getActivePublicKey();
  }
  async getAllAddresses() {
    return mt(this, ut, gt).call(this).getAllAddresses();
  }
  async getWalletNames() {
    return mt(this, ut, gt).call(this).getWalletNames();
  }
  async userDetails() {
    return mt(this, ut, gt).call(this).getUserDetails();
  }
  async sign(e2, r2) {
    return r2 && console.warn(
      "[Arweave Wallet Kit] Othent does not support `sign()` options"
    ), mt(this, ut, gt).call(this).sign(e2);
  }
  async dispatch(e2) {
    return mt(this, ut, gt).call(this).dispatch(e2);
  }
  signDataItem(e2) {
    return mt(this, ut, gt).call(this).signDataItem(e2);
  }
  encrypt(e2, r2) {
    return r2 && console.warn(
      "[Arweave Wallet Kit] Othent does not support `encrypt()` options"
    ), mt(this, ut, gt).call(this).encrypt(e2);
  }
  decrypt(e2, r2) {
    return r2 && console.warn(
      "[Arweave Wallet Kit] Othent does not support `decrypt()` options"
    ), mt(this, ut, gt).call(this).decrypt(e2);
  }
  signature(e2, r2) {
    return r2 && console.warn(
      "[Arweave Wallet Kit] Othent does not support `signature()` options"
    ), mt(this, ut, gt).call(this).signature(e2);
  }
  getArweaveConfig() {
    return mt(this, ut, gt).call(this).getArweaveConfig();
  }
  async getPermissions() {
    const e2 = mt(this, ut, gt).call(this);
    return e2.getSyncUserDetails() ? e2.getPermissions() : Promise.resolve([]);
  }
  async addToken(e2) {
    throw new Error("Not implemented");
  }
  addAddressEvent(e2) {
    return pt2(this, wr).push(e2), e2;
  }
  removeAddressEvent(e2) {
    pt2(this, wr).splice(
      pt2(this, wr).indexOf(e2),
      1
    );
  }
};
Qt = /* @__PURE__ */ new WeakMap(), Vr = /* @__PURE__ */ new WeakMap(), wr = /* @__PURE__ */ new WeakMap(), ut = /* @__PURE__ */ new WeakSet(), gt = function() {
  var e2;
  if (pt2(this, Qt))
    return pt2(this, Qt);
  try {
    const r2 = {
      name: typeof location > "u" ? "UNKNOWN" : location.hostname,
      version: "ArweaveWalletKit",
      env: ""
    };
    Un(this, Qt, new Othent({
      appInfo: r2,
      persistLocalStorage: true,
      ...pt2(this, Vr)
    })), pt2(this, Qt).addEventListener("auth", (n2) => {
      for (const i2 of pt2(this, wr))
        i2((n2 == null ? void 0 : n2.walletAddress) || void 0);
    }), (e2 = pt2(this, Vr)) != null && e2.persistLocalStorage && pt2(this, Qt).startTabSynching();
  } catch (r2) {
    throw new Error(`[Arweave Wallet Kit] ${r2 instanceof Error && r2.message || r2}`);
  }
  return pt2(this, Qt);
};
var dn = [
  new ih(),
  new nh(),
  new oh(),
  new qo()
];
var Sn = "wallet_kit_strategy_id";
async function sh(t2, e2) {
  let r2 = (localStorage == null ? void 0 : localStorage.getItem(Sn)) || false;
  if (r2 && Ir(r2))
    return Ir(r2);
  for (const n2 of dn) {
    const i2 = await n2.getPermissions();
    if (!e2 && i2.length > 0)
      return fo(n2.id), Ir(n2.id);
    if (e2 && Vo(t2, i2))
      return fo(n2.id), Ir(n2.id);
  }
  return false;
}
function fo(t2) {
  localStorage && localStorage.setItem(Sn, t2);
}
function Ir(t2) {
  return dn.find((e2) => e2.id === t2);
}
var Wo = {
  activeModal: false,
  activeStrategy: false,
  givenPermissions: [],
  config: {
    permissions: []
  }
};
var cc = (0, import_react.createContext)(void 0);
function xt2() {
  const t2 = (0, import_react.useContext)(cc);
  return (0, import_react.useMemo)(
    () => t2 || { state: Wo, dispatch: () => {
    } },
    [t2]
  );
}
function ah() {
  const { state: t2 } = xt2();
  return (0, import_react.useMemo)(() => t2.activeStrategy, [t2]);
}
function Gt2() {
  const t2 = ah();
  return (0, import_react.useMemo)(() => Ir(t2), [t2]);
}
function D1() {
  const t2 = Gt2();
  return (0, import_react.useMemo)(() => {
    if (!t2)
      return;
    const r2 = t2, n2 = [
      "name",
      "description",
      "theme",
      "logo",
      "url",
      "resumeSession",
      "isAvailable",
      "addAddressEvent",
      "removeAddressEvent",
      "connect"
    ];
    for (const i2 in t2)
      n2.includes(i2) && delete r2[i2];
    return r2;
  }, [t2]);
}
function di() {
  const { state: t2 } = xt2();
  return t2 == null ? void 0 : t2.activeAddress;
}
async function uh() {
  const t2 = Gt2(), { dispatch: e2 } = xt2();
  (0, import_react.useEffect)(() => {
    (async () => {
      var i2;
      if (!t2)
        return;
      const r2 = async () => {
        try {
          const o2 = await t2.getActiveAddress();
          e2({
            type: "UPDATE_ADDRESS",
            payload: o2
          });
        } catch (o2) {
          console.error(
            `[Arweave Wallet Kit] Failed to sync address
${(o2 == null ? void 0 : o2.message) || o2}`
          );
        }
      };
      await r2();
      const n2 = (i2 = t2.addAddressEvent) == null ? void 0 : i2.call(
        t2,
        (o2) => e2({
          type: "UPDATE_ADDRESS",
          payload: o2
        })
      );
      return addEventListener("focus", r2), () => {
        n2 && t2.removeAddressEvent && t2.removeAddressEvent(n2), removeEventListener("focus", r2);
      };
    })();
  }, [t2, e2]);
}
function L1() {
  const [t2, e2] = (0, import_react.useState)(), r2 = Gt2(), n2 = di();
  return (0, import_react.useEffect)(() => {
    (async () => !r2 || !r2.getActivePublicKey || e2(await r2.getActivePublicKey()))();
  }, [n2, r2]), t2;
}
function ch() {
  const [t2, e2] = (0, import_react.useState)([]), r2 = di(), { state: n2 } = xt2(), i2 = Gt2();
  return (0, import_react.useEffect)(() => {
    (async () => {
      if (!i2)
        return e2([]);
      const o2 = async () => {
        try {
          e2(await i2.getAllAddresses());
        } catch (s2) {
          console.error(
            `[Arweave Wallet Kit] Failed to sync addresses
${(s2 == null ? void 0 : s2.message) || s2}`
          );
        }
      };
      return await o2(), addEventListener("focus", o2), () => removeEventListener("focus", o2);
    })();
  }, [r2, n2, i2]), t2;
}
function N12() {
  const [t2, e2] = (0, import_react.useState)({}), r2 = ch(), { state: n2 } = xt2(), i2 = Gt2();
  return (0, import_react.useEffect)(() => {
    (async () => {
      if (!i2 || !i2.getWalletNames)
        return e2({});
      try {
        const o2 = await i2.getWalletNames();
        e2(o2);
      } catch (o2) {
        console.error(
          `[Arweave Wallet Kit] Failed to sync wallet names
${(o2 == null ? void 0 : o2.message) || o2}`
        );
      }
    })();
  }, [r2, n2 == null ? void 0 : n2.activeStrategy]), t2;
}
var ge2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Pn(t2) {
  return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
}
function lh(t2) {
  if (t2.__esModule)
    return t2;
  var e2 = t2.default;
  if (typeof e2 == "function") {
    var r2 = function n2() {
      return this instanceof n2 ? Reflect.construct(e2, arguments, this.constructor) : e2.apply(this, arguments);
    };
    r2.prototype = e2.prototype;
  } else
    r2 = {};
  return Object.defineProperty(r2, "__esModule", { value: true }), Object.keys(t2).forEach(function(n2) {
    var i2 = Object.getOwnPropertyDescriptor(t2, n2);
    Object.defineProperty(r2, n2, i2.get ? i2 : {
      enumerable: true,
      get: function() {
        return t2[n2];
      }
    });
  }), r2;
}
var ho = { exports: {} };
var rn = {};
var la;
function hh() {
  return la || (la = 1, function() {
    var t2 = import_react.default, e2 = Symbol.for("react.element"), r2 = Symbol.for("react.portal"), n2 = Symbol.for("react.fragment"), i2 = Symbol.for("react.strict_mode"), o2 = Symbol.for("react.profiler"), s2 = Symbol.for("react.provider"), a2 = Symbol.for("react.context"), f2 = Symbol.for("react.forward_ref"), p2 = Symbol.for("react.suspense"), d2 = Symbol.for("react.suspense_list"), y2 = Symbol.for("react.memo"), v3 = Symbol.for("react.lazy"), w3 = Symbol.for("react.offscreen"), I3 = Symbol.iterator, N11 = "@@iterator";
    function k2(D2) {
      if (D2 === null || typeof D2 != "object")
        return null;
      var le = I3 && D2[I3] || D2[N11];
      return typeof le == "function" ? le : null;
    }
    var M3 = t2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function S2(D2) {
      {
        for (var le = arguments.length, he = new Array(le > 1 ? le - 1 : 0), Te = 1; Te < le; Te++)
          he[Te - 1] = arguments[Te];
        Y2("error", D2, he);
      }
    }
    function Y2(D2, le, he) {
      {
        var Te = M3.ReactDebugCurrentFrame, Ie = Te.getStackAddendum();
        Ie !== "" && (le += "%s", he = he.concat([Ie]));
        var De = he.map(function(Re) {
          return String(Re);
        });
        De.unshift("Warning: " + le), Function.prototype.apply.call(console[D2], console, De);
      }
    }
    var W2 = false, Q3 = false, X3 = false, ne = false, ue = false, se;
    se = Symbol.for("react.module.reference");
    function ie(D2) {
      return !!(typeof D2 == "string" || typeof D2 == "function" || D2 === n2 || D2 === o2 || ue || D2 === i2 || D2 === p2 || D2 === d2 || ne || D2 === w3 || W2 || Q3 || X3 || typeof D2 == "object" && D2 !== null && (D2.$$typeof === v3 || D2.$$typeof === y2 || D2.$$typeof === s2 || D2.$$typeof === a2 || D2.$$typeof === f2 || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      D2.$$typeof === se || D2.getModuleId !== void 0));
    }
    function O2(D2, le, he) {
      var Te = D2.displayName;
      if (Te)
        return Te;
      var Ie = le.displayName || le.name || "";
      return Ie !== "" ? he + "(" + Ie + ")" : he;
    }
    function c2(D2) {
      return D2.displayName || "Context";
    }
    function m2(D2) {
      if (D2 == null)
        return null;
      if (typeof D2.tag == "number" && S2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof D2 == "function")
        return D2.displayName || D2.name || null;
      if (typeof D2 == "string")
        return D2;
      switch (D2) {
        case n2:
          return "Fragment";
        case r2:
          return "Portal";
        case o2:
          return "Profiler";
        case i2:
          return "StrictMode";
        case p2:
          return "Suspense";
        case d2:
          return "SuspenseList";
      }
      if (typeof D2 == "object")
        switch (D2.$$typeof) {
          case a2:
            var le = D2;
            return c2(le) + ".Consumer";
          case s2:
            var he = D2;
            return c2(he._context) + ".Provider";
          case f2:
            return O2(D2, D2.render, "ForwardRef");
          case y2:
            var Te = D2.displayName || null;
            return Te !== null ? Te : m2(D2.type) || "Memo";
          case v3: {
            var Ie = D2, De = Ie._payload, Re = Ie._init;
            try {
              return m2(Re(De));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var _3 = Object.assign, T3 = 0, C3, L2, H2, P3, l2, x3, re;
    function ae() {
    }
    ae.__reactDisabledLog = true;
    function G2() {
      {
        if (T3 === 0) {
          C3 = console.log, L2 = console.info, H2 = console.warn, P3 = console.error, l2 = console.group, x3 = console.groupCollapsed, re = console.groupEnd;
          var D2 = {
            configurable: true,
            enumerable: true,
            value: ae,
            writable: true
          };
          Object.defineProperties(console, {
            info: D2,
            log: D2,
            warn: D2,
            error: D2,
            group: D2,
            groupCollapsed: D2,
            groupEnd: D2
          });
        }
        T3++;
      }
    }
    function ce() {
      {
        if (T3--, T3 === 0) {
          var D2 = {
            configurable: true,
            enumerable: true,
            writable: true
          };
          Object.defineProperties(console, {
            log: _3({}, D2, {
              value: C3
            }),
            info: _3({}, D2, {
              value: L2
            }),
            warn: _3({}, D2, {
              value: H2
            }),
            error: _3({}, D2, {
              value: P3
            }),
            group: _3({}, D2, {
              value: l2
            }),
            groupCollapsed: _3({}, D2, {
              value: x3
            }),
            groupEnd: _3({}, D2, {
              value: re
            })
          });
        }
        T3 < 0 && S2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var me = M3.ReactCurrentDispatcher, ye;
    function xe(D2, le, he) {
      {
        if (ye === void 0)
          try {
            throw Error();
          } catch (Ie) {
            var Te = Ie.stack.trim().match(/\n( *(at )?)/);
            ye = Te && Te[1] || "";
          }
        return `
` + ye + D2;
      }
    }
    var ve = false, b2;
    {
      var R2 = typeof WeakMap == "function" ? WeakMap : Map;
      b2 = new R2();
    }
    function E3(D2, le) {
      if (!D2 || ve)
        return "";
      {
        var he = b2.get(D2);
        if (he !== void 0)
          return he;
      }
      var Te;
      ve = true;
      var Ie = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var De;
      De = me.current, me.current = null, G2();
      try {
        if (le) {
          var Re = function() {
            throw Error();
          };
          if (Object.defineProperty(Re.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Re, []);
            } catch (ft) {
              Te = ft;
            }
            Reflect.construct(D2, [], Re);
          } else {
            try {
              Re.call();
            } catch (ft) {
              Te = ft;
            }
            D2.call(Re.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ft) {
            Te = ft;
          }
          D2();
        }
      } catch (ft) {
        if (ft && Te && typeof ft.stack == "string") {
          for (var Oe = ft.stack.split(`
`), at = Te.stack.split(`
`), Ve = Oe.length - 1, Ke = at.length - 1; Ve >= 1 && Ke >= 0 && Oe[Ve] !== at[Ke]; )
            Ke--;
          for (; Ve >= 1 && Ke >= 0; Ve--, Ke--)
            if (Oe[Ve] !== at[Ke]) {
              if (Ve !== 1 || Ke !== 1)
                do
                  if (Ve--, Ke--, Ke < 0 || Oe[Ve] !== at[Ke]) {
                    var yt2 = `
` + Oe[Ve].replace(" at new ", " at ");
                    return D2.displayName && yt2.includes("<anonymous>") && (yt2 = yt2.replace("<anonymous>", D2.displayName)), typeof D2 == "function" && b2.set(D2, yt2), yt2;
                  }
                while (Ve >= 1 && Ke >= 0);
              break;
            }
        }
      } finally {
        ve = false, me.current = De, ce(), Error.prepareStackTrace = Ie;
      }
      var Wt2 = D2 ? D2.displayName || D2.name : "", Ft = Wt2 ? xe(Wt2) : "";
      return typeof D2 == "function" && b2.set(D2, Ft), Ft;
    }
    function V2(D2, le, he) {
      return E3(D2, false);
    }
    function K2(D2) {
      var le = D2.prototype;
      return !!(le && le.isReactComponent);
    }
    function $3(D2, le, he) {
      if (D2 == null)
        return "";
      if (typeof D2 == "function")
        return E3(D2, K2(D2));
      if (typeof D2 == "string")
        return xe(D2);
      switch (D2) {
        case p2:
          return xe("Suspense");
        case d2:
          return xe("SuspenseList");
      }
      if (typeof D2 == "object")
        switch (D2.$$typeof) {
          case f2:
            return V2(D2.render);
          case y2:
            return $3(D2.type, le, he);
          case v3: {
            var Te = D2, Ie = Te._payload, De = Te._init;
            try {
              return $3(De(Ie), le, he);
            } catch {
            }
          }
        }
      return "";
    }
    var J2 = Object.prototype.hasOwnProperty, j2 = {}, q2 = M3.ReactDebugCurrentFrame;
    function Z3(D2) {
      if (D2) {
        var le = D2._owner, he = $3(D2.type, D2._source, le ? le.type : null);
        q2.setExtraStackFrame(he);
      } else
        q2.setExtraStackFrame(null);
    }
    function ee2(D2, le, he, Te, Ie) {
      {
        var De = Function.call.bind(J2);
        for (var Re in D2)
          if (De(D2, Re)) {
            var Oe = void 0;
            try {
              if (typeof D2[Re] != "function") {
                var at = Error((Te || "React class") + ": " + he + " type `" + Re + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof D2[Re] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw at.name = "Invariant Violation", at;
              }
              Oe = D2[Re](le, Re, Te, he, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ve) {
              Oe = Ve;
            }
            Oe && !(Oe instanceof Error) && (Z3(Ie), S2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Te || "React class", he, Re, typeof Oe), Z3(null)), Oe instanceof Error && !(Oe.message in j2) && (j2[Oe.message] = true, Z3(Ie), S2("Failed %s type: %s", he, Oe.message), Z3(null));
          }
      }
    }
    var oe2 = Array.isArray;
    function de(D2) {
      return oe2(D2);
    }
    function Ee(D2) {
      {
        var le = typeof Symbol == "function" && Symbol.toStringTag, he = le && D2[Symbol.toStringTag] || D2.constructor.name || "Object";
        return he;
      }
    }
    function Ae(D2) {
      try {
        return U2(D2), false;
      } catch {
        return true;
      }
    }
    function U2(D2) {
      return "" + D2;
    }
    function te2(D2) {
      if (Ae(D2))
        return S2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ee(D2)), U2(D2);
    }
    var g2 = M3.ReactCurrentOwner, u2 = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    }, h2, A2, B3;
    B3 = {};
    function z3(D2) {
      if (J2.call(D2, "ref")) {
        var le = Object.getOwnPropertyDescriptor(D2, "ref").get;
        if (le && le.isReactWarning)
          return false;
      }
      return D2.ref !== void 0;
    }
    function F2(D2) {
      if (J2.call(D2, "key")) {
        var le = Object.getOwnPropertyDescriptor(D2, "key").get;
        if (le && le.isReactWarning)
          return false;
      }
      return D2.key !== void 0;
    }
    function fe(D2, le) {
      if (typeof D2.ref == "string" && g2.current && le && g2.current.stateNode !== le) {
        var he = m2(g2.current.type);
        B3[he] || (S2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', m2(g2.current.type), D2.ref), B3[he] = true);
      }
    }
    function we(D2, le) {
      {
        var he = function() {
          h2 || (h2 = true, S2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", le));
        };
        he.isReactWarning = true, Object.defineProperty(D2, "key", {
          get: he,
          configurable: true
        });
      }
    }
    function _e(D2, le) {
      {
        var he = function() {
          A2 || (A2 = true, S2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", le));
        };
        he.isReactWarning = true, Object.defineProperty(D2, "ref", {
          get: he,
          configurable: true
        });
      }
    }
    var be = function(D2, le, he, Te, Ie, De, Re) {
      var Oe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e2,
        // Built-in properties that belong on the element
        type: D2,
        key: le,
        ref: he,
        props: Re,
        // Record the component responsible for creating this element.
        _owner: De
      };
      return Oe._store = {}, Object.defineProperty(Oe._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }), Object.defineProperty(Oe, "_self", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Te
      }), Object.defineProperty(Oe, "_source", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Ie
      }), Object.freeze && (Object.freeze(Oe.props), Object.freeze(Oe)), Oe;
    };
    function Be(D2, le, he, Te, Ie) {
      {
        var De, Re = {}, Oe = null, at = null;
        he !== void 0 && (te2(he), Oe = "" + he), F2(le) && (te2(le.key), Oe = "" + le.key), z3(le) && (at = le.ref, fe(le, Ie));
        for (De in le)
          J2.call(le, De) && !u2.hasOwnProperty(De) && (Re[De] = le[De]);
        if (D2 && D2.defaultProps) {
          var Ve = D2.defaultProps;
          for (De in Ve)
            Re[De] === void 0 && (Re[De] = Ve[De]);
        }
        if (Oe || at) {
          var Ke = typeof D2 == "function" ? D2.displayName || D2.name || "Unknown" : D2;
          Oe && we(Re, Ke), at && _e(Re, Ke);
        }
        return be(D2, Oe, at, Ie, Te, g2.current, Re);
      }
    }
    var qe = M3.ReactCurrentOwner, Ye = M3.ReactDebugCurrentFrame;
    function Yt2(D2) {
      if (D2) {
        var le = D2._owner, he = $3(D2.type, D2._source, le ? le.type : null);
        Ye.setExtraStackFrame(he);
      } else
        Ye.setExtraStackFrame(null);
    }
    var We;
    We = false;
    function He(D2) {
      return typeof D2 == "object" && D2 !== null && D2.$$typeof === e2;
    }
    function Xr() {
      {
        if (qe.current) {
          var D2 = m2(qe.current.type);
          if (D2)
            return `

Check the render method of \`` + D2 + "`.";
        }
        return "";
      }
    }
    function et(D2) {
      {
        if (D2 !== void 0) {
          var le = D2.fileName.replace(/^.*[\\\/]/, ""), he = D2.lineNumber;
          return `

Check your code at ` + le + ":" + he + ".";
        }
        return "";
      }
    }
    var Xe = {};
    function Dn(D2) {
      {
        var le = Xr();
        if (!le) {
          var he = typeof D2 == "string" ? D2 : D2.displayName || D2.name;
          he && (le = `

Check the top-level render call using <` + he + ">.");
        }
        return le;
      }
    }
    function Ze(D2, le) {
      {
        if (!D2._store || D2._store.validated || D2.key != null)
          return;
        D2._store.validated = true;
        var he = Dn(le);
        if (Xe[he])
          return;
        Xe[he] = true;
        var Te = "";
        D2 && D2._owner && D2._owner !== qe.current && (Te = " It was passed a child from " + m2(D2._owner.type) + "."), Yt2(D2), S2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', he, Te), Yt2(null);
      }
    }
    function Je(D2, le) {
      {
        if (typeof D2 != "object")
          return;
        if (de(D2))
          for (var he = 0; he < D2.length; he++) {
            var Te = D2[he];
            He(Te) && Ze(Te, le);
          }
        else if (He(D2))
          D2._store && (D2._store.validated = true);
        else if (D2) {
          var Ie = k2(D2);
          if (typeof Ie == "function" && Ie !== D2.entries)
            for (var De = Ie.call(D2), Re; !(Re = De.next()).done; )
              He(Re.value) && Ze(Re.value, le);
        }
      }
    }
    function Ln(D2) {
      {
        var le = D2.type;
        if (le == null || typeof le == "string")
          return;
        var he;
        if (typeof le == "function")
          he = le.propTypes;
        else if (typeof le == "object" && (le.$$typeof === f2 || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        le.$$typeof === y2))
          he = le.propTypes;
        else
          return;
        if (he) {
          var Te = m2(le);
          ee2(he, D2.props, "prop", Te, D2);
        } else if (le.PropTypes !== void 0 && !We) {
          We = true;
          var Ie = m2(le);
          S2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ie || "Unknown");
        }
        typeof le.getDefaultProps == "function" && !le.getDefaultProps.isReactClassApproved && S2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function tt2(D2) {
      {
        for (var le = Object.keys(D2.props), he = 0; he < le.length; he++) {
          var Te = le[he];
          if (Te !== "children" && Te !== "key") {
            Yt2(D2), S2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Te), Yt2(null);
            break;
          }
        }
        D2.ref !== null && (Yt2(D2), S2("Invalid attribute `ref` supplied to `React.Fragment`."), Yt2(null));
      }
    }
    var Qe = {};
    function Zr(D2, le, he, Te, Ie, De) {
      {
        var Re = ie(D2);
        if (!Re) {
          var Oe = "";
          (D2 === void 0 || typeof D2 == "object" && D2 !== null && Object.keys(D2).length === 0) && (Oe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var at = et(Ie);
          at ? Oe += at : Oe += Xr();
          var Ve;
          D2 === null ? Ve = "null" : de(D2) ? Ve = "array" : D2 !== void 0 && D2.$$typeof === e2 ? (Ve = "<" + (m2(D2.type) || "Unknown") + " />", Oe = " Did you accidentally export a JSX literal instead of a component?") : Ve = typeof D2, S2("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ve, Oe);
        }
        var Ke = Be(D2, le, he, Ie, De);
        if (Ke == null)
          return Ke;
        if (Re) {
          var yt2 = le.children;
          if (yt2 !== void 0)
            if (Te)
              if (de(yt2)) {
                for (var Wt2 = 0; Wt2 < yt2.length; Wt2++)
                  Je(yt2[Wt2], D2);
                Object.freeze && Object.freeze(yt2);
              } else
                S2("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Je(yt2, D2);
        }
        if (J2.call(le, "key")) {
          var Ft = m2(D2), ft = Object.keys(le).filter(function(Qr) {
            return Qr !== "key";
          }), fr = ft.length > 0 ? "{key: someKey, " + ft.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Qe[Ft + fr]) {
            var Jr = ft.length > 0 ? "{" + ft.join(": ..., ") + ": ...}" : "{}";
            S2(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, fr, Ft, Jr, Ft), Qe[Ft + fr] = true;
          }
        }
        return D2 === n2 ? tt2(Ke) : Ln(Ke), Ke;
      }
    }
    function rt(D2, le, he) {
      return Zr(D2, le, he, true);
    }
    function nt2(D2, le, he) {
      return Zr(D2, le, he, false);
    }
    var Nn = nt2, it2 = rt;
    rn.Fragment = n2, rn.jsx = Nn, rn.jsxs = it2;
  }()), rn;
}
false ? ho.exports = fh() : ho.exports = hh();
var Ho = ho.exports;
var _n = Ho.Fragment;
var Me = Ho.jsx;
var Fe = Ho.jsxs;
function dh(t2) {
  return ke.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, t2), ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M15.25 10.75L12 14.25L8.75 10.75"
  }));
}
function ph(t2) {
  return ke.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, t2), ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M13.25 8.75L9.75 12L13.25 15.25"
  }));
}
function mh(t2) {
  return ke.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, t2), ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M17.25 6.75L6.75 17.25"
  }), ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M6.75 6.75L17.25 17.25"
  }));
}
function gh(t2) {
  return ke.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, t2), ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M6.5 15.25V15.25C5.5335 15.25 4.75 14.4665 4.75 13.5V6.75C4.75 5.64543 5.64543 4.75 6.75 4.75H13.5C14.4665 4.75 15.25 5.5335 15.25 6.5V6.5"
  }), ke.createElement("rect", {
    width: 10.5,
    height: 10.5,
    x: 8.75,
    y: 8.75,
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    rx: 2
  }));
}
function yh(t2) {
  return ke.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, t2), ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M15.75 8.75L19.25 12L15.75 15.25"
  }), ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M19 12H10.75"
  }), ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M15.25 4.75H6.75C5.64543 4.75 4.75 5.64543 4.75 6.75V17.25C4.75 18.3546 5.64543 19.25 6.75 19.25H15.25"
  }));
}
function lc(t2) {
  return ke.createElement("svg", Object.assign({
    width: 24,
    height: 24,
    fill: "none",
    viewBox: "0 0 24 24"
  }, t2), ke.createElement("circle", {
    cx: 12,
    cy: 8,
    r: 3.25,
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5
  }), ke.createElement("path", {
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1.5,
    d: "M6.8475 19.25H17.1525C18.2944 19.25 19.174 18.2681 18.6408 17.2584C17.8563 15.7731 16.068 14 12 14C7.93201 14 6.14367 15.7731 5.35924 17.2584C4.82597 18.2681 5.70558 19.25 6.8475 19.25Z"
  }));
}
var Ko = {};
var fc = { exports: {} };
(function(t2, e2) {
  (function(r2, n2) {
    t2.exports = n2();
  })(ge2, function() {
    var r2 = function(S2) {
      return n2(S2) && !i2(S2);
    };
    function n2(M3) {
      return !!M3 && typeof M3 == "object";
    }
    function i2(M3) {
      var S2 = Object.prototype.toString.call(M3);
      return S2 === "[object RegExp]" || S2 === "[object Date]" || a2(M3);
    }
    var o2 = typeof Symbol == "function" && Symbol.for, s2 = o2 ? Symbol.for("react.element") : 60103;
    function a2(M3) {
      return M3.$$typeof === s2;
    }
    function f2(M3) {
      return Array.isArray(M3) ? [] : {};
    }
    function p2(M3, S2) {
      return S2.clone !== false && S2.isMergeableObject(M3) ? N11(f2(M3), M3, S2) : M3;
    }
    function d2(M3, S2, Y2) {
      return M3.concat(S2).map(function(W2) {
        return p2(W2, Y2);
      });
    }
    function y2(M3, S2) {
      if (!S2.customMerge)
        return N11;
      var Y2 = S2.customMerge(M3);
      return typeof Y2 == "function" ? Y2 : N11;
    }
    function v3(M3) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(M3).filter(function(S2) {
        return M3.propertyIsEnumerable(S2);
      }) : [];
    }
    function w3(M3) {
      return Object.keys(M3).concat(v3(M3));
    }
    function I3(M3, S2, Y2) {
      var W2 = {};
      return Y2.isMergeableObject(M3) && w3(M3).forEach(function(Q3) {
        W2[Q3] = p2(M3[Q3], Y2);
      }), w3(S2).forEach(function(Q3) {
        !Y2.isMergeableObject(S2[Q3]) || !M3[Q3] ? W2[Q3] = p2(S2[Q3], Y2) : W2[Q3] = y2(Q3, Y2)(M3[Q3], S2[Q3], Y2);
      }), W2;
    }
    function N11(M3, S2, Y2) {
      Y2 = Y2 || {}, Y2.arrayMerge = Y2.arrayMerge || d2, Y2.isMergeableObject = Y2.isMergeableObject || r2;
      var W2 = Array.isArray(S2), Q3 = Array.isArray(M3), X3 = W2 === Q3;
      return X3 ? W2 ? Y2.arrayMerge(M3, S2, Y2) : I3(M3, S2, Y2) : p2(S2, Y2);
    }
    N11.all = function(S2, Y2) {
      if (!Array.isArray(S2))
        throw new Error("first argument should be an array");
      return S2.reduce(function(W2, Q3) {
        return N11(W2, Q3, Y2);
      }, {});
    };
    var k2 = N11;
    return k2;
  });
})(fc);
var hc = fc.exports;
var pi = {};
pi.__esModule = true;
pi.default = void 0;
var fa = vh(import_react.default);
function vh(t2) {
  if (t2 && t2.__esModule)
    return t2;
  var e2 = {};
  if (t2 != null) {
    for (var r2 in t2)
      if (Object.prototype.hasOwnProperty.call(t2, r2)) {
        var n2 = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(t2, r2) : {};
        n2.get || n2.set ? Object.defineProperty(e2, r2, n2) : e2[r2] = t2[r2];
      }
  }
  return e2.default = t2, e2;
}
function wh(t2, e2) {
  t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, t2.__proto__ = e2;
}
function _h(t2, e2, r2) {
  return e2 in t2 ? Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }) : t2[e2] = r2, t2;
}
function bh(t2, e2) {
  var r2, n2;
  return n2 = r2 = function(i2) {
    wh(o2, i2);
    function o2() {
      return i2.apply(this, arguments) || this;
    }
    var s2 = o2.prototype;
    return s2.render = function() {
      return fa.createElement(e2.Provider, {
        value: this.props.theme
      }, this.props.children);
    }, o2;
  }(fa.Component), _h(r2, "defaultProps", {
    theme: t2
  }), n2;
}
var xh = bh;
pi.default = xh;
var mi = {};
var Fn = { exports: {} };
var Ue = {};
var da;
function Eh() {
  return da || (da = 1, function() {
    var t2 = typeof Symbol == "function" && Symbol.for, e2 = t2 ? Symbol.for("react.element") : 60103, r2 = t2 ? Symbol.for("react.portal") : 60106, n2 = t2 ? Symbol.for("react.fragment") : 60107, i2 = t2 ? Symbol.for("react.strict_mode") : 60108, o2 = t2 ? Symbol.for("react.profiler") : 60114, s2 = t2 ? Symbol.for("react.provider") : 60109, a2 = t2 ? Symbol.for("react.context") : 60110, f2 = t2 ? Symbol.for("react.async_mode") : 60111, p2 = t2 ? Symbol.for("react.concurrent_mode") : 60111, d2 = t2 ? Symbol.for("react.forward_ref") : 60112, y2 = t2 ? Symbol.for("react.suspense") : 60113, v3 = t2 ? Symbol.for("react.suspense_list") : 60120, w3 = t2 ? Symbol.for("react.memo") : 60115, I3 = t2 ? Symbol.for("react.lazy") : 60116, N11 = t2 ? Symbol.for("react.block") : 60121, k2 = t2 ? Symbol.for("react.fundamental") : 60117, M3 = t2 ? Symbol.for("react.responder") : 60118, S2 = t2 ? Symbol.for("react.scope") : 60119;
    function Y2(E3) {
      return typeof E3 == "string" || typeof E3 == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      E3 === n2 || E3 === p2 || E3 === o2 || E3 === i2 || E3 === y2 || E3 === v3 || typeof E3 == "object" && E3 !== null && (E3.$$typeof === I3 || E3.$$typeof === w3 || E3.$$typeof === s2 || E3.$$typeof === a2 || E3.$$typeof === d2 || E3.$$typeof === k2 || E3.$$typeof === M3 || E3.$$typeof === S2 || E3.$$typeof === N11);
    }
    function W2(E3) {
      if (typeof E3 == "object" && E3 !== null) {
        var V2 = E3.$$typeof;
        switch (V2) {
          case e2:
            var K2 = E3.type;
            switch (K2) {
              case f2:
              case p2:
              case n2:
              case o2:
              case i2:
              case y2:
                return K2;
              default:
                var $3 = K2 && K2.$$typeof;
                switch ($3) {
                  case a2:
                  case d2:
                  case I3:
                  case w3:
                  case s2:
                    return $3;
                  default:
                    return V2;
                }
            }
          case r2:
            return V2;
        }
      }
    }
    var Q3 = f2, X3 = p2, ne = a2, ue = s2, se = e2, ie = d2, O2 = n2, c2 = I3, m2 = w3, _3 = r2, T3 = o2, C3 = i2, L2 = y2, H2 = false;
    function P3(E3) {
      return H2 || (H2 = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), l2(E3) || W2(E3) === f2;
    }
    function l2(E3) {
      return W2(E3) === p2;
    }
    function x3(E3) {
      return W2(E3) === a2;
    }
    function re(E3) {
      return W2(E3) === s2;
    }
    function ae(E3) {
      return typeof E3 == "object" && E3 !== null && E3.$$typeof === e2;
    }
    function G2(E3) {
      return W2(E3) === d2;
    }
    function ce(E3) {
      return W2(E3) === n2;
    }
    function me(E3) {
      return W2(E3) === I3;
    }
    function ye(E3) {
      return W2(E3) === w3;
    }
    function xe(E3) {
      return W2(E3) === r2;
    }
    function ve(E3) {
      return W2(E3) === o2;
    }
    function b2(E3) {
      return W2(E3) === i2;
    }
    function R2(E3) {
      return W2(E3) === y2;
    }
    Ue.AsyncMode = Q3, Ue.ConcurrentMode = X3, Ue.ContextConsumer = ne, Ue.ContextProvider = ue, Ue.Element = se, Ue.ForwardRef = ie, Ue.Fragment = O2, Ue.Lazy = c2, Ue.Memo = m2, Ue.Portal = _3, Ue.Profiler = T3, Ue.StrictMode = C3, Ue.Suspense = L2, Ue.isAsyncMode = P3, Ue.isConcurrentMode = l2, Ue.isContextConsumer = x3, Ue.isContextProvider = re, Ue.isElement = ae, Ue.isForwardRef = G2, Ue.isFragment = ce, Ue.isLazy = me, Ue.isMemo = ye, Ue.isPortal = xe, Ue.isProfiler = ve, Ue.isStrictMode = b2, Ue.isSuspense = R2, Ue.isValidElementType = Y2, Ue.typeOf = W2;
  }()), Ue;
}
var pa;
function zo() {
  return pa || (pa = 1, false ? Fn.exports = Th() : Fn.exports = Eh()), Fn.exports;
}
var Go = zo();
var Ah = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var Mh = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var Sh = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var dc = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var Yo = {};
Yo[Go.ForwardRef] = Sh;
Yo[Go.Memo] = dc;
function ma(t2) {
  return Go.isMemo(t2) ? dc : Yo[t2.$$typeof] || Ah;
}
var Ph = Object.defineProperty;
var Ch = Object.getOwnPropertyNames;
var ga = Object.getOwnPropertySymbols;
var Oh = Object.getOwnPropertyDescriptor;
var Rh = Object.getPrototypeOf;
var ya = Object.prototype;
function pc(t2, e2, r2) {
  if (typeof e2 != "string") {
    if (ya) {
      var n2 = Rh(e2);
      n2 && n2 !== ya && pc(t2, n2, r2);
    }
    var i2 = Ch(e2);
    ga && (i2 = i2.concat(ga(e2)));
    for (var o2 = ma(t2), s2 = ma(e2), a2 = 0; a2 < i2.length; ++a2) {
      var f2 = i2[a2];
      if (!Mh[f2] && !(r2 && r2[f2]) && !(s2 && s2[f2]) && !(o2 && o2[f2])) {
        var p2 = Oh(e2, f2);
        try {
          Ph(t2, f2, p2);
        } catch {
        }
      }
    }
  }
  return t2;
}
var Ih = pc;
mi.__esModule = true;
mi.default = void 0;
var nn = Dh(import_react.default);
var Bh = mc(hc);
var kh = mc(Ih);
function mc(t2) {
  return t2 && t2.__esModule ? t2 : { default: t2 };
}
function Dh(t2) {
  if (t2 && t2.__esModule)
    return t2;
  var e2 = {};
  if (t2 != null) {
    for (var r2 in t2)
      if (Object.prototype.hasOwnProperty.call(t2, r2)) {
        var n2 = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(t2, r2) : {};
        n2.get || n2.set ? Object.defineProperty(e2, r2, n2) : e2[r2] = t2[r2];
      }
  }
  return e2.default = t2, e2;
}
function Qn() {
  return Qn = Object.assign || function(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var r2 = arguments[e2];
      for (var n2 in r2)
        Object.prototype.hasOwnProperty.call(r2, n2) && (t2[n2] = r2[n2]);
    }
    return t2;
  }, Qn.apply(this, arguments);
}
function Lh(t2, e2) {
  if (t2 == null)
    return {};
  var r2 = {}, n2 = Object.keys(t2), i2, o2;
  for (o2 = 0; o2 < n2.length; o2++)
    i2 = n2[o2], !(e2.indexOf(i2) >= 0) && (r2[i2] = t2[i2]);
  return r2;
}
function va(t2) {
  if (t2 === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t2;
}
function Nh(t2, e2) {
  t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, t2.__proto__ = e2;
}
function wa(t2, e2, r2) {
  return e2 in t2 ? Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }) : t2[e2] = r2, t2;
}
var Uh = function(e2, r2) {
  return function(i2) {
    var o2 = function(a2) {
      Nh(f2, a2);
      function f2() {
        for (var d2, y2 = arguments.length, v3 = new Array(y2), w3 = 0; w3 < y2; w3++)
          v3[w3] = arguments[w3];
        return d2 = a2.call.apply(a2, [this].concat(v3)) || this, wa(va(d2), "_previous", void 0), wa(va(d2), "_merge", function(I3, N11) {
          var k2 = d2._previous;
          if (k2 && k2.a === I3 && k2.b === N11)
            return k2.result;
          var M3 = I3 && N11 && I3 !== N11 ? (0, Bh.default)(I3, N11) : I3 || N11;
          return d2._previous = {
            a: I3,
            b: N11,
            result: M3
          }, M3;
        }), d2;
      }
      var p2 = f2.prototype;
      return p2.render = function() {
        var y2 = this, v3 = this.props, w3 = v3._reactThemeProviderForwardedRef, I3 = Lh(v3, ["_reactThemeProviderForwardedRef"]);
        return nn.createElement(r2.Consumer, null, function(N11) {
          return nn.createElement(i2, Qn({}, I3, {
            theme: y2._merge(N11, I3.theme),
            ref: w3
          }));
        });
      }, f2;
    }(nn.Component), s2 = nn.forwardRef(function(a2, f2) {
      return nn.createElement(o2, Qn({}, a2, {
        _reactThemeProviderForwardedRef: f2
      }));
    });
    return s2.displayName = "withTheme(" + (i2.displayName || i2.name) + ")", (0, kh.default)(s2, i2), s2;
  };
};
var Fh = Uh;
mi.default = Fh;
Ko.__esModule = true;
Ko.default = Wh;
var Ni = qh(import_react.default);
var jh = Xo(hc);
var $h = Xo(pi);
var Vh = Xo(mi);
function Xo(t2) {
  return t2 && t2.__esModule ? t2 : { default: t2 };
}
function qh(t2) {
  if (t2 && t2.__esModule)
    return t2;
  var e2 = {};
  if (t2 != null) {
    for (var r2 in t2)
      if (Object.prototype.hasOwnProperty.call(t2, r2)) {
        var n2 = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(t2, r2) : {};
        n2.get || n2.set ? Object.defineProperty(e2, r2, n2) : e2[r2] = t2[r2];
      }
  }
  return e2.default = t2, e2;
}
function Wh(t2) {
  var e2 = Ni.createContext(t2), r2 = (0, $h.default)(t2, e2), n2 = (0, Vh.default)(r2, e2), i2 = function(s2) {
    var a2 = Ni.useContext(e2), f2 = Ni.useMemo(function() {
      return a2 && s2 ? (0, jh.default)(a2, s2) : a2 || s2;
    }, [a2, s2]);
    return f2;
  };
  return {
    ThemeContext: e2,
    ThemeProvider: r2,
    withTheme: n2,
    useTheme: i2
  };
}
var Hh = zh(Ko);
var Kh = Hh.default;
function zh(t2) {
  return t2 && t2.__esModule ? t2 : { default: t2 };
}
var gc = {
  primaryText: "0, 0, 0",
  background: "255, 255, 255",
  secondaryText: "146, 146, 147",
  light: "242, 242, 247"
};
var Gh = {
  primaryText: "240, 240, 240",
  background: "26, 27, 31",
  secondaryText: "161, 161, 161",
  light: "44, 45, 49"
};
var Yh = {
  displayTheme: "light",
  accent: {
    r: 0,
    g: 0,
    b: 0
  },
  titleHighlight: {
    r: 0,
    g: 122,
    b: 255
  },
  radius: "default",
  font: {
    fontFamily: "Manrope"
  }
};
var yc = Kh({
  displayTheme: "light",
  theme: "0, 0, 0",
  themeConfig: Yh,
  ...gc
});
var { ThemeProvider: Xh, useTheme: U1 } = yc;
var st = yc.withTheme || ((t2) => t2);
function Zh() {
  const { state: t2, dispatch: e2 } = xt2(), r2 = Gt2();
  return (0, import_react.useEffect)(() => {
    (async () => r2 && e2({
      type: "UPDATE_PERMISSIONS",
      payload: await r2.getPermissions()
    }))();
  }, [e2]), t2.givenPermissions;
}
function Jh() {
  const t2 = (0, import_react.useRef)(false), { state: e2, dispatch: r2 } = xt2(), n2 = Gt2(), { permissions: i2, ensurePermissions: o2 } = e2.config;
  (0, import_react.useEffect)(() => {
    async function s2() {
      if (!n2)
        return f2(), r2({
          type: "UPDATE_PERMISSIONS",
          payload: []
        });
      try {
        const d2 = await n2.getPermissions(), y2 = Vo(
          i2,
          d2
        );
        if (r2({
          type: "UPDATE_PERMISSIONS",
          payload: d2
        }), i2.length === 0 && o2) {
          f2();
          return;
        }
        !y2 && o2 && !t2.current && (t2.current = true, await n2.connect(
          i2,
          e2.config.appInfo,
          e2.config.gatewayConfig
        )), d2.length === 0 && f2();
      } catch {
        f2(), r2({
          type: "UPDATE_PERMISSIONS",
          payload: []
        });
      }
    }
    async function a2(d2) {
      d2.data.type === "connect_result" && await s2();
    }
    function f2() {
      !e2.activeAddress && !e2.activeStrategy || (r2({ type: "DISCONNECT" }), localStorage.removeItem(Sn));
    }
    s2(), addEventListener("arweaveWalletLoaded", s2), addEventListener("focus", s2), addEventListener("message", a2);
    let p2;
    return n2 && (p2 = n2.addAddressEvent(s2)), () => {
      removeEventListener("arweaveWalletLoaded", s2), removeEventListener("focus", s2), removeEventListener("message", a2), n2 && p2 && n2.removeAddressEvent(p2);
    };
  }, [n2, i2, r2]);
}
function Zo() {
  const [t2, e2] = (0, import_react.useState)(false), r2 = Gt2(), n2 = Zh(), { state: i2 } = xt2(), { permissions: o2, ensurePermissions: s2 } = i2.config;
  return (0, import_react.useEffect)(() => {
    if (!r2)
      return e2(false);
    e2(s2 ? Vo(o2, n2) : n2.length > 0);
  }, [r2, n2, o2, s2]), t2;
}
function Qh() {
  const t2 = Gt2(), { dispatch: e2 } = xt2(), r2 = Zo();
  async function n2() {
    if (!t2 || !r2)
      throw new Error("[Arweave Wallet Kit] Not yet connected");
    try {
      await t2.disconnect(), localStorage.removeItem(Sn), e2({ type: "DISCONNECT" });
    } catch (i2) {
      throw new Error(
        `[Arweave Wallet Kit] Could not disconnect
` + ((i2 == null ? void 0 : i2.message) || i2)
      );
    }
  }
  return n2;
}
function ed() {
  const { dispatch: t2 } = xt2(), e2 = Zo();
  return () => new Promise((n2, i2) => {
    if (e2)
      return i2("[Arweave Wallet Kit] Already connected");
    t2({
      type: "OPEN_MODAL",
      payload: "connect"
    });
    async function o2(s2) {
      s2.data.type === "connect_result" && (removeEventListener("message", o2), s2.data.res ? n2() : i2("[Arweave Wallet Kit] User cancelled the connection"));
    }
    addEventListener("message", o2);
  });
}
function Jo() {
  const t2 = Zo(), e2 = ed(), r2 = Qh();
  return {
    connected: t2,
    connect: e2,
    disconnect: r2
  };
}
function td() {
  const { state: t2, dispatch: e2 } = xt2();
  return (0, import_react.useEffect)(() => {
    t2.activeStrategy || t2.activeModal !== "profile" || e2({ type: "CLOSE_MODAL" });
  }, [t2, e2]), {
    setOpen(r2) {
      if (!t2.activeStrategy)
        throw new Error("[Arweave Wallet Kit] App not connected");
      e2(r2 ? {
        type: "OPEN_MODAL",
        payload: "profile"
      } : { type: "CLOSE_MODAL" });
    },
    open: t2.activeModal === "profile"
  };
}
var jn = {};
var Qo = {};
var vc = { exports: {} };
(function(t2) {
  (function(e2) {
    var r2, n2 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, i2 = Math.ceil, o2 = Math.floor, s2 = "[BigNumber Error] ", a2 = s2 + "Number primitive has more than 15 significant digits: ", f2 = 1e14, p2 = 14, d2 = 9007199254740991, y2 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], v3 = 1e7, w3 = 1e9;
    function I3(X3) {
      var ne, ue, se, ie = G2.prototype = { constructor: G2, toString: null, valueOf: null }, O2 = new G2(1), c2 = 20, m2 = 4, _3 = -7, T3 = 21, C3 = -1e7, L2 = 1e7, H2 = false, P3 = 1, l2 = 0, x3 = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: " ",
        // non-breaking space
        suffix: ""
      }, re = "0123456789abcdefghijklmnopqrstuvwxyz", ae = true;
      function G2(b2, R2) {
        var E3, V2, K2, $3, J2, j2, q2, Z3, ee2 = this;
        if (!(ee2 instanceof G2))
          return new G2(b2, R2);
        if (R2 == null) {
          if (b2 && b2._isBigNumber === true) {
            ee2.s = b2.s, !b2.c || b2.e > L2 ? ee2.c = ee2.e = null : b2.e < C3 ? ee2.c = [ee2.e = 0] : (ee2.e = b2.e, ee2.c = b2.c.slice());
            return;
          }
          if ((j2 = typeof b2 == "number") && b2 * 0 == 0) {
            if (ee2.s = 1 / b2 < 0 ? (b2 = -b2, -1) : 1, b2 === ~~b2) {
              for ($3 = 0, J2 = b2; J2 >= 10; J2 /= 10, $3++)
                ;
              $3 > L2 ? ee2.c = ee2.e = null : (ee2.e = $3, ee2.c = [b2]);
              return;
            }
            Z3 = String(b2);
          } else {
            if (!n2.test(Z3 = String(b2)))
              return se(ee2, Z3, j2);
            ee2.s = Z3.charCodeAt(0) == 45 ? (Z3 = Z3.slice(1), -1) : 1;
          }
          ($3 = Z3.indexOf(".")) > -1 && (Z3 = Z3.replace(".", "")), (J2 = Z3.search(/e/i)) > 0 ? ($3 < 0 && ($3 = J2), $3 += +Z3.slice(J2 + 1), Z3 = Z3.substring(0, J2)) : $3 < 0 && ($3 = Z3.length);
        } else {
          if (S2(R2, 2, re.length, "Base"), R2 == 10 && ae)
            return ee2 = new G2(b2), xe(ee2, c2 + ee2.e + 1, m2);
          if (Z3 = String(b2), j2 = typeof b2 == "number") {
            if (b2 * 0 != 0)
              return se(ee2, Z3, j2, R2);
            if (ee2.s = 1 / b2 < 0 ? (Z3 = Z3.slice(1), -1) : 1, G2.DEBUG && Z3.replace(/^0\.0*|\./, "").length > 15)
              throw Error(a2 + b2);
          } else
            ee2.s = Z3.charCodeAt(0) === 45 ? (Z3 = Z3.slice(1), -1) : 1;
          for (E3 = re.slice(0, R2), $3 = J2 = 0, q2 = Z3.length; J2 < q2; J2++)
            if (E3.indexOf(V2 = Z3.charAt(J2)) < 0) {
              if (V2 == ".") {
                if (J2 > $3) {
                  $3 = q2;
                  continue;
                }
              } else if (!K2 && (Z3 == Z3.toUpperCase() && (Z3 = Z3.toLowerCase()) || Z3 == Z3.toLowerCase() && (Z3 = Z3.toUpperCase()))) {
                K2 = true, J2 = -1, $3 = 0;
                continue;
              }
              return se(ee2, String(b2), j2, R2);
            }
          j2 = false, Z3 = ue(Z3, R2, 10, ee2.s), ($3 = Z3.indexOf(".")) > -1 ? Z3 = Z3.replace(".", "") : $3 = Z3.length;
        }
        for (J2 = 0; Z3.charCodeAt(J2) === 48; J2++)
          ;
        for (q2 = Z3.length; Z3.charCodeAt(--q2) === 48; )
          ;
        if (Z3 = Z3.slice(J2, ++q2)) {
          if (q2 -= J2, j2 && G2.DEBUG && q2 > 15 && (b2 > d2 || b2 !== o2(b2)))
            throw Error(a2 + ee2.s * b2);
          if (($3 = $3 - J2 - 1) > L2)
            ee2.c = ee2.e = null;
          else if ($3 < C3)
            ee2.c = [ee2.e = 0];
          else {
            if (ee2.e = $3, ee2.c = [], J2 = ($3 + 1) % p2, $3 < 0 && (J2 += p2), J2 < q2) {
              for (J2 && ee2.c.push(+Z3.slice(0, J2)), q2 -= p2; J2 < q2; )
                ee2.c.push(+Z3.slice(J2, J2 += p2));
              J2 = p2 - (Z3 = Z3.slice(J2)).length;
            } else
              J2 -= q2;
            for (; J2--; Z3 += "0")
              ;
            ee2.c.push(+Z3);
          }
        } else
          ee2.c = [ee2.e = 0];
      }
      G2.clone = I3, G2.ROUND_UP = 0, G2.ROUND_DOWN = 1, G2.ROUND_CEIL = 2, G2.ROUND_FLOOR = 3, G2.ROUND_HALF_UP = 4, G2.ROUND_HALF_DOWN = 5, G2.ROUND_HALF_EVEN = 6, G2.ROUND_HALF_CEIL = 7, G2.ROUND_HALF_FLOOR = 8, G2.EUCLID = 9, G2.config = G2.set = function(b2) {
        var R2, E3;
        if (b2 != null)
          if (typeof b2 == "object") {
            if (b2.hasOwnProperty(R2 = "DECIMAL_PLACES") && (E3 = b2[R2], S2(E3, 0, w3, R2), c2 = E3), b2.hasOwnProperty(R2 = "ROUNDING_MODE") && (E3 = b2[R2], S2(E3, 0, 8, R2), m2 = E3), b2.hasOwnProperty(R2 = "EXPONENTIAL_AT") && (E3 = b2[R2], E3 && E3.pop ? (S2(E3[0], -w3, 0, R2), S2(E3[1], 0, w3, R2), _3 = E3[0], T3 = E3[1]) : (S2(E3, -w3, w3, R2), _3 = -(T3 = E3 < 0 ? -E3 : E3))), b2.hasOwnProperty(R2 = "RANGE"))
              if (E3 = b2[R2], E3 && E3.pop)
                S2(E3[0], -w3, -1, R2), S2(E3[1], 1, w3, R2), C3 = E3[0], L2 = E3[1];
              else if (S2(E3, -w3, w3, R2), E3)
                C3 = -(L2 = E3 < 0 ? -E3 : E3);
              else
                throw Error(s2 + R2 + " cannot be zero: " + E3);
            if (b2.hasOwnProperty(R2 = "CRYPTO"))
              if (E3 = b2[R2], E3 === !!E3)
                if (E3)
                  if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                    H2 = E3;
                  else
                    throw H2 = !E3, Error(s2 + "crypto unavailable");
                else
                  H2 = E3;
              else
                throw Error(s2 + R2 + " not true or false: " + E3);
            if (b2.hasOwnProperty(R2 = "MODULO_MODE") && (E3 = b2[R2], S2(E3, 0, 9, R2), P3 = E3), b2.hasOwnProperty(R2 = "POW_PRECISION") && (E3 = b2[R2], S2(E3, 0, w3, R2), l2 = E3), b2.hasOwnProperty(R2 = "FORMAT"))
              if (E3 = b2[R2], typeof E3 == "object")
                x3 = E3;
              else
                throw Error(s2 + R2 + " not an object: " + E3);
            if (b2.hasOwnProperty(R2 = "ALPHABET"))
              if (E3 = b2[R2], typeof E3 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(E3))
                ae = E3.slice(0, 10) == "0123456789", re = E3;
              else
                throw Error(s2 + R2 + " invalid: " + E3);
          } else
            throw Error(s2 + "Object expected: " + b2);
        return {
          DECIMAL_PLACES: c2,
          ROUNDING_MODE: m2,
          EXPONENTIAL_AT: [_3, T3],
          RANGE: [C3, L2],
          CRYPTO: H2,
          MODULO_MODE: P3,
          POW_PRECISION: l2,
          FORMAT: x3,
          ALPHABET: re
        };
      }, G2.isBigNumber = function(b2) {
        if (!b2 || b2._isBigNumber !== true)
          return false;
        if (!G2.DEBUG)
          return true;
        var R2, E3, V2 = b2.c, K2 = b2.e, $3 = b2.s;
        e:
          if ({}.toString.call(V2) == "[object Array]") {
            if (($3 === 1 || $3 === -1) && K2 >= -w3 && K2 <= w3 && K2 === o2(K2)) {
              if (V2[0] === 0) {
                if (K2 === 0 && V2.length === 1)
                  return true;
                break e;
              }
              if (R2 = (K2 + 1) % p2, R2 < 1 && (R2 += p2), String(V2[0]).length == R2) {
                for (R2 = 0; R2 < V2.length; R2++)
                  if (E3 = V2[R2], E3 < 0 || E3 >= f2 || E3 !== o2(E3))
                    break e;
                if (E3 !== 0)
                  return true;
              }
            }
          } else if (V2 === null && K2 === null && ($3 === null || $3 === 1 || $3 === -1))
            return true;
        throw Error(s2 + "Invalid BigNumber: " + b2);
      }, G2.maximum = G2.max = function() {
        return me(arguments, -1);
      }, G2.minimum = G2.min = function() {
        return me(arguments, 1);
      }, G2.random = function() {
        var b2 = 9007199254740992, R2 = Math.random() * b2 & 2097151 ? function() {
          return o2(Math.random() * b2);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(E3) {
          var V2, K2, $3, J2, j2, q2 = 0, Z3 = [], ee2 = new G2(O2);
          if (E3 == null ? E3 = c2 : S2(E3, 0, w3), J2 = i2(E3 / p2), H2)
            if (crypto.getRandomValues) {
              for (V2 = crypto.getRandomValues(new Uint32Array(J2 *= 2)); q2 < J2; )
                j2 = V2[q2] * 131072 + (V2[q2 + 1] >>> 11), j2 >= 9e15 ? (K2 = crypto.getRandomValues(new Uint32Array(2)), V2[q2] = K2[0], V2[q2 + 1] = K2[1]) : (Z3.push(j2 % 1e14), q2 += 2);
              q2 = J2 / 2;
            } else if (crypto.randomBytes) {
              for (V2 = crypto.randomBytes(J2 *= 7); q2 < J2; )
                j2 = (V2[q2] & 31) * 281474976710656 + V2[q2 + 1] * 1099511627776 + V2[q2 + 2] * 4294967296 + V2[q2 + 3] * 16777216 + (V2[q2 + 4] << 16) + (V2[q2 + 5] << 8) + V2[q2 + 6], j2 >= 9e15 ? crypto.randomBytes(7).copy(V2, q2) : (Z3.push(j2 % 1e14), q2 += 7);
              q2 = J2 / 7;
            } else
              throw H2 = false, Error(s2 + "crypto unavailable");
          if (!H2)
            for (; q2 < J2; )
              j2 = R2(), j2 < 9e15 && (Z3[q2++] = j2 % 1e14);
          for (J2 = Z3[--q2], E3 %= p2, J2 && E3 && (j2 = y2[p2 - E3], Z3[q2] = o2(J2 / j2) * j2); Z3[q2] === 0; Z3.pop(), q2--)
            ;
          if (q2 < 0)
            Z3 = [$3 = 0];
          else {
            for ($3 = -1; Z3[0] === 0; Z3.splice(0, 1), $3 -= p2)
              ;
            for (q2 = 1, j2 = Z3[0]; j2 >= 10; j2 /= 10, q2++)
              ;
            q2 < p2 && ($3 -= p2 - q2);
          }
          return ee2.e = $3, ee2.c = Z3, ee2;
        };
      }(), G2.sum = function() {
        for (var b2 = 1, R2 = arguments, E3 = new G2(R2[0]); b2 < R2.length; )
          E3 = E3.plus(R2[b2++]);
        return E3;
      }, ue = /* @__PURE__ */ function() {
        var b2 = "0123456789";
        function R2(E3, V2, K2, $3) {
          for (var J2, j2 = [0], q2, Z3 = 0, ee2 = E3.length; Z3 < ee2; ) {
            for (q2 = j2.length; q2--; j2[q2] *= V2)
              ;
            for (j2[0] += $3.indexOf(E3.charAt(Z3++)), J2 = 0; J2 < j2.length; J2++)
              j2[J2] > K2 - 1 && (j2[J2 + 1] == null && (j2[J2 + 1] = 0), j2[J2 + 1] += j2[J2] / K2 | 0, j2[J2] %= K2);
          }
          return j2.reverse();
        }
        return function(E3, V2, K2, $3, J2) {
          var j2, q2, Z3, ee2, oe2, de, Ee, Ae, U2 = E3.indexOf("."), te2 = c2, g2 = m2;
          for (U2 >= 0 && (ee2 = l2, l2 = 0, E3 = E3.replace(".", ""), Ae = new G2(V2), de = Ae.pow(E3.length - U2), l2 = ee2, Ae.c = R2(
            Q3(k2(de.c), de.e, "0"),
            10,
            K2,
            b2
          ), Ae.e = Ae.c.length), Ee = R2(E3, V2, K2, J2 ? (j2 = re, b2) : (j2 = b2, re)), Z3 = ee2 = Ee.length; Ee[--ee2] == 0; Ee.pop())
            ;
          if (!Ee[0])
            return j2.charAt(0);
          if (U2 < 0 ? --Z3 : (de.c = Ee, de.e = Z3, de.s = $3, de = ne(de, Ae, te2, g2, K2), Ee = de.c, oe2 = de.r, Z3 = de.e), q2 = Z3 + te2 + 1, U2 = Ee[q2], ee2 = K2 / 2, oe2 = oe2 || q2 < 0 || Ee[q2 + 1] != null, oe2 = g2 < 4 ? (U2 != null || oe2) && (g2 == 0 || g2 == (de.s < 0 ? 3 : 2)) : U2 > ee2 || U2 == ee2 && (g2 == 4 || oe2 || g2 == 6 && Ee[q2 - 1] & 1 || g2 == (de.s < 0 ? 8 : 7)), q2 < 1 || !Ee[0])
            E3 = oe2 ? Q3(j2.charAt(1), -te2, j2.charAt(0)) : j2.charAt(0);
          else {
            if (Ee.length = q2, oe2)
              for (--K2; ++Ee[--q2] > K2; )
                Ee[q2] = 0, q2 || (++Z3, Ee = [1].concat(Ee));
            for (ee2 = Ee.length; !Ee[--ee2]; )
              ;
            for (U2 = 0, E3 = ""; U2 <= ee2; E3 += j2.charAt(Ee[U2++]))
              ;
            E3 = Q3(E3, Z3, j2.charAt(0));
          }
          return E3;
        };
      }(), ne = /* @__PURE__ */ function() {
        function b2(V2, K2, $3) {
          var J2, j2, q2, Z3, ee2 = 0, oe2 = V2.length, de = K2 % v3, Ee = K2 / v3 | 0;
          for (V2 = V2.slice(); oe2--; )
            q2 = V2[oe2] % v3, Z3 = V2[oe2] / v3 | 0, J2 = Ee * q2 + Z3 * de, j2 = de * q2 + J2 % v3 * v3 + ee2, ee2 = (j2 / $3 | 0) + (J2 / v3 | 0) + Ee * Z3, V2[oe2] = j2 % $3;
          return ee2 && (V2 = [ee2].concat(V2)), V2;
        }
        function R2(V2, K2, $3, J2) {
          var j2, q2;
          if ($3 != J2)
            q2 = $3 > J2 ? 1 : -1;
          else
            for (j2 = q2 = 0; j2 < $3; j2++)
              if (V2[j2] != K2[j2]) {
                q2 = V2[j2] > K2[j2] ? 1 : -1;
                break;
              }
          return q2;
        }
        function E3(V2, K2, $3, J2) {
          for (var j2 = 0; $3--; )
            V2[$3] -= j2, j2 = V2[$3] < K2[$3] ? 1 : 0, V2[$3] = j2 * J2 + V2[$3] - K2[$3];
          for (; !V2[0] && V2.length > 1; V2.splice(0, 1))
            ;
        }
        return function(V2, K2, $3, J2, j2) {
          var q2, Z3, ee2, oe2, de, Ee, Ae, U2, te2, g2, u2, h2, A2, B3, z3, F2, fe, we = V2.s == K2.s ? 1 : -1, _e = V2.c, be = K2.c;
          if (!_e || !_e[0] || !be || !be[0])
            return new G2(
              // Return NaN if either NaN, or both Infinity or 0.
              !V2.s || !K2.s || (_e ? be && _e[0] == be[0] : !be) ? NaN : (
                // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                _e && _e[0] == 0 || !be ? we * 0 : we / 0
              )
            );
          for (U2 = new G2(we), te2 = U2.c = [], Z3 = V2.e - K2.e, we = $3 + Z3 + 1, j2 || (j2 = f2, Z3 = N11(V2.e / p2) - N11(K2.e / p2), we = we / p2 | 0), ee2 = 0; be[ee2] == (_e[ee2] || 0); ee2++)
            ;
          if (be[ee2] > (_e[ee2] || 0) && Z3--, we < 0)
            te2.push(1), oe2 = true;
          else {
            for (B3 = _e.length, F2 = be.length, ee2 = 0, we += 2, de = o2(j2 / (be[0] + 1)), de > 1 && (be = b2(be, de, j2), _e = b2(_e, de, j2), F2 = be.length, B3 = _e.length), A2 = F2, g2 = _e.slice(0, F2), u2 = g2.length; u2 < F2; g2[u2++] = 0)
              ;
            fe = be.slice(), fe = [0].concat(fe), z3 = be[0], be[1] >= j2 / 2 && z3++;
            do {
              if (de = 0, q2 = R2(be, g2, F2, u2), q2 < 0) {
                if (h2 = g2[0], F2 != u2 && (h2 = h2 * j2 + (g2[1] || 0)), de = o2(h2 / z3), de > 1)
                  for (de >= j2 && (de = j2 - 1), Ee = b2(be, de, j2), Ae = Ee.length, u2 = g2.length; R2(Ee, g2, Ae, u2) == 1; )
                    de--, E3(Ee, F2 < Ae ? fe : be, Ae, j2), Ae = Ee.length, q2 = 1;
                else
                  de == 0 && (q2 = de = 1), Ee = be.slice(), Ae = Ee.length;
                if (Ae < u2 && (Ee = [0].concat(Ee)), E3(g2, Ee, u2, j2), u2 = g2.length, q2 == -1)
                  for (; R2(be, g2, F2, u2) < 1; )
                    de++, E3(g2, F2 < u2 ? fe : be, u2, j2), u2 = g2.length;
              } else
                q2 === 0 && (de++, g2 = [0]);
              te2[ee2++] = de, g2[0] ? g2[u2++] = _e[A2] || 0 : (g2 = [_e[A2]], u2 = 1);
            } while ((A2++ < B3 || g2[0] != null) && we--);
            oe2 = g2[0] != null, te2[0] || te2.splice(0, 1);
          }
          if (j2 == f2) {
            for (ee2 = 1, we = te2[0]; we >= 10; we /= 10, ee2++)
              ;
            xe(U2, $3 + (U2.e = ee2 + Z3 * p2 - 1) + 1, J2, oe2);
          } else
            U2.e = Z3, U2.r = +oe2;
          return U2;
        };
      }();
      function ce(b2, R2, E3, V2) {
        var K2, $3, J2, j2, q2;
        if (E3 == null ? E3 = m2 : S2(E3, 0, 8), !b2.c)
          return b2.toString();
        if (K2 = b2.c[0], J2 = b2.e, R2 == null)
          q2 = k2(b2.c), q2 = V2 == 1 || V2 == 2 && (J2 <= _3 || J2 >= T3) ? W2(q2, J2) : Q3(q2, J2, "0");
        else if (b2 = xe(new G2(b2), R2, E3), $3 = b2.e, q2 = k2(b2.c), j2 = q2.length, V2 == 1 || V2 == 2 && (R2 <= $3 || $3 <= _3)) {
          for (; j2 < R2; q2 += "0", j2++)
            ;
          q2 = W2(q2, $3);
        } else if (R2 -= J2, q2 = Q3(q2, $3, "0"), $3 + 1 > j2) {
          if (--R2 > 0)
            for (q2 += "."; R2--; q2 += "0")
              ;
        } else if (R2 += $3 - j2, R2 > 0)
          for ($3 + 1 == j2 && (q2 += "."); R2--; q2 += "0")
            ;
        return b2.s < 0 && K2 ? "-" + q2 : q2;
      }
      function me(b2, R2) {
        for (var E3, V2, K2 = 1, $3 = new G2(b2[0]); K2 < b2.length; K2++)
          V2 = new G2(b2[K2]), (!V2.s || (E3 = M3($3, V2)) === R2 || E3 === 0 && $3.s === R2) && ($3 = V2);
        return $3;
      }
      function ye(b2, R2, E3) {
        for (var V2 = 1, K2 = R2.length; !R2[--K2]; R2.pop())
          ;
        for (K2 = R2[0]; K2 >= 10; K2 /= 10, V2++)
          ;
        return (E3 = V2 + E3 * p2 - 1) > L2 ? b2.c = b2.e = null : E3 < C3 ? b2.c = [b2.e = 0] : (b2.e = E3, b2.c = R2), b2;
      }
      se = /* @__PURE__ */ function() {
        var b2 = /^(-?)0([xbo])(?=\w[\w.]*$)/i, R2 = /^([^.]+)\.$/, E3 = /^\.([^.]+)$/, V2 = /^-?(Infinity|NaN)$/, K2 = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function($3, J2, j2, q2) {
          var Z3, ee2 = j2 ? J2 : J2.replace(K2, "");
          if (V2.test(ee2))
            $3.s = isNaN(ee2) ? null : ee2 < 0 ? -1 : 1;
          else {
            if (!j2 && (ee2 = ee2.replace(b2, function(oe2, de, Ee) {
              return Z3 = (Ee = Ee.toLowerCase()) == "x" ? 16 : Ee == "b" ? 2 : 8, !q2 || q2 == Z3 ? de : oe2;
            }), q2 && (Z3 = q2, ee2 = ee2.replace(R2, "$1").replace(E3, "0.$1")), J2 != ee2))
              return new G2(ee2, Z3);
            if (G2.DEBUG)
              throw Error(s2 + "Not a" + (q2 ? " base " + q2 : "") + " number: " + J2);
            $3.s = null;
          }
          $3.c = $3.e = null;
        };
      }();
      function xe(b2, R2, E3, V2) {
        var K2, $3, J2, j2, q2, Z3, ee2, oe2 = b2.c, de = y2;
        if (oe2) {
          e: {
            for (K2 = 1, j2 = oe2[0]; j2 >= 10; j2 /= 10, K2++)
              ;
            if ($3 = R2 - K2, $3 < 0)
              $3 += p2, J2 = R2, q2 = oe2[Z3 = 0], ee2 = o2(q2 / de[K2 - J2 - 1] % 10);
            else if (Z3 = i2(($3 + 1) / p2), Z3 >= oe2.length)
              if (V2) {
                for (; oe2.length <= Z3; oe2.push(0))
                  ;
                q2 = ee2 = 0, K2 = 1, $3 %= p2, J2 = $3 - p2 + 1;
              } else
                break e;
            else {
              for (q2 = j2 = oe2[Z3], K2 = 1; j2 >= 10; j2 /= 10, K2++)
                ;
              $3 %= p2, J2 = $3 - p2 + K2, ee2 = J2 < 0 ? 0 : o2(q2 / de[K2 - J2 - 1] % 10);
            }
            if (V2 = V2 || R2 < 0 || // Are there any non-zero digits after the rounding digit?
            // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
            // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
            oe2[Z3 + 1] != null || (J2 < 0 ? q2 : q2 % de[K2 - J2 - 1]), V2 = E3 < 4 ? (ee2 || V2) && (E3 == 0 || E3 == (b2.s < 0 ? 3 : 2)) : ee2 > 5 || ee2 == 5 && (E3 == 4 || V2 || E3 == 6 && // Check whether the digit to the left of the rounding digit is odd.
            ($3 > 0 ? J2 > 0 ? q2 / de[K2 - J2] : 0 : oe2[Z3 - 1]) % 10 & 1 || E3 == (b2.s < 0 ? 8 : 7)), R2 < 1 || !oe2[0])
              return oe2.length = 0, V2 ? (R2 -= b2.e + 1, oe2[0] = de[(p2 - R2 % p2) % p2], b2.e = -R2 || 0) : oe2[0] = b2.e = 0, b2;
            if ($3 == 0 ? (oe2.length = Z3, j2 = 1, Z3--) : (oe2.length = Z3 + 1, j2 = de[p2 - $3], oe2[Z3] = J2 > 0 ? o2(q2 / de[K2 - J2] % de[J2]) * j2 : 0), V2)
              for (; ; )
                if (Z3 == 0) {
                  for ($3 = 1, J2 = oe2[0]; J2 >= 10; J2 /= 10, $3++)
                    ;
                  for (J2 = oe2[0] += j2, j2 = 1; J2 >= 10; J2 /= 10, j2++)
                    ;
                  $3 != j2 && (b2.e++, oe2[0] == f2 && (oe2[0] = 1));
                  break;
                } else {
                  if (oe2[Z3] += j2, oe2[Z3] != f2)
                    break;
                  oe2[Z3--] = 0, j2 = 1;
                }
            for ($3 = oe2.length; oe2[--$3] === 0; oe2.pop())
              ;
          }
          b2.e > L2 ? b2.c = b2.e = null : b2.e < C3 && (b2.c = [b2.e = 0]);
        }
        return b2;
      }
      function ve(b2) {
        var R2, E3 = b2.e;
        return E3 === null ? b2.toString() : (R2 = k2(b2.c), R2 = E3 <= _3 || E3 >= T3 ? W2(R2, E3) : Q3(R2, E3, "0"), b2.s < 0 ? "-" + R2 : R2);
      }
      return ie.absoluteValue = ie.abs = function() {
        var b2 = new G2(this);
        return b2.s < 0 && (b2.s = 1), b2;
      }, ie.comparedTo = function(b2, R2) {
        return M3(this, new G2(b2, R2));
      }, ie.decimalPlaces = ie.dp = function(b2, R2) {
        var E3, V2, K2, $3 = this;
        if (b2 != null)
          return S2(b2, 0, w3), R2 == null ? R2 = m2 : S2(R2, 0, 8), xe(new G2($3), b2 + $3.e + 1, R2);
        if (!(E3 = $3.c))
          return null;
        if (V2 = ((K2 = E3.length - 1) - N11(this.e / p2)) * p2, K2 = E3[K2])
          for (; K2 % 10 == 0; K2 /= 10, V2--)
            ;
        return V2 < 0 && (V2 = 0), V2;
      }, ie.dividedBy = ie.div = function(b2, R2) {
        return ne(this, new G2(b2, R2), c2, m2);
      }, ie.dividedToIntegerBy = ie.idiv = function(b2, R2) {
        return ne(this, new G2(b2, R2), 0, 1);
      }, ie.exponentiatedBy = ie.pow = function(b2, R2) {
        var E3, V2, K2, $3, J2, j2, q2, Z3, ee2, oe2 = this;
        if (b2 = new G2(b2), b2.c && !b2.isInteger())
          throw Error(s2 + "Exponent not an integer: " + ve(b2));
        if (R2 != null && (R2 = new G2(R2)), j2 = b2.e > 14, !oe2.c || !oe2.c[0] || oe2.c[0] == 1 && !oe2.e && oe2.c.length == 1 || !b2.c || !b2.c[0])
          return ee2 = new G2(Math.pow(+ve(oe2), j2 ? b2.s * (2 - Y2(b2)) : +ve(b2))), R2 ? ee2.mod(R2) : ee2;
        if (q2 = b2.s < 0, R2) {
          if (R2.c ? !R2.c[0] : !R2.s)
            return new G2(NaN);
          V2 = !q2 && oe2.isInteger() && R2.isInteger(), V2 && (oe2 = oe2.mod(R2));
        } else {
          if (b2.e > 9 && (oe2.e > 0 || oe2.e < -1 || (oe2.e == 0 ? oe2.c[0] > 1 || j2 && oe2.c[1] >= 24e7 : oe2.c[0] < 8e13 || j2 && oe2.c[0] <= 9999975e7)))
            return $3 = oe2.s < 0 && Y2(b2) ? -0 : 0, oe2.e > -1 && ($3 = 1 / $3), new G2(q2 ? 1 / $3 : $3);
          l2 && ($3 = i2(l2 / p2 + 2));
        }
        for (j2 ? (E3 = new G2(0.5), q2 && (b2.s = 1), Z3 = Y2(b2)) : (K2 = Math.abs(+ve(b2)), Z3 = K2 % 2), ee2 = new G2(O2); ; ) {
          if (Z3) {
            if (ee2 = ee2.times(oe2), !ee2.c)
              break;
            $3 ? ee2.c.length > $3 && (ee2.c.length = $3) : V2 && (ee2 = ee2.mod(R2));
          }
          if (K2) {
            if (K2 = o2(K2 / 2), K2 === 0)
              break;
            Z3 = K2 % 2;
          } else if (b2 = b2.times(E3), xe(b2, b2.e + 1, 1), b2.e > 14)
            Z3 = Y2(b2);
          else {
            if (K2 = +ve(b2), K2 === 0)
              break;
            Z3 = K2 % 2;
          }
          oe2 = oe2.times(oe2), $3 ? oe2.c && oe2.c.length > $3 && (oe2.c.length = $3) : V2 && (oe2 = oe2.mod(R2));
        }
        return V2 ? ee2 : (q2 && (ee2 = O2.div(ee2)), R2 ? ee2.mod(R2) : $3 ? xe(ee2, l2, m2, J2) : ee2);
      }, ie.integerValue = function(b2) {
        var R2 = new G2(this);
        return b2 == null ? b2 = m2 : S2(b2, 0, 8), xe(R2, R2.e + 1, b2);
      }, ie.isEqualTo = ie.eq = function(b2, R2) {
        return M3(this, new G2(b2, R2)) === 0;
      }, ie.isFinite = function() {
        return !!this.c;
      }, ie.isGreaterThan = ie.gt = function(b2, R2) {
        return M3(this, new G2(b2, R2)) > 0;
      }, ie.isGreaterThanOrEqualTo = ie.gte = function(b2, R2) {
        return (R2 = M3(this, new G2(b2, R2))) === 1 || R2 === 0;
      }, ie.isInteger = function() {
        return !!this.c && N11(this.e / p2) > this.c.length - 2;
      }, ie.isLessThan = ie.lt = function(b2, R2) {
        return M3(this, new G2(b2, R2)) < 0;
      }, ie.isLessThanOrEqualTo = ie.lte = function(b2, R2) {
        return (R2 = M3(this, new G2(b2, R2))) === -1 || R2 === 0;
      }, ie.isNaN = function() {
        return !this.s;
      }, ie.isNegative = function() {
        return this.s < 0;
      }, ie.isPositive = function() {
        return this.s > 0;
      }, ie.isZero = function() {
        return !!this.c && this.c[0] == 0;
      }, ie.minus = function(b2, R2) {
        var E3, V2, K2, $3, J2 = this, j2 = J2.s;
        if (b2 = new G2(b2, R2), R2 = b2.s, !j2 || !R2)
          return new G2(NaN);
        if (j2 != R2)
          return b2.s = -R2, J2.plus(b2);
        var q2 = J2.e / p2, Z3 = b2.e / p2, ee2 = J2.c, oe2 = b2.c;
        if (!q2 || !Z3) {
          if (!ee2 || !oe2)
            return ee2 ? (b2.s = -R2, b2) : new G2(oe2 ? J2 : NaN);
          if (!ee2[0] || !oe2[0])
            return oe2[0] ? (b2.s = -R2, b2) : new G2(ee2[0] ? J2 : (
              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
              m2 == 3 ? -0 : 0
            ));
        }
        if (q2 = N11(q2), Z3 = N11(Z3), ee2 = ee2.slice(), j2 = q2 - Z3) {
          for (($3 = j2 < 0) ? (j2 = -j2, K2 = ee2) : (Z3 = q2, K2 = oe2), K2.reverse(), R2 = j2; R2--; K2.push(0))
            ;
          K2.reverse();
        } else
          for (V2 = ($3 = (j2 = ee2.length) < (R2 = oe2.length)) ? j2 : R2, j2 = R2 = 0; R2 < V2; R2++)
            if (ee2[R2] != oe2[R2]) {
              $3 = ee2[R2] < oe2[R2];
              break;
            }
        if ($3 && (K2 = ee2, ee2 = oe2, oe2 = K2, b2.s = -b2.s), R2 = (V2 = oe2.length) - (E3 = ee2.length), R2 > 0)
          for (; R2--; ee2[E3++] = 0)
            ;
        for (R2 = f2 - 1; V2 > j2; ) {
          if (ee2[--V2] < oe2[V2]) {
            for (E3 = V2; E3 && !ee2[--E3]; ee2[E3] = R2)
              ;
            --ee2[E3], ee2[V2] += f2;
          }
          ee2[V2] -= oe2[V2];
        }
        for (; ee2[0] == 0; ee2.splice(0, 1), --Z3)
          ;
        return ee2[0] ? ye(b2, ee2, Z3) : (b2.s = m2 == 3 ? -1 : 1, b2.c = [b2.e = 0], b2);
      }, ie.modulo = ie.mod = function(b2, R2) {
        var E3, V2, K2 = this;
        return b2 = new G2(b2, R2), !K2.c || !b2.s || b2.c && !b2.c[0] ? new G2(NaN) : !b2.c || K2.c && !K2.c[0] ? new G2(K2) : (P3 == 9 ? (V2 = b2.s, b2.s = 1, E3 = ne(K2, b2, 0, 3), b2.s = V2, E3.s *= V2) : E3 = ne(K2, b2, 0, P3), b2 = K2.minus(E3.times(b2)), !b2.c[0] && P3 == 1 && (b2.s = K2.s), b2);
      }, ie.multipliedBy = ie.times = function(b2, R2) {
        var E3, V2, K2, $3, J2, j2, q2, Z3, ee2, oe2, de, Ee, Ae, U2, te2, g2 = this, u2 = g2.c, h2 = (b2 = new G2(b2, R2)).c;
        if (!u2 || !h2 || !u2[0] || !h2[0])
          return !g2.s || !b2.s || u2 && !u2[0] && !h2 || h2 && !h2[0] && !u2 ? b2.c = b2.e = b2.s = null : (b2.s *= g2.s, !u2 || !h2 ? b2.c = b2.e = null : (b2.c = [0], b2.e = 0)), b2;
        for (V2 = N11(g2.e / p2) + N11(b2.e / p2), b2.s *= g2.s, q2 = u2.length, oe2 = h2.length, q2 < oe2 && (Ae = u2, u2 = h2, h2 = Ae, K2 = q2, q2 = oe2, oe2 = K2), K2 = q2 + oe2, Ae = []; K2--; Ae.push(0))
          ;
        for (U2 = f2, te2 = v3, K2 = oe2; --K2 >= 0; ) {
          for (E3 = 0, de = h2[K2] % te2, Ee = h2[K2] / te2 | 0, J2 = q2, $3 = K2 + J2; $3 > K2; )
            Z3 = u2[--J2] % te2, ee2 = u2[J2] / te2 | 0, j2 = Ee * Z3 + ee2 * de, Z3 = de * Z3 + j2 % te2 * te2 + Ae[$3] + E3, E3 = (Z3 / U2 | 0) + (j2 / te2 | 0) + Ee * ee2, Ae[$3--] = Z3 % U2;
          Ae[$3] = E3;
        }
        return E3 ? ++V2 : Ae.splice(0, 1), ye(b2, Ae, V2);
      }, ie.negated = function() {
        var b2 = new G2(this);
        return b2.s = -b2.s || null, b2;
      }, ie.plus = function(b2, R2) {
        var E3, V2 = this, K2 = V2.s;
        if (b2 = new G2(b2, R2), R2 = b2.s, !K2 || !R2)
          return new G2(NaN);
        if (K2 != R2)
          return b2.s = -R2, V2.minus(b2);
        var $3 = V2.e / p2, J2 = b2.e / p2, j2 = V2.c, q2 = b2.c;
        if (!$3 || !J2) {
          if (!j2 || !q2)
            return new G2(K2 / 0);
          if (!j2[0] || !q2[0])
            return q2[0] ? b2 : new G2(j2[0] ? V2 : K2 * 0);
        }
        if ($3 = N11($3), J2 = N11(J2), j2 = j2.slice(), K2 = $3 - J2) {
          for (K2 > 0 ? (J2 = $3, E3 = q2) : (K2 = -K2, E3 = j2), E3.reverse(); K2--; E3.push(0))
            ;
          E3.reverse();
        }
        for (K2 = j2.length, R2 = q2.length, K2 - R2 < 0 && (E3 = q2, q2 = j2, j2 = E3, R2 = K2), K2 = 0; R2; )
          K2 = (j2[--R2] = j2[R2] + q2[R2] + K2) / f2 | 0, j2[R2] = f2 === j2[R2] ? 0 : j2[R2] % f2;
        return K2 && (j2 = [K2].concat(j2), ++J2), ye(b2, j2, J2);
      }, ie.precision = ie.sd = function(b2, R2) {
        var E3, V2, K2, $3 = this;
        if (b2 != null && b2 !== !!b2)
          return S2(b2, 1, w3), R2 == null ? R2 = m2 : S2(R2, 0, 8), xe(new G2($3), b2, R2);
        if (!(E3 = $3.c))
          return null;
        if (K2 = E3.length - 1, V2 = K2 * p2 + 1, K2 = E3[K2]) {
          for (; K2 % 10 == 0; K2 /= 10, V2--)
            ;
          for (K2 = E3[0]; K2 >= 10; K2 /= 10, V2++)
            ;
        }
        return b2 && $3.e + 1 > V2 && (V2 = $3.e + 1), V2;
      }, ie.shiftedBy = function(b2) {
        return S2(b2, -d2, d2), this.times("1e" + b2);
      }, ie.squareRoot = ie.sqrt = function() {
        var b2, R2, E3, V2, K2, $3 = this, J2 = $3.c, j2 = $3.s, q2 = $3.e, Z3 = c2 + 4, ee2 = new G2("0.5");
        if (j2 !== 1 || !J2 || !J2[0])
          return new G2(!j2 || j2 < 0 && (!J2 || J2[0]) ? NaN : J2 ? $3 : 1 / 0);
        if (j2 = Math.sqrt(+ve($3)), j2 == 0 || j2 == 1 / 0 ? (R2 = k2(J2), (R2.length + q2) % 2 == 0 && (R2 += "0"), j2 = Math.sqrt(+R2), q2 = N11((q2 + 1) / 2) - (q2 < 0 || q2 % 2), j2 == 1 / 0 ? R2 = "5e" + q2 : (R2 = j2.toExponential(), R2 = R2.slice(0, R2.indexOf("e") + 1) + q2), E3 = new G2(R2)) : E3 = new G2(j2 + ""), E3.c[0]) {
          for (q2 = E3.e, j2 = q2 + Z3, j2 < 3 && (j2 = 0); ; )
            if (K2 = E3, E3 = ee2.times(K2.plus(ne($3, K2, Z3, 1))), k2(K2.c).slice(0, j2) === (R2 = k2(E3.c)).slice(0, j2))
              if (E3.e < q2 && --j2, R2 = R2.slice(j2 - 3, j2 + 1), R2 == "9999" || !V2 && R2 == "4999") {
                if (!V2 && (xe(K2, K2.e + c2 + 2, 0), K2.times(K2).eq($3))) {
                  E3 = K2;
                  break;
                }
                Z3 += 4, j2 += 4, V2 = 1;
              } else {
                (!+R2 || !+R2.slice(1) && R2.charAt(0) == "5") && (xe(E3, E3.e + c2 + 2, 1), b2 = !E3.times(E3).eq($3));
                break;
              }
        }
        return xe(E3, E3.e + c2 + 1, m2, b2);
      }, ie.toExponential = function(b2, R2) {
        return b2 != null && (S2(b2, 0, w3), b2++), ce(this, b2, R2, 1);
      }, ie.toFixed = function(b2, R2) {
        return b2 != null && (S2(b2, 0, w3), b2 = b2 + this.e + 1), ce(this, b2, R2);
      }, ie.toFormat = function(b2, R2, E3) {
        var V2, K2 = this;
        if (E3 == null)
          b2 != null && R2 && typeof R2 == "object" ? (E3 = R2, R2 = null) : b2 && typeof b2 == "object" ? (E3 = b2, b2 = R2 = null) : E3 = x3;
        else if (typeof E3 != "object")
          throw Error(s2 + "Argument not an object: " + E3);
        if (V2 = K2.toFixed(b2, R2), K2.c) {
          var $3, J2 = V2.split("."), j2 = +E3.groupSize, q2 = +E3.secondaryGroupSize, Z3 = E3.groupSeparator || "", ee2 = J2[0], oe2 = J2[1], de = K2.s < 0, Ee = de ? ee2.slice(1) : ee2, Ae = Ee.length;
          if (q2 && ($3 = j2, j2 = q2, q2 = $3, Ae -= $3), j2 > 0 && Ae > 0) {
            for ($3 = Ae % j2 || j2, ee2 = Ee.substr(0, $3); $3 < Ae; $3 += j2)
              ee2 += Z3 + Ee.substr($3, j2);
            q2 > 0 && (ee2 += Z3 + Ee.slice($3)), de && (ee2 = "-" + ee2);
          }
          V2 = oe2 ? ee2 + (E3.decimalSeparator || "") + ((q2 = +E3.fractionGroupSize) ? oe2.replace(
            new RegExp("\\d{" + q2 + "}\\B", "g"),
            "$&" + (E3.fractionGroupSeparator || "")
          ) : oe2) : ee2;
        }
        return (E3.prefix || "") + V2 + (E3.suffix || "");
      }, ie.toFraction = function(b2) {
        var R2, E3, V2, K2, $3, J2, j2, q2, Z3, ee2, oe2, de, Ee = this, Ae = Ee.c;
        if (b2 != null && (j2 = new G2(b2), !j2.isInteger() && (j2.c || j2.s !== 1) || j2.lt(O2)))
          throw Error(s2 + "Argument " + (j2.isInteger() ? "out of range: " : "not an integer: ") + ve(j2));
        if (!Ae)
          return new G2(Ee);
        for (R2 = new G2(O2), Z3 = E3 = new G2(O2), V2 = q2 = new G2(O2), de = k2(Ae), $3 = R2.e = de.length - Ee.e - 1, R2.c[0] = y2[(J2 = $3 % p2) < 0 ? p2 + J2 : J2], b2 = !b2 || j2.comparedTo(R2) > 0 ? $3 > 0 ? R2 : Z3 : j2, J2 = L2, L2 = 1 / 0, j2 = new G2(de), q2.c[0] = 0; ee2 = ne(j2, R2, 0, 1), K2 = E3.plus(ee2.times(V2)), K2.comparedTo(b2) != 1; )
          E3 = V2, V2 = K2, Z3 = q2.plus(ee2.times(K2 = Z3)), q2 = K2, R2 = j2.minus(ee2.times(K2 = R2)), j2 = K2;
        return K2 = ne(b2.minus(E3), V2, 0, 1), q2 = q2.plus(K2.times(Z3)), E3 = E3.plus(K2.times(V2)), q2.s = Z3.s = Ee.s, $3 = $3 * 2, oe2 = ne(Z3, V2, $3, m2).minus(Ee).abs().comparedTo(
          ne(q2, E3, $3, m2).minus(Ee).abs()
        ) < 1 ? [Z3, V2] : [q2, E3], L2 = J2, oe2;
      }, ie.toNumber = function() {
        return +ve(this);
      }, ie.toPrecision = function(b2, R2) {
        return b2 != null && S2(b2, 1, w3), ce(this, b2, R2, 2);
      }, ie.toString = function(b2) {
        var R2, E3 = this, V2 = E3.s, K2 = E3.e;
        return K2 === null ? V2 ? (R2 = "Infinity", V2 < 0 && (R2 = "-" + R2)) : R2 = "NaN" : (b2 == null ? R2 = K2 <= _3 || K2 >= T3 ? W2(k2(E3.c), K2) : Q3(k2(E3.c), K2, "0") : b2 === 10 && ae ? (E3 = xe(new G2(E3), c2 + K2 + 1, m2), R2 = Q3(k2(E3.c), E3.e, "0")) : (S2(b2, 2, re.length, "Base"), R2 = ue(Q3(k2(E3.c), K2, "0"), 10, b2, V2, true)), V2 < 0 && E3.c[0] && (R2 = "-" + R2)), R2;
      }, ie.valueOf = ie.toJSON = function() {
        return ve(this);
      }, ie._isBigNumber = true, X3 != null && G2.set(X3), G2;
    }
    function N11(X3) {
      var ne = X3 | 0;
      return X3 > 0 || X3 === ne ? ne : ne - 1;
    }
    function k2(X3) {
      for (var ne, ue, se = 1, ie = X3.length, O2 = X3[0] + ""; se < ie; ) {
        for (ne = X3[se++] + "", ue = p2 - ne.length; ue--; ne = "0" + ne)
          ;
        O2 += ne;
      }
      for (ie = O2.length; O2.charCodeAt(--ie) === 48; )
        ;
      return O2.slice(0, ie + 1 || 1);
    }
    function M3(X3, ne) {
      var ue, se, ie = X3.c, O2 = ne.c, c2 = X3.s, m2 = ne.s, _3 = X3.e, T3 = ne.e;
      if (!c2 || !m2)
        return null;
      if (ue = ie && !ie[0], se = O2 && !O2[0], ue || se)
        return ue ? se ? 0 : -m2 : c2;
      if (c2 != m2)
        return c2;
      if (ue = c2 < 0, se = _3 == T3, !ie || !O2)
        return se ? 0 : !ie ^ ue ? 1 : -1;
      if (!se)
        return _3 > T3 ^ ue ? 1 : -1;
      for (m2 = (_3 = ie.length) < (T3 = O2.length) ? _3 : T3, c2 = 0; c2 < m2; c2++)
        if (ie[c2] != O2[c2])
          return ie[c2] > O2[c2] ^ ue ? 1 : -1;
      return _3 == T3 ? 0 : _3 > T3 ^ ue ? 1 : -1;
    }
    function S2(X3, ne, ue, se) {
      if (X3 < ne || X3 > ue || X3 !== o2(X3))
        throw Error(s2 + (se || "Argument") + (typeof X3 == "number" ? X3 < ne || X3 > ue ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(X3));
    }
    function Y2(X3) {
      var ne = X3.c.length - 1;
      return N11(X3.e / p2) == ne && X3.c[ne] % 2 != 0;
    }
    function W2(X3, ne) {
      return (X3.length > 1 ? X3.charAt(0) + "." + X3.slice(1) : X3) + (ne < 0 ? "e" : "e+") + ne;
    }
    function Q3(X3, ne, ue) {
      var se, ie;
      if (ne < 0) {
        for (ie = ue + "."; ++ne; ie += ue)
          ;
        X3 = ie + X3;
      } else if (se = X3.length, ++ne > se) {
        for (ie = ue, ne -= se; --ne; ie += ue)
          ;
        X3 += ie;
      } else
        ne < se && (X3 = X3.slice(0, ne) + "." + X3.slice(ne));
      return X3;
    }
    r2 = I3(), r2.default = r2.BigNumber = r2, t2.exports ? t2.exports = r2 : (e2 || (e2 = typeof self < "u" && self ? self : window), e2.BigNumber = r2);
  })(ge2);
})(vc);
var rd = vc.exports;
Object.defineProperty(Qo, "__esModule", { value: true });
var nd = rd;
var id = class {
  constructor() {
    pe(this, "BigNum");
    this.BigNum = (e2, r2) => {
      let n2 = nd.BigNumber.clone({ DECIMAL_PLACES: r2 });
      return new n2(e2);
    };
  }
  winstonToAr(e2, { formatted: r2 = false, decimals: n2 = 12, trim: i2 = true } = {}) {
    let o2 = this.stringToBigNum(e2, n2).shiftedBy(-12);
    return r2 ? o2.toFormat(n2) : o2.toFixed(n2);
  }
  arToWinston(e2, { formatted: r2 = false } = {}) {
    let n2 = this.stringToBigNum(e2).shiftedBy(12);
    return r2 ? n2.toFormat() : n2.toFixed(0);
  }
  compare(e2, r2) {
    let n2 = this.stringToBigNum(e2), i2 = this.stringToBigNum(r2);
    return n2.comparedTo(i2);
  }
  isEqual(e2, r2) {
    return this.compare(e2, r2) === 0;
  }
  isLessThan(e2, r2) {
    let n2 = this.stringToBigNum(e2), i2 = this.stringToBigNum(r2);
    return n2.isLessThan(i2);
  }
  isGreaterThan(e2, r2) {
    let n2 = this.stringToBigNum(e2), i2 = this.stringToBigNum(r2);
    return n2.isGreaterThan(i2);
  }
  add(e2, r2) {
    let n2 = this.stringToBigNum(e2);
    return this.stringToBigNum(r2), n2.plus(r2).toFixed(0);
  }
  sub(e2, r2) {
    let n2 = this.stringToBigNum(e2);
    return this.stringToBigNum(r2), n2.minus(r2).toFixed(0);
  }
  stringToBigNum(e2, r2 = 12) {
    return this.BigNum(e2, r2);
  }
};
Qo.default = id;
var es = {};
Object.defineProperty(es, "__esModule", { value: true });
var od = class {
  constructor(e2) {
    pe(this, "METHOD_GET", "GET");
    pe(this, "METHOD_POST", "POST");
    pe(this, "config");
    this.applyConfig(e2);
  }
  applyConfig(e2) {
    this.config = this.mergeDefaults(e2);
  }
  getConfig() {
    return this.config;
  }
  mergeDefaults(e2) {
    const r2 = e2.protocol || "http", n2 = e2.port || (r2 === "https" ? 443 : 80);
    return {
      host: e2.host || "127.0.0.1",
      protocol: r2,
      port: n2,
      timeout: e2.timeout || 2e4,
      logging: e2.logging || false,
      logger: e2.logger || console.log,
      network: e2.network
    };
  }
  async get(e2, r2) {
    return await this.request(e2, { ...r2, method: this.METHOD_GET });
  }
  async post(e2, r2, n2) {
    var o2;
    const i2 = new Headers((n2 == null ? void 0 : n2.headers) || {});
    return (o2 = i2.get("content-type")) != null && o2.includes("application/json") || i2.append("content-type", "application/json"), i2.append("accept", "application/json, text/plain, */*"), await this.request(e2, {
      ...n2,
      method: this.METHOD_POST,
      body: typeof r2 != "string" ? JSON.stringify(r2) : r2,
      headers: i2
    });
  }
  async request(e2, r2) {
    var y2;
    const n2 = new Headers((r2 == null ? void 0 : r2.headers) || {}), i2 = `${this.config.protocol}://${this.config.host}:${this.config.port}`, o2 = r2 == null ? void 0 : r2.responseType;
    r2 == null || delete r2.responseType, e2.startsWith("/") && (e2 = e2.slice(1)), this.config.network && n2.append("x-network", this.config.network), this.config.logging && this.config.logger(`Requesting: ${i2}/${e2}`);
    let s2 = await fetch(`${i2}/${e2}`, {
      ...r2 || {},
      headers: n2
    });
    this.config.logging && this.config.logger(`Response:   ${s2.url} - ${s2.status}`);
    const a2 = s2.headers.get("content-type"), f2 = (y2 = a2 == null ? void 0 : a2.match(/charset=([^()<>@,;:\"/[\]?.=\s]*)/i)) == null ? void 0 : y2[1], p2 = s2, d2 = async () => {
      if (f2)
        try {
          p2.data = new TextDecoder(f2).decode(await s2.arrayBuffer());
        } catch {
          p2.data = await s2.text();
        }
      else
        p2.data = await s2.text();
    };
    if (o2 === "arraybuffer")
      p2.data = await s2.arrayBuffer();
    else if (o2 === "text")
      await d2();
    else if (o2 === "webstream")
      p2.data = sd(s2.body);
    else
      try {
        let v3 = await s2.clone().json();
        typeof v3 != "object" ? await d2() : p2.data = await s2.json(), v3 = null;
      } catch {
        await d2();
      }
    return p2;
  }
};
es.default = od;
var sd = (t2) => {
  const e2 = t2;
  return typeof e2[Symbol.asyncIterator] > "u" && (e2[Symbol.asyncIterator] = ad(t2)), e2;
};
var ad = function(t2) {
  return async function* () {
    const r2 = t2.getReader();
    try {
      for (; ; ) {
        const { done: n2, value: i2 } = await r2.read();
        if (n2)
          return;
        yield i2;
      }
    } finally {
      r2.releaseLock();
    }
  };
};
var ts = {};
var gi = {};
var wc = {};
var rs = { exports: {} };
var ud = {};
var cd = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: ud
}, Symbol.toStringTag, { value: "Module" }));
var _c = lh(cd);
rs.exports;
(function(t2) {
  (function(e2, r2) {
    function n2(O2, c2) {
      if (!O2)
        throw new Error(c2 || "Assertion failed");
    }
    function i2(O2, c2) {
      O2.super_ = c2;
      var m2 = function() {
      };
      m2.prototype = c2.prototype, O2.prototype = new m2(), O2.prototype.constructor = O2;
    }
    function o2(O2, c2, m2) {
      if (o2.isBN(O2))
        return O2;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, O2 !== null && ((c2 === "le" || c2 === "be") && (m2 = c2, c2 = 10), this._init(O2 || 0, c2 || 10, m2 || "be"));
    }
    typeof e2 == "object" ? e2.exports = o2 : r2.BN = o2, o2.BN = o2, o2.wordSize = 26;
    var s2;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? s2 = window.Buffer : s2 = _c.Buffer;
    } catch {
    }
    o2.isBN = function(c2) {
      return c2 instanceof o2 ? true : c2 !== null && typeof c2 == "object" && c2.constructor.wordSize === o2.wordSize && Array.isArray(c2.words);
    }, o2.max = function(c2, m2) {
      return c2.cmp(m2) > 0 ? c2 : m2;
    }, o2.min = function(c2, m2) {
      return c2.cmp(m2) < 0 ? c2 : m2;
    }, o2.prototype._init = function(c2, m2, _3) {
      if (typeof c2 == "number")
        return this._initNumber(c2, m2, _3);
      if (typeof c2 == "object")
        return this._initArray(c2, m2, _3);
      m2 === "hex" && (m2 = 16), n2(m2 === (m2 | 0) && m2 >= 2 && m2 <= 36), c2 = c2.toString().replace(/\s+/g, "");
      var T3 = 0;
      c2[0] === "-" && (T3++, this.negative = 1), T3 < c2.length && (m2 === 16 ? this._parseHex(c2, T3, _3) : (this._parseBase(c2, m2, T3), _3 === "le" && this._initArray(this.toArray(), m2, _3)));
    }, o2.prototype._initNumber = function(c2, m2, _3) {
      c2 < 0 && (this.negative = 1, c2 = -c2), c2 < 67108864 ? (this.words = [c2 & 67108863], this.length = 1) : c2 < 4503599627370496 ? (this.words = [
        c2 & 67108863,
        c2 / 67108864 & 67108863
      ], this.length = 2) : (n2(c2 < 9007199254740992), this.words = [
        c2 & 67108863,
        c2 / 67108864 & 67108863,
        1
      ], this.length = 3), _3 === "le" && this._initArray(this.toArray(), m2, _3);
    }, o2.prototype._initArray = function(c2, m2, _3) {
      if (n2(typeof c2.length == "number"), c2.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(c2.length / 3), this.words = new Array(this.length);
      for (var T3 = 0; T3 < this.length; T3++)
        this.words[T3] = 0;
      var C3, L2, H2 = 0;
      if (_3 === "be")
        for (T3 = c2.length - 1, C3 = 0; T3 >= 0; T3 -= 3)
          L2 = c2[T3] | c2[T3 - 1] << 8 | c2[T3 - 2] << 16, this.words[C3] |= L2 << H2 & 67108863, this.words[C3 + 1] = L2 >>> 26 - H2 & 67108863, H2 += 24, H2 >= 26 && (H2 -= 26, C3++);
      else if (_3 === "le")
        for (T3 = 0, C3 = 0; T3 < c2.length; T3 += 3)
          L2 = c2[T3] | c2[T3 + 1] << 8 | c2[T3 + 2] << 16, this.words[C3] |= L2 << H2 & 67108863, this.words[C3 + 1] = L2 >>> 26 - H2 & 67108863, H2 += 24, H2 >= 26 && (H2 -= 26, C3++);
      return this.strip();
    };
    function a2(O2, c2) {
      var m2 = O2.charCodeAt(c2);
      return m2 >= 65 && m2 <= 70 ? m2 - 55 : m2 >= 97 && m2 <= 102 ? m2 - 87 : m2 - 48 & 15;
    }
    function f2(O2, c2, m2) {
      var _3 = a2(O2, m2);
      return m2 - 1 >= c2 && (_3 |= a2(O2, m2 - 1) << 4), _3;
    }
    o2.prototype._parseHex = function(c2, m2, _3) {
      this.length = Math.ceil((c2.length - m2) / 6), this.words = new Array(this.length);
      for (var T3 = 0; T3 < this.length; T3++)
        this.words[T3] = 0;
      var C3 = 0, L2 = 0, H2;
      if (_3 === "be")
        for (T3 = c2.length - 1; T3 >= m2; T3 -= 2)
          H2 = f2(c2, m2, T3) << C3, this.words[L2] |= H2 & 67108863, C3 >= 18 ? (C3 -= 18, L2 += 1, this.words[L2] |= H2 >>> 26) : C3 += 8;
      else {
        var P3 = c2.length - m2;
        for (T3 = P3 % 2 === 0 ? m2 + 1 : m2; T3 < c2.length; T3 += 2)
          H2 = f2(c2, m2, T3) << C3, this.words[L2] |= H2 & 67108863, C3 >= 18 ? (C3 -= 18, L2 += 1, this.words[L2] |= H2 >>> 26) : C3 += 8;
      }
      this.strip();
    };
    function p2(O2, c2, m2, _3) {
      for (var T3 = 0, C3 = Math.min(O2.length, m2), L2 = c2; L2 < C3; L2++) {
        var H2 = O2.charCodeAt(L2) - 48;
        T3 *= _3, H2 >= 49 ? T3 += H2 - 49 + 10 : H2 >= 17 ? T3 += H2 - 17 + 10 : T3 += H2;
      }
      return T3;
    }
    o2.prototype._parseBase = function(c2, m2, _3) {
      this.words = [0], this.length = 1;
      for (var T3 = 0, C3 = 1; C3 <= 67108863; C3 *= m2)
        T3++;
      T3--, C3 = C3 / m2 | 0;
      for (var L2 = c2.length - _3, H2 = L2 % T3, P3 = Math.min(L2, L2 - H2) + _3, l2 = 0, x3 = _3; x3 < P3; x3 += T3)
        l2 = p2(c2, x3, x3 + T3, m2), this.imuln(C3), this.words[0] + l2 < 67108864 ? this.words[0] += l2 : this._iaddn(l2);
      if (H2 !== 0) {
        var re = 1;
        for (l2 = p2(c2, x3, c2.length, m2), x3 = 0; x3 < H2; x3++)
          re *= m2;
        this.imuln(re), this.words[0] + l2 < 67108864 ? this.words[0] += l2 : this._iaddn(l2);
      }
      this.strip();
    }, o2.prototype.copy = function(c2) {
      c2.words = new Array(this.length);
      for (var m2 = 0; m2 < this.length; m2++)
        c2.words[m2] = this.words[m2];
      c2.length = this.length, c2.negative = this.negative, c2.red = this.red;
    }, o2.prototype.clone = function() {
      var c2 = new o2(null);
      return this.copy(c2), c2;
    }, o2.prototype._expand = function(c2) {
      for (; this.length < c2; )
        this.words[this.length++] = 0;
      return this;
    }, o2.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, o2.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, o2.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var d2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], y2 = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], v3 = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    o2.prototype.toString = function(c2, m2) {
      c2 = c2 || 10, m2 = m2 | 0 || 1;
      var _3;
      if (c2 === 16 || c2 === "hex") {
        _3 = "";
        for (var T3 = 0, C3 = 0, L2 = 0; L2 < this.length; L2++) {
          var H2 = this.words[L2], P3 = ((H2 << T3 | C3) & 16777215).toString(16);
          C3 = H2 >>> 24 - T3 & 16777215, C3 !== 0 || L2 !== this.length - 1 ? _3 = d2[6 - P3.length] + P3 + _3 : _3 = P3 + _3, T3 += 2, T3 >= 26 && (T3 -= 26, L2--);
        }
        for (C3 !== 0 && (_3 = C3.toString(16) + _3); _3.length % m2 !== 0; )
          _3 = "0" + _3;
        return this.negative !== 0 && (_3 = "-" + _3), _3;
      }
      if (c2 === (c2 | 0) && c2 >= 2 && c2 <= 36) {
        var l2 = y2[c2], x3 = v3[c2];
        _3 = "";
        var re = this.clone();
        for (re.negative = 0; !re.isZero(); ) {
          var ae = re.modn(x3).toString(c2);
          re = re.idivn(x3), re.isZero() ? _3 = ae + _3 : _3 = d2[l2 - ae.length] + ae + _3;
        }
        for (this.isZero() && (_3 = "0" + _3); _3.length % m2 !== 0; )
          _3 = "0" + _3;
        return this.negative !== 0 && (_3 = "-" + _3), _3;
      }
      n2(false, "Base should be between 2 and 36");
    }, o2.prototype.toNumber = function() {
      var c2 = this.words[0];
      return this.length === 2 ? c2 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? c2 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n2(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -c2 : c2;
    }, o2.prototype.toJSON = function() {
      return this.toString(16);
    }, o2.prototype.toBuffer = function(c2, m2) {
      return n2(typeof s2 < "u"), this.toArrayLike(s2, c2, m2);
    }, o2.prototype.toArray = function(c2, m2) {
      return this.toArrayLike(Array, c2, m2);
    }, o2.prototype.toArrayLike = function(c2, m2, _3) {
      var T3 = this.byteLength(), C3 = _3 || Math.max(1, T3);
      n2(T3 <= C3, "byte array longer than desired length"), n2(C3 > 0, "Requested array length <= 0"), this.strip();
      var L2 = m2 === "le", H2 = new c2(C3), P3, l2, x3 = this.clone();
      if (L2) {
        for (l2 = 0; !x3.isZero(); l2++)
          P3 = x3.andln(255), x3.iushrn(8), H2[l2] = P3;
        for (; l2 < C3; l2++)
          H2[l2] = 0;
      } else {
        for (l2 = 0; l2 < C3 - T3; l2++)
          H2[l2] = 0;
        for (l2 = 0; !x3.isZero(); l2++)
          P3 = x3.andln(255), x3.iushrn(8), H2[C3 - l2 - 1] = P3;
      }
      return H2;
    }, Math.clz32 ? o2.prototype._countBits = function(c2) {
      return 32 - Math.clz32(c2);
    } : o2.prototype._countBits = function(c2) {
      var m2 = c2, _3 = 0;
      return m2 >= 4096 && (_3 += 13, m2 >>>= 13), m2 >= 64 && (_3 += 7, m2 >>>= 7), m2 >= 8 && (_3 += 4, m2 >>>= 4), m2 >= 2 && (_3 += 2, m2 >>>= 2), _3 + m2;
    }, o2.prototype._zeroBits = function(c2) {
      if (c2 === 0)
        return 26;
      var m2 = c2, _3 = 0;
      return m2 & 8191 || (_3 += 13, m2 >>>= 13), m2 & 127 || (_3 += 7, m2 >>>= 7), m2 & 15 || (_3 += 4, m2 >>>= 4), m2 & 3 || (_3 += 2, m2 >>>= 2), m2 & 1 || _3++, _3;
    }, o2.prototype.bitLength = function() {
      var c2 = this.words[this.length - 1], m2 = this._countBits(c2);
      return (this.length - 1) * 26 + m2;
    };
    function w3(O2) {
      for (var c2 = new Array(O2.bitLength()), m2 = 0; m2 < c2.length; m2++) {
        var _3 = m2 / 26 | 0, T3 = m2 % 26;
        c2[m2] = (O2.words[_3] & 1 << T3) >>> T3;
      }
      return c2;
    }
    o2.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var c2 = 0, m2 = 0; m2 < this.length; m2++) {
        var _3 = this._zeroBits(this.words[m2]);
        if (c2 += _3, _3 !== 26)
          break;
      }
      return c2;
    }, o2.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, o2.prototype.toTwos = function(c2) {
      return this.negative !== 0 ? this.abs().inotn(c2).iaddn(1) : this.clone();
    }, o2.prototype.fromTwos = function(c2) {
      return this.testn(c2 - 1) ? this.notn(c2).iaddn(1).ineg() : this.clone();
    }, o2.prototype.isNeg = function() {
      return this.negative !== 0;
    }, o2.prototype.neg = function() {
      return this.clone().ineg();
    }, o2.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, o2.prototype.iuor = function(c2) {
      for (; this.length < c2.length; )
        this.words[this.length++] = 0;
      for (var m2 = 0; m2 < c2.length; m2++)
        this.words[m2] = this.words[m2] | c2.words[m2];
      return this.strip();
    }, o2.prototype.ior = function(c2) {
      return n2((this.negative | c2.negative) === 0), this.iuor(c2);
    }, o2.prototype.or = function(c2) {
      return this.length > c2.length ? this.clone().ior(c2) : c2.clone().ior(this);
    }, o2.prototype.uor = function(c2) {
      return this.length > c2.length ? this.clone().iuor(c2) : c2.clone().iuor(this);
    }, o2.prototype.iuand = function(c2) {
      var m2;
      this.length > c2.length ? m2 = c2 : m2 = this;
      for (var _3 = 0; _3 < m2.length; _3++)
        this.words[_3] = this.words[_3] & c2.words[_3];
      return this.length = m2.length, this.strip();
    }, o2.prototype.iand = function(c2) {
      return n2((this.negative | c2.negative) === 0), this.iuand(c2);
    }, o2.prototype.and = function(c2) {
      return this.length > c2.length ? this.clone().iand(c2) : c2.clone().iand(this);
    }, o2.prototype.uand = function(c2) {
      return this.length > c2.length ? this.clone().iuand(c2) : c2.clone().iuand(this);
    }, o2.prototype.iuxor = function(c2) {
      var m2, _3;
      this.length > c2.length ? (m2 = this, _3 = c2) : (m2 = c2, _3 = this);
      for (var T3 = 0; T3 < _3.length; T3++)
        this.words[T3] = m2.words[T3] ^ _3.words[T3];
      if (this !== m2)
        for (; T3 < m2.length; T3++)
          this.words[T3] = m2.words[T3];
      return this.length = m2.length, this.strip();
    }, o2.prototype.ixor = function(c2) {
      return n2((this.negative | c2.negative) === 0), this.iuxor(c2);
    }, o2.prototype.xor = function(c2) {
      return this.length > c2.length ? this.clone().ixor(c2) : c2.clone().ixor(this);
    }, o2.prototype.uxor = function(c2) {
      return this.length > c2.length ? this.clone().iuxor(c2) : c2.clone().iuxor(this);
    }, o2.prototype.inotn = function(c2) {
      n2(typeof c2 == "number" && c2 >= 0);
      var m2 = Math.ceil(c2 / 26) | 0, _3 = c2 % 26;
      this._expand(m2), _3 > 0 && m2--;
      for (var T3 = 0; T3 < m2; T3++)
        this.words[T3] = ~this.words[T3] & 67108863;
      return _3 > 0 && (this.words[T3] = ~this.words[T3] & 67108863 >> 26 - _3), this.strip();
    }, o2.prototype.notn = function(c2) {
      return this.clone().inotn(c2);
    }, o2.prototype.setn = function(c2, m2) {
      n2(typeof c2 == "number" && c2 >= 0);
      var _3 = c2 / 26 | 0, T3 = c2 % 26;
      return this._expand(_3 + 1), m2 ? this.words[_3] = this.words[_3] | 1 << T3 : this.words[_3] = this.words[_3] & ~(1 << T3), this.strip();
    }, o2.prototype.iadd = function(c2) {
      var m2;
      if (this.negative !== 0 && c2.negative === 0)
        return this.negative = 0, m2 = this.isub(c2), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && c2.negative !== 0)
        return c2.negative = 0, m2 = this.isub(c2), c2.negative = 1, m2._normSign();
      var _3, T3;
      this.length > c2.length ? (_3 = this, T3 = c2) : (_3 = c2, T3 = this);
      for (var C3 = 0, L2 = 0; L2 < T3.length; L2++)
        m2 = (_3.words[L2] | 0) + (T3.words[L2] | 0) + C3, this.words[L2] = m2 & 67108863, C3 = m2 >>> 26;
      for (; C3 !== 0 && L2 < _3.length; L2++)
        m2 = (_3.words[L2] | 0) + C3, this.words[L2] = m2 & 67108863, C3 = m2 >>> 26;
      if (this.length = _3.length, C3 !== 0)
        this.words[this.length] = C3, this.length++;
      else if (_3 !== this)
        for (; L2 < _3.length; L2++)
          this.words[L2] = _3.words[L2];
      return this;
    }, o2.prototype.add = function(c2) {
      var m2;
      return c2.negative !== 0 && this.negative === 0 ? (c2.negative = 0, m2 = this.sub(c2), c2.negative ^= 1, m2) : c2.negative === 0 && this.negative !== 0 ? (this.negative = 0, m2 = c2.sub(this), this.negative = 1, m2) : this.length > c2.length ? this.clone().iadd(c2) : c2.clone().iadd(this);
    }, o2.prototype.isub = function(c2) {
      if (c2.negative !== 0) {
        c2.negative = 0;
        var m2 = this.iadd(c2);
        return c2.negative = 1, m2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(c2), this.negative = 1, this._normSign();
      var _3 = this.cmp(c2);
      if (_3 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var T3, C3;
      _3 > 0 ? (T3 = this, C3 = c2) : (T3 = c2, C3 = this);
      for (var L2 = 0, H2 = 0; H2 < C3.length; H2++)
        m2 = (T3.words[H2] | 0) - (C3.words[H2] | 0) + L2, L2 = m2 >> 26, this.words[H2] = m2 & 67108863;
      for (; L2 !== 0 && H2 < T3.length; H2++)
        m2 = (T3.words[H2] | 0) + L2, L2 = m2 >> 26, this.words[H2] = m2 & 67108863;
      if (L2 === 0 && H2 < T3.length && T3 !== this)
        for (; H2 < T3.length; H2++)
          this.words[H2] = T3.words[H2];
      return this.length = Math.max(this.length, H2), T3 !== this && (this.negative = 1), this.strip();
    }, o2.prototype.sub = function(c2) {
      return this.clone().isub(c2);
    };
    function I3(O2, c2, m2) {
      m2.negative = c2.negative ^ O2.negative;
      var _3 = O2.length + c2.length | 0;
      m2.length = _3, _3 = _3 - 1 | 0;
      var T3 = O2.words[0] | 0, C3 = c2.words[0] | 0, L2 = T3 * C3, H2 = L2 & 67108863, P3 = L2 / 67108864 | 0;
      m2.words[0] = H2;
      for (var l2 = 1; l2 < _3; l2++) {
        for (var x3 = P3 >>> 26, re = P3 & 67108863, ae = Math.min(l2, c2.length - 1), G2 = Math.max(0, l2 - O2.length + 1); G2 <= ae; G2++) {
          var ce = l2 - G2 | 0;
          T3 = O2.words[ce] | 0, C3 = c2.words[G2] | 0, L2 = T3 * C3 + re, x3 += L2 / 67108864 | 0, re = L2 & 67108863;
        }
        m2.words[l2] = re | 0, P3 = x3 | 0;
      }
      return P3 !== 0 ? m2.words[l2] = P3 | 0 : m2.length--, m2.strip();
    }
    var N11 = function(c2, m2, _3) {
      var T3 = c2.words, C3 = m2.words, L2 = _3.words, H2 = 0, P3, l2, x3, re = T3[0] | 0, ae = re & 8191, G2 = re >>> 13, ce = T3[1] | 0, me = ce & 8191, ye = ce >>> 13, xe = T3[2] | 0, ve = xe & 8191, b2 = xe >>> 13, R2 = T3[3] | 0, E3 = R2 & 8191, V2 = R2 >>> 13, K2 = T3[4] | 0, $3 = K2 & 8191, J2 = K2 >>> 13, j2 = T3[5] | 0, q2 = j2 & 8191, Z3 = j2 >>> 13, ee2 = T3[6] | 0, oe2 = ee2 & 8191, de = ee2 >>> 13, Ee = T3[7] | 0, Ae = Ee & 8191, U2 = Ee >>> 13, te2 = T3[8] | 0, g2 = te2 & 8191, u2 = te2 >>> 13, h2 = T3[9] | 0, A2 = h2 & 8191, B3 = h2 >>> 13, z3 = C3[0] | 0, F2 = z3 & 8191, fe = z3 >>> 13, we = C3[1] | 0, _e = we & 8191, be = we >>> 13, Be = C3[2] | 0, qe = Be & 8191, Ye = Be >>> 13, Yt2 = C3[3] | 0, We = Yt2 & 8191, He = Yt2 >>> 13, Xr = C3[4] | 0, et = Xr & 8191, Xe = Xr >>> 13, Dn = C3[5] | 0, Ze = Dn & 8191, Je = Dn >>> 13, Ln = C3[6] | 0, tt2 = Ln & 8191, Qe = Ln >>> 13, Zr = C3[7] | 0, rt = Zr & 8191, nt2 = Zr >>> 13, Nn = C3[8] | 0, it2 = Nn & 8191, D2 = Nn >>> 13, le = C3[9] | 0, he = le & 8191, Te = le >>> 13;
      _3.negative = c2.negative ^ m2.negative, _3.length = 19, P3 = Math.imul(ae, F2), l2 = Math.imul(ae, fe), l2 = l2 + Math.imul(G2, F2) | 0, x3 = Math.imul(G2, fe);
      var Ie = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, P3 = Math.imul(me, F2), l2 = Math.imul(me, fe), l2 = l2 + Math.imul(ye, F2) | 0, x3 = Math.imul(ye, fe), P3 = P3 + Math.imul(ae, _e) | 0, l2 = l2 + Math.imul(ae, be) | 0, l2 = l2 + Math.imul(G2, _e) | 0, x3 = x3 + Math.imul(G2, be) | 0;
      var De = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (De >>> 26) | 0, De &= 67108863, P3 = Math.imul(ve, F2), l2 = Math.imul(ve, fe), l2 = l2 + Math.imul(b2, F2) | 0, x3 = Math.imul(b2, fe), P3 = P3 + Math.imul(me, _e) | 0, l2 = l2 + Math.imul(me, be) | 0, l2 = l2 + Math.imul(ye, _e) | 0, x3 = x3 + Math.imul(ye, be) | 0, P3 = P3 + Math.imul(ae, qe) | 0, l2 = l2 + Math.imul(ae, Ye) | 0, l2 = l2 + Math.imul(G2, qe) | 0, x3 = x3 + Math.imul(G2, Ye) | 0;
      var Re = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, P3 = Math.imul(E3, F2), l2 = Math.imul(E3, fe), l2 = l2 + Math.imul(V2, F2) | 0, x3 = Math.imul(V2, fe), P3 = P3 + Math.imul(ve, _e) | 0, l2 = l2 + Math.imul(ve, be) | 0, l2 = l2 + Math.imul(b2, _e) | 0, x3 = x3 + Math.imul(b2, be) | 0, P3 = P3 + Math.imul(me, qe) | 0, l2 = l2 + Math.imul(me, Ye) | 0, l2 = l2 + Math.imul(ye, qe) | 0, x3 = x3 + Math.imul(ye, Ye) | 0, P3 = P3 + Math.imul(ae, We) | 0, l2 = l2 + Math.imul(ae, He) | 0, l2 = l2 + Math.imul(G2, We) | 0, x3 = x3 + Math.imul(G2, He) | 0;
      var Oe = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, P3 = Math.imul($3, F2), l2 = Math.imul($3, fe), l2 = l2 + Math.imul(J2, F2) | 0, x3 = Math.imul(J2, fe), P3 = P3 + Math.imul(E3, _e) | 0, l2 = l2 + Math.imul(E3, be) | 0, l2 = l2 + Math.imul(V2, _e) | 0, x3 = x3 + Math.imul(V2, be) | 0, P3 = P3 + Math.imul(ve, qe) | 0, l2 = l2 + Math.imul(ve, Ye) | 0, l2 = l2 + Math.imul(b2, qe) | 0, x3 = x3 + Math.imul(b2, Ye) | 0, P3 = P3 + Math.imul(me, We) | 0, l2 = l2 + Math.imul(me, He) | 0, l2 = l2 + Math.imul(ye, We) | 0, x3 = x3 + Math.imul(ye, He) | 0, P3 = P3 + Math.imul(ae, et) | 0, l2 = l2 + Math.imul(ae, Xe) | 0, l2 = l2 + Math.imul(G2, et) | 0, x3 = x3 + Math.imul(G2, Xe) | 0;
      var at = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, P3 = Math.imul(q2, F2), l2 = Math.imul(q2, fe), l2 = l2 + Math.imul(Z3, F2) | 0, x3 = Math.imul(Z3, fe), P3 = P3 + Math.imul($3, _e) | 0, l2 = l2 + Math.imul($3, be) | 0, l2 = l2 + Math.imul(J2, _e) | 0, x3 = x3 + Math.imul(J2, be) | 0, P3 = P3 + Math.imul(E3, qe) | 0, l2 = l2 + Math.imul(E3, Ye) | 0, l2 = l2 + Math.imul(V2, qe) | 0, x3 = x3 + Math.imul(V2, Ye) | 0, P3 = P3 + Math.imul(ve, We) | 0, l2 = l2 + Math.imul(ve, He) | 0, l2 = l2 + Math.imul(b2, We) | 0, x3 = x3 + Math.imul(b2, He) | 0, P3 = P3 + Math.imul(me, et) | 0, l2 = l2 + Math.imul(me, Xe) | 0, l2 = l2 + Math.imul(ye, et) | 0, x3 = x3 + Math.imul(ye, Xe) | 0, P3 = P3 + Math.imul(ae, Ze) | 0, l2 = l2 + Math.imul(ae, Je) | 0, l2 = l2 + Math.imul(G2, Ze) | 0, x3 = x3 + Math.imul(G2, Je) | 0;
      var Ve = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, P3 = Math.imul(oe2, F2), l2 = Math.imul(oe2, fe), l2 = l2 + Math.imul(de, F2) | 0, x3 = Math.imul(de, fe), P3 = P3 + Math.imul(q2, _e) | 0, l2 = l2 + Math.imul(q2, be) | 0, l2 = l2 + Math.imul(Z3, _e) | 0, x3 = x3 + Math.imul(Z3, be) | 0, P3 = P3 + Math.imul($3, qe) | 0, l2 = l2 + Math.imul($3, Ye) | 0, l2 = l2 + Math.imul(J2, qe) | 0, x3 = x3 + Math.imul(J2, Ye) | 0, P3 = P3 + Math.imul(E3, We) | 0, l2 = l2 + Math.imul(E3, He) | 0, l2 = l2 + Math.imul(V2, We) | 0, x3 = x3 + Math.imul(V2, He) | 0, P3 = P3 + Math.imul(ve, et) | 0, l2 = l2 + Math.imul(ve, Xe) | 0, l2 = l2 + Math.imul(b2, et) | 0, x3 = x3 + Math.imul(b2, Xe) | 0, P3 = P3 + Math.imul(me, Ze) | 0, l2 = l2 + Math.imul(me, Je) | 0, l2 = l2 + Math.imul(ye, Ze) | 0, x3 = x3 + Math.imul(ye, Je) | 0, P3 = P3 + Math.imul(ae, tt2) | 0, l2 = l2 + Math.imul(ae, Qe) | 0, l2 = l2 + Math.imul(G2, tt2) | 0, x3 = x3 + Math.imul(G2, Qe) | 0;
      var Ke = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, P3 = Math.imul(Ae, F2), l2 = Math.imul(Ae, fe), l2 = l2 + Math.imul(U2, F2) | 0, x3 = Math.imul(U2, fe), P3 = P3 + Math.imul(oe2, _e) | 0, l2 = l2 + Math.imul(oe2, be) | 0, l2 = l2 + Math.imul(de, _e) | 0, x3 = x3 + Math.imul(de, be) | 0, P3 = P3 + Math.imul(q2, qe) | 0, l2 = l2 + Math.imul(q2, Ye) | 0, l2 = l2 + Math.imul(Z3, qe) | 0, x3 = x3 + Math.imul(Z3, Ye) | 0, P3 = P3 + Math.imul($3, We) | 0, l2 = l2 + Math.imul($3, He) | 0, l2 = l2 + Math.imul(J2, We) | 0, x3 = x3 + Math.imul(J2, He) | 0, P3 = P3 + Math.imul(E3, et) | 0, l2 = l2 + Math.imul(E3, Xe) | 0, l2 = l2 + Math.imul(V2, et) | 0, x3 = x3 + Math.imul(V2, Xe) | 0, P3 = P3 + Math.imul(ve, Ze) | 0, l2 = l2 + Math.imul(ve, Je) | 0, l2 = l2 + Math.imul(b2, Ze) | 0, x3 = x3 + Math.imul(b2, Je) | 0, P3 = P3 + Math.imul(me, tt2) | 0, l2 = l2 + Math.imul(me, Qe) | 0, l2 = l2 + Math.imul(ye, tt2) | 0, x3 = x3 + Math.imul(ye, Qe) | 0, P3 = P3 + Math.imul(ae, rt) | 0, l2 = l2 + Math.imul(ae, nt2) | 0, l2 = l2 + Math.imul(G2, rt) | 0, x3 = x3 + Math.imul(G2, nt2) | 0;
      var yt2 = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (yt2 >>> 26) | 0, yt2 &= 67108863, P3 = Math.imul(g2, F2), l2 = Math.imul(g2, fe), l2 = l2 + Math.imul(u2, F2) | 0, x3 = Math.imul(u2, fe), P3 = P3 + Math.imul(Ae, _e) | 0, l2 = l2 + Math.imul(Ae, be) | 0, l2 = l2 + Math.imul(U2, _e) | 0, x3 = x3 + Math.imul(U2, be) | 0, P3 = P3 + Math.imul(oe2, qe) | 0, l2 = l2 + Math.imul(oe2, Ye) | 0, l2 = l2 + Math.imul(de, qe) | 0, x3 = x3 + Math.imul(de, Ye) | 0, P3 = P3 + Math.imul(q2, We) | 0, l2 = l2 + Math.imul(q2, He) | 0, l2 = l2 + Math.imul(Z3, We) | 0, x3 = x3 + Math.imul(Z3, He) | 0, P3 = P3 + Math.imul($3, et) | 0, l2 = l2 + Math.imul($3, Xe) | 0, l2 = l2 + Math.imul(J2, et) | 0, x3 = x3 + Math.imul(J2, Xe) | 0, P3 = P3 + Math.imul(E3, Ze) | 0, l2 = l2 + Math.imul(E3, Je) | 0, l2 = l2 + Math.imul(V2, Ze) | 0, x3 = x3 + Math.imul(V2, Je) | 0, P3 = P3 + Math.imul(ve, tt2) | 0, l2 = l2 + Math.imul(ve, Qe) | 0, l2 = l2 + Math.imul(b2, tt2) | 0, x3 = x3 + Math.imul(b2, Qe) | 0, P3 = P3 + Math.imul(me, rt) | 0, l2 = l2 + Math.imul(me, nt2) | 0, l2 = l2 + Math.imul(ye, rt) | 0, x3 = x3 + Math.imul(ye, nt2) | 0, P3 = P3 + Math.imul(ae, it2) | 0, l2 = l2 + Math.imul(ae, D2) | 0, l2 = l2 + Math.imul(G2, it2) | 0, x3 = x3 + Math.imul(G2, D2) | 0;
      var Wt2 = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (Wt2 >>> 26) | 0, Wt2 &= 67108863, P3 = Math.imul(A2, F2), l2 = Math.imul(A2, fe), l2 = l2 + Math.imul(B3, F2) | 0, x3 = Math.imul(B3, fe), P3 = P3 + Math.imul(g2, _e) | 0, l2 = l2 + Math.imul(g2, be) | 0, l2 = l2 + Math.imul(u2, _e) | 0, x3 = x3 + Math.imul(u2, be) | 0, P3 = P3 + Math.imul(Ae, qe) | 0, l2 = l2 + Math.imul(Ae, Ye) | 0, l2 = l2 + Math.imul(U2, qe) | 0, x3 = x3 + Math.imul(U2, Ye) | 0, P3 = P3 + Math.imul(oe2, We) | 0, l2 = l2 + Math.imul(oe2, He) | 0, l2 = l2 + Math.imul(de, We) | 0, x3 = x3 + Math.imul(de, He) | 0, P3 = P3 + Math.imul(q2, et) | 0, l2 = l2 + Math.imul(q2, Xe) | 0, l2 = l2 + Math.imul(Z3, et) | 0, x3 = x3 + Math.imul(Z3, Xe) | 0, P3 = P3 + Math.imul($3, Ze) | 0, l2 = l2 + Math.imul($3, Je) | 0, l2 = l2 + Math.imul(J2, Ze) | 0, x3 = x3 + Math.imul(J2, Je) | 0, P3 = P3 + Math.imul(E3, tt2) | 0, l2 = l2 + Math.imul(E3, Qe) | 0, l2 = l2 + Math.imul(V2, tt2) | 0, x3 = x3 + Math.imul(V2, Qe) | 0, P3 = P3 + Math.imul(ve, rt) | 0, l2 = l2 + Math.imul(ve, nt2) | 0, l2 = l2 + Math.imul(b2, rt) | 0, x3 = x3 + Math.imul(b2, nt2) | 0, P3 = P3 + Math.imul(me, it2) | 0, l2 = l2 + Math.imul(me, D2) | 0, l2 = l2 + Math.imul(ye, it2) | 0, x3 = x3 + Math.imul(ye, D2) | 0, P3 = P3 + Math.imul(ae, he) | 0, l2 = l2 + Math.imul(ae, Te) | 0, l2 = l2 + Math.imul(G2, he) | 0, x3 = x3 + Math.imul(G2, Te) | 0;
      var Ft = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, P3 = Math.imul(A2, _e), l2 = Math.imul(A2, be), l2 = l2 + Math.imul(B3, _e) | 0, x3 = Math.imul(B3, be), P3 = P3 + Math.imul(g2, qe) | 0, l2 = l2 + Math.imul(g2, Ye) | 0, l2 = l2 + Math.imul(u2, qe) | 0, x3 = x3 + Math.imul(u2, Ye) | 0, P3 = P3 + Math.imul(Ae, We) | 0, l2 = l2 + Math.imul(Ae, He) | 0, l2 = l2 + Math.imul(U2, We) | 0, x3 = x3 + Math.imul(U2, He) | 0, P3 = P3 + Math.imul(oe2, et) | 0, l2 = l2 + Math.imul(oe2, Xe) | 0, l2 = l2 + Math.imul(de, et) | 0, x3 = x3 + Math.imul(de, Xe) | 0, P3 = P3 + Math.imul(q2, Ze) | 0, l2 = l2 + Math.imul(q2, Je) | 0, l2 = l2 + Math.imul(Z3, Ze) | 0, x3 = x3 + Math.imul(Z3, Je) | 0, P3 = P3 + Math.imul($3, tt2) | 0, l2 = l2 + Math.imul($3, Qe) | 0, l2 = l2 + Math.imul(J2, tt2) | 0, x3 = x3 + Math.imul(J2, Qe) | 0, P3 = P3 + Math.imul(E3, rt) | 0, l2 = l2 + Math.imul(E3, nt2) | 0, l2 = l2 + Math.imul(V2, rt) | 0, x3 = x3 + Math.imul(V2, nt2) | 0, P3 = P3 + Math.imul(ve, it2) | 0, l2 = l2 + Math.imul(ve, D2) | 0, l2 = l2 + Math.imul(b2, it2) | 0, x3 = x3 + Math.imul(b2, D2) | 0, P3 = P3 + Math.imul(me, he) | 0, l2 = l2 + Math.imul(me, Te) | 0, l2 = l2 + Math.imul(ye, he) | 0, x3 = x3 + Math.imul(ye, Te) | 0;
      var ft = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, P3 = Math.imul(A2, qe), l2 = Math.imul(A2, Ye), l2 = l2 + Math.imul(B3, qe) | 0, x3 = Math.imul(B3, Ye), P3 = P3 + Math.imul(g2, We) | 0, l2 = l2 + Math.imul(g2, He) | 0, l2 = l2 + Math.imul(u2, We) | 0, x3 = x3 + Math.imul(u2, He) | 0, P3 = P3 + Math.imul(Ae, et) | 0, l2 = l2 + Math.imul(Ae, Xe) | 0, l2 = l2 + Math.imul(U2, et) | 0, x3 = x3 + Math.imul(U2, Xe) | 0, P3 = P3 + Math.imul(oe2, Ze) | 0, l2 = l2 + Math.imul(oe2, Je) | 0, l2 = l2 + Math.imul(de, Ze) | 0, x3 = x3 + Math.imul(de, Je) | 0, P3 = P3 + Math.imul(q2, tt2) | 0, l2 = l2 + Math.imul(q2, Qe) | 0, l2 = l2 + Math.imul(Z3, tt2) | 0, x3 = x3 + Math.imul(Z3, Qe) | 0, P3 = P3 + Math.imul($3, rt) | 0, l2 = l2 + Math.imul($3, nt2) | 0, l2 = l2 + Math.imul(J2, rt) | 0, x3 = x3 + Math.imul(J2, nt2) | 0, P3 = P3 + Math.imul(E3, it2) | 0, l2 = l2 + Math.imul(E3, D2) | 0, l2 = l2 + Math.imul(V2, it2) | 0, x3 = x3 + Math.imul(V2, D2) | 0, P3 = P3 + Math.imul(ve, he) | 0, l2 = l2 + Math.imul(ve, Te) | 0, l2 = l2 + Math.imul(b2, he) | 0, x3 = x3 + Math.imul(b2, Te) | 0;
      var fr = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (fr >>> 26) | 0, fr &= 67108863, P3 = Math.imul(A2, We), l2 = Math.imul(A2, He), l2 = l2 + Math.imul(B3, We) | 0, x3 = Math.imul(B3, He), P3 = P3 + Math.imul(g2, et) | 0, l2 = l2 + Math.imul(g2, Xe) | 0, l2 = l2 + Math.imul(u2, et) | 0, x3 = x3 + Math.imul(u2, Xe) | 0, P3 = P3 + Math.imul(Ae, Ze) | 0, l2 = l2 + Math.imul(Ae, Je) | 0, l2 = l2 + Math.imul(U2, Ze) | 0, x3 = x3 + Math.imul(U2, Je) | 0, P3 = P3 + Math.imul(oe2, tt2) | 0, l2 = l2 + Math.imul(oe2, Qe) | 0, l2 = l2 + Math.imul(de, tt2) | 0, x3 = x3 + Math.imul(de, Qe) | 0, P3 = P3 + Math.imul(q2, rt) | 0, l2 = l2 + Math.imul(q2, nt2) | 0, l2 = l2 + Math.imul(Z3, rt) | 0, x3 = x3 + Math.imul(Z3, nt2) | 0, P3 = P3 + Math.imul($3, it2) | 0, l2 = l2 + Math.imul($3, D2) | 0, l2 = l2 + Math.imul(J2, it2) | 0, x3 = x3 + Math.imul(J2, D2) | 0, P3 = P3 + Math.imul(E3, he) | 0, l2 = l2 + Math.imul(E3, Te) | 0, l2 = l2 + Math.imul(V2, he) | 0, x3 = x3 + Math.imul(V2, Te) | 0;
      var Jr = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, P3 = Math.imul(A2, et), l2 = Math.imul(A2, Xe), l2 = l2 + Math.imul(B3, et) | 0, x3 = Math.imul(B3, Xe), P3 = P3 + Math.imul(g2, Ze) | 0, l2 = l2 + Math.imul(g2, Je) | 0, l2 = l2 + Math.imul(u2, Ze) | 0, x3 = x3 + Math.imul(u2, Je) | 0, P3 = P3 + Math.imul(Ae, tt2) | 0, l2 = l2 + Math.imul(Ae, Qe) | 0, l2 = l2 + Math.imul(U2, tt2) | 0, x3 = x3 + Math.imul(U2, Qe) | 0, P3 = P3 + Math.imul(oe2, rt) | 0, l2 = l2 + Math.imul(oe2, nt2) | 0, l2 = l2 + Math.imul(de, rt) | 0, x3 = x3 + Math.imul(de, nt2) | 0, P3 = P3 + Math.imul(q2, it2) | 0, l2 = l2 + Math.imul(q2, D2) | 0, l2 = l2 + Math.imul(Z3, it2) | 0, x3 = x3 + Math.imul(Z3, D2) | 0, P3 = P3 + Math.imul($3, he) | 0, l2 = l2 + Math.imul($3, Te) | 0, l2 = l2 + Math.imul(J2, he) | 0, x3 = x3 + Math.imul(J2, Te) | 0;
      var Qr = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, P3 = Math.imul(A2, Ze), l2 = Math.imul(A2, Je), l2 = l2 + Math.imul(B3, Ze) | 0, x3 = Math.imul(B3, Je), P3 = P3 + Math.imul(g2, tt2) | 0, l2 = l2 + Math.imul(g2, Qe) | 0, l2 = l2 + Math.imul(u2, tt2) | 0, x3 = x3 + Math.imul(u2, Qe) | 0, P3 = P3 + Math.imul(Ae, rt) | 0, l2 = l2 + Math.imul(Ae, nt2) | 0, l2 = l2 + Math.imul(U2, rt) | 0, x3 = x3 + Math.imul(U2, nt2) | 0, P3 = P3 + Math.imul(oe2, it2) | 0, l2 = l2 + Math.imul(oe2, D2) | 0, l2 = l2 + Math.imul(de, it2) | 0, x3 = x3 + Math.imul(de, D2) | 0, P3 = P3 + Math.imul(q2, he) | 0, l2 = l2 + Math.imul(q2, Te) | 0, l2 = l2 + Math.imul(Z3, he) | 0, x3 = x3 + Math.imul(Z3, Te) | 0;
      var Ri = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (Ri >>> 26) | 0, Ri &= 67108863, P3 = Math.imul(A2, tt2), l2 = Math.imul(A2, Qe), l2 = l2 + Math.imul(B3, tt2) | 0, x3 = Math.imul(B3, Qe), P3 = P3 + Math.imul(g2, rt) | 0, l2 = l2 + Math.imul(g2, nt2) | 0, l2 = l2 + Math.imul(u2, rt) | 0, x3 = x3 + Math.imul(u2, nt2) | 0, P3 = P3 + Math.imul(Ae, it2) | 0, l2 = l2 + Math.imul(Ae, D2) | 0, l2 = l2 + Math.imul(U2, it2) | 0, x3 = x3 + Math.imul(U2, D2) | 0, P3 = P3 + Math.imul(oe2, he) | 0, l2 = l2 + Math.imul(oe2, Te) | 0, l2 = l2 + Math.imul(de, he) | 0, x3 = x3 + Math.imul(de, Te) | 0;
      var Ii = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (Ii >>> 26) | 0, Ii &= 67108863, P3 = Math.imul(A2, rt), l2 = Math.imul(A2, nt2), l2 = l2 + Math.imul(B3, rt) | 0, x3 = Math.imul(B3, nt2), P3 = P3 + Math.imul(g2, it2) | 0, l2 = l2 + Math.imul(g2, D2) | 0, l2 = l2 + Math.imul(u2, it2) | 0, x3 = x3 + Math.imul(u2, D2) | 0, P3 = P3 + Math.imul(Ae, he) | 0, l2 = l2 + Math.imul(Ae, Te) | 0, l2 = l2 + Math.imul(U2, he) | 0, x3 = x3 + Math.imul(U2, Te) | 0;
      var Bi = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (Bi >>> 26) | 0, Bi &= 67108863, P3 = Math.imul(A2, it2), l2 = Math.imul(A2, D2), l2 = l2 + Math.imul(B3, it2) | 0, x3 = Math.imul(B3, D2), P3 = P3 + Math.imul(g2, he) | 0, l2 = l2 + Math.imul(g2, Te) | 0, l2 = l2 + Math.imul(u2, he) | 0, x3 = x3 + Math.imul(u2, Te) | 0;
      var ki = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      H2 = (x3 + (l2 >>> 13) | 0) + (ki >>> 26) | 0, ki &= 67108863, P3 = Math.imul(A2, he), l2 = Math.imul(A2, Te), l2 = l2 + Math.imul(B3, he) | 0, x3 = Math.imul(B3, Te);
      var Di = (H2 + P3 | 0) + ((l2 & 8191) << 13) | 0;
      return H2 = (x3 + (l2 >>> 13) | 0) + (Di >>> 26) | 0, Di &= 67108863, L2[0] = Ie, L2[1] = De, L2[2] = Re, L2[3] = Oe, L2[4] = at, L2[5] = Ve, L2[6] = Ke, L2[7] = yt2, L2[8] = Wt2, L2[9] = Ft, L2[10] = ft, L2[11] = fr, L2[12] = Jr, L2[13] = Qr, L2[14] = Ri, L2[15] = Ii, L2[16] = Bi, L2[17] = ki, L2[18] = Di, H2 !== 0 && (L2[19] = H2, _3.length++), _3;
    };
    Math.imul || (N11 = I3);
    function k2(O2, c2, m2) {
      m2.negative = c2.negative ^ O2.negative, m2.length = O2.length + c2.length;
      for (var _3 = 0, T3 = 0, C3 = 0; C3 < m2.length - 1; C3++) {
        var L2 = T3;
        T3 = 0;
        for (var H2 = _3 & 67108863, P3 = Math.min(C3, c2.length - 1), l2 = Math.max(0, C3 - O2.length + 1); l2 <= P3; l2++) {
          var x3 = C3 - l2, re = O2.words[x3] | 0, ae = c2.words[l2] | 0, G2 = re * ae, ce = G2 & 67108863;
          L2 = L2 + (G2 / 67108864 | 0) | 0, ce = ce + H2 | 0, H2 = ce & 67108863, L2 = L2 + (ce >>> 26) | 0, T3 += L2 >>> 26, L2 &= 67108863;
        }
        m2.words[C3] = H2, _3 = L2, L2 = T3;
      }
      return _3 !== 0 ? m2.words[C3] = _3 : m2.length--, m2.strip();
    }
    function M3(O2, c2, m2) {
      var _3 = new S2();
      return _3.mulp(O2, c2, m2);
    }
    o2.prototype.mulTo = function(c2, m2) {
      var _3, T3 = this.length + c2.length;
      return this.length === 10 && c2.length === 10 ? _3 = N11(this, c2, m2) : T3 < 63 ? _3 = I3(this, c2, m2) : T3 < 1024 ? _3 = k2(this, c2, m2) : _3 = M3(this, c2, m2), _3;
    };
    function S2(O2, c2) {
      this.x = O2, this.y = c2;
    }
    S2.prototype.makeRBT = function(c2) {
      for (var m2 = new Array(c2), _3 = o2.prototype._countBits(c2) - 1, T3 = 0; T3 < c2; T3++)
        m2[T3] = this.revBin(T3, _3, c2);
      return m2;
    }, S2.prototype.revBin = function(c2, m2, _3) {
      if (c2 === 0 || c2 === _3 - 1)
        return c2;
      for (var T3 = 0, C3 = 0; C3 < m2; C3++)
        T3 |= (c2 & 1) << m2 - C3 - 1, c2 >>= 1;
      return T3;
    }, S2.prototype.permute = function(c2, m2, _3, T3, C3, L2) {
      for (var H2 = 0; H2 < L2; H2++)
        T3[H2] = m2[c2[H2]], C3[H2] = _3[c2[H2]];
    }, S2.prototype.transform = function(c2, m2, _3, T3, C3, L2) {
      this.permute(L2, c2, m2, _3, T3, C3);
      for (var H2 = 1; H2 < C3; H2 <<= 1)
        for (var P3 = H2 << 1, l2 = Math.cos(2 * Math.PI / P3), x3 = Math.sin(2 * Math.PI / P3), re = 0; re < C3; re += P3)
          for (var ae = l2, G2 = x3, ce = 0; ce < H2; ce++) {
            var me = _3[re + ce], ye = T3[re + ce], xe = _3[re + ce + H2], ve = T3[re + ce + H2], b2 = ae * xe - G2 * ve;
            ve = ae * ve + G2 * xe, xe = b2, _3[re + ce] = me + xe, T3[re + ce] = ye + ve, _3[re + ce + H2] = me - xe, T3[re + ce + H2] = ye - ve, ce !== P3 && (b2 = l2 * ae - x3 * G2, G2 = l2 * G2 + x3 * ae, ae = b2);
          }
    }, S2.prototype.guessLen13b = function(c2, m2) {
      var _3 = Math.max(m2, c2) | 1, T3 = _3 & 1, C3 = 0;
      for (_3 = _3 / 2 | 0; _3; _3 = _3 >>> 1)
        C3++;
      return 1 << C3 + 1 + T3;
    }, S2.prototype.conjugate = function(c2, m2, _3) {
      if (!(_3 <= 1))
        for (var T3 = 0; T3 < _3 / 2; T3++) {
          var C3 = c2[T3];
          c2[T3] = c2[_3 - T3 - 1], c2[_3 - T3 - 1] = C3, C3 = m2[T3], m2[T3] = -m2[_3 - T3 - 1], m2[_3 - T3 - 1] = -C3;
        }
    }, S2.prototype.normalize13b = function(c2, m2) {
      for (var _3 = 0, T3 = 0; T3 < m2 / 2; T3++) {
        var C3 = Math.round(c2[2 * T3 + 1] / m2) * 8192 + Math.round(c2[2 * T3] / m2) + _3;
        c2[T3] = C3 & 67108863, C3 < 67108864 ? _3 = 0 : _3 = C3 / 67108864 | 0;
      }
      return c2;
    }, S2.prototype.convert13b = function(c2, m2, _3, T3) {
      for (var C3 = 0, L2 = 0; L2 < m2; L2++)
        C3 = C3 + (c2[L2] | 0), _3[2 * L2] = C3 & 8191, C3 = C3 >>> 13, _3[2 * L2 + 1] = C3 & 8191, C3 = C3 >>> 13;
      for (L2 = 2 * m2; L2 < T3; ++L2)
        _3[L2] = 0;
      n2(C3 === 0), n2((C3 & -8192) === 0);
    }, S2.prototype.stub = function(c2) {
      for (var m2 = new Array(c2), _3 = 0; _3 < c2; _3++)
        m2[_3] = 0;
      return m2;
    }, S2.prototype.mulp = function(c2, m2, _3) {
      var T3 = 2 * this.guessLen13b(c2.length, m2.length), C3 = this.makeRBT(T3), L2 = this.stub(T3), H2 = new Array(T3), P3 = new Array(T3), l2 = new Array(T3), x3 = new Array(T3), re = new Array(T3), ae = new Array(T3), G2 = _3.words;
      G2.length = T3, this.convert13b(c2.words, c2.length, H2, T3), this.convert13b(m2.words, m2.length, x3, T3), this.transform(H2, L2, P3, l2, T3, C3), this.transform(x3, L2, re, ae, T3, C3);
      for (var ce = 0; ce < T3; ce++) {
        var me = P3[ce] * re[ce] - l2[ce] * ae[ce];
        l2[ce] = P3[ce] * ae[ce] + l2[ce] * re[ce], P3[ce] = me;
      }
      return this.conjugate(P3, l2, T3), this.transform(P3, l2, G2, L2, T3, C3), this.conjugate(G2, L2, T3), this.normalize13b(G2, T3), _3.negative = c2.negative ^ m2.negative, _3.length = c2.length + m2.length, _3.strip();
    }, o2.prototype.mul = function(c2) {
      var m2 = new o2(null);
      return m2.words = new Array(this.length + c2.length), this.mulTo(c2, m2);
    }, o2.prototype.mulf = function(c2) {
      var m2 = new o2(null);
      return m2.words = new Array(this.length + c2.length), M3(this, c2, m2);
    }, o2.prototype.imul = function(c2) {
      return this.clone().mulTo(c2, this);
    }, o2.prototype.imuln = function(c2) {
      n2(typeof c2 == "number"), n2(c2 < 67108864);
      for (var m2 = 0, _3 = 0; _3 < this.length; _3++) {
        var T3 = (this.words[_3] | 0) * c2, C3 = (T3 & 67108863) + (m2 & 67108863);
        m2 >>= 26, m2 += T3 / 67108864 | 0, m2 += C3 >>> 26, this.words[_3] = C3 & 67108863;
      }
      return m2 !== 0 && (this.words[_3] = m2, this.length++), this;
    }, o2.prototype.muln = function(c2) {
      return this.clone().imuln(c2);
    }, o2.prototype.sqr = function() {
      return this.mul(this);
    }, o2.prototype.isqr = function() {
      return this.imul(this.clone());
    }, o2.prototype.pow = function(c2) {
      var m2 = w3(c2);
      if (m2.length === 0)
        return new o2(1);
      for (var _3 = this, T3 = 0; T3 < m2.length && m2[T3] === 0; T3++, _3 = _3.sqr())
        ;
      if (++T3 < m2.length)
        for (var C3 = _3.sqr(); T3 < m2.length; T3++, C3 = C3.sqr())
          m2[T3] !== 0 && (_3 = _3.mul(C3));
      return _3;
    }, o2.prototype.iushln = function(c2) {
      n2(typeof c2 == "number" && c2 >= 0);
      var m2 = c2 % 26, _3 = (c2 - m2) / 26, T3 = 67108863 >>> 26 - m2 << 26 - m2, C3;
      if (m2 !== 0) {
        var L2 = 0;
        for (C3 = 0; C3 < this.length; C3++) {
          var H2 = this.words[C3] & T3, P3 = (this.words[C3] | 0) - H2 << m2;
          this.words[C3] = P3 | L2, L2 = H2 >>> 26 - m2;
        }
        L2 && (this.words[C3] = L2, this.length++);
      }
      if (_3 !== 0) {
        for (C3 = this.length - 1; C3 >= 0; C3--)
          this.words[C3 + _3] = this.words[C3];
        for (C3 = 0; C3 < _3; C3++)
          this.words[C3] = 0;
        this.length += _3;
      }
      return this.strip();
    }, o2.prototype.ishln = function(c2) {
      return n2(this.negative === 0), this.iushln(c2);
    }, o2.prototype.iushrn = function(c2, m2, _3) {
      n2(typeof c2 == "number" && c2 >= 0);
      var T3;
      m2 ? T3 = (m2 - m2 % 26) / 26 : T3 = 0;
      var C3 = c2 % 26, L2 = Math.min((c2 - C3) / 26, this.length), H2 = 67108863 ^ 67108863 >>> C3 << C3, P3 = _3;
      if (T3 -= L2, T3 = Math.max(0, T3), P3) {
        for (var l2 = 0; l2 < L2; l2++)
          P3.words[l2] = this.words[l2];
        P3.length = L2;
      }
      if (L2 !== 0)
        if (this.length > L2)
          for (this.length -= L2, l2 = 0; l2 < this.length; l2++)
            this.words[l2] = this.words[l2 + L2];
        else
          this.words[0] = 0, this.length = 1;
      var x3 = 0;
      for (l2 = this.length - 1; l2 >= 0 && (x3 !== 0 || l2 >= T3); l2--) {
        var re = this.words[l2] | 0;
        this.words[l2] = x3 << 26 - C3 | re >>> C3, x3 = re & H2;
      }
      return P3 && x3 !== 0 && (P3.words[P3.length++] = x3), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, o2.prototype.ishrn = function(c2, m2, _3) {
      return n2(this.negative === 0), this.iushrn(c2, m2, _3);
    }, o2.prototype.shln = function(c2) {
      return this.clone().ishln(c2);
    }, o2.prototype.ushln = function(c2) {
      return this.clone().iushln(c2);
    }, o2.prototype.shrn = function(c2) {
      return this.clone().ishrn(c2);
    }, o2.prototype.ushrn = function(c2) {
      return this.clone().iushrn(c2);
    }, o2.prototype.testn = function(c2) {
      n2(typeof c2 == "number" && c2 >= 0);
      var m2 = c2 % 26, _3 = (c2 - m2) / 26, T3 = 1 << m2;
      if (this.length <= _3)
        return false;
      var C3 = this.words[_3];
      return !!(C3 & T3);
    }, o2.prototype.imaskn = function(c2) {
      n2(typeof c2 == "number" && c2 >= 0);
      var m2 = c2 % 26, _3 = (c2 - m2) / 26;
      if (n2(this.negative === 0, "imaskn works only with positive numbers"), this.length <= _3)
        return this;
      if (m2 !== 0 && _3++, this.length = Math.min(_3, this.length), m2 !== 0) {
        var T3 = 67108863 ^ 67108863 >>> m2 << m2;
        this.words[this.length - 1] &= T3;
      }
      return this.strip();
    }, o2.prototype.maskn = function(c2) {
      return this.clone().imaskn(c2);
    }, o2.prototype.iaddn = function(c2) {
      return n2(typeof c2 == "number"), n2(c2 < 67108864), c2 < 0 ? this.isubn(-c2) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < c2 ? (this.words[0] = c2 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(c2), this.negative = 1, this) : this._iaddn(c2);
    }, o2.prototype._iaddn = function(c2) {
      this.words[0] += c2;
      for (var m2 = 0; m2 < this.length && this.words[m2] >= 67108864; m2++)
        this.words[m2] -= 67108864, m2 === this.length - 1 ? this.words[m2 + 1] = 1 : this.words[m2 + 1]++;
      return this.length = Math.max(this.length, m2 + 1), this;
    }, o2.prototype.isubn = function(c2) {
      if (n2(typeof c2 == "number"), n2(c2 < 67108864), c2 < 0)
        return this.iaddn(-c2);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(c2), this.negative = 1, this;
      if (this.words[0] -= c2, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var m2 = 0; m2 < this.length && this.words[m2] < 0; m2++)
          this.words[m2] += 67108864, this.words[m2 + 1] -= 1;
      return this.strip();
    }, o2.prototype.addn = function(c2) {
      return this.clone().iaddn(c2);
    }, o2.prototype.subn = function(c2) {
      return this.clone().isubn(c2);
    }, o2.prototype.iabs = function() {
      return this.negative = 0, this;
    }, o2.prototype.abs = function() {
      return this.clone().iabs();
    }, o2.prototype._ishlnsubmul = function(c2, m2, _3) {
      var T3 = c2.length + _3, C3;
      this._expand(T3);
      var L2, H2 = 0;
      for (C3 = 0; C3 < c2.length; C3++) {
        L2 = (this.words[C3 + _3] | 0) + H2;
        var P3 = (c2.words[C3] | 0) * m2;
        L2 -= P3 & 67108863, H2 = (L2 >> 26) - (P3 / 67108864 | 0), this.words[C3 + _3] = L2 & 67108863;
      }
      for (; C3 < this.length - _3; C3++)
        L2 = (this.words[C3 + _3] | 0) + H2, H2 = L2 >> 26, this.words[C3 + _3] = L2 & 67108863;
      if (H2 === 0)
        return this.strip();
      for (n2(H2 === -1), H2 = 0, C3 = 0; C3 < this.length; C3++)
        L2 = -(this.words[C3] | 0) + H2, H2 = L2 >> 26, this.words[C3] = L2 & 67108863;
      return this.negative = 1, this.strip();
    }, o2.prototype._wordDiv = function(c2, m2) {
      var _3 = this.length - c2.length, T3 = this.clone(), C3 = c2, L2 = C3.words[C3.length - 1] | 0, H2 = this._countBits(L2);
      _3 = 26 - H2, _3 !== 0 && (C3 = C3.ushln(_3), T3.iushln(_3), L2 = C3.words[C3.length - 1] | 0);
      var P3 = T3.length - C3.length, l2;
      if (m2 !== "mod") {
        l2 = new o2(null), l2.length = P3 + 1, l2.words = new Array(l2.length);
        for (var x3 = 0; x3 < l2.length; x3++)
          l2.words[x3] = 0;
      }
      var re = T3.clone()._ishlnsubmul(C3, 1, P3);
      re.negative === 0 && (T3 = re, l2 && (l2.words[P3] = 1));
      for (var ae = P3 - 1; ae >= 0; ae--) {
        var G2 = (T3.words[C3.length + ae] | 0) * 67108864 + (T3.words[C3.length + ae - 1] | 0);
        for (G2 = Math.min(G2 / L2 | 0, 67108863), T3._ishlnsubmul(C3, G2, ae); T3.negative !== 0; )
          G2--, T3.negative = 0, T3._ishlnsubmul(C3, 1, ae), T3.isZero() || (T3.negative ^= 1);
        l2 && (l2.words[ae] = G2);
      }
      return l2 && l2.strip(), T3.strip(), m2 !== "div" && _3 !== 0 && T3.iushrn(_3), {
        div: l2 || null,
        mod: T3
      };
    }, o2.prototype.divmod = function(c2, m2, _3) {
      if (n2(!c2.isZero()), this.isZero())
        return {
          div: new o2(0),
          mod: new o2(0)
        };
      var T3, C3, L2;
      return this.negative !== 0 && c2.negative === 0 ? (L2 = this.neg().divmod(c2, m2), m2 !== "mod" && (T3 = L2.div.neg()), m2 !== "div" && (C3 = L2.mod.neg(), _3 && C3.negative !== 0 && C3.iadd(c2)), {
        div: T3,
        mod: C3
      }) : this.negative === 0 && c2.negative !== 0 ? (L2 = this.divmod(c2.neg(), m2), m2 !== "mod" && (T3 = L2.div.neg()), {
        div: T3,
        mod: L2.mod
      }) : this.negative & c2.negative ? (L2 = this.neg().divmod(c2.neg(), m2), m2 !== "div" && (C3 = L2.mod.neg(), _3 && C3.negative !== 0 && C3.isub(c2)), {
        div: L2.div,
        mod: C3
      }) : c2.length > this.length || this.cmp(c2) < 0 ? {
        div: new o2(0),
        mod: this
      } : c2.length === 1 ? m2 === "div" ? {
        div: this.divn(c2.words[0]),
        mod: null
      } : m2 === "mod" ? {
        div: null,
        mod: new o2(this.modn(c2.words[0]))
      } : {
        div: this.divn(c2.words[0]),
        mod: new o2(this.modn(c2.words[0]))
      } : this._wordDiv(c2, m2);
    }, o2.prototype.div = function(c2) {
      return this.divmod(c2, "div", false).div;
    }, o2.prototype.mod = function(c2) {
      return this.divmod(c2, "mod", false).mod;
    }, o2.prototype.umod = function(c2) {
      return this.divmod(c2, "mod", true).mod;
    }, o2.prototype.divRound = function(c2) {
      var m2 = this.divmod(c2);
      if (m2.mod.isZero())
        return m2.div;
      var _3 = m2.div.negative !== 0 ? m2.mod.isub(c2) : m2.mod, T3 = c2.ushrn(1), C3 = c2.andln(1), L2 = _3.cmp(T3);
      return L2 < 0 || C3 === 1 && L2 === 0 ? m2.div : m2.div.negative !== 0 ? m2.div.isubn(1) : m2.div.iaddn(1);
    }, o2.prototype.modn = function(c2) {
      n2(c2 <= 67108863);
      for (var m2 = (1 << 26) % c2, _3 = 0, T3 = this.length - 1; T3 >= 0; T3--)
        _3 = (m2 * _3 + (this.words[T3] | 0)) % c2;
      return _3;
    }, o2.prototype.idivn = function(c2) {
      n2(c2 <= 67108863);
      for (var m2 = 0, _3 = this.length - 1; _3 >= 0; _3--) {
        var T3 = (this.words[_3] | 0) + m2 * 67108864;
        this.words[_3] = T3 / c2 | 0, m2 = T3 % c2;
      }
      return this.strip();
    }, o2.prototype.divn = function(c2) {
      return this.clone().idivn(c2);
    }, o2.prototype.egcd = function(c2) {
      n2(c2.negative === 0), n2(!c2.isZero());
      var m2 = this, _3 = c2.clone();
      m2.negative !== 0 ? m2 = m2.umod(c2) : m2 = m2.clone();
      for (var T3 = new o2(1), C3 = new o2(0), L2 = new o2(0), H2 = new o2(1), P3 = 0; m2.isEven() && _3.isEven(); )
        m2.iushrn(1), _3.iushrn(1), ++P3;
      for (var l2 = _3.clone(), x3 = m2.clone(); !m2.isZero(); ) {
        for (var re = 0, ae = 1; !(m2.words[0] & ae) && re < 26; ++re, ae <<= 1)
          ;
        if (re > 0)
          for (m2.iushrn(re); re-- > 0; )
            (T3.isOdd() || C3.isOdd()) && (T3.iadd(l2), C3.isub(x3)), T3.iushrn(1), C3.iushrn(1);
        for (var G2 = 0, ce = 1; !(_3.words[0] & ce) && G2 < 26; ++G2, ce <<= 1)
          ;
        if (G2 > 0)
          for (_3.iushrn(G2); G2-- > 0; )
            (L2.isOdd() || H2.isOdd()) && (L2.iadd(l2), H2.isub(x3)), L2.iushrn(1), H2.iushrn(1);
        m2.cmp(_3) >= 0 ? (m2.isub(_3), T3.isub(L2), C3.isub(H2)) : (_3.isub(m2), L2.isub(T3), H2.isub(C3));
      }
      return {
        a: L2,
        b: H2,
        gcd: _3.iushln(P3)
      };
    }, o2.prototype._invmp = function(c2) {
      n2(c2.negative === 0), n2(!c2.isZero());
      var m2 = this, _3 = c2.clone();
      m2.negative !== 0 ? m2 = m2.umod(c2) : m2 = m2.clone();
      for (var T3 = new o2(1), C3 = new o2(0), L2 = _3.clone(); m2.cmpn(1) > 0 && _3.cmpn(1) > 0; ) {
        for (var H2 = 0, P3 = 1; !(m2.words[0] & P3) && H2 < 26; ++H2, P3 <<= 1)
          ;
        if (H2 > 0)
          for (m2.iushrn(H2); H2-- > 0; )
            T3.isOdd() && T3.iadd(L2), T3.iushrn(1);
        for (var l2 = 0, x3 = 1; !(_3.words[0] & x3) && l2 < 26; ++l2, x3 <<= 1)
          ;
        if (l2 > 0)
          for (_3.iushrn(l2); l2-- > 0; )
            C3.isOdd() && C3.iadd(L2), C3.iushrn(1);
        m2.cmp(_3) >= 0 ? (m2.isub(_3), T3.isub(C3)) : (_3.isub(m2), C3.isub(T3));
      }
      var re;
      return m2.cmpn(1) === 0 ? re = T3 : re = C3, re.cmpn(0) < 0 && re.iadd(c2), re;
    }, o2.prototype.gcd = function(c2) {
      if (this.isZero())
        return c2.abs();
      if (c2.isZero())
        return this.abs();
      var m2 = this.clone(), _3 = c2.clone();
      m2.negative = 0, _3.negative = 0;
      for (var T3 = 0; m2.isEven() && _3.isEven(); T3++)
        m2.iushrn(1), _3.iushrn(1);
      do {
        for (; m2.isEven(); )
          m2.iushrn(1);
        for (; _3.isEven(); )
          _3.iushrn(1);
        var C3 = m2.cmp(_3);
        if (C3 < 0) {
          var L2 = m2;
          m2 = _3, _3 = L2;
        } else if (C3 === 0 || _3.cmpn(1) === 0)
          break;
        m2.isub(_3);
      } while (true);
      return _3.iushln(T3);
    }, o2.prototype.invm = function(c2) {
      return this.egcd(c2).a.umod(c2);
    }, o2.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, o2.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, o2.prototype.andln = function(c2) {
      return this.words[0] & c2;
    }, o2.prototype.bincn = function(c2) {
      n2(typeof c2 == "number");
      var m2 = c2 % 26, _3 = (c2 - m2) / 26, T3 = 1 << m2;
      if (this.length <= _3)
        return this._expand(_3 + 1), this.words[_3] |= T3, this;
      for (var C3 = T3, L2 = _3; C3 !== 0 && L2 < this.length; L2++) {
        var H2 = this.words[L2] | 0;
        H2 += C3, C3 = H2 >>> 26, H2 &= 67108863, this.words[L2] = H2;
      }
      return C3 !== 0 && (this.words[L2] = C3, this.length++), this;
    }, o2.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, o2.prototype.cmpn = function(c2) {
      var m2 = c2 < 0;
      if (this.negative !== 0 && !m2)
        return -1;
      if (this.negative === 0 && m2)
        return 1;
      this.strip();
      var _3;
      if (this.length > 1)
        _3 = 1;
      else {
        m2 && (c2 = -c2), n2(c2 <= 67108863, "Number is too big");
        var T3 = this.words[0] | 0;
        _3 = T3 === c2 ? 0 : T3 < c2 ? -1 : 1;
      }
      return this.negative !== 0 ? -_3 | 0 : _3;
    }, o2.prototype.cmp = function(c2) {
      if (this.negative !== 0 && c2.negative === 0)
        return -1;
      if (this.negative === 0 && c2.negative !== 0)
        return 1;
      var m2 = this.ucmp(c2);
      return this.negative !== 0 ? -m2 | 0 : m2;
    }, o2.prototype.ucmp = function(c2) {
      if (this.length > c2.length)
        return 1;
      if (this.length < c2.length)
        return -1;
      for (var m2 = 0, _3 = this.length - 1; _3 >= 0; _3--) {
        var T3 = this.words[_3] | 0, C3 = c2.words[_3] | 0;
        if (T3 !== C3) {
          T3 < C3 ? m2 = -1 : T3 > C3 && (m2 = 1);
          break;
        }
      }
      return m2;
    }, o2.prototype.gtn = function(c2) {
      return this.cmpn(c2) === 1;
    }, o2.prototype.gt = function(c2) {
      return this.cmp(c2) === 1;
    }, o2.prototype.gten = function(c2) {
      return this.cmpn(c2) >= 0;
    }, o2.prototype.gte = function(c2) {
      return this.cmp(c2) >= 0;
    }, o2.prototype.ltn = function(c2) {
      return this.cmpn(c2) === -1;
    }, o2.prototype.lt = function(c2) {
      return this.cmp(c2) === -1;
    }, o2.prototype.lten = function(c2) {
      return this.cmpn(c2) <= 0;
    }, o2.prototype.lte = function(c2) {
      return this.cmp(c2) <= 0;
    }, o2.prototype.eqn = function(c2) {
      return this.cmpn(c2) === 0;
    }, o2.prototype.eq = function(c2) {
      return this.cmp(c2) === 0;
    }, o2.red = function(c2) {
      return new se(c2);
    }, o2.prototype.toRed = function(c2) {
      return n2(!this.red, "Already a number in reduction context"), n2(this.negative === 0, "red works only with positives"), c2.convertTo(this)._forceRed(c2);
    }, o2.prototype.fromRed = function() {
      return n2(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, o2.prototype._forceRed = function(c2) {
      return this.red = c2, this;
    }, o2.prototype.forceRed = function(c2) {
      return n2(!this.red, "Already a number in reduction context"), this._forceRed(c2);
    }, o2.prototype.redAdd = function(c2) {
      return n2(this.red, "redAdd works only with red numbers"), this.red.add(this, c2);
    }, o2.prototype.redIAdd = function(c2) {
      return n2(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, c2);
    }, o2.prototype.redSub = function(c2) {
      return n2(this.red, "redSub works only with red numbers"), this.red.sub(this, c2);
    }, o2.prototype.redISub = function(c2) {
      return n2(this.red, "redISub works only with red numbers"), this.red.isub(this, c2);
    }, o2.prototype.redShl = function(c2) {
      return n2(this.red, "redShl works only with red numbers"), this.red.shl(this, c2);
    }, o2.prototype.redMul = function(c2) {
      return n2(this.red, "redMul works only with red numbers"), this.red._verify2(this, c2), this.red.mul(this, c2);
    }, o2.prototype.redIMul = function(c2) {
      return n2(this.red, "redMul works only with red numbers"), this.red._verify2(this, c2), this.red.imul(this, c2);
    }, o2.prototype.redSqr = function() {
      return n2(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, o2.prototype.redISqr = function() {
      return n2(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, o2.prototype.redSqrt = function() {
      return n2(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, o2.prototype.redInvm = function() {
      return n2(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, o2.prototype.redNeg = function() {
      return n2(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, o2.prototype.redPow = function(c2) {
      return n2(this.red && !c2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, c2);
    };
    var Y2 = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function W2(O2, c2) {
      this.name = O2, this.p = new o2(c2, 16), this.n = this.p.bitLength(), this.k = new o2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    W2.prototype._tmp = function() {
      var c2 = new o2(null);
      return c2.words = new Array(Math.ceil(this.n / 13)), c2;
    }, W2.prototype.ireduce = function(c2) {
      var m2 = c2, _3;
      do
        this.split(m2, this.tmp), m2 = this.imulK(m2), m2 = m2.iadd(this.tmp), _3 = m2.bitLength();
      while (_3 > this.n);
      var T3 = _3 < this.n ? -1 : m2.ucmp(this.p);
      return T3 === 0 ? (m2.words[0] = 0, m2.length = 1) : T3 > 0 ? m2.isub(this.p) : m2.strip !== void 0 ? m2.strip() : m2._strip(), m2;
    }, W2.prototype.split = function(c2, m2) {
      c2.iushrn(this.n, 0, m2);
    }, W2.prototype.imulK = function(c2) {
      return c2.imul(this.k);
    };
    function Q3() {
      W2.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i2(Q3, W2), Q3.prototype.split = function(c2, m2) {
      for (var _3 = 4194303, T3 = Math.min(c2.length, 9), C3 = 0; C3 < T3; C3++)
        m2.words[C3] = c2.words[C3];
      if (m2.length = T3, c2.length <= 9) {
        c2.words[0] = 0, c2.length = 1;
        return;
      }
      var L2 = c2.words[9];
      for (m2.words[m2.length++] = L2 & _3, C3 = 10; C3 < c2.length; C3++) {
        var H2 = c2.words[C3] | 0;
        c2.words[C3 - 10] = (H2 & _3) << 4 | L2 >>> 22, L2 = H2;
      }
      L2 >>>= 22, c2.words[C3 - 10] = L2, L2 === 0 && c2.length > 10 ? c2.length -= 10 : c2.length -= 9;
    }, Q3.prototype.imulK = function(c2) {
      c2.words[c2.length] = 0, c2.words[c2.length + 1] = 0, c2.length += 2;
      for (var m2 = 0, _3 = 0; _3 < c2.length; _3++) {
        var T3 = c2.words[_3] | 0;
        m2 += T3 * 977, c2.words[_3] = m2 & 67108863, m2 = T3 * 64 + (m2 / 67108864 | 0);
      }
      return c2.words[c2.length - 1] === 0 && (c2.length--, c2.words[c2.length - 1] === 0 && c2.length--), c2;
    };
    function X3() {
      W2.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i2(X3, W2);
    function ne() {
      W2.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i2(ne, W2);
    function ue() {
      W2.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i2(ue, W2), ue.prototype.imulK = function(c2) {
      for (var m2 = 0, _3 = 0; _3 < c2.length; _3++) {
        var T3 = (c2.words[_3] | 0) * 19 + m2, C3 = T3 & 67108863;
        T3 >>>= 26, c2.words[_3] = C3, m2 = T3;
      }
      return m2 !== 0 && (c2.words[c2.length++] = m2), c2;
    }, o2._prime = function(c2) {
      if (Y2[c2])
        return Y2[c2];
      var m2;
      if (c2 === "k256")
        m2 = new Q3();
      else if (c2 === "p224")
        m2 = new X3();
      else if (c2 === "p192")
        m2 = new ne();
      else if (c2 === "p25519")
        m2 = new ue();
      else
        throw new Error("Unknown prime " + c2);
      return Y2[c2] = m2, m2;
    };
    function se(O2) {
      if (typeof O2 == "string") {
        var c2 = o2._prime(O2);
        this.m = c2.p, this.prime = c2;
      } else
        n2(O2.gtn(1), "modulus must be greater than 1"), this.m = O2, this.prime = null;
    }
    se.prototype._verify1 = function(c2) {
      n2(c2.negative === 0, "red works only with positives"), n2(c2.red, "red works only with red numbers");
    }, se.prototype._verify2 = function(c2, m2) {
      n2((c2.negative | m2.negative) === 0, "red works only with positives"), n2(
        c2.red && c2.red === m2.red,
        "red works only with red numbers"
      );
    }, se.prototype.imod = function(c2) {
      return this.prime ? this.prime.ireduce(c2)._forceRed(this) : c2.umod(this.m)._forceRed(this);
    }, se.prototype.neg = function(c2) {
      return c2.isZero() ? c2.clone() : this.m.sub(c2)._forceRed(this);
    }, se.prototype.add = function(c2, m2) {
      this._verify2(c2, m2);
      var _3 = c2.add(m2);
      return _3.cmp(this.m) >= 0 && _3.isub(this.m), _3._forceRed(this);
    }, se.prototype.iadd = function(c2, m2) {
      this._verify2(c2, m2);
      var _3 = c2.iadd(m2);
      return _3.cmp(this.m) >= 0 && _3.isub(this.m), _3;
    }, se.prototype.sub = function(c2, m2) {
      this._verify2(c2, m2);
      var _3 = c2.sub(m2);
      return _3.cmpn(0) < 0 && _3.iadd(this.m), _3._forceRed(this);
    }, se.prototype.isub = function(c2, m2) {
      this._verify2(c2, m2);
      var _3 = c2.isub(m2);
      return _3.cmpn(0) < 0 && _3.iadd(this.m), _3;
    }, se.prototype.shl = function(c2, m2) {
      return this._verify1(c2), this.imod(c2.ushln(m2));
    }, se.prototype.imul = function(c2, m2) {
      return this._verify2(c2, m2), this.imod(c2.imul(m2));
    }, se.prototype.mul = function(c2, m2) {
      return this._verify2(c2, m2), this.imod(c2.mul(m2));
    }, se.prototype.isqr = function(c2) {
      return this.imul(c2, c2.clone());
    }, se.prototype.sqr = function(c2) {
      return this.mul(c2, c2);
    }, se.prototype.sqrt = function(c2) {
      if (c2.isZero())
        return c2.clone();
      var m2 = this.m.andln(3);
      if (n2(m2 % 2 === 1), m2 === 3) {
        var _3 = this.m.add(new o2(1)).iushrn(2);
        return this.pow(c2, _3);
      }
      for (var T3 = this.m.subn(1), C3 = 0; !T3.isZero() && T3.andln(1) === 0; )
        C3++, T3.iushrn(1);
      n2(!T3.isZero());
      var L2 = new o2(1).toRed(this), H2 = L2.redNeg(), P3 = this.m.subn(1).iushrn(1), l2 = this.m.bitLength();
      for (l2 = new o2(2 * l2 * l2).toRed(this); this.pow(l2, P3).cmp(H2) !== 0; )
        l2.redIAdd(H2);
      for (var x3 = this.pow(l2, T3), re = this.pow(c2, T3.addn(1).iushrn(1)), ae = this.pow(c2, T3), G2 = C3; ae.cmp(L2) !== 0; ) {
        for (var ce = ae, me = 0; ce.cmp(L2) !== 0; me++)
          ce = ce.redSqr();
        n2(me < G2);
        var ye = this.pow(x3, new o2(1).iushln(G2 - me - 1));
        re = re.redMul(ye), x3 = ye.redSqr(), ae = ae.redMul(x3), G2 = me;
      }
      return re;
    }, se.prototype.invm = function(c2) {
      var m2 = c2._invmp(this.m);
      return m2.negative !== 0 ? (m2.negative = 0, this.imod(m2).redNeg()) : this.imod(m2);
    }, se.prototype.pow = function(c2, m2) {
      if (m2.isZero())
        return new o2(1).toRed(this);
      if (m2.cmpn(1) === 0)
        return c2.clone();
      var _3 = 4, T3 = new Array(1 << _3);
      T3[0] = new o2(1).toRed(this), T3[1] = c2;
      for (var C3 = 2; C3 < T3.length; C3++)
        T3[C3] = this.mul(T3[C3 - 1], c2);
      var L2 = T3[0], H2 = 0, P3 = 0, l2 = m2.bitLength() % 26;
      for (l2 === 0 && (l2 = 26), C3 = m2.length - 1; C3 >= 0; C3--) {
        for (var x3 = m2.words[C3], re = l2 - 1; re >= 0; re--) {
          var ae = x3 >> re & 1;
          if (L2 !== T3[0] && (L2 = this.sqr(L2)), ae === 0 && H2 === 0) {
            P3 = 0;
            continue;
          }
          H2 <<= 1, H2 |= ae, P3++, !(P3 !== _3 && (C3 !== 0 || re !== 0)) && (L2 = this.mul(L2, T3[H2]), P3 = 0, H2 = 0);
        }
        l2 = 26;
      }
      return L2;
    }, se.prototype.convertTo = function(c2) {
      var m2 = c2.umod(this.m);
      return m2 === c2 ? m2.clone() : m2;
    }, se.prototype.convertFrom = function(c2) {
      var m2 = c2.clone();
      return m2.red = null, m2;
    }, o2.mont = function(c2) {
      return new ie(c2);
    };
    function ie(O2) {
      se.call(this, O2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i2(ie, se), ie.prototype.convertTo = function(c2) {
      return this.imod(c2.ushln(this.shift));
    }, ie.prototype.convertFrom = function(c2) {
      var m2 = this.imod(c2.mul(this.rinv));
      return m2.red = null, m2;
    }, ie.prototype.imul = function(c2, m2) {
      if (c2.isZero() || m2.isZero())
        return c2.words[0] = 0, c2.length = 1, c2;
      var _3 = c2.imul(m2), T3 = _3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), C3 = _3.isub(T3).iushrn(this.shift), L2 = C3;
      return C3.cmp(this.m) >= 0 ? L2 = C3.isub(this.m) : C3.cmpn(0) < 0 && (L2 = C3.iadd(this.m)), L2._forceRed(this);
    }, ie.prototype.mul = function(c2, m2) {
      if (c2.isZero() || m2.isZero())
        return new o2(0)._forceRed(this);
      var _3 = c2.mul(m2), T3 = _3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), C3 = _3.isub(T3).iushrn(this.shift), L2 = C3;
      return C3.cmp(this.m) >= 0 ? L2 = C3.isub(this.m) : C3.cmpn(0) < 0 && (L2 = C3.iadd(this.m)), L2._forceRed(this);
    }, ie.prototype.invm = function(c2) {
      var m2 = this.imod(c2._invmp(this.m).mul(this.r2));
      return m2._forceRed(this);
    };
  })(t2, ge2);
})(rs);
var bc = rs.exports;
var xc = {};
var ns = {};
var po = { exports: {} };
typeof Object.create == "function" ? po.exports = function(e2, r2) {
  r2 && (e2.super_ = r2, e2.prototype = Object.create(r2.prototype, {
    constructor: {
      value: e2,
      enumerable: false,
      writable: true,
      configurable: true
    }
  }));
} : po.exports = function(e2, r2) {
  if (r2) {
    e2.super_ = r2;
    var n2 = function() {
    };
    n2.prototype = r2.prototype, e2.prototype = new n2(), e2.prototype.constructor = e2;
  }
};
var Er2 = po.exports;
var Tc = {};
var Cn = {};
Cn.byteLength = hd;
Cn.toByteArray = pd;
Cn.fromByteArray = yd;
var Kt = [];
var kt = [];
var ld = typeof Uint8Array < "u" ? Uint8Array : Array;
var Ui = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (Pr = 0, fd = Ui.length; Pr < fd; ++Pr)
  Kt[Pr] = Ui[Pr], kt[Ui.charCodeAt(Pr)] = Pr;
var Pr;
var fd;
kt["-".charCodeAt(0)] = 62;
kt["_".charCodeAt(0)] = 63;
function Ec(t2) {
  var e2 = t2.length;
  if (e2 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r2 = t2.indexOf("=");
  r2 === -1 && (r2 = e2);
  var n2 = r2 === e2 ? 0 : 4 - r2 % 4;
  return [r2, n2];
}
function hd(t2) {
  var e2 = Ec(t2), r2 = e2[0], n2 = e2[1];
  return (r2 + n2) * 3 / 4 - n2;
}
function dd(t2, e2, r2) {
  return (e2 + r2) * 3 / 4 - r2;
}
function pd(t2) {
  var e2, r2 = Ec(t2), n2 = r2[0], i2 = r2[1], o2 = new ld(dd(t2, n2, i2)), s2 = 0, a2 = i2 > 0 ? n2 - 4 : n2, f2;
  for (f2 = 0; f2 < a2; f2 += 4)
    e2 = kt[t2.charCodeAt(f2)] << 18 | kt[t2.charCodeAt(f2 + 1)] << 12 | kt[t2.charCodeAt(f2 + 2)] << 6 | kt[t2.charCodeAt(f2 + 3)], o2[s2++] = e2 >> 16 & 255, o2[s2++] = e2 >> 8 & 255, o2[s2++] = e2 & 255;
  return i2 === 2 && (e2 = kt[t2.charCodeAt(f2)] << 2 | kt[t2.charCodeAt(f2 + 1)] >> 4, o2[s2++] = e2 & 255), i2 === 1 && (e2 = kt[t2.charCodeAt(f2)] << 10 | kt[t2.charCodeAt(f2 + 1)] << 4 | kt[t2.charCodeAt(f2 + 2)] >> 2, o2[s2++] = e2 >> 8 & 255, o2[s2++] = e2 & 255), o2;
}
function md(t2) {
  return Kt[t2 >> 18 & 63] + Kt[t2 >> 12 & 63] + Kt[t2 >> 6 & 63] + Kt[t2 & 63];
}
function gd(t2, e2, r2) {
  for (var n2, i2 = [], o2 = e2; o2 < r2; o2 += 3)
    n2 = (t2[o2] << 16 & 16711680) + (t2[o2 + 1] << 8 & 65280) + (t2[o2 + 2] & 255), i2.push(md(n2));
  return i2.join("");
}
function yd(t2) {
  for (var e2, r2 = t2.length, n2 = r2 % 3, i2 = [], o2 = 16383, s2 = 0, a2 = r2 - n2; s2 < a2; s2 += o2)
    i2.push(gd(t2, s2, s2 + o2 > a2 ? a2 : s2 + o2));
  return n2 === 1 ? (e2 = t2[r2 - 1], i2.push(
    Kt[e2 >> 2] + Kt[e2 << 4 & 63] + "=="
  )) : n2 === 2 && (e2 = (t2[r2 - 2] << 8) + t2[r2 - 1], i2.push(
    Kt[e2 >> 10] + Kt[e2 >> 4 & 63] + Kt[e2 << 2 & 63] + "="
  )), i2.join("");
}
var is = {};
is.read = function(t2, e2, r2, n2, i2) {
  var o2, s2, a2 = i2 * 8 - n2 - 1, f2 = (1 << a2) - 1, p2 = f2 >> 1, d2 = -7, y2 = r2 ? i2 - 1 : 0, v3 = r2 ? -1 : 1, w3 = t2[e2 + y2];
  for (y2 += v3, o2 = w3 & (1 << -d2) - 1, w3 >>= -d2, d2 += a2; d2 > 0; o2 = o2 * 256 + t2[e2 + y2], y2 += v3, d2 -= 8)
    ;
  for (s2 = o2 & (1 << -d2) - 1, o2 >>= -d2, d2 += n2; d2 > 0; s2 = s2 * 256 + t2[e2 + y2], y2 += v3, d2 -= 8)
    ;
  if (o2 === 0)
    o2 = 1 - p2;
  else {
    if (o2 === f2)
      return s2 ? NaN : (w3 ? -1 : 1) * (1 / 0);
    s2 = s2 + Math.pow(2, n2), o2 = o2 - p2;
  }
  return (w3 ? -1 : 1) * s2 * Math.pow(2, o2 - n2);
};
is.write = function(t2, e2, r2, n2, i2, o2) {
  var s2, a2, f2, p2 = o2 * 8 - i2 - 1, d2 = (1 << p2) - 1, y2 = d2 >> 1, v3 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, w3 = n2 ? 0 : o2 - 1, I3 = n2 ? 1 : -1, N11 = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0;
  for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (a2 = isNaN(e2) ? 1 : 0, s2 = d2) : (s2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (f2 = Math.pow(2, -s2)) < 1 && (s2--, f2 *= 2), s2 + y2 >= 1 ? e2 += v3 / f2 : e2 += v3 * Math.pow(2, 1 - y2), e2 * f2 >= 2 && (s2++, f2 /= 2), s2 + y2 >= d2 ? (a2 = 0, s2 = d2) : s2 + y2 >= 1 ? (a2 = (e2 * f2 - 1) * Math.pow(2, i2), s2 = s2 + y2) : (a2 = e2 * Math.pow(2, y2 - 1) * Math.pow(2, i2), s2 = 0)); i2 >= 8; t2[r2 + w3] = a2 & 255, w3 += I3, a2 /= 256, i2 -= 8)
    ;
  for (s2 = s2 << i2 | a2, p2 += i2; p2 > 0; t2[r2 + w3] = s2 & 255, w3 += I3, s2 /= 256, p2 -= 8)
    ;
  t2[r2 + w3 - I3] |= N11 * 128;
};
(function(t2) {
  const e2 = Cn, r2 = is, n2 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t2.Buffer = a2, t2.SlowBuffer = S2, t2.INSPECT_MAX_BYTES = 50;
  const i2 = 2147483647;
  t2.kMaxLength = i2, a2.TYPED_ARRAY_SUPPORT = o2(), !a2.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function o2() {
    try {
      const g2 = new Uint8Array(1), u2 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(u2, Uint8Array.prototype), Object.setPrototypeOf(g2, u2), g2.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(a2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (a2.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(a2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (a2.isBuffer(this))
        return this.byteOffset;
    }
  });
  function s2(g2) {
    if (g2 > i2)
      throw new RangeError('The value "' + g2 + '" is invalid for option "size"');
    const u2 = new Uint8Array(g2);
    return Object.setPrototypeOf(u2, a2.prototype), u2;
  }
  function a2(g2, u2, h2) {
    if (typeof g2 == "number") {
      if (typeof u2 == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return y2(g2);
    }
    return f2(g2, u2, h2);
  }
  a2.poolSize = 8192;
  function f2(g2, u2, h2) {
    if (typeof g2 == "string")
      return v3(g2, u2);
    if (ArrayBuffer.isView(g2))
      return I3(g2);
    if (g2 == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof g2
      );
    if (de(g2, ArrayBuffer) || g2 && de(g2.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (de(g2, SharedArrayBuffer) || g2 && de(g2.buffer, SharedArrayBuffer)))
      return N11(g2, u2, h2);
    if (typeof g2 == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const A2 = g2.valueOf && g2.valueOf();
    if (A2 != null && A2 !== g2)
      return a2.from(A2, u2, h2);
    const B3 = k2(g2);
    if (B3)
      return B3;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof g2[Symbol.toPrimitive] == "function")
      return a2.from(g2[Symbol.toPrimitive]("string"), u2, h2);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof g2
    );
  }
  a2.from = function(g2, u2, h2) {
    return f2(g2, u2, h2);
  }, Object.setPrototypeOf(a2.prototype, Uint8Array.prototype), Object.setPrototypeOf(a2, Uint8Array);
  function p2(g2) {
    if (typeof g2 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (g2 < 0)
      throw new RangeError('The value "' + g2 + '" is invalid for option "size"');
  }
  function d2(g2, u2, h2) {
    return p2(g2), g2 <= 0 ? s2(g2) : u2 !== void 0 ? typeof h2 == "string" ? s2(g2).fill(u2, h2) : s2(g2).fill(u2) : s2(g2);
  }
  a2.alloc = function(g2, u2, h2) {
    return d2(g2, u2, h2);
  };
  function y2(g2) {
    return p2(g2), s2(g2 < 0 ? 0 : M3(g2) | 0);
  }
  a2.allocUnsafe = function(g2) {
    return y2(g2);
  }, a2.allocUnsafeSlow = function(g2) {
    return y2(g2);
  };
  function v3(g2, u2) {
    if ((typeof u2 != "string" || u2 === "") && (u2 = "utf8"), !a2.isEncoding(u2))
      throw new TypeError("Unknown encoding: " + u2);
    const h2 = Y2(g2, u2) | 0;
    let A2 = s2(h2);
    const B3 = A2.write(g2, u2);
    return B3 !== h2 && (A2 = A2.slice(0, B3)), A2;
  }
  function w3(g2) {
    const u2 = g2.length < 0 ? 0 : M3(g2.length) | 0, h2 = s2(u2);
    for (let A2 = 0; A2 < u2; A2 += 1)
      h2[A2] = g2[A2] & 255;
    return h2;
  }
  function I3(g2) {
    if (de(g2, Uint8Array)) {
      const u2 = new Uint8Array(g2);
      return N11(u2.buffer, u2.byteOffset, u2.byteLength);
    }
    return w3(g2);
  }
  function N11(g2, u2, h2) {
    if (u2 < 0 || g2.byteLength < u2)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (g2.byteLength < u2 + (h2 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let A2;
    return u2 === void 0 && h2 === void 0 ? A2 = new Uint8Array(g2) : h2 === void 0 ? A2 = new Uint8Array(g2, u2) : A2 = new Uint8Array(g2, u2, h2), Object.setPrototypeOf(A2, a2.prototype), A2;
  }
  function k2(g2) {
    if (a2.isBuffer(g2)) {
      const u2 = M3(g2.length) | 0, h2 = s2(u2);
      return h2.length === 0 || g2.copy(h2, 0, 0, u2), h2;
    }
    if (g2.length !== void 0)
      return typeof g2.length != "number" || Ee(g2.length) ? s2(0) : w3(g2);
    if (g2.type === "Buffer" && Array.isArray(g2.data))
      return w3(g2.data);
  }
  function M3(g2) {
    if (g2 >= i2)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i2.toString(16) + " bytes");
    return g2 | 0;
  }
  function S2(g2) {
    return +g2 != g2 && (g2 = 0), a2.alloc(+g2);
  }
  a2.isBuffer = function(u2) {
    return u2 != null && u2._isBuffer === true && u2 !== a2.prototype;
  }, a2.compare = function(u2, h2) {
    if (de(u2, Uint8Array) && (u2 = a2.from(u2, u2.offset, u2.byteLength)), de(h2, Uint8Array) && (h2 = a2.from(h2, h2.offset, h2.byteLength)), !a2.isBuffer(u2) || !a2.isBuffer(h2))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (u2 === h2)
      return 0;
    let A2 = u2.length, B3 = h2.length;
    for (let z3 = 0, F2 = Math.min(A2, B3); z3 < F2; ++z3)
      if (u2[z3] !== h2[z3]) {
        A2 = u2[z3], B3 = h2[z3];
        break;
      }
    return A2 < B3 ? -1 : B3 < A2 ? 1 : 0;
  }, a2.isEncoding = function(u2) {
    switch (String(u2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, a2.concat = function(u2, h2) {
    if (!Array.isArray(u2))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (u2.length === 0)
      return a2.alloc(0);
    let A2;
    if (h2 === void 0)
      for (h2 = 0, A2 = 0; A2 < u2.length; ++A2)
        h2 += u2[A2].length;
    const B3 = a2.allocUnsafe(h2);
    let z3 = 0;
    for (A2 = 0; A2 < u2.length; ++A2) {
      let F2 = u2[A2];
      if (de(F2, Uint8Array))
        z3 + F2.length > B3.length ? (a2.isBuffer(F2) || (F2 = a2.from(F2)), F2.copy(B3, z3)) : Uint8Array.prototype.set.call(
          B3,
          F2,
          z3
        );
      else if (a2.isBuffer(F2))
        F2.copy(B3, z3);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      z3 += F2.length;
    }
    return B3;
  };
  function Y2(g2, u2) {
    if (a2.isBuffer(g2))
      return g2.length;
    if (ArrayBuffer.isView(g2) || de(g2, ArrayBuffer))
      return g2.byteLength;
    if (typeof g2 != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof g2
      );
    const h2 = g2.length, A2 = arguments.length > 2 && arguments[2] === true;
    if (!A2 && h2 === 0)
      return 0;
    let B3 = false;
    for (; ; )
      switch (u2) {
        case "ascii":
        case "latin1":
        case "binary":
          return h2;
        case "utf8":
        case "utf-8":
          return j2(g2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return h2 * 2;
        case "hex":
          return h2 >>> 1;
        case "base64":
          return ee2(g2).length;
        default:
          if (B3)
            return A2 ? -1 : j2(g2).length;
          u2 = ("" + u2).toLowerCase(), B3 = true;
      }
  }
  a2.byteLength = Y2;
  function W2(g2, u2, h2) {
    let A2 = false;
    if ((u2 === void 0 || u2 < 0) && (u2 = 0), u2 > this.length || ((h2 === void 0 || h2 > this.length) && (h2 = this.length), h2 <= 0) || (h2 >>>= 0, u2 >>>= 0, h2 <= u2))
      return "";
    for (g2 || (g2 = "utf8"); ; )
      switch (g2) {
        case "hex":
          return P3(this, u2, h2);
        case "utf8":
        case "utf-8":
          return _3(this, u2, h2);
        case "ascii":
          return L2(this, u2, h2);
        case "latin1":
        case "binary":
          return H2(this, u2, h2);
        case "base64":
          return m2(this, u2, h2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return l2(this, u2, h2);
        default:
          if (A2)
            throw new TypeError("Unknown encoding: " + g2);
          g2 = (g2 + "").toLowerCase(), A2 = true;
      }
  }
  a2.prototype._isBuffer = true;
  function Q3(g2, u2, h2) {
    const A2 = g2[u2];
    g2[u2] = g2[h2], g2[h2] = A2;
  }
  a2.prototype.swap16 = function() {
    const u2 = this.length;
    if (u2 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let h2 = 0; h2 < u2; h2 += 2)
      Q3(this, h2, h2 + 1);
    return this;
  }, a2.prototype.swap32 = function() {
    const u2 = this.length;
    if (u2 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let h2 = 0; h2 < u2; h2 += 4)
      Q3(this, h2, h2 + 3), Q3(this, h2 + 1, h2 + 2);
    return this;
  }, a2.prototype.swap64 = function() {
    const u2 = this.length;
    if (u2 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let h2 = 0; h2 < u2; h2 += 8)
      Q3(this, h2, h2 + 7), Q3(this, h2 + 1, h2 + 6), Q3(this, h2 + 2, h2 + 5), Q3(this, h2 + 3, h2 + 4);
    return this;
  }, a2.prototype.toString = function() {
    const u2 = this.length;
    return u2 === 0 ? "" : arguments.length === 0 ? _3(this, 0, u2) : W2.apply(this, arguments);
  }, a2.prototype.toLocaleString = a2.prototype.toString, a2.prototype.equals = function(u2) {
    if (!a2.isBuffer(u2))
      throw new TypeError("Argument must be a Buffer");
    return this === u2 ? true : a2.compare(this, u2) === 0;
  }, a2.prototype.inspect = function() {
    let u2 = "";
    const h2 = t2.INSPECT_MAX_BYTES;
    return u2 = this.toString("hex", 0, h2).replace(/(.{2})/g, "$1 ").trim(), this.length > h2 && (u2 += " ... "), "<Buffer " + u2 + ">";
  }, n2 && (a2.prototype[n2] = a2.prototype.inspect), a2.prototype.compare = function(u2, h2, A2, B3, z3) {
    if (de(u2, Uint8Array) && (u2 = a2.from(u2, u2.offset, u2.byteLength)), !a2.isBuffer(u2))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof u2
      );
    if (h2 === void 0 && (h2 = 0), A2 === void 0 && (A2 = u2 ? u2.length : 0), B3 === void 0 && (B3 = 0), z3 === void 0 && (z3 = this.length), h2 < 0 || A2 > u2.length || B3 < 0 || z3 > this.length)
      throw new RangeError("out of range index");
    if (B3 >= z3 && h2 >= A2)
      return 0;
    if (B3 >= z3)
      return -1;
    if (h2 >= A2)
      return 1;
    if (h2 >>>= 0, A2 >>>= 0, B3 >>>= 0, z3 >>>= 0, this === u2)
      return 0;
    let F2 = z3 - B3, fe = A2 - h2;
    const we = Math.min(F2, fe), _e = this.slice(B3, z3), be = u2.slice(h2, A2);
    for (let Be = 0; Be < we; ++Be)
      if (_e[Be] !== be[Be]) {
        F2 = _e[Be], fe = be[Be];
        break;
      }
    return F2 < fe ? -1 : fe < F2 ? 1 : 0;
  };
  function X3(g2, u2, h2, A2, B3) {
    if (g2.length === 0)
      return -1;
    if (typeof h2 == "string" ? (A2 = h2, h2 = 0) : h2 > 2147483647 ? h2 = 2147483647 : h2 < -2147483648 && (h2 = -2147483648), h2 = +h2, Ee(h2) && (h2 = B3 ? 0 : g2.length - 1), h2 < 0 && (h2 = g2.length + h2), h2 >= g2.length) {
      if (B3)
        return -1;
      h2 = g2.length - 1;
    } else if (h2 < 0)
      if (B3)
        h2 = 0;
      else
        return -1;
    if (typeof u2 == "string" && (u2 = a2.from(u2, A2)), a2.isBuffer(u2))
      return u2.length === 0 ? -1 : ne(g2, u2, h2, A2, B3);
    if (typeof u2 == "number")
      return u2 = u2 & 255, typeof Uint8Array.prototype.indexOf == "function" ? B3 ? Uint8Array.prototype.indexOf.call(g2, u2, h2) : Uint8Array.prototype.lastIndexOf.call(g2, u2, h2) : ne(g2, [u2], h2, A2, B3);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ne(g2, u2, h2, A2, B3) {
    let z3 = 1, F2 = g2.length, fe = u2.length;
    if (A2 !== void 0 && (A2 = String(A2).toLowerCase(), A2 === "ucs2" || A2 === "ucs-2" || A2 === "utf16le" || A2 === "utf-16le")) {
      if (g2.length < 2 || u2.length < 2)
        return -1;
      z3 = 2, F2 /= 2, fe /= 2, h2 /= 2;
    }
    function we(be, Be) {
      return z3 === 1 ? be[Be] : be.readUInt16BE(Be * z3);
    }
    let _e;
    if (B3) {
      let be = -1;
      for (_e = h2; _e < F2; _e++)
        if (we(g2, _e) === we(u2, be === -1 ? 0 : _e - be)) {
          if (be === -1 && (be = _e), _e - be + 1 === fe)
            return be * z3;
        } else
          be !== -1 && (_e -= _e - be), be = -1;
    } else
      for (h2 + fe > F2 && (h2 = F2 - fe), _e = h2; _e >= 0; _e--) {
        let be = true;
        for (let Be = 0; Be < fe; Be++)
          if (we(g2, _e + Be) !== we(u2, Be)) {
            be = false;
            break;
          }
        if (be)
          return _e;
      }
    return -1;
  }
  a2.prototype.includes = function(u2, h2, A2) {
    return this.indexOf(u2, h2, A2) !== -1;
  }, a2.prototype.indexOf = function(u2, h2, A2) {
    return X3(this, u2, h2, A2, true);
  }, a2.prototype.lastIndexOf = function(u2, h2, A2) {
    return X3(this, u2, h2, A2, false);
  };
  function ue(g2, u2, h2, A2) {
    h2 = Number(h2) || 0;
    const B3 = g2.length - h2;
    A2 ? (A2 = Number(A2), A2 > B3 && (A2 = B3)) : A2 = B3;
    const z3 = u2.length;
    A2 > z3 / 2 && (A2 = z3 / 2);
    let F2;
    for (F2 = 0; F2 < A2; ++F2) {
      const fe = parseInt(u2.substr(F2 * 2, 2), 16);
      if (Ee(fe))
        return F2;
      g2[h2 + F2] = fe;
    }
    return F2;
  }
  function se(g2, u2, h2, A2) {
    return oe2(j2(u2, g2.length - h2), g2, h2, A2);
  }
  function ie(g2, u2, h2, A2) {
    return oe2(q2(u2), g2, h2, A2);
  }
  function O2(g2, u2, h2, A2) {
    return oe2(ee2(u2), g2, h2, A2);
  }
  function c2(g2, u2, h2, A2) {
    return oe2(Z3(u2, g2.length - h2), g2, h2, A2);
  }
  a2.prototype.write = function(u2, h2, A2, B3) {
    if (h2 === void 0)
      B3 = "utf8", A2 = this.length, h2 = 0;
    else if (A2 === void 0 && typeof h2 == "string")
      B3 = h2, A2 = this.length, h2 = 0;
    else if (isFinite(h2))
      h2 = h2 >>> 0, isFinite(A2) ? (A2 = A2 >>> 0, B3 === void 0 && (B3 = "utf8")) : (B3 = A2, A2 = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const z3 = this.length - h2;
    if ((A2 === void 0 || A2 > z3) && (A2 = z3), u2.length > 0 && (A2 < 0 || h2 < 0) || h2 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    B3 || (B3 = "utf8");
    let F2 = false;
    for (; ; )
      switch (B3) {
        case "hex":
          return ue(this, u2, h2, A2);
        case "utf8":
        case "utf-8":
          return se(this, u2, h2, A2);
        case "ascii":
        case "latin1":
        case "binary":
          return ie(this, u2, h2, A2);
        case "base64":
          return O2(this, u2, h2, A2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return c2(this, u2, h2, A2);
        default:
          if (F2)
            throw new TypeError("Unknown encoding: " + B3);
          B3 = ("" + B3).toLowerCase(), F2 = true;
      }
  }, a2.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function m2(g2, u2, h2) {
    return u2 === 0 && h2 === g2.length ? e2.fromByteArray(g2) : e2.fromByteArray(g2.slice(u2, h2));
  }
  function _3(g2, u2, h2) {
    h2 = Math.min(g2.length, h2);
    const A2 = [];
    let B3 = u2;
    for (; B3 < h2; ) {
      const z3 = g2[B3];
      let F2 = null, fe = z3 > 239 ? 4 : z3 > 223 ? 3 : z3 > 191 ? 2 : 1;
      if (B3 + fe <= h2) {
        let we, _e, be, Be;
        switch (fe) {
          case 1:
            z3 < 128 && (F2 = z3);
            break;
          case 2:
            we = g2[B3 + 1], (we & 192) === 128 && (Be = (z3 & 31) << 6 | we & 63, Be > 127 && (F2 = Be));
            break;
          case 3:
            we = g2[B3 + 1], _e = g2[B3 + 2], (we & 192) === 128 && (_e & 192) === 128 && (Be = (z3 & 15) << 12 | (we & 63) << 6 | _e & 63, Be > 2047 && (Be < 55296 || Be > 57343) && (F2 = Be));
            break;
          case 4:
            we = g2[B3 + 1], _e = g2[B3 + 2], be = g2[B3 + 3], (we & 192) === 128 && (_e & 192) === 128 && (be & 192) === 128 && (Be = (z3 & 15) << 18 | (we & 63) << 12 | (_e & 63) << 6 | be & 63, Be > 65535 && Be < 1114112 && (F2 = Be));
        }
      }
      F2 === null ? (F2 = 65533, fe = 1) : F2 > 65535 && (F2 -= 65536, A2.push(F2 >>> 10 & 1023 | 55296), F2 = 56320 | F2 & 1023), A2.push(F2), B3 += fe;
    }
    return C3(A2);
  }
  const T3 = 4096;
  function C3(g2) {
    const u2 = g2.length;
    if (u2 <= T3)
      return String.fromCharCode.apply(String, g2);
    let h2 = "", A2 = 0;
    for (; A2 < u2; )
      h2 += String.fromCharCode.apply(
        String,
        g2.slice(A2, A2 += T3)
      );
    return h2;
  }
  function L2(g2, u2, h2) {
    let A2 = "";
    h2 = Math.min(g2.length, h2);
    for (let B3 = u2; B3 < h2; ++B3)
      A2 += String.fromCharCode(g2[B3] & 127);
    return A2;
  }
  function H2(g2, u2, h2) {
    let A2 = "";
    h2 = Math.min(g2.length, h2);
    for (let B3 = u2; B3 < h2; ++B3)
      A2 += String.fromCharCode(g2[B3]);
    return A2;
  }
  function P3(g2, u2, h2) {
    const A2 = g2.length;
    (!u2 || u2 < 0) && (u2 = 0), (!h2 || h2 < 0 || h2 > A2) && (h2 = A2);
    let B3 = "";
    for (let z3 = u2; z3 < h2; ++z3)
      B3 += Ae[g2[z3]];
    return B3;
  }
  function l2(g2, u2, h2) {
    const A2 = g2.slice(u2, h2);
    let B3 = "";
    for (let z3 = 0; z3 < A2.length - 1; z3 += 2)
      B3 += String.fromCharCode(A2[z3] + A2[z3 + 1] * 256);
    return B3;
  }
  a2.prototype.slice = function(u2, h2) {
    const A2 = this.length;
    u2 = ~~u2, h2 = h2 === void 0 ? A2 : ~~h2, u2 < 0 ? (u2 += A2, u2 < 0 && (u2 = 0)) : u2 > A2 && (u2 = A2), h2 < 0 ? (h2 += A2, h2 < 0 && (h2 = 0)) : h2 > A2 && (h2 = A2), h2 < u2 && (h2 = u2);
    const B3 = this.subarray(u2, h2);
    return Object.setPrototypeOf(B3, a2.prototype), B3;
  };
  function x3(g2, u2, h2) {
    if (g2 % 1 !== 0 || g2 < 0)
      throw new RangeError("offset is not uint");
    if (g2 + u2 > h2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  a2.prototype.readUintLE = a2.prototype.readUIntLE = function(u2, h2, A2) {
    u2 = u2 >>> 0, h2 = h2 >>> 0, A2 || x3(u2, h2, this.length);
    let B3 = this[u2], z3 = 1, F2 = 0;
    for (; ++F2 < h2 && (z3 *= 256); )
      B3 += this[u2 + F2] * z3;
    return B3;
  }, a2.prototype.readUintBE = a2.prototype.readUIntBE = function(u2, h2, A2) {
    u2 = u2 >>> 0, h2 = h2 >>> 0, A2 || x3(u2, h2, this.length);
    let B3 = this[u2 + --h2], z3 = 1;
    for (; h2 > 0 && (z3 *= 256); )
      B3 += this[u2 + --h2] * z3;
    return B3;
  }, a2.prototype.readUint8 = a2.prototype.readUInt8 = function(u2, h2) {
    return u2 = u2 >>> 0, h2 || x3(u2, 1, this.length), this[u2];
  }, a2.prototype.readUint16LE = a2.prototype.readUInt16LE = function(u2, h2) {
    return u2 = u2 >>> 0, h2 || x3(u2, 2, this.length), this[u2] | this[u2 + 1] << 8;
  }, a2.prototype.readUint16BE = a2.prototype.readUInt16BE = function(u2, h2) {
    return u2 = u2 >>> 0, h2 || x3(u2, 2, this.length), this[u2] << 8 | this[u2 + 1];
  }, a2.prototype.readUint32LE = a2.prototype.readUInt32LE = function(u2, h2) {
    return u2 = u2 >>> 0, h2 || x3(u2, 4, this.length), (this[u2] | this[u2 + 1] << 8 | this[u2 + 2] << 16) + this[u2 + 3] * 16777216;
  }, a2.prototype.readUint32BE = a2.prototype.readUInt32BE = function(u2, h2) {
    return u2 = u2 >>> 0, h2 || x3(u2, 4, this.length), this[u2] * 16777216 + (this[u2 + 1] << 16 | this[u2 + 2] << 8 | this[u2 + 3]);
  }, a2.prototype.readBigUInt64LE = U2(function(u2) {
    u2 = u2 >>> 0, V2(u2, "offset");
    const h2 = this[u2], A2 = this[u2 + 7];
    (h2 === void 0 || A2 === void 0) && K2(u2, this.length - 8);
    const B3 = h2 + this[++u2] * 2 ** 8 + this[++u2] * 2 ** 16 + this[++u2] * 2 ** 24, z3 = this[++u2] + this[++u2] * 2 ** 8 + this[++u2] * 2 ** 16 + A2 * 2 ** 24;
    return BigInt(B3) + (BigInt(z3) << BigInt(32));
  }), a2.prototype.readBigUInt64BE = U2(function(u2) {
    u2 = u2 >>> 0, V2(u2, "offset");
    const h2 = this[u2], A2 = this[u2 + 7];
    (h2 === void 0 || A2 === void 0) && K2(u2, this.length - 8);
    const B3 = h2 * 2 ** 24 + this[++u2] * 2 ** 16 + this[++u2] * 2 ** 8 + this[++u2], z3 = this[++u2] * 2 ** 24 + this[++u2] * 2 ** 16 + this[++u2] * 2 ** 8 + A2;
    return (BigInt(B3) << BigInt(32)) + BigInt(z3);
  }), a2.prototype.readIntLE = function(u2, h2, A2) {
    u2 = u2 >>> 0, h2 = h2 >>> 0, A2 || x3(u2, h2, this.length);
    let B3 = this[u2], z3 = 1, F2 = 0;
    for (; ++F2 < h2 && (z3 *= 256); )
      B3 += this[u2 + F2] * z3;
    return z3 *= 128, B3 >= z3 && (B3 -= Math.pow(2, 8 * h2)), B3;
  }, a2.prototype.readIntBE = function(u2, h2, A2) {
    u2 = u2 >>> 0, h2 = h2 >>> 0, A2 || x3(u2, h2, this.length);
    let B3 = h2, z3 = 1, F2 = this[u2 + --B3];
    for (; B3 > 0 && (z3 *= 256); )
      F2 += this[u2 + --B3] * z3;
    return z3 *= 128, F2 >= z3 && (F2 -= Math.pow(2, 8 * h2)), F2;
  }, a2.prototype.readInt8 = function(u2, h2) {
    return u2 = u2 >>> 0, h2 || x3(u2, 1, this.length), this[u2] & 128 ? (255 - this[u2] + 1) * -1 : this[u2];
  }, a2.prototype.readInt16LE = function(u2, h2) {
    u2 = u2 >>> 0, h2 || x3(u2, 2, this.length);
    const A2 = this[u2] | this[u2 + 1] << 8;
    return A2 & 32768 ? A2 | 4294901760 : A2;
  }, a2.prototype.readInt16BE = function(u2, h2) {
    u2 = u2 >>> 0, h2 || x3(u2, 2, this.length);
    const A2 = this[u2 + 1] | this[u2] << 8;
    return A2 & 32768 ? A2 | 4294901760 : A2;
  }, a2.prototype.readInt32LE = function(u2, h2) {
    return u2 = u2 >>> 0, h2 || x3(u2, 4, this.length), this[u2] | this[u2 + 1] << 8 | this[u2 + 2] << 16 | this[u2 + 3] << 24;
  }, a2.prototype.readInt32BE = function(u2, h2) {
    return u2 = u2 >>> 0, h2 || x3(u2, 4, this.length), this[u2] << 24 | this[u2 + 1] << 16 | this[u2 + 2] << 8 | this[u2 + 3];
  }, a2.prototype.readBigInt64LE = U2(function(u2) {
    u2 = u2 >>> 0, V2(u2, "offset");
    const h2 = this[u2], A2 = this[u2 + 7];
    (h2 === void 0 || A2 === void 0) && K2(u2, this.length - 8);
    const B3 = this[u2 + 4] + this[u2 + 5] * 2 ** 8 + this[u2 + 6] * 2 ** 16 + (A2 << 24);
    return (BigInt(B3) << BigInt(32)) + BigInt(h2 + this[++u2] * 2 ** 8 + this[++u2] * 2 ** 16 + this[++u2] * 2 ** 24);
  }), a2.prototype.readBigInt64BE = U2(function(u2) {
    u2 = u2 >>> 0, V2(u2, "offset");
    const h2 = this[u2], A2 = this[u2 + 7];
    (h2 === void 0 || A2 === void 0) && K2(u2, this.length - 8);
    const B3 = (h2 << 24) + // Overflow
    this[++u2] * 2 ** 16 + this[++u2] * 2 ** 8 + this[++u2];
    return (BigInt(B3) << BigInt(32)) + BigInt(this[++u2] * 2 ** 24 + this[++u2] * 2 ** 16 + this[++u2] * 2 ** 8 + A2);
  }), a2.prototype.readFloatLE = function(u2, h2) {
    return u2 = u2 >>> 0, h2 || x3(u2, 4, this.length), r2.read(this, u2, true, 23, 4);
  }, a2.prototype.readFloatBE = function(u2, h2) {
    return u2 = u2 >>> 0, h2 || x3(u2, 4, this.length), r2.read(this, u2, false, 23, 4);
  }, a2.prototype.readDoubleLE = function(u2, h2) {
    return u2 = u2 >>> 0, h2 || x3(u2, 8, this.length), r2.read(this, u2, true, 52, 8);
  }, a2.prototype.readDoubleBE = function(u2, h2) {
    return u2 = u2 >>> 0, h2 || x3(u2, 8, this.length), r2.read(this, u2, false, 52, 8);
  };
  function re(g2, u2, h2, A2, B3, z3) {
    if (!a2.isBuffer(g2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (u2 > B3 || u2 < z3)
      throw new RangeError('"value" argument is out of bounds');
    if (h2 + A2 > g2.length)
      throw new RangeError("Index out of range");
  }
  a2.prototype.writeUintLE = a2.prototype.writeUIntLE = function(u2, h2, A2, B3) {
    if (u2 = +u2, h2 = h2 >>> 0, A2 = A2 >>> 0, !B3) {
      const fe = Math.pow(2, 8 * A2) - 1;
      re(this, u2, h2, A2, fe, 0);
    }
    let z3 = 1, F2 = 0;
    for (this[h2] = u2 & 255; ++F2 < A2 && (z3 *= 256); )
      this[h2 + F2] = u2 / z3 & 255;
    return h2 + A2;
  }, a2.prototype.writeUintBE = a2.prototype.writeUIntBE = function(u2, h2, A2, B3) {
    if (u2 = +u2, h2 = h2 >>> 0, A2 = A2 >>> 0, !B3) {
      const fe = Math.pow(2, 8 * A2) - 1;
      re(this, u2, h2, A2, fe, 0);
    }
    let z3 = A2 - 1, F2 = 1;
    for (this[h2 + z3] = u2 & 255; --z3 >= 0 && (F2 *= 256); )
      this[h2 + z3] = u2 / F2 & 255;
    return h2 + A2;
  }, a2.prototype.writeUint8 = a2.prototype.writeUInt8 = function(u2, h2, A2) {
    return u2 = +u2, h2 = h2 >>> 0, A2 || re(this, u2, h2, 1, 255, 0), this[h2] = u2 & 255, h2 + 1;
  }, a2.prototype.writeUint16LE = a2.prototype.writeUInt16LE = function(u2, h2, A2) {
    return u2 = +u2, h2 = h2 >>> 0, A2 || re(this, u2, h2, 2, 65535, 0), this[h2] = u2 & 255, this[h2 + 1] = u2 >>> 8, h2 + 2;
  }, a2.prototype.writeUint16BE = a2.prototype.writeUInt16BE = function(u2, h2, A2) {
    return u2 = +u2, h2 = h2 >>> 0, A2 || re(this, u2, h2, 2, 65535, 0), this[h2] = u2 >>> 8, this[h2 + 1] = u2 & 255, h2 + 2;
  }, a2.prototype.writeUint32LE = a2.prototype.writeUInt32LE = function(u2, h2, A2) {
    return u2 = +u2, h2 = h2 >>> 0, A2 || re(this, u2, h2, 4, 4294967295, 0), this[h2 + 3] = u2 >>> 24, this[h2 + 2] = u2 >>> 16, this[h2 + 1] = u2 >>> 8, this[h2] = u2 & 255, h2 + 4;
  }, a2.prototype.writeUint32BE = a2.prototype.writeUInt32BE = function(u2, h2, A2) {
    return u2 = +u2, h2 = h2 >>> 0, A2 || re(this, u2, h2, 4, 4294967295, 0), this[h2] = u2 >>> 24, this[h2 + 1] = u2 >>> 16, this[h2 + 2] = u2 >>> 8, this[h2 + 3] = u2 & 255, h2 + 4;
  };
  function ae(g2, u2, h2, A2, B3) {
    E3(u2, A2, B3, g2, h2, 7);
    let z3 = Number(u2 & BigInt(4294967295));
    g2[h2++] = z3, z3 = z3 >> 8, g2[h2++] = z3, z3 = z3 >> 8, g2[h2++] = z3, z3 = z3 >> 8, g2[h2++] = z3;
    let F2 = Number(u2 >> BigInt(32) & BigInt(4294967295));
    return g2[h2++] = F2, F2 = F2 >> 8, g2[h2++] = F2, F2 = F2 >> 8, g2[h2++] = F2, F2 = F2 >> 8, g2[h2++] = F2, h2;
  }
  function G2(g2, u2, h2, A2, B3) {
    E3(u2, A2, B3, g2, h2, 7);
    let z3 = Number(u2 & BigInt(4294967295));
    g2[h2 + 7] = z3, z3 = z3 >> 8, g2[h2 + 6] = z3, z3 = z3 >> 8, g2[h2 + 5] = z3, z3 = z3 >> 8, g2[h2 + 4] = z3;
    let F2 = Number(u2 >> BigInt(32) & BigInt(4294967295));
    return g2[h2 + 3] = F2, F2 = F2 >> 8, g2[h2 + 2] = F2, F2 = F2 >> 8, g2[h2 + 1] = F2, F2 = F2 >> 8, g2[h2] = F2, h2 + 8;
  }
  a2.prototype.writeBigUInt64LE = U2(function(u2, h2 = 0) {
    return ae(this, u2, h2, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a2.prototype.writeBigUInt64BE = U2(function(u2, h2 = 0) {
    return G2(this, u2, h2, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a2.prototype.writeIntLE = function(u2, h2, A2, B3) {
    if (u2 = +u2, h2 = h2 >>> 0, !B3) {
      const we = Math.pow(2, 8 * A2 - 1);
      re(this, u2, h2, A2, we - 1, -we);
    }
    let z3 = 0, F2 = 1, fe = 0;
    for (this[h2] = u2 & 255; ++z3 < A2 && (F2 *= 256); )
      u2 < 0 && fe === 0 && this[h2 + z3 - 1] !== 0 && (fe = 1), this[h2 + z3] = (u2 / F2 >> 0) - fe & 255;
    return h2 + A2;
  }, a2.prototype.writeIntBE = function(u2, h2, A2, B3) {
    if (u2 = +u2, h2 = h2 >>> 0, !B3) {
      const we = Math.pow(2, 8 * A2 - 1);
      re(this, u2, h2, A2, we - 1, -we);
    }
    let z3 = A2 - 1, F2 = 1, fe = 0;
    for (this[h2 + z3] = u2 & 255; --z3 >= 0 && (F2 *= 256); )
      u2 < 0 && fe === 0 && this[h2 + z3 + 1] !== 0 && (fe = 1), this[h2 + z3] = (u2 / F2 >> 0) - fe & 255;
    return h2 + A2;
  }, a2.prototype.writeInt8 = function(u2, h2, A2) {
    return u2 = +u2, h2 = h2 >>> 0, A2 || re(this, u2, h2, 1, 127, -128), u2 < 0 && (u2 = 255 + u2 + 1), this[h2] = u2 & 255, h2 + 1;
  }, a2.prototype.writeInt16LE = function(u2, h2, A2) {
    return u2 = +u2, h2 = h2 >>> 0, A2 || re(this, u2, h2, 2, 32767, -32768), this[h2] = u2 & 255, this[h2 + 1] = u2 >>> 8, h2 + 2;
  }, a2.prototype.writeInt16BE = function(u2, h2, A2) {
    return u2 = +u2, h2 = h2 >>> 0, A2 || re(this, u2, h2, 2, 32767, -32768), this[h2] = u2 >>> 8, this[h2 + 1] = u2 & 255, h2 + 2;
  }, a2.prototype.writeInt32LE = function(u2, h2, A2) {
    return u2 = +u2, h2 = h2 >>> 0, A2 || re(this, u2, h2, 4, 2147483647, -2147483648), this[h2] = u2 & 255, this[h2 + 1] = u2 >>> 8, this[h2 + 2] = u2 >>> 16, this[h2 + 3] = u2 >>> 24, h2 + 4;
  }, a2.prototype.writeInt32BE = function(u2, h2, A2) {
    return u2 = +u2, h2 = h2 >>> 0, A2 || re(this, u2, h2, 4, 2147483647, -2147483648), u2 < 0 && (u2 = 4294967295 + u2 + 1), this[h2] = u2 >>> 24, this[h2 + 1] = u2 >>> 16, this[h2 + 2] = u2 >>> 8, this[h2 + 3] = u2 & 255, h2 + 4;
  }, a2.prototype.writeBigInt64LE = U2(function(u2, h2 = 0) {
    return ae(this, u2, h2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), a2.prototype.writeBigInt64BE = U2(function(u2, h2 = 0) {
    return G2(this, u2, h2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ce(g2, u2, h2, A2, B3, z3) {
    if (h2 + A2 > g2.length)
      throw new RangeError("Index out of range");
    if (h2 < 0)
      throw new RangeError("Index out of range");
  }
  function me(g2, u2, h2, A2, B3) {
    return u2 = +u2, h2 = h2 >>> 0, B3 || ce(g2, u2, h2, 4), r2.write(g2, u2, h2, A2, 23, 4), h2 + 4;
  }
  a2.prototype.writeFloatLE = function(u2, h2, A2) {
    return me(this, u2, h2, true, A2);
  }, a2.prototype.writeFloatBE = function(u2, h2, A2) {
    return me(this, u2, h2, false, A2);
  };
  function ye(g2, u2, h2, A2, B3) {
    return u2 = +u2, h2 = h2 >>> 0, B3 || ce(g2, u2, h2, 8), r2.write(g2, u2, h2, A2, 52, 8), h2 + 8;
  }
  a2.prototype.writeDoubleLE = function(u2, h2, A2) {
    return ye(this, u2, h2, true, A2);
  }, a2.prototype.writeDoubleBE = function(u2, h2, A2) {
    return ye(this, u2, h2, false, A2);
  }, a2.prototype.copy = function(u2, h2, A2, B3) {
    if (!a2.isBuffer(u2))
      throw new TypeError("argument should be a Buffer");
    if (A2 || (A2 = 0), !B3 && B3 !== 0 && (B3 = this.length), h2 >= u2.length && (h2 = u2.length), h2 || (h2 = 0), B3 > 0 && B3 < A2 && (B3 = A2), B3 === A2 || u2.length === 0 || this.length === 0)
      return 0;
    if (h2 < 0)
      throw new RangeError("targetStart out of bounds");
    if (A2 < 0 || A2 >= this.length)
      throw new RangeError("Index out of range");
    if (B3 < 0)
      throw new RangeError("sourceEnd out of bounds");
    B3 > this.length && (B3 = this.length), u2.length - h2 < B3 - A2 && (B3 = u2.length - h2 + A2);
    const z3 = B3 - A2;
    return this === u2 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h2, A2, B3) : Uint8Array.prototype.set.call(
      u2,
      this.subarray(A2, B3),
      h2
    ), z3;
  }, a2.prototype.fill = function(u2, h2, A2, B3) {
    if (typeof u2 == "string") {
      if (typeof h2 == "string" ? (B3 = h2, h2 = 0, A2 = this.length) : typeof A2 == "string" && (B3 = A2, A2 = this.length), B3 !== void 0 && typeof B3 != "string")
        throw new TypeError("encoding must be a string");
      if (typeof B3 == "string" && !a2.isEncoding(B3))
        throw new TypeError("Unknown encoding: " + B3);
      if (u2.length === 1) {
        const F2 = u2.charCodeAt(0);
        (B3 === "utf8" && F2 < 128 || B3 === "latin1") && (u2 = F2);
      }
    } else
      typeof u2 == "number" ? u2 = u2 & 255 : typeof u2 == "boolean" && (u2 = Number(u2));
    if (h2 < 0 || this.length < h2 || this.length < A2)
      throw new RangeError("Out of range index");
    if (A2 <= h2)
      return this;
    h2 = h2 >>> 0, A2 = A2 === void 0 ? this.length : A2 >>> 0, u2 || (u2 = 0);
    let z3;
    if (typeof u2 == "number")
      for (z3 = h2; z3 < A2; ++z3)
        this[z3] = u2;
    else {
      const F2 = a2.isBuffer(u2) ? u2 : a2.from(u2, B3), fe = F2.length;
      if (fe === 0)
        throw new TypeError('The value "' + u2 + '" is invalid for argument "value"');
      for (z3 = 0; z3 < A2 - h2; ++z3)
        this[z3 + h2] = F2[z3 % fe];
    }
    return this;
  };
  const xe = {};
  function ve(g2, u2, h2) {
    xe[g2] = class extends h2 {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: u2.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${g2}]`, this.stack, delete this.name;
      }
      get code() {
        return g2;
      }
      set code(B3) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: B3,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${g2}]: ${this.message}`;
      }
    };
  }
  ve(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(g2) {
      return g2 ? `${g2} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), ve(
    "ERR_INVALID_ARG_TYPE",
    function(g2, u2) {
      return `The "${g2}" argument must be of type number. Received type ${typeof u2}`;
    },
    TypeError
  ), ve(
    "ERR_OUT_OF_RANGE",
    function(g2, u2, h2) {
      let A2 = `The value of "${g2}" is out of range.`, B3 = h2;
      return Number.isInteger(h2) && Math.abs(h2) > 2 ** 32 ? B3 = b2(String(h2)) : typeof h2 == "bigint" && (B3 = String(h2), (h2 > BigInt(2) ** BigInt(32) || h2 < -(BigInt(2) ** BigInt(32))) && (B3 = b2(B3)), B3 += "n"), A2 += ` It must be ${u2}. Received ${B3}`, A2;
    },
    RangeError
  );
  function b2(g2) {
    let u2 = "", h2 = g2.length;
    const A2 = g2[0] === "-" ? 1 : 0;
    for (; h2 >= A2 + 4; h2 -= 3)
      u2 = `_${g2.slice(h2 - 3, h2)}${u2}`;
    return `${g2.slice(0, h2)}${u2}`;
  }
  function R2(g2, u2, h2) {
    V2(u2, "offset"), (g2[u2] === void 0 || g2[u2 + h2] === void 0) && K2(u2, g2.length - (h2 + 1));
  }
  function E3(g2, u2, h2, A2, B3, z3) {
    if (g2 > h2 || g2 < u2) {
      const F2 = typeof u2 == "bigint" ? "n" : "";
      let fe;
      throw z3 > 3 ? u2 === 0 || u2 === BigInt(0) ? fe = `>= 0${F2} and < 2${F2} ** ${(z3 + 1) * 8}${F2}` : fe = `>= -(2${F2} ** ${(z3 + 1) * 8 - 1}${F2}) and < 2 ** ${(z3 + 1) * 8 - 1}${F2}` : fe = `>= ${u2}${F2} and <= ${h2}${F2}`, new xe.ERR_OUT_OF_RANGE("value", fe, g2);
    }
    R2(A2, B3, z3);
  }
  function V2(g2, u2) {
    if (typeof g2 != "number")
      throw new xe.ERR_INVALID_ARG_TYPE(u2, "number", g2);
  }
  function K2(g2, u2, h2) {
    throw Math.floor(g2) !== g2 ? (V2(g2, h2), new xe.ERR_OUT_OF_RANGE(h2 || "offset", "an integer", g2)) : u2 < 0 ? new xe.ERR_BUFFER_OUT_OF_BOUNDS() : new xe.ERR_OUT_OF_RANGE(
      h2 || "offset",
      `>= ${h2 ? 1 : 0} and <= ${u2}`,
      g2
    );
  }
  const $3 = /[^+/0-9A-Za-z-_]/g;
  function J2(g2) {
    if (g2 = g2.split("=")[0], g2 = g2.trim().replace($3, ""), g2.length < 2)
      return "";
    for (; g2.length % 4 !== 0; )
      g2 = g2 + "=";
    return g2;
  }
  function j2(g2, u2) {
    u2 = u2 || 1 / 0;
    let h2;
    const A2 = g2.length;
    let B3 = null;
    const z3 = [];
    for (let F2 = 0; F2 < A2; ++F2) {
      if (h2 = g2.charCodeAt(F2), h2 > 55295 && h2 < 57344) {
        if (!B3) {
          if (h2 > 56319) {
            (u2 -= 3) > -1 && z3.push(239, 191, 189);
            continue;
          } else if (F2 + 1 === A2) {
            (u2 -= 3) > -1 && z3.push(239, 191, 189);
            continue;
          }
          B3 = h2;
          continue;
        }
        if (h2 < 56320) {
          (u2 -= 3) > -1 && z3.push(239, 191, 189), B3 = h2;
          continue;
        }
        h2 = (B3 - 55296 << 10 | h2 - 56320) + 65536;
      } else
        B3 && (u2 -= 3) > -1 && z3.push(239, 191, 189);
      if (B3 = null, h2 < 128) {
        if ((u2 -= 1) < 0)
          break;
        z3.push(h2);
      } else if (h2 < 2048) {
        if ((u2 -= 2) < 0)
          break;
        z3.push(
          h2 >> 6 | 192,
          h2 & 63 | 128
        );
      } else if (h2 < 65536) {
        if ((u2 -= 3) < 0)
          break;
        z3.push(
          h2 >> 12 | 224,
          h2 >> 6 & 63 | 128,
          h2 & 63 | 128
        );
      } else if (h2 < 1114112) {
        if ((u2 -= 4) < 0)
          break;
        z3.push(
          h2 >> 18 | 240,
          h2 >> 12 & 63 | 128,
          h2 >> 6 & 63 | 128,
          h2 & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return z3;
  }
  function q2(g2) {
    const u2 = [];
    for (let h2 = 0; h2 < g2.length; ++h2)
      u2.push(g2.charCodeAt(h2) & 255);
    return u2;
  }
  function Z3(g2, u2) {
    let h2, A2, B3;
    const z3 = [];
    for (let F2 = 0; F2 < g2.length && !((u2 -= 2) < 0); ++F2)
      h2 = g2.charCodeAt(F2), A2 = h2 >> 8, B3 = h2 % 256, z3.push(B3), z3.push(A2);
    return z3;
  }
  function ee2(g2) {
    return e2.toByteArray(J2(g2));
  }
  function oe2(g2, u2, h2, A2) {
    let B3;
    for (B3 = 0; B3 < A2 && !(B3 + h2 >= u2.length || B3 >= g2.length); ++B3)
      u2[B3 + h2] = g2[B3];
    return B3;
  }
  function de(g2, u2) {
    return g2 instanceof u2 || g2 != null && g2.constructor != null && g2.constructor.name != null && g2.constructor.name === u2.name;
  }
  function Ee(g2) {
    return g2 !== g2;
  }
  const Ae = function() {
    const g2 = "0123456789abcdef", u2 = new Array(256);
    for (let h2 = 0; h2 < 16; ++h2) {
      const A2 = h2 * 16;
      for (let B3 = 0; B3 < 16; ++B3)
        u2[A2 + B3] = g2[h2] + g2[B3];
    }
    return u2;
  }();
  function U2(g2) {
    return typeof BigInt > "u" ? te2 : g2;
  }
  function te2() {
    throw new Error("BigInt not supported");
  }
})(Tc);
var Gn = Tc;
var Nr = Gn.Buffer;
var Dt2 = {};
var Lt2;
for (Lt2 in Gn)
  Gn.hasOwnProperty(Lt2) && (Lt2 === "SlowBuffer" || Lt2 === "Buffer" || (Dt2[Lt2] = Gn[Lt2]));
var Ur = Dt2.Buffer = {};
for (Lt2 in Nr)
  Nr.hasOwnProperty(Lt2) && (Lt2 === "allocUnsafe" || Lt2 === "allocUnsafeSlow" || (Ur[Lt2] = Nr[Lt2]));
Dt2.Buffer.prototype = Nr.prototype;
(!Ur.from || Ur.from === Uint8Array.from) && (Ur.from = function(t2, e2, r2) {
  if (typeof t2 == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t2);
  if (t2 && typeof t2.length > "u")
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t2);
  return Nr(t2, e2, r2);
});
Ur.alloc || (Ur.alloc = function(t2, e2, r2) {
  if (typeof t2 != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t2);
  if (t2 < 0 || t2 >= 2 * (1 << 30))
    throw new RangeError('The value "' + t2 + '" is invalid for option "size"');
  var n2 = Nr(t2);
  return !e2 || e2.length === 0 ? n2.fill(0) : typeof r2 == "string" ? n2.fill(e2, r2) : n2.fill(e2), n2;
});
if (!Dt2.kStringMaxLength)
  try {
    Dt2.kStringMaxLength = process.binding("buffer").kStringMaxLength;
  } catch {
  }
Dt2.constants || (Dt2.constants = {
  MAX_LENGTH: Dt2.kMaxLength
}, Dt2.kStringMaxLength && (Dt2.constants.MAX_STRING_LENGTH = Dt2.kStringMaxLength));
var os = Dt2;
var yi = {};
var vd = Er2;
function Ut(t2) {
  this._reporterState = {
    obj: null,
    path: [],
    options: t2 || {},
    errors: []
  };
}
yi.Reporter = Ut;
Ut.prototype.isError = function(e2) {
  return e2 instanceof Wr;
};
Ut.prototype.save = function() {
  const e2 = this._reporterState;
  return { obj: e2.obj, pathLen: e2.path.length };
};
Ut.prototype.restore = function(e2) {
  const r2 = this._reporterState;
  r2.obj = e2.obj, r2.path = r2.path.slice(0, e2.pathLen);
};
Ut.prototype.enterKey = function(e2) {
  return this._reporterState.path.push(e2);
};
Ut.prototype.exitKey = function(e2) {
  const r2 = this._reporterState;
  r2.path = r2.path.slice(0, e2 - 1);
};
Ut.prototype.leaveKey = function(e2, r2, n2) {
  const i2 = this._reporterState;
  this.exitKey(e2), i2.obj !== null && (i2.obj[r2] = n2);
};
Ut.prototype.path = function() {
  return this._reporterState.path.join("/");
};
Ut.prototype.enterObject = function() {
  const e2 = this._reporterState, r2 = e2.obj;
  return e2.obj = {}, r2;
};
Ut.prototype.leaveObject = function(e2) {
  const r2 = this._reporterState, n2 = r2.obj;
  return r2.obj = e2, n2;
};
Ut.prototype.error = function(e2) {
  let r2;
  const n2 = this._reporterState, i2 = e2 instanceof Wr;
  if (i2 ? r2 = e2 : r2 = new Wr(n2.path.map(function(o2) {
    return "[" + JSON.stringify(o2) + "]";
  }).join(""), e2.message || e2, e2.stack), !n2.options.partial)
    throw r2;
  return i2 || n2.errors.push(r2), r2;
};
Ut.prototype.wrapResult = function(e2) {
  const r2 = this._reporterState;
  return r2.options.partial ? {
    result: this.isError(e2) ? null : e2,
    errors: r2.errors
  } : e2;
};
function Wr(t2, e2) {
  this.path = t2, this.rethrow(e2);
}
vd(Wr, Error);
Wr.prototype.rethrow = function(e2) {
  if (this.message = e2 + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Wr), !this.stack)
    try {
      throw new Error(this.message);
    } catch (r2) {
      this.stack = r2.stack;
    }
  return this;
};
var xr2 = {};
var wd = Er2;
var vi = yi.Reporter;
var Hr2 = os.Buffer;
function Nt(t2, e2) {
  if (vi.call(this, e2), !Hr2.isBuffer(t2)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = t2, this.offset = 0, this.length = t2.length;
}
wd(Nt, vi);
xr2.DecoderBuffer = Nt;
Nt.isDecoderBuffer = function(e2) {
  return e2 instanceof Nt ? true : typeof e2 == "object" && Hr2.isBuffer(e2.base) && e2.constructor.name === "DecoderBuffer" && typeof e2.offset == "number" && typeof e2.length == "number" && typeof e2.save == "function" && typeof e2.restore == "function" && typeof e2.isEmpty == "function" && typeof e2.readUInt8 == "function" && typeof e2.skip == "function" && typeof e2.raw == "function";
};
Nt.prototype.save = function() {
  return { offset: this.offset, reporter: vi.prototype.save.call(this) };
};
Nt.prototype.restore = function(e2) {
  const r2 = new Nt(this.base);
  return r2.offset = e2.offset, r2.length = this.offset, this.offset = e2.offset, vi.prototype.restore.call(this, e2.reporter), r2;
};
Nt.prototype.isEmpty = function() {
  return this.offset === this.length;
};
Nt.prototype.readUInt8 = function(e2) {
  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e2 || "DecoderBuffer overrun");
};
Nt.prototype.skip = function(e2, r2) {
  if (!(this.offset + e2 <= this.length))
    return this.error(r2 || "DecoderBuffer overrun");
  const n2 = new Nt(this.base);
  return n2._reporterState = this._reporterState, n2.offset = this.offset, n2.length = this.offset + e2, this.offset += e2, n2;
};
Nt.prototype.raw = function(e2) {
  return this.base.slice(e2 ? e2.offset : this.offset, this.length);
};
function Kr2(t2, e2) {
  if (Array.isArray(t2))
    this.length = 0, this.value = t2.map(function(r2) {
      return Kr2.isEncoderBuffer(r2) || (r2 = new Kr2(r2, e2)), this.length += r2.length, r2;
    }, this);
  else if (typeof t2 == "number") {
    if (!(0 <= t2 && t2 <= 255))
      return e2.error("non-byte EncoderBuffer value");
    this.value = t2, this.length = 1;
  } else if (typeof t2 == "string")
    this.value = t2, this.length = Hr2.byteLength(t2);
  else if (Hr2.isBuffer(t2))
    this.value = t2, this.length = t2.length;
  else
    return e2.error("Unsupported type: " + typeof t2);
}
xr2.EncoderBuffer = Kr2;
Kr2.isEncoderBuffer = function(e2) {
  return e2 instanceof Kr2 ? true : typeof e2 == "object" && e2.constructor.name === "EncoderBuffer" && typeof e2.length == "number" && typeof e2.join == "function";
};
Kr2.prototype.join = function(e2, r2) {
  return e2 || (e2 = Hr2.alloc(this.length)), r2 || (r2 = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(n2) {
    n2.join(e2, r2), r2 += n2.length;
  }) : (typeof this.value == "number" ? e2[r2] = this.value : typeof this.value == "string" ? e2.write(this.value, r2) : Hr2.isBuffer(this.value) && this.value.copy(e2, r2), r2 += this.length)), e2;
};
var _d = Ac;
function Ac(t2, e2) {
  if (!t2)
    throw new Error(e2 || "Assertion failed");
}
Ac.equal = function(e2, r2, n2) {
  if (e2 != r2)
    throw new Error(n2 || "Assertion failed: " + e2 + " != " + r2);
};
var bd = yi.Reporter;
var xd = xr2.EncoderBuffer;
var Td = xr2.DecoderBuffer;
var Et = _d;
var Mc = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
];
var Ed = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(Mc);
var Ad = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function je(t2, e2, r2) {
  const n2 = {};
  this._baseState = n2, n2.name = r2, n2.enc = t2, n2.parent = e2 || null, n2.children = null, n2.tag = null, n2.args = null, n2.reverseArgs = null, n2.choice = null, n2.optional = false, n2.any = false, n2.obj = false, n2.use = null, n2.useDecoder = null, n2.key = null, n2.default = null, n2.explicit = null, n2.implicit = null, n2.contains = null, n2.parent || (n2.children = [], this._wrap());
}
var ss = je;
var Md = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
je.prototype.clone = function() {
  const e2 = this._baseState, r2 = {};
  Md.forEach(function(i2) {
    r2[i2] = e2[i2];
  });
  const n2 = new this.constructor(r2.parent);
  return n2._baseState = r2, n2;
};
je.prototype._wrap = function() {
  const e2 = this._baseState;
  Ed.forEach(function(r2) {
    this[r2] = function() {
      const i2 = new this.constructor(this);
      return e2.children.push(i2), i2[r2].apply(i2, arguments);
    };
  }, this);
};
je.prototype._init = function(e2) {
  const r2 = this._baseState;
  Et(r2.parent === null), e2.call(this), r2.children = r2.children.filter(function(n2) {
    return n2._baseState.parent === this;
  }, this), Et.equal(r2.children.length, 1, "Root node can have only one child");
};
je.prototype._useArgs = function(e2) {
  const r2 = this._baseState, n2 = e2.filter(function(i2) {
    return i2 instanceof this.constructor;
  }, this);
  e2 = e2.filter(function(i2) {
    return !(i2 instanceof this.constructor);
  }, this), n2.length !== 0 && (Et(r2.children === null), r2.children = n2, n2.forEach(function(i2) {
    i2._baseState.parent = this;
  }, this)), e2.length !== 0 && (Et(r2.args === null), r2.args = e2, r2.reverseArgs = e2.map(function(i2) {
    if (typeof i2 != "object" || i2.constructor !== Object)
      return i2;
    const o2 = {};
    return Object.keys(i2).forEach(function(s2) {
      s2 == (s2 | 0) && (s2 |= 0);
      const a2 = i2[s2];
      o2[a2] = s2;
    }), o2;
  }));
};
Ad.forEach(function(t2) {
  je.prototype[t2] = function() {
    const r2 = this._baseState;
    throw new Error(t2 + " not implemented for encoding: " + r2.enc);
  };
});
Mc.forEach(function(t2) {
  je.prototype[t2] = function() {
    const r2 = this._baseState, n2 = Array.prototype.slice.call(arguments);
    return Et(r2.tag === null), r2.tag = t2, this._useArgs(n2), this;
  };
});
je.prototype.use = function(e2) {
  Et(e2);
  const r2 = this._baseState;
  return Et(r2.use === null), r2.use = e2, this;
};
je.prototype.optional = function() {
  const e2 = this._baseState;
  return e2.optional = true, this;
};
je.prototype.def = function(e2) {
  const r2 = this._baseState;
  return Et(r2.default === null), r2.default = e2, r2.optional = true, this;
};
je.prototype.explicit = function(e2) {
  const r2 = this._baseState;
  return Et(r2.explicit === null && r2.implicit === null), r2.explicit = e2, this;
};
je.prototype.implicit = function(e2) {
  const r2 = this._baseState;
  return Et(r2.explicit === null && r2.implicit === null), r2.implicit = e2, this;
};
je.prototype.obj = function() {
  const e2 = this._baseState, r2 = Array.prototype.slice.call(arguments);
  return e2.obj = true, r2.length !== 0 && this._useArgs(r2), this;
};
je.prototype.key = function(e2) {
  const r2 = this._baseState;
  return Et(r2.key === null), r2.key = e2, this;
};
je.prototype.any = function() {
  const e2 = this._baseState;
  return e2.any = true, this;
};
je.prototype.choice = function(e2) {
  const r2 = this._baseState;
  return Et(r2.choice === null), r2.choice = e2, this._useArgs(Object.keys(e2).map(function(n2) {
    return e2[n2];
  })), this;
};
je.prototype.contains = function(e2) {
  const r2 = this._baseState;
  return Et(r2.use === null), r2.contains = e2, this;
};
je.prototype._decode = function(e2, r2) {
  const n2 = this._baseState;
  if (n2.parent === null)
    return e2.wrapResult(n2.children[0]._decode(e2, r2));
  let i2 = n2.default, o2 = true, s2 = null;
  if (n2.key !== null && (s2 = e2.enterKey(n2.key)), n2.optional) {
    let f2 = null;
    if (n2.explicit !== null ? f2 = n2.explicit : n2.implicit !== null ? f2 = n2.implicit : n2.tag !== null && (f2 = n2.tag), f2 === null && !n2.any) {
      const p2 = e2.save();
      try {
        n2.choice === null ? this._decodeGeneric(n2.tag, e2, r2) : this._decodeChoice(e2, r2), o2 = true;
      } catch {
        o2 = false;
      }
      e2.restore(p2);
    } else if (o2 = this._peekTag(e2, f2, n2.any), e2.isError(o2))
      return o2;
  }
  let a2;
  if (n2.obj && o2 && (a2 = e2.enterObject()), o2) {
    if (n2.explicit !== null) {
      const p2 = this._decodeTag(e2, n2.explicit);
      if (e2.isError(p2))
        return p2;
      e2 = p2;
    }
    const f2 = e2.offset;
    if (n2.use === null && n2.choice === null) {
      let p2;
      n2.any && (p2 = e2.save());
      const d2 = this._decodeTag(
        e2,
        n2.implicit !== null ? n2.implicit : n2.tag,
        n2.any
      );
      if (e2.isError(d2))
        return d2;
      n2.any ? i2 = e2.raw(p2) : e2 = d2;
    }
    if (r2 && r2.track && n2.tag !== null && r2.track(e2.path(), f2, e2.length, "tagged"), r2 && r2.track && n2.tag !== null && r2.track(e2.path(), e2.offset, e2.length, "content"), n2.any || (n2.choice === null ? i2 = this._decodeGeneric(n2.tag, e2, r2) : i2 = this._decodeChoice(e2, r2)), e2.isError(i2))
      return i2;
    if (!n2.any && n2.choice === null && n2.children !== null && n2.children.forEach(function(d2) {
      d2._decode(e2, r2);
    }), n2.contains && (n2.tag === "octstr" || n2.tag === "bitstr")) {
      const p2 = new Td(i2);
      i2 = this._getUse(n2.contains, e2._reporterState.obj)._decode(p2, r2);
    }
  }
  return n2.obj && o2 && (i2 = e2.leaveObject(a2)), n2.key !== null && (i2 !== null || o2 === true) ? e2.leaveKey(s2, n2.key, i2) : s2 !== null && e2.exitKey(s2), i2;
};
je.prototype._decodeGeneric = function(e2, r2, n2) {
  const i2 = this._baseState;
  return e2 === "seq" || e2 === "set" ? null : e2 === "seqof" || e2 === "setof" ? this._decodeList(r2, e2, i2.args[0], n2) : /str$/.test(e2) ? this._decodeStr(r2, e2, n2) : e2 === "objid" && i2.args ? this._decodeObjid(r2, i2.args[0], i2.args[1], n2) : e2 === "objid" ? this._decodeObjid(r2, null, null, n2) : e2 === "gentime" || e2 === "utctime" ? this._decodeTime(r2, e2, n2) : e2 === "null_" ? this._decodeNull(r2, n2) : e2 === "bool" ? this._decodeBool(r2, n2) : e2 === "objDesc" ? this._decodeStr(r2, e2, n2) : e2 === "int" || e2 === "enum" ? this._decodeInt(r2, i2.args && i2.args[0], n2) : i2.use !== null ? this._getUse(i2.use, r2._reporterState.obj)._decode(r2, n2) : r2.error("unknown tag: " + e2);
};
je.prototype._getUse = function(e2, r2) {
  const n2 = this._baseState;
  return n2.useDecoder = this._use(e2, r2), Et(n2.useDecoder._baseState.parent === null), n2.useDecoder = n2.useDecoder._baseState.children[0], n2.implicit !== n2.useDecoder._baseState.implicit && (n2.useDecoder = n2.useDecoder.clone(), n2.useDecoder._baseState.implicit = n2.implicit), n2.useDecoder;
};
je.prototype._decodeChoice = function(e2, r2) {
  const n2 = this._baseState;
  let i2 = null, o2 = false;
  return Object.keys(n2.choice).some(function(s2) {
    const a2 = e2.save(), f2 = n2.choice[s2];
    try {
      const p2 = f2._decode(e2, r2);
      if (e2.isError(p2))
        return false;
      i2 = { type: s2, value: p2 }, o2 = true;
    } catch {
      return e2.restore(a2), false;
    }
    return true;
  }, this), o2 ? i2 : e2.error("Choice not matched");
};
je.prototype._createEncoderBuffer = function(e2) {
  return new xd(e2, this.reporter);
};
je.prototype._encode = function(e2, r2, n2) {
  const i2 = this._baseState;
  if (i2.default !== null && i2.default === e2)
    return;
  const o2 = this._encodeValue(e2, r2, n2);
  if (o2 !== void 0 && !this._skipDefault(o2, r2, n2))
    return o2;
};
je.prototype._encodeValue = function(e2, r2, n2) {
  const i2 = this._baseState;
  if (i2.parent === null)
    return i2.children[0]._encode(e2, r2 || new bd());
  let o2 = null;
  if (this.reporter = r2, i2.optional && e2 === void 0)
    if (i2.default !== null)
      e2 = i2.default;
    else
      return;
  let s2 = null, a2 = false;
  if (i2.any)
    o2 = this._createEncoderBuffer(e2);
  else if (i2.choice)
    o2 = this._encodeChoice(e2, r2);
  else if (i2.contains)
    s2 = this._getUse(i2.contains, n2)._encode(e2, r2), a2 = true;
  else if (i2.children)
    s2 = i2.children.map(function(f2) {
      if (f2._baseState.tag === "null_")
        return f2._encode(null, r2, e2);
      if (f2._baseState.key === null)
        return r2.error("Child should have a key");
      const p2 = r2.enterKey(f2._baseState.key);
      if (typeof e2 != "object")
        return r2.error("Child expected, but input is not object");
      const d2 = f2._encode(e2[f2._baseState.key], r2, e2);
      return r2.leaveKey(p2), d2;
    }, this).filter(function(f2) {
      return f2;
    }), s2 = this._createEncoderBuffer(s2);
  else if (i2.tag === "seqof" || i2.tag === "setof") {
    if (!(i2.args && i2.args.length === 1))
      return r2.error("Too many args for : " + i2.tag);
    if (!Array.isArray(e2))
      return r2.error("seqof/setof, but data is not Array");
    const f2 = this.clone();
    f2._baseState.implicit = null, s2 = this._createEncoderBuffer(e2.map(function(p2) {
      const d2 = this._baseState;
      return this._getUse(d2.args[0], e2)._encode(p2, r2);
    }, f2));
  } else
    i2.use !== null ? o2 = this._getUse(i2.use, n2)._encode(e2, r2) : (s2 = this._encodePrimitive(i2.tag, e2), a2 = true);
  if (!i2.any && i2.choice === null) {
    const f2 = i2.implicit !== null ? i2.implicit : i2.tag, p2 = i2.implicit === null ? "universal" : "context";
    f2 === null ? i2.use === null && r2.error("Tag could be omitted only for .use()") : i2.use === null && (o2 = this._encodeComposite(f2, a2, p2, s2));
  }
  return i2.explicit !== null && (o2 = this._encodeComposite(i2.explicit, false, "context", o2)), o2;
};
je.prototype._encodeChoice = function(e2, r2) {
  const n2 = this._baseState, i2 = n2.choice[e2.type];
  return i2 || Et(
    false,
    e2.type + " not found in " + JSON.stringify(Object.keys(n2.choice))
  ), i2._encode(e2.value, r2);
};
je.prototype._encodePrimitive = function(e2, r2) {
  const n2 = this._baseState;
  if (/str$/.test(e2))
    return this._encodeStr(r2, e2);
  if (e2 === "objid" && n2.args)
    return this._encodeObjid(r2, n2.reverseArgs[0], n2.args[1]);
  if (e2 === "objid")
    return this._encodeObjid(r2, null, null);
  if (e2 === "gentime" || e2 === "utctime")
    return this._encodeTime(r2, e2);
  if (e2 === "null_")
    return this._encodeNull();
  if (e2 === "int" || e2 === "enum")
    return this._encodeInt(r2, n2.args && n2.reverseArgs[0]);
  if (e2 === "bool")
    return this._encodeBool(r2);
  if (e2 === "objDesc")
    return this._encodeStr(r2, e2);
  throw new Error("Unsupported tag: " + e2);
};
je.prototype._isNumstr = function(e2) {
  return /^[0-9 ]*$/.test(e2);
};
je.prototype._isPrintstr = function(e2) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e2);
};
var wi = {};
(function(t2) {
  function e2(r2) {
    const n2 = {};
    return Object.keys(r2).forEach(function(i2) {
      (i2 | 0) == i2 && (i2 = i2 | 0);
      const o2 = r2[i2];
      n2[o2] = i2;
    }), n2;
  }
  t2.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  }, t2.tagClassByName = e2(t2.tagClass), t2.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  }, t2.tagByName = e2(t2.tag);
})(wi);
var Sd = Er2;
var er = os.Buffer;
var Sc = ss;
var Fi = wi;
function Pc(t2) {
  this.enc = "der", this.name = t2.name, this.entity = t2, this.tree = new qt(), this.tree._init(t2.body);
}
var Cc = Pc;
Pc.prototype.encode = function(e2, r2) {
  return this.tree._encode(e2, r2).join();
};
function qt(t2) {
  Sc.call(this, "der", t2);
}
Sd(qt, Sc);
qt.prototype._encodeComposite = function(e2, r2, n2, i2) {
  const o2 = Pd(e2, r2, n2, this.reporter);
  if (i2.length < 128) {
    const f2 = er.alloc(2);
    return f2[0] = o2, f2[1] = i2.length, this._createEncoderBuffer([f2, i2]);
  }
  let s2 = 1;
  for (let f2 = i2.length; f2 >= 256; f2 >>= 8)
    s2++;
  const a2 = er.alloc(1 + 1 + s2);
  a2[0] = o2, a2[1] = 128 | s2;
  for (let f2 = 1 + s2, p2 = i2.length; p2 > 0; f2--, p2 >>= 8)
    a2[f2] = p2 & 255;
  return this._createEncoderBuffer([a2, i2]);
};
qt.prototype._encodeStr = function(e2, r2) {
  if (r2 === "bitstr")
    return this._createEncoderBuffer([e2.unused | 0, e2.data]);
  if (r2 === "bmpstr") {
    const n2 = er.alloc(e2.length * 2);
    for (let i2 = 0; i2 < e2.length; i2++)
      n2.writeUInt16BE(e2.charCodeAt(i2), i2 * 2);
    return this._createEncoderBuffer(n2);
  } else
    return r2 === "numstr" ? this._isNumstr(e2) ? this._createEncoderBuffer(e2) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r2 === "printstr" ? this._isPrintstr(e2) ? this._createEncoderBuffer(e2) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r2) ? this._createEncoderBuffer(e2) : r2 === "objDesc" ? this._createEncoderBuffer(e2) : this.reporter.error("Encoding of string type: " + r2 + " unsupported");
};
qt.prototype._encodeObjid = function(e2, r2, n2) {
  if (typeof e2 == "string") {
    if (!r2)
      return this.reporter.error("string objid given, but no values map found");
    if (!r2.hasOwnProperty(e2))
      return this.reporter.error("objid not found in values map");
    e2 = r2[e2].split(/[\s.]+/g);
    for (let a2 = 0; a2 < e2.length; a2++)
      e2[a2] |= 0;
  } else if (Array.isArray(e2)) {
    e2 = e2.slice();
    for (let a2 = 0; a2 < e2.length; a2++)
      e2[a2] |= 0;
  }
  if (!Array.isArray(e2))
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e2));
  if (!n2) {
    if (e2[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    e2.splice(0, 2, e2[0] * 40 + e2[1]);
  }
  let i2 = 0;
  for (let a2 = 0; a2 < e2.length; a2++) {
    let f2 = e2[a2];
    for (i2++; f2 >= 128; f2 >>= 7)
      i2++;
  }
  const o2 = er.alloc(i2);
  let s2 = o2.length - 1;
  for (let a2 = e2.length - 1; a2 >= 0; a2--) {
    let f2 = e2[a2];
    for (o2[s2--] = f2 & 127; (f2 >>= 7) > 0; )
      o2[s2--] = 128 | f2 & 127;
  }
  return this._createEncoderBuffer(o2);
};
function Bt(t2) {
  return t2 < 10 ? "0" + t2 : t2;
}
qt.prototype._encodeTime = function(e2, r2) {
  let n2;
  const i2 = new Date(e2);
  return r2 === "gentime" ? n2 = [
    Bt(i2.getUTCFullYear()),
    Bt(i2.getUTCMonth() + 1),
    Bt(i2.getUTCDate()),
    Bt(i2.getUTCHours()),
    Bt(i2.getUTCMinutes()),
    Bt(i2.getUTCSeconds()),
    "Z"
  ].join("") : r2 === "utctime" ? n2 = [
    Bt(i2.getUTCFullYear() % 100),
    Bt(i2.getUTCMonth() + 1),
    Bt(i2.getUTCDate()),
    Bt(i2.getUTCHours()),
    Bt(i2.getUTCMinutes()),
    Bt(i2.getUTCSeconds()),
    "Z"
  ].join("") : this.reporter.error("Encoding " + r2 + " time is not supported yet"), this._encodeStr(n2, "octstr");
};
qt.prototype._encodeNull = function() {
  return this._createEncoderBuffer("");
};
qt.prototype._encodeInt = function(e2, r2) {
  if (typeof e2 == "string") {
    if (!r2)
      return this.reporter.error("String int or enum given, but no values map");
    if (!r2.hasOwnProperty(e2))
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e2));
    e2 = r2[e2];
  }
  if (typeof e2 != "number" && !er.isBuffer(e2)) {
    const o2 = e2.toArray();
    !e2.sign && o2[0] & 128 && o2.unshift(0), e2 = er.from(o2);
  }
  if (er.isBuffer(e2)) {
    let o2 = e2.length;
    e2.length === 0 && o2++;
    const s2 = er.alloc(o2);
    return e2.copy(s2), e2.length === 0 && (s2[0] = 0), this._createEncoderBuffer(s2);
  }
  if (e2 < 128)
    return this._createEncoderBuffer(e2);
  if (e2 < 256)
    return this._createEncoderBuffer([0, e2]);
  let n2 = 1;
  for (let o2 = e2; o2 >= 256; o2 >>= 8)
    n2++;
  const i2 = new Array(n2);
  for (let o2 = i2.length - 1; o2 >= 0; o2--)
    i2[o2] = e2 & 255, e2 >>= 8;
  return i2[0] & 128 && i2.unshift(0), this._createEncoderBuffer(er.from(i2));
};
qt.prototype._encodeBool = function(e2) {
  return this._createEncoderBuffer(e2 ? 255 : 0);
};
qt.prototype._use = function(e2, r2) {
  return typeof e2 == "function" && (e2 = e2(r2)), e2._getEncoder("der").tree;
};
qt.prototype._skipDefault = function(e2, r2, n2) {
  const i2 = this._baseState;
  let o2;
  if (i2.default === null)
    return false;
  const s2 = e2.join();
  if (i2.defaultBuffer === void 0 && (i2.defaultBuffer = this._encodeValue(i2.default, r2, n2).join()), s2.length !== i2.defaultBuffer.length)
    return false;
  for (o2 = 0; o2 < s2.length; o2++)
    if (s2[o2] !== i2.defaultBuffer[o2])
      return false;
  return true;
};
function Pd(t2, e2, r2, n2) {
  let i2;
  if (t2 === "seqof" ? t2 = "seq" : t2 === "setof" && (t2 = "set"), Fi.tagByName.hasOwnProperty(t2))
    i2 = Fi.tagByName[t2];
  else if (typeof t2 == "number" && (t2 | 0) === t2)
    i2 = t2;
  else
    return n2.error("Unknown tag: " + t2);
  return i2 >= 31 ? n2.error("Multi-octet tag encoding unsupported") : (e2 || (i2 |= 32), i2 |= Fi.tagClassByName[r2 || "universal"] << 6, i2);
}
var Cd = Er2;
var as = Cc;
function us(t2) {
  as.call(this, t2), this.enc = "pem";
}
Cd(us, as);
var Od = us;
us.prototype.encode = function(e2, r2) {
  const i2 = as.prototype.encode.call(this, e2).toString("base64"), o2 = ["-----BEGIN " + r2.label + "-----"];
  for (let s2 = 0; s2 < i2.length; s2 += 64)
    o2.push(i2.slice(s2, s2 + 64));
  return o2.push("-----END " + r2.label + "-----"), o2.join(`
`);
};
(function(t2) {
  const e2 = t2;
  e2.der = Cc, e2.pem = Od;
})(ns);
var cs = {};
var Rd = Er2;
var Id = bc;
var _a = xr2.DecoderBuffer;
var Oc = ss;
var ba = wi;
function Rc(t2) {
  this.enc = "der", this.name = t2.name, this.entity = t2, this.tree = new It(), this.tree._init(t2.body);
}
var Ic = Rc;
Rc.prototype.decode = function(e2, r2) {
  return _a.isDecoderBuffer(e2) || (e2 = new _a(e2, r2)), this.tree._decode(e2, r2);
};
function It(t2) {
  Oc.call(this, "der", t2);
}
Rd(It, Oc);
It.prototype._peekTag = function(e2, r2, n2) {
  if (e2.isEmpty())
    return false;
  const i2 = e2.save(), o2 = ls(e2, 'Failed to peek tag: "' + r2 + '"');
  return e2.isError(o2) ? o2 : (e2.restore(i2), o2.tag === r2 || o2.tagStr === r2 || o2.tagStr + "of" === r2 || n2);
};
It.prototype._decodeTag = function(e2, r2, n2) {
  const i2 = ls(
    e2,
    'Failed to decode tag of "' + r2 + '"'
  );
  if (e2.isError(i2))
    return i2;
  let o2 = Bc(
    e2,
    i2.primitive,
    'Failed to get length of "' + r2 + '"'
  );
  if (e2.isError(o2))
    return o2;
  if (!n2 && i2.tag !== r2 && i2.tagStr !== r2 && i2.tagStr + "of" !== r2)
    return e2.error('Failed to match tag: "' + r2 + '"');
  if (i2.primitive || o2 !== null)
    return e2.skip(o2, 'Failed to match body of: "' + r2 + '"');
  const s2 = e2.save(), a2 = this._skipUntilEnd(
    e2,
    'Failed to skip indefinite length body: "' + this.tag + '"'
  );
  return e2.isError(a2) ? a2 : (o2 = e2.offset - s2.offset, e2.restore(s2), e2.skip(o2, 'Failed to match body of: "' + r2 + '"'));
};
It.prototype._skipUntilEnd = function(e2, r2) {
  for (; ; ) {
    const n2 = ls(e2, r2);
    if (e2.isError(n2))
      return n2;
    const i2 = Bc(e2, n2.primitive, r2);
    if (e2.isError(i2))
      return i2;
    let o2;
    if (n2.primitive || i2 !== null ? o2 = e2.skip(i2) : o2 = this._skipUntilEnd(e2, r2), e2.isError(o2))
      return o2;
    if (n2.tagStr === "end")
      break;
  }
};
It.prototype._decodeList = function(e2, r2, n2, i2) {
  const o2 = [];
  for (; !e2.isEmpty(); ) {
    const s2 = this._peekTag(e2, "end");
    if (e2.isError(s2))
      return s2;
    const a2 = n2.decode(e2, "der", i2);
    if (e2.isError(a2) && s2)
      break;
    o2.push(a2);
  }
  return o2;
};
It.prototype._decodeStr = function(e2, r2) {
  if (r2 === "bitstr") {
    const n2 = e2.readUInt8();
    return e2.isError(n2) ? n2 : { unused: n2, data: e2.raw() };
  } else if (r2 === "bmpstr") {
    const n2 = e2.raw();
    if (n2.length % 2 === 1)
      return e2.error("Decoding of string type: bmpstr length mismatch");
    let i2 = "";
    for (let o2 = 0; o2 < n2.length / 2; o2++)
      i2 += String.fromCharCode(n2.readUInt16BE(o2 * 2));
    return i2;
  } else if (r2 === "numstr") {
    const n2 = e2.raw().toString("ascii");
    return this._isNumstr(n2) ? n2 : e2.error("Decoding of string type: numstr unsupported characters");
  } else {
    if (r2 === "octstr")
      return e2.raw();
    if (r2 === "objDesc")
      return e2.raw();
    if (r2 === "printstr") {
      const n2 = e2.raw().toString("ascii");
      return this._isPrintstr(n2) ? n2 : e2.error("Decoding of string type: printstr unsupported characters");
    } else
      return /str$/.test(r2) ? e2.raw().toString() : e2.error("Decoding of string type: " + r2 + " unsupported");
  }
};
It.prototype._decodeObjid = function(e2, r2, n2) {
  let i2;
  const o2 = [];
  let s2 = 0, a2 = 0;
  for (; !e2.isEmpty(); )
    a2 = e2.readUInt8(), s2 <<= 7, s2 |= a2 & 127, a2 & 128 || (o2.push(s2), s2 = 0);
  a2 & 128 && o2.push(s2);
  const f2 = o2[0] / 40 | 0, p2 = o2[0] % 40;
  if (n2 ? i2 = o2 : i2 = [f2, p2].concat(o2.slice(1)), r2) {
    let d2 = r2[i2.join(" ")];
    d2 === void 0 && (d2 = r2[i2.join(".")]), d2 !== void 0 && (i2 = d2);
  }
  return i2;
};
It.prototype._decodeTime = function(e2, r2) {
  const n2 = e2.raw().toString();
  let i2, o2, s2, a2, f2, p2;
  if (r2 === "gentime")
    i2 = n2.slice(0, 4) | 0, o2 = n2.slice(4, 6) | 0, s2 = n2.slice(6, 8) | 0, a2 = n2.slice(8, 10) | 0, f2 = n2.slice(10, 12) | 0, p2 = n2.slice(12, 14) | 0;
  else if (r2 === "utctime")
    i2 = n2.slice(0, 2) | 0, o2 = n2.slice(2, 4) | 0, s2 = n2.slice(4, 6) | 0, a2 = n2.slice(6, 8) | 0, f2 = n2.slice(8, 10) | 0, p2 = n2.slice(10, 12) | 0, i2 < 70 ? i2 = 2e3 + i2 : i2 = 1900 + i2;
  else
    return e2.error("Decoding " + r2 + " time is not supported yet");
  return Date.UTC(i2, o2 - 1, s2, a2, f2, p2, 0);
};
It.prototype._decodeNull = function() {
  return null;
};
It.prototype._decodeBool = function(e2) {
  const r2 = e2.readUInt8();
  return e2.isError(r2) ? r2 : r2 !== 0;
};
It.prototype._decodeInt = function(e2, r2) {
  const n2 = e2.raw();
  let i2 = new Id(n2);
  return r2 && (i2 = r2[i2.toString(10)] || i2), i2;
};
It.prototype._use = function(e2, r2) {
  return typeof e2 == "function" && (e2 = e2(r2)), e2._getDecoder("der").tree;
};
function ls(t2, e2) {
  let r2 = t2.readUInt8(e2);
  if (t2.isError(r2))
    return r2;
  const n2 = ba.tagClass[r2 >> 6], i2 = (r2 & 32) === 0;
  if ((r2 & 31) === 31) {
    let s2 = r2;
    for (r2 = 0; (s2 & 128) === 128; ) {
      if (s2 = t2.readUInt8(e2), t2.isError(s2))
        return s2;
      r2 <<= 7, r2 |= s2 & 127;
    }
  } else
    r2 &= 31;
  const o2 = ba.tag[r2];
  return {
    cls: n2,
    primitive: i2,
    tag: r2,
    tagStr: o2
  };
}
function Bc(t2, e2, r2) {
  let n2 = t2.readUInt8(r2);
  if (t2.isError(n2))
    return n2;
  if (!e2 && n2 === 128)
    return null;
  if (!(n2 & 128))
    return n2;
  const i2 = n2 & 127;
  if (i2 > 4)
    return t2.error("length octect is too long");
  n2 = 0;
  for (let o2 = 0; o2 < i2; o2++) {
    n2 <<= 8;
    const s2 = t2.readUInt8(r2);
    if (t2.isError(s2))
      return s2;
    n2 |= s2;
  }
  return n2;
}
var Bd = Er2;
var kd = os.Buffer;
var fs = Ic;
function hs(t2) {
  fs.call(this, t2), this.enc = "pem";
}
Bd(hs, fs);
var Dd = hs;
hs.prototype.decode = function(e2, r2) {
  const n2 = e2.toString().split(/[\r\n]+/g), i2 = r2.label.toUpperCase(), o2 = /^-----(BEGIN|END) ([^-]+)-----$/;
  let s2 = -1, a2 = -1;
  for (let d2 = 0; d2 < n2.length; d2++) {
    const y2 = n2[d2].match(o2);
    if (y2 !== null && y2[2] === i2)
      if (s2 === -1) {
        if (y2[1] !== "BEGIN")
          break;
        s2 = d2;
      } else {
        if (y2[1] !== "END")
          break;
        a2 = d2;
        break;
      }
  }
  if (s2 === -1 || a2 === -1)
    throw new Error("PEM section not found for: " + i2);
  const f2 = n2.slice(s2 + 1, a2).join("");
  f2.replace(/[^a-z0-9+/=]+/gi, "");
  const p2 = kd.from(f2, "base64");
  return fs.prototype.decode.call(this, p2, r2);
};
(function(t2) {
  const e2 = t2;
  e2.der = Ic, e2.pem = Dd;
})(cs);
(function(t2) {
  const e2 = ns, r2 = cs, n2 = Er2, i2 = t2;
  i2.define = function(a2, f2) {
    return new o2(a2, f2);
  };
  function o2(s2, a2) {
    this.name = s2, this.body = a2, this.decoders = {}, this.encoders = {};
  }
  o2.prototype._createNamed = function(a2) {
    const f2 = this.name;
    function p2(d2) {
      this._initNamed(d2, f2);
    }
    return n2(p2, a2), p2.prototype._initNamed = function(y2, v3) {
      a2.call(this, y2, v3);
    }, new p2(this);
  }, o2.prototype._getDecoder = function(a2) {
    return a2 = a2 || "der", this.decoders.hasOwnProperty(a2) || (this.decoders[a2] = this._createNamed(r2[a2])), this.decoders[a2];
  }, o2.prototype.decode = function(a2, f2, p2) {
    return this._getDecoder(f2).decode(a2, p2);
  }, o2.prototype._getEncoder = function(a2) {
    return a2 = a2 || "der", this.encoders.hasOwnProperty(a2) || (this.encoders[a2] = this._createNamed(e2[a2])), this.encoders[a2];
  }, o2.prototype.encode = function(a2, f2, p2) {
    return this._getEncoder(f2).encode(a2, p2);
  };
})(xc);
var kc = {};
(function(t2) {
  const e2 = t2;
  e2.Reporter = yi.Reporter, e2.DecoderBuffer = xr2.DecoderBuffer, e2.EncoderBuffer = xr2.EncoderBuffer, e2.Node = ss;
})(kc);
var Dc = {};
(function(t2) {
  const e2 = t2;
  e2._reverse = function(n2) {
    const i2 = {};
    return Object.keys(n2).forEach(function(o2) {
      (o2 | 0) == o2 && (o2 = o2 | 0);
      const s2 = n2[o2];
      i2[s2] = o2;
    }), i2;
  }, e2.der = wi;
})(Dc);
(function(t2) {
  const e2 = t2;
  e2.bignum = bc, e2.define = xc.define, e2.base = kc, e2.constants = Dc, e2.decoders = cs, e2.encoders = ns;
})(wc);
var Ld = ge2 && ge2.__createBinding || (Object.create ? function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = r2);
  var i2 = Object.getOwnPropertyDescriptor(e2, r2);
  (!i2 || ("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable)) && (i2 = { enumerable: true, get: function() {
    return e2[r2];
  } }), Object.defineProperty(t2, n2, i2);
} : function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = r2), t2[n2] = e2[r2];
});
var Nd = ge2 && ge2.__setModuleDefault || (Object.create ? function(t2, e2) {
  Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
} : function(t2, e2) {
  t2.default = e2;
});
var Ud = ge2 && ge2.__importStar || function(t2) {
  if (t2 && t2.__esModule)
    return t2;
  var e2 = {};
  if (t2 != null)
    for (var r2 in t2)
      r2 !== "default" && Object.prototype.hasOwnProperty.call(t2, r2) && Ld(e2, t2, r2);
  return Nd(e2, t2), e2;
};
Object.defineProperty(gi, "__esModule", { value: true });
gi.pemTojwk = Gd;
gi.jwkTopem = Yd;
var rr = Ud(wc);
function Fd(t2) {
  return t2.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function ds(t2) {
  return Fd(Buffer.from(t2, "hex").toString("base64"));
}
var Lc = rr.define("RSAPublicKey", function() {
  this.seq().obj(this.key("n").int(), this.key("e").int());
});
var Nc = rr.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional().any());
});
var jd = rr.define("PublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(Nc), this.key("publicKey").bitstr());
});
var Uc = rr.define("Version", function() {
  this.int({
    0: "two-prime",
    1: "multi"
  });
});
var $d = rr.define("OtherPrimeInfos", function() {
  this.seq().obj(this.key("ri").int(), this.key("di").int(), this.key("ti").int());
});
var Fc = rr.define("RSAPrivateKey", function() {
  this.seq().obj(this.key("version").use(Uc), this.key("n").int(), this.key("e").int(), this.key("d").int(), this.key("p").int(), this.key("q").int(), this.key("dp").int(), this.key("dq").int(), this.key("qi").int(), this.key("other").optional().use($d));
});
var Vd = rr.define("PrivateKeyInfo", function() {
  this.seq().obj(this.key("version").use(Uc), this.key("algorithm").use(Nc), this.key("privateKey").bitstr());
});
function jc(t2, e2) {
  return e2 = e2 || {}, Object.keys(e2).forEach(function(r2) {
    t2[r2] = e2[r2];
  }), t2;
}
function ps(t2) {
  return t2.length % 2 === 1 ? "0" + t2 : t2;
}
function $c(t2, e2) {
  var r2 = Lc.decode(t2, "der"), n2 = ps(r2.e.toString(16)), i2 = {
    kty: "RSA",
    n: ir(r2.n),
    e: ds(n2)
  };
  return jc(i2, e2);
}
function Vc(t2, e2) {
  var r2 = Fc.decode(t2, "der"), n2 = ps(r2.e.toString(16)), i2 = {
    kty: "RSA",
    n: ir(r2.n),
    e: ds(n2),
    d: ir(r2.d),
    p: ir(r2.p),
    q: ir(r2.q),
    dp: ir(r2.dp),
    dq: ir(r2.dq),
    qi: ir(r2.qi)
  };
  return jc(i2, e2);
}
function qd(t2, e2) {
  var r2 = jd.decode(t2, "der");
  return $c(r2.publicKey.data, e2);
}
function Wd(t2, e2) {
  var r2 = Vd.decode(t2, "der");
  return Vc(r2.privateKey.data, e2);
}
function Hd(t2) {
  var e2 = /^-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----$/.exec(t2);
  if (!e2)
    return null;
  var r2 = !!e2[1], n2 = e2[2] === "PRIVATE";
  return n2 ? r2 ? Vc : Wd : r2 ? $c : qd;
}
function Kd(t2) {
  return {
    n: nr(t2.n),
    e: nr(t2.e),
    d: t2.d && nr(t2.d),
    p: t2.p && nr(t2.p),
    q: t2.q && nr(t2.q),
    dp: t2.dp && nr(t2.dp),
    dq: t2.dq && nr(t2.dq),
    qi: t2.qi && nr(t2.qi)
  };
}
function ir(t2) {
  return ds(ps(t2.toString(16)));
}
function zd(t2) {
  return new rr.bignum(Buffer.from(t2, "base64"));
}
function nr(t2) {
  return /^[0-9]+$/.test(t2) ? new rr.bignum(t2, 10) : zd(t2);
}
function Gd(t2, e2) {
  var r2 = t2.toString().split(/(\r\n|\r|\n)+/g);
  r2 = r2.filter(function(i2) {
    return i2.trim().length !== 0;
  });
  var n2 = Hd(r2[0]);
  return r2 = r2.slice(1, -1).join(""), n2(Buffer.from(r2.replace(/[^\w\d\+\/=]+/g, ""), "base64"), e2);
}
function Yd(t2) {
  var e2 = Kd(t2), r2 = !!e2.d, n2 = r2 ? "PRIVATE" : "PUBLIC", i2 = "-----BEGIN RSA " + n2 + ` KEY-----
`, o2 = `
-----END RSA ` + n2 + ` KEY-----
`, s2 = Buffer.alloc(0);
  r2 ? (e2.version = "two-prime", s2 = Fc.encode(e2, "der")) : s2 = Lc.encode(e2, "der");
  var a2 = s2.toString("base64").match(/.{1,64}/g).join(`
`);
  return i2 + a2 + o2;
}
var Xd = ge2 && ge2.__createBinding || (Object.create ? function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = r2);
  var i2 = Object.getOwnPropertyDescriptor(e2, r2);
  (!i2 || ("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable)) && (i2 = { enumerable: true, get: function() {
    return e2[r2];
  } }), Object.defineProperty(t2, n2, i2);
} : function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = r2), t2[n2] = e2[r2];
});
var Zd = ge2 && ge2.__setModuleDefault || (Object.create ? function(t2, e2) {
  Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
} : function(t2, e2) {
  t2.default = e2;
});
var Jd = ge2 && ge2.__importStar || function(t2) {
  if (t2 && t2.__esModule)
    return t2;
  var e2 = {};
  if (t2 != null)
    for (var r2 in t2)
      r2 !== "default" && Object.prototype.hasOwnProperty.call(t2, r2) && Xd(e2, t2, r2);
  return Zd(e2, t2), e2;
};
Object.defineProperty(ts, "__esModule", { value: true });
var xa = gi;
var Pt = Jd(_c);
var Qd = class {
  constructor() {
    pe(this, "keyLength", 4096);
    pe(this, "publicExponent", 65537);
    pe(this, "hashAlgorithm", "sha256");
    pe(this, "encryptionAlgorithm", "aes-256-cbc");
  }
  generateJWK() {
    if (typeof Pt.generateKeyPair != "function")
      throw new Error("Keypair generation not supported in this version of Node, only supported in versions 10+");
    return new Promise((e2, r2) => {
      Pt.generateKeyPair("rsa", {
        modulusLength: this.keyLength,
        publicExponent: this.publicExponent,
        privateKeyEncoding: {
          type: "pkcs1",
          format: "pem"
        },
        publicKeyEncoding: { type: "pkcs1", format: "pem" }
      }, (n2, i2, o2) => {
        n2 && r2(n2), e2(this.pemToJWK(o2));
      });
    });
  }
  sign(e2, r2, { saltLength: n2 } = {}) {
    return new Promise((i2, o2) => {
      i2(Pt.createSign(this.hashAlgorithm).update(r2).sign({
        key: this.jwkToPem(e2),
        padding: Pt.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: n2
      }));
    });
  }
  verify(e2, r2, n2) {
    return new Promise((i2, o2) => {
      var y2;
      const s2 = {
        kty: "RSA",
        e: "AQAB",
        n: e2
      }, a2 = this.jwkToPem(s2), f2 = Pt.createPublicKey({
        key: a2,
        format: "pem"
      }), p2 = Pt.createVerify(this.hashAlgorithm);
      p2.update(r2);
      const d2 = p2.verify({
        key: f2,
        padding: Pt.constants.RSA_PKCS1_PSS_PADDING
      }, n2);
      if (!d2) {
        const v3 = {
          asymmetricKeyType: f2.asymmetricKeyType,
          modulusLength: (y2 = f2.asymmetricKeyDetails) == null ? void 0 : y2.modulusLength
        };
        console.warn(`Transaction Verification Failed! 
Details: ${JSON.stringify(v3, null, 2)} 
N.B. ArweaveJS is only guaranteed to verify txs created using ArweaveJS.`);
      }
      i2(d2);
    });
  }
  hash(e2, r2 = "SHA-256") {
    if (typeof e2 == "string")
      throw new TypeError("Data must be a Uint8Array");
    return new Promise((n2, i2) => {
      n2(Pt.createHash(this.parseHashAlgorithm(r2)).update(e2).digest());
    });
  }
  /**
   * If a key is passed as a buffer it *must* be exactly 32 bytes.
   * If a key is passed as a string then any length may be used.
   *
   * @param {Buffer} data
   * @param {(string | Buffer)} key
   * @returns {Promise<Uint8Array>}
   */
  async encrypt(e2, r2, n2) {
    const i2 = Pt.pbkdf2Sync(r2, n2 = n2 || "salt", 1e5, 32, this.hashAlgorithm), o2 = Pt.randomBytes(16), s2 = Pt.createCipheriv(this.encryptionAlgorithm, i2, o2);
    return Buffer.concat([o2, s2.update(e2), s2.final()]);
  }
  /**
   * If a key is passed as a buffer it *must* be exactly 32 bytes.
   * If a key is passed as a string then any length may be used.
   *
   * @param {Buffer} encrypted
   * @param {(string | Buffer)} key
   * @returns {Promise<Uint8Array>}
   */
  async decrypt(e2, r2, n2) {
    try {
      const i2 = Pt.pbkdf2Sync(r2, n2 = n2 || "salt", 1e5, 32, this.hashAlgorithm), o2 = e2.slice(0, 16), s2 = e2.slice(16), a2 = Pt.createDecipheriv(this.encryptionAlgorithm, i2, o2);
      return Buffer.concat([
        a2.update(s2),
        a2.final()
      ]);
    } catch {
      throw new Error("Failed to decrypt");
    }
  }
  jwkToPem(e2) {
    return (0, xa.jwkTopem)(e2);
  }
  pemToJWK(e2) {
    return (0, xa.pemTojwk)(e2);
  }
  parseHashAlgorithm(e2) {
    switch (e2) {
      case "SHA-256":
        return "sha256";
      case "SHA-384":
        return "sha384";
      default:
        throw new Error(`Algorithm not supported: ${e2}`);
    }
  }
};
ts.default = Qd;
var ms = {};
Object.defineProperty(ms, "__esModule", { value: true });
var ep = class {
  constructor(e2) {
    pe(this, "api");
    this.api = e2;
  }
  getInfo() {
    return this.api.get("info").then((e2) => e2.data);
  }
  getPeers() {
    return this.api.get("peers").then((e2) => e2.data);
  }
};
ms.default = ep;
var $n = {};
var Ar2 = {};
Object.defineProperty(Ar2, "__esModule", { value: true });
Ar2.getError = rp;
var tp = class extends Error {
  constructor(r2, n2 = {}) {
    var e2 = (...args) => {
      super(...args);
      pe(this, "type");
      pe(this, "response");
    };
    n2.message ? e2(n2.message) : e2(), this.type = r2, this.response = n2.response;
  }
  getType() {
    return this.type;
  }
};
Ar2.default = tp;
function rp(t2) {
  let e2 = t2.data;
  if (typeof t2.data == "string")
    try {
      e2 = JSON.parse(t2.data);
    } catch {
    }
  if (t2.data instanceof ArrayBuffer || t2.data instanceof Uint8Array)
    try {
      e2 = JSON.parse(e2.toString());
    } catch {
    }
  return e2 ? e2.error || e2 : t2.statusText || "unknown";
}
var Cr = {};
var lt = {};
var np = ge2 && ge2.__createBinding || (Object.create ? function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = r2);
  var i2 = Object.getOwnPropertyDescriptor(e2, r2);
  (!i2 || ("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable)) && (i2 = { enumerable: true, get: function() {
    return e2[r2];
  } }), Object.defineProperty(t2, n2, i2);
} : function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = r2), t2[n2] = e2[r2];
});
var ip = ge2 && ge2.__setModuleDefault || (Object.create ? function(t2, e2) {
  Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
} : function(t2, e2) {
  t2.default = e2;
});
var op = ge2 && ge2.__importStar || function(t2) {
  if (t2 && t2.__esModule)
    return t2;
  var e2 = {};
  if (t2 != null)
    for (var r2 in t2)
      r2 !== "default" && Object.prototype.hasOwnProperty.call(t2, r2) && np(e2, t2, r2);
  return ip(e2, t2), e2;
};
Object.defineProperty(lt, "__esModule", { value: true });
lt.concatBuffers = sp;
lt.b64UrlToString = ap;
lt.bufferToString = Wc;
lt.stringToBuffer = Hc;
lt.stringToB64Url = up;
lt.b64UrlToBuffer = Kc;
lt.bufferTob64 = zc;
lt.bufferTob64Url = Gc;
lt.b64UrlEncode = Yc;
lt.b64UrlDecode = Xc;
var qc = op(Cn);
function sp(t2) {
  let e2 = 0;
  for (let i2 = 0; i2 < t2.length; i2++)
    e2 += t2[i2].byteLength;
  let r2 = new Uint8Array(e2), n2 = 0;
  r2.set(new Uint8Array(t2[0]), n2), n2 += t2[0].byteLength;
  for (let i2 = 1; i2 < t2.length; i2++)
    r2.set(new Uint8Array(t2[i2]), n2), n2 += t2[i2].byteLength;
  return r2;
}
function ap(t2) {
  let e2 = Kc(t2);
  return Wc(e2);
}
function Wc(t2) {
  return new TextDecoder("utf-8", { fatal: true }).decode(t2);
}
function Hc(t2) {
  return new TextEncoder().encode(t2);
}
function up(t2) {
  return Gc(Hc(t2));
}
function Kc(t2) {
  return new Uint8Array(qc.toByteArray(Xc(t2)));
}
function zc(t2) {
  return qc.fromByteArray(new Uint8Array(t2));
}
function Gc(t2) {
  return Yc(zc(t2));
}
function Yc(t2) {
  try {
    return t2.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  } catch (e2) {
    throw new Error("Failed to encode string", { cause: e2 });
  }
}
function Xc(t2) {
  try {
    t2 = t2.replace(/\-/g, "+").replace(/\_/g, "/");
    let e2;
    return t2.length % 4 == 0 ? e2 = 0 : e2 = 4 - t2.length % 4, t2.concat("=".repeat(e2));
  } catch (e2) {
    throw new Error("Failed to decode string", { cause: e2 });
  }
}
var Vn = {};
var Ta;
function cp() {
  if (Ta)
    return Vn;
  Ta = 1;
  var t2 = ge2 && ge2.__importDefault || function(i2) {
    return i2 && i2.__esModule ? i2 : { default: i2 };
  };
  Object.defineProperty(Vn, "__esModule", { value: true }), Vn.default = r2;
  const e2 = t2(_s());
  async function r2(i2) {
    if (Array.isArray(i2)) {
      const a2 = e2.default.utils.concatBuffers([
        e2.default.utils.stringToBuffer("list"),
        e2.default.utils.stringToBuffer(i2.length.toString())
      ]);
      return await n2(i2, await e2.default.crypto.hash(a2, "SHA-384"));
    }
    const o2 = e2.default.utils.concatBuffers([
      e2.default.utils.stringToBuffer("blob"),
      e2.default.utils.stringToBuffer(i2.byteLength.toString())
    ]), s2 = e2.default.utils.concatBuffers([
      await e2.default.crypto.hash(o2, "SHA-384"),
      await e2.default.crypto.hash(i2, "SHA-384")
    ]);
    return await e2.default.crypto.hash(s2, "SHA-384");
  }
  async function n2(i2, o2) {
    if (i2.length < 1)
      return o2;
    const s2 = e2.default.utils.concatBuffers([
      o2,
      await r2(i2[0])
    ]), a2 = await e2.default.crypto.hash(s2, "SHA-384");
    return await n2(i2.slice(1), a2);
  }
  return Vn;
}
var ji = {};
var Ea;
function Zc() {
  return Ea || (Ea = 1, function(t2) {
    var e2 = ge2 && ge2.__importDefault || function(X3) {
      return X3 && X3.__esModule ? X3 : { default: X3 };
    };
    Object.defineProperty(t2, "__esModule", { value: true }), t2.arrayCompare = t2.MIN_CHUNK_SIZE = t2.MAX_CHUNK_SIZE = void 0, t2.chunkData = s2, t2.generateLeaves = a2, t2.computeRootHash = f2, t2.generateTree = p2, t2.generateTransactionChunks = d2, t2.buildLayers = y2, t2.generateProofs = v3, t2.arrayFlatten = I3, t2.intToBuffer = M3, t2.bufferToInt = S2, t2.validatePath = W2, t2.debug = Q3;
    const r2 = e2(_s()), n2 = lt;
    t2.MAX_CHUNK_SIZE = 256 * 1024, t2.MIN_CHUNK_SIZE = 32 * 1024;
    const i2 = 32, o2 = 32;
    async function s2(X3) {
      let ne = [], ue = X3, se = 0;
      for (; ue.byteLength >= t2.MAX_CHUNK_SIZE; ) {
        let ie = t2.MAX_CHUNK_SIZE, O2 = ue.byteLength - t2.MAX_CHUNK_SIZE;
        O2 > 0 && O2 < t2.MIN_CHUNK_SIZE && (ie = Math.ceil(ue.byteLength / 2));
        const c2 = ue.slice(0, ie), m2 = await r2.default.crypto.hash(c2);
        se += c2.byteLength, ne.push({
          dataHash: m2,
          minByteRange: se - c2.byteLength,
          maxByteRange: se
        }), ue = ue.slice(ie);
      }
      return ne.push({
        dataHash: await r2.default.crypto.hash(ue),
        minByteRange: se,
        maxByteRange: se + ue.byteLength
      }), ne;
    }
    async function a2(X3) {
      return Promise.all(X3.map(async ({ dataHash: ne, minByteRange: ue, maxByteRange: se }) => ({
        type: "leaf",
        id: await k2(await Promise.all([k2(ne), k2(M3(se))])),
        dataHash: ne,
        minByteRange: ue,
        maxByteRange: se
      })));
    }
    async function f2(X3) {
      return (await p2(X3)).id;
    }
    async function p2(X3) {
      return await y2(await a2(await s2(X3)));
    }
    async function d2(X3) {
      const ne = await s2(X3), ue = await a2(ne), se = await y2(ue), ie = await v3(se), O2 = ne.slice(-1)[0];
      return O2.maxByteRange - O2.minByteRange === 0 && (ne.splice(ne.length - 1, 1), ie.splice(ie.length - 1, 1)), {
        data_root: se.id,
        chunks: ne,
        proofs: ie
      };
    }
    async function y2(X3, ne = 0) {
      if (X3.length < 2)
        return X3[0];
      const ue = [];
      for (let se = 0; se < X3.length; se += 2)
        ue.push(await N11(X3[se], X3[se + 1]));
      return y2(ue, ne + 1);
    }
    function v3(X3) {
      const ne = w3(X3);
      return Array.isArray(ne) ? I3(ne) : [ne];
    }
    function w3(X3, ne = new Uint8Array(), ue = 0) {
      if (X3.type == "leaf")
        return {
          offset: X3.maxByteRange - 1,
          proof: (0, n2.concatBuffers)([
            ne,
            X3.dataHash,
            M3(X3.maxByteRange)
          ])
        };
      if (X3.type == "branch") {
        const se = (0, n2.concatBuffers)([
          ne,
          X3.leftChild.id,
          X3.rightChild.id,
          M3(X3.byteRange)
        ]);
        return [
          w3(X3.leftChild, se, ue + 1),
          w3(X3.rightChild, se, ue + 1)
        ];
      }
      throw new Error("Unexpected node type");
    }
    function I3(X3) {
      const ne = [];
      return X3.forEach((ue) => {
        Array.isArray(ue) ? ne.push(...I3(ue)) : ne.push(ue);
      }), ne;
    }
    async function N11(X3, ne) {
      return ne ? {
        type: "branch",
        id: await k2([
          await k2(X3.id),
          await k2(ne.id),
          await k2(M3(X3.maxByteRange))
        ]),
        byteRange: X3.maxByteRange,
        maxByteRange: ne.maxByteRange,
        leftChild: X3,
        rightChild: ne
      } : X3;
    }
    async function k2(X3) {
      return Array.isArray(X3) && (X3 = r2.default.utils.concatBuffers(X3)), new Uint8Array(await r2.default.crypto.hash(X3));
    }
    function M3(X3) {
      const ne = new Uint8Array(i2);
      for (var ue = ne.length - 1; ue >= 0; ue--) {
        var se = X3 % 256;
        ne[ue] = se, X3 = (X3 - se) / 256;
      }
      return ne;
    }
    function S2(X3) {
      let ne = 0;
      for (var ue = 0; ue < X3.length; ue++)
        ne *= 256, ne += X3[ue];
      return ne;
    }
    const Y2 = (X3, ne) => X3.every((ue, se) => ne[se] === ue);
    t2.arrayCompare = Y2;
    async function W2(X3, ne, ue, se, ie) {
      if (se <= 0)
        return false;
      if (ne >= se)
        return W2(X3, 0, se - 1, se, ie);
      if (ne < 0)
        return W2(X3, 0, 0, se, ie);
      if (ie.length == o2 + i2) {
        const L2 = ie.slice(0, o2), H2 = ie.slice(L2.length, L2.length + i2), P3 = await k2([
          await k2(L2),
          await k2(H2)
        ]);
        return (0, t2.arrayCompare)(X3, P3) ? {
          offset: se - 1,
          leftBound: ue,
          rightBound: se,
          chunkSize: se - ue
        } : false;
      }
      const O2 = ie.slice(0, o2), c2 = ie.slice(O2.length, O2.length + o2), m2 = ie.slice(O2.length + c2.length, O2.length + c2.length + i2), _3 = S2(m2), T3 = ie.slice(O2.length + c2.length + m2.length), C3 = await k2([
        await k2(O2),
        await k2(c2),
        await k2(m2)
      ]);
      return (0, t2.arrayCompare)(X3, C3) ? ne < _3 ? await W2(O2, ne, ue, Math.min(se, _3), T3) : await W2(c2, ne, Math.max(ue, _3), se, T3) : false;
    }
    async function Q3(X3, ne = "") {
      if (X3.byteLength < 1)
        return ne;
      const ue = X3.slice(0, o2), se = X3.slice(ue.length, ue.length + o2), ie = X3.slice(ue.length + se.length, ue.length + se.length + i2), O2 = S2(ie), c2 = X3.slice(ue.length + se.length + ie.length), m2 = await k2([
        await k2(ue),
        await k2(se),
        await k2(ie)
      ]), _3 = `${ne}
${JSON.stringify(Buffer.from(ue))},${JSON.stringify(Buffer.from(se))},${O2} => ${JSON.stringify(m2)}`;
      return Q3(c2, _3);
    }
  }(ji)), ji;
}
var Aa;
function gs() {
  if (Aa)
    return Cr;
  Aa = 1;
  var t2 = ge2 && ge2.__createBinding || (Object.create ? function(d2, y2, v3, w3) {
    w3 === void 0 && (w3 = v3);
    var I3 = Object.getOwnPropertyDescriptor(y2, v3);
    (!I3 || ("get" in I3 ? !y2.__esModule : I3.writable || I3.configurable)) && (I3 = { enumerable: true, get: function() {
      return y2[v3];
    } }), Object.defineProperty(d2, w3, I3);
  } : function(d2, y2, v3, w3) {
    w3 === void 0 && (w3 = v3), d2[w3] = y2[v3];
  }), e2 = ge2 && ge2.__setModuleDefault || (Object.create ? function(d2, y2) {
    Object.defineProperty(d2, "default", { enumerable: true, value: y2 });
  } : function(d2, y2) {
    d2.default = y2;
  }), r2 = ge2 && ge2.__importStar || function(d2) {
    if (d2 && d2.__esModule)
      return d2;
    var y2 = {};
    if (d2 != null)
      for (var v3 in d2)
        v3 !== "default" && Object.prototype.hasOwnProperty.call(d2, v3) && t2(y2, d2, v3);
    return e2(y2, d2), y2;
  }, n2 = ge2 && ge2.__importDefault || function(d2) {
    return d2 && d2.__esModule ? d2 : { default: d2 };
  };
  Object.defineProperty(Cr, "__esModule", { value: true }), Cr.Tag = void 0;
  const i2 = r2(lt), o2 = n2(cp()), s2 = Zc();
  class a2 {
    get(y2, v3) {
      if (!Object.getOwnPropertyNames(this).includes(y2))
        throw new Error(`Field "${y2}" is not a property of the Arweave Transaction class.`);
      if (this[y2] instanceof Uint8Array)
        return v3 && v3.decode && v3.string ? i2.bufferToString(this[y2]) : v3 && v3.decode && !v3.string ? this[y2] : i2.bufferTob64Url(this[y2]);
      if (this[y2] instanceof Array) {
        if ((v3 == null ? void 0 : v3.decode) !== void 0 || (v3 == null ? void 0 : v3.string) !== void 0)
          throw y2 === "tags" && console.warn(`Did you mean to use 'transaction["tags"]' ?`), new Error("Cannot decode or stringify an array.");
        return this[y2];
      }
      return v3 && v3.decode == true ? v3 && v3.string ? i2.b64UrlToString(this[y2]) : i2.b64UrlToBuffer(this[y2]) : this[y2];
    }
  }
  class f2 extends a2 {
    constructor(v3, w3, I3 = false) {
      super();
      pe(this, "name");
      pe(this, "value");
      this.name = v3, this.value = w3;
    }
  }
  Cr.Tag = f2;
  class p2 extends a2 {
    constructor(v3 = {}) {
      super();
      pe(this, "format", 2);
      pe(this, "id", "");
      pe(this, "last_tx", "");
      pe(this, "owner", "");
      pe(this, "tags", []);
      pe(this, "target", "");
      pe(this, "quantity", "0");
      pe(this, "data_size", "0");
      pe(this, "data", new Uint8Array());
      pe(this, "data_root", "");
      pe(this, "reward", "0");
      pe(this, "signature", "");
      pe(this, "chunks");
      Object.assign(this, v3), typeof this.data == "string" && (this.data = i2.b64UrlToBuffer(this.data)), v3.tags && (this.tags = v3.tags.map((w3) => new f2(w3.name, w3.value)));
    }
    addTag(v3, w3) {
      this.tags.push(new f2(i2.stringToB64Url(v3), i2.stringToB64Url(w3)));
    }
    toJSON() {
      return {
        format: this.format,
        id: this.id,
        last_tx: this.last_tx,
        owner: this.owner,
        tags: this.tags,
        target: this.target,
        quantity: this.quantity,
        data: i2.bufferTob64Url(this.data),
        data_size: this.data_size,
        data_root: this.data_root,
        data_tree: this.data_tree,
        reward: this.reward,
        signature: this.signature
      };
    }
    setOwner(v3) {
      this.owner = v3;
    }
    setSignature({ id: v3, owner: w3, reward: I3, tags: N11, signature: k2 }) {
      this.id = v3, this.owner = w3, I3 && (this.reward = I3), N11 && (this.tags = N11), this.signature = k2;
    }
    async prepareChunks(v3) {
      !this.chunks && v3.byteLength > 0 && (this.chunks = await (0, s2.generateTransactionChunks)(v3), this.data_root = i2.bufferTob64Url(this.chunks.data_root)), !this.chunks && v3.byteLength === 0 && (this.chunks = {
        chunks: [],
        data_root: new Uint8Array(),
        proofs: []
      }, this.data_root = "");
    }
    // Returns a chunk in a format suitable for posting to /chunk.
    // Similar to `prepareChunks()` this does not operate `this.data`,
    // instead using the data passed in.
    getChunk(v3, w3) {
      if (!this.chunks)
        throw new Error("Chunks have not been prepared");
      const I3 = this.chunks.proofs[v3], N11 = this.chunks.chunks[v3];
      return {
        data_root: this.data_root,
        data_size: this.data_size,
        data_path: i2.bufferTob64Url(I3.proof),
        offset: I3.offset.toString(),
        chunk: i2.bufferTob64Url(w3.slice(N11.minByteRange, N11.maxByteRange))
      };
    }
    async getSignatureData() {
      switch (this.format) {
        case 1:
          let v3 = this.tags.reduce((I3, N11) => i2.concatBuffers([
            I3,
            N11.get("name", { decode: true, string: false }),
            N11.get("value", { decode: true, string: false })
          ]), new Uint8Array());
          return i2.concatBuffers([
            this.get("owner", { decode: true, string: false }),
            this.get("target", { decode: true, string: false }),
            this.get("data", { decode: true, string: false }),
            i2.stringToBuffer(this.quantity),
            i2.stringToBuffer(this.reward),
            this.get("last_tx", { decode: true, string: false }),
            v3
          ]);
        case 2:
          this.data_root || await this.prepareChunks(this.data);
          const w3 = this.tags.map((I3) => [
            I3.get("name", { decode: true, string: false }),
            I3.get("value", { decode: true, string: false })
          ]);
          return await (0, o2.default)([
            i2.stringToBuffer(this.format.toString()),
            this.get("owner", { decode: true, string: false }),
            this.get("target", { decode: true, string: false }),
            i2.stringToBuffer(this.quantity),
            i2.stringToBuffer(this.reward),
            this.get("last_tx", { decode: true, string: false }),
            w3,
            i2.stringToBuffer(this.data_size),
            this.get("data_root", { decode: true, string: false })
          ]);
        default:
          throw new Error(`Unexpected transaction format: ${this.format}`);
      }
    }
  }
  return Cr.default = p2, Cr;
}
var on = {};
var Ma;
function lp() {
  if (Ma)
    return on;
  Ma = 1;
  var t2 = ge2 && ge2.__createBinding || (Object.create ? function(v3, w3, I3, N11) {
    N11 === void 0 && (N11 = I3);
    var k2 = Object.getOwnPropertyDescriptor(w3, I3);
    (!k2 || ("get" in k2 ? !w3.__esModule : k2.writable || k2.configurable)) && (k2 = { enumerable: true, get: function() {
      return w3[I3];
    } }), Object.defineProperty(v3, N11, k2);
  } : function(v3, w3, I3, N11) {
    N11 === void 0 && (N11 = I3), v3[N11] = w3[I3];
  }), e2 = ge2 && ge2.__setModuleDefault || (Object.create ? function(v3, w3) {
    Object.defineProperty(v3, "default", { enumerable: true, value: w3 });
  } : function(v3, w3) {
    v3.default = w3;
  }), r2 = ge2 && ge2.__importStar || function(v3) {
    if (v3 && v3.__esModule)
      return v3;
    var w3 = {};
    if (v3 != null)
      for (var I3 in v3)
        I3 !== "default" && Object.prototype.hasOwnProperty.call(v3, I3) && t2(w3, v3, I3);
    return e2(w3, v3), w3;
  }, n2 = ge2 && ge2.__importDefault || function(v3) {
    return v3 && v3.__esModule ? v3 : { default: v3 };
  };
  Object.defineProperty(on, "__esModule", { value: true }), on.TransactionUploader = void 0;
  const i2 = n2(gs()), o2 = r2(lt), s2 = Ar2, a2 = Zc(), f2 = 1, p2 = [
    "invalid_json",
    "chunk_too_big",
    "data_path_too_big",
    "offset_too_big",
    "data_size_too_big",
    "chunk_proof_ratio_not_attractive",
    "invalid_proof"
  ], d2 = 1e3 * 40;
  class y2 {
    constructor(w3, I3) {
      pe(this, "api");
      pe(this, "chunkIndex", 0);
      pe(this, "txPosted", false);
      pe(this, "transaction");
      pe(this, "lastRequestTimeEnd", 0);
      pe(this, "totalErrors", 0);
      pe(this, "data");
      pe(this, "lastResponseStatus", 0);
      pe(this, "lastResponseError", "");
      if (this.api = w3, !I3.id)
        throw new Error("Transaction is not signed");
      if (!I3.chunks)
        throw new Error("Transaction chunks not prepared");
      this.data = I3.data, this.transaction = new i2.default(Object.assign({}, I3, { data: new Uint8Array(0) }));
    }
    get isComplete() {
      return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
    }
    get totalChunks() {
      return this.transaction.chunks.chunks.length;
    }
    get uploadedChunks() {
      return this.chunkIndex;
    }
    get pctComplete() {
      return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
    }
    /**
     * Uploads the next part of the transaction.
     * On the first call this posts the transaction
     * itself and on any subsequent calls uploads the
     * next chunk until it completes.
     */
    async uploadChunk(w3) {
      if (this.isComplete)
        throw new Error("Upload is already complete");
      if (this.lastResponseError !== "" ? this.totalErrors++ : this.totalErrors = 0, this.totalErrors === 100)
        throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
      let I3 = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + d2 - Date.now(), d2);
      if (I3 > 0 && (I3 = I3 - I3 * Math.random() * 0.3, await new Promise((S2) => setTimeout(S2, I3))), this.lastResponseError = "", !this.txPosted) {
        await this.postTransaction();
        return;
      }
      w3 && (this.chunkIndex = w3);
      const N11 = this.transaction.getChunk(w3 || this.chunkIndex, this.data);
      if (!await (0, a2.validatePath)(this.transaction.chunks.data_root, parseInt(N11.offset), 0, parseInt(N11.data_size), o2.b64UrlToBuffer(N11.data_path)))
        throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
      const M3 = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((S2) => (console.error(S2.message), { status: -1, data: { error: S2.message } }));
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = M3.status, this.lastResponseStatus == 200)
        this.chunkIndex++;
      else if (this.lastResponseError = (0, s2.getError)(M3), p2.includes(this.lastResponseError))
        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
    }
    /**
     * Reconstructs an upload from its serialized state and data.
     * Checks if data matches the expected data_root.
     *
     * @param serialized
     * @param data
     */
    static async fromSerialized(w3, I3, N11) {
      if (!I3 || typeof I3.chunkIndex != "number" || typeof I3.transaction != "object")
        throw new Error("Serialized object does not match expected format.");
      var k2 = new i2.default(I3.transaction);
      k2.chunks || await k2.prepareChunks(N11);
      const M3 = new y2(w3, k2);
      if (M3.chunkIndex = I3.chunkIndex, M3.lastRequestTimeEnd = I3.lastRequestTimeEnd, M3.lastResponseError = I3.lastResponseError, M3.lastResponseStatus = I3.lastResponseStatus, M3.txPosted = I3.txPosted, M3.data = N11, M3.transaction.data_root !== I3.transaction.data_root)
        throw new Error("Data mismatch: Uploader doesn't match provided data.");
      return M3;
    }
    /**
     * Reconstruct an upload from the tx metadata, ie /tx/<id>.
     *
     * @param api
     * @param id
     * @param data
     */
    static async fromTransactionId(w3, I3) {
      const N11 = await w3.get(`tx/${I3}`);
      if (N11.status !== 200)
        throw new Error(`Tx ${I3} not found: ${N11.status}`);
      const k2 = N11.data;
      return k2.data = new Uint8Array(0), {
        txPosted: true,
        chunkIndex: 0,
        lastResponseError: "",
        lastRequestTimeEnd: 0,
        lastResponseStatus: 0,
        transaction: k2
      };
    }
    toJSON() {
      return {
        chunkIndex: this.chunkIndex,
        transaction: this.transaction,
        lastRequestTimeEnd: this.lastRequestTimeEnd,
        lastResponseStatus: this.lastResponseStatus,
        lastResponseError: this.lastResponseError,
        txPosted: this.txPosted
      };
    }
    // POST to /tx
    async postTransaction() {
      if (this.totalChunks <= f2) {
        this.transaction.data = this.data;
        const N11 = await this.api.post("tx", this.transaction).catch((k2) => (console.error(k2), { status: -1, data: { error: k2.message } }));
        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = N11.status, this.transaction.data = new Uint8Array(0), N11.status >= 200 && N11.status < 300) {
          this.txPosted = true, this.chunkIndex = f2;
          return;
        }
        throw this.lastResponseError = (0, s2.getError)(N11), new Error(`Unable to upload transaction: ${N11.status}, ${this.lastResponseError}`);
      }
      const I3 = await this.api.post("tx", this.transaction);
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = I3.status, !(I3.status >= 200 && I3.status < 300))
        throw this.lastResponseError = (0, s2.getError)(I3), new Error(`Unable to upload transaction: ${I3.status}, ${this.lastResponseError}`);
      this.txPosted = true;
    }
  }
  return on.TransactionUploader = y2, on;
}
var Sa;
function fp() {
  if (Sa)
    return $n;
  Sa = 1;
  var t2 = ge2 && ge2.__createBinding || (Object.create ? function(p2, d2, y2, v3) {
    v3 === void 0 && (v3 = y2);
    var w3 = Object.getOwnPropertyDescriptor(d2, y2);
    (!w3 || ("get" in w3 ? !d2.__esModule : w3.writable || w3.configurable)) && (w3 = { enumerable: true, get: function() {
      return d2[y2];
    } }), Object.defineProperty(p2, v3, w3);
  } : function(p2, d2, y2, v3) {
    v3 === void 0 && (v3 = y2), p2[v3] = d2[y2];
  }), e2 = ge2 && ge2.__setModuleDefault || (Object.create ? function(p2, d2) {
    Object.defineProperty(p2, "default", { enumerable: true, value: d2 });
  } : function(p2, d2) {
    p2.default = d2;
  }), r2 = ge2 && ge2.__importStar || function(p2) {
    if (p2 && p2.__esModule)
      return p2;
    var d2 = {};
    if (p2 != null)
      for (var y2 in p2)
        y2 !== "default" && Object.prototype.hasOwnProperty.call(p2, y2) && t2(d2, p2, y2);
    return e2(d2, p2), d2;
  }, n2 = ge2 && ge2.__importDefault || function(p2) {
    return p2 && p2.__esModule ? p2 : { default: p2 };
  };
  Object.defineProperty($n, "__esModule", { value: true });
  const i2 = n2(Ar2), o2 = n2(gs()), s2 = r2(lt), a2 = lp();
  class f2 {
    constructor(d2, y2, v3) {
      pe(this, "api");
      pe(this, "crypto");
      pe(this, "chunks");
      this.api = d2, this.crypto = y2, this.chunks = v3;
    }
    async getTransactionAnchor() {
      const d2 = await this.api.get("tx_anchor");
      if (!d2.data.match(/^[a-z0-9_-]{43,}/i) || !d2.ok)
        throw new Error(`Could not getTransactionAnchor. Received: ${d2.data}. Status: ${d2.status}, ${d2.statusText}`);
      return d2.data;
    }
    async getPrice(d2, y2) {
      let v3 = y2 ? `price/${d2}/${y2}` : `price/${d2}`;
      const w3 = await this.api.get(v3);
      if (!/^\d+$/.test(w3.data) || !w3.ok)
        throw new Error(`Could not getPrice. Received: ${w3.data}. Status: ${w3.status}, ${w3.statusText}`);
      return w3.data;
    }
    async get(d2) {
      const y2 = await this.api.get(`tx/${d2}`);
      if (y2.status == 200) {
        const v3 = parseInt(y2.data.data_size);
        if (y2.data.format >= 2 && v3 > 0 && v3 <= 1024 * 1024 * 12) {
          const w3 = await this.getData(d2);
          return new o2.default({
            ...y2.data,
            data: w3
          });
        }
        return new o2.default({
          ...y2.data,
          format: y2.data.format || 1
        });
      }
      throw y2.status == 404 ? new i2.default(
        "TX_NOT_FOUND"
        /* ArweaveErrorType.TX_NOT_FOUND */
      ) : y2.status == 410 ? new i2.default(
        "TX_FAILED"
        /* ArweaveErrorType.TX_FAILED */
      ) : new i2.default(
        "TX_INVALID"
        /* ArweaveErrorType.TX_INVALID */
      );
    }
    fromRaw(d2) {
      return new o2.default(d2);
    }
    /** @deprecated use GQL https://gql-guide.arweave.net */
    async search(d2, y2) {
      return this.api.post("arql", {
        op: "equals",
        expr1: d2,
        expr2: y2
      }).then((v3) => v3.data ? v3.data : []);
    }
    getStatus(d2) {
      return this.api.get(`tx/${d2}/status`).then((y2) => y2.status == 200 ? {
        status: 200,
        confirmed: y2.data
      } : {
        status: y2.status,
        confirmed: null
      });
    }
    async getData(d2, y2) {
      let v3;
      try {
        v3 = await this.chunks.downloadChunkedData(d2);
      } catch (w3) {
        console.error(`Error while trying to download chunked data for ${d2}`), console.error(w3);
      }
      if (!v3) {
        console.warn(`Falling back to gateway cache for ${d2}`);
        try {
          const { data: w3, ok: I3, status: N11, statusText: k2 } = await this.api.get(`/${d2}`, { responseType: "arraybuffer" });
          if (!I3)
            throw new Error("Bad http status code", {
              cause: { status: N11, statusText: k2 }
            });
          v3 = w3;
        } catch (w3) {
          console.error(`Error while trying to download contiguous data from gateway cache for ${d2}`), console.error(w3);
        }
      }
      if (!v3)
        throw new Error(`${d2} data was not found!`);
      return y2 && y2.decode && !y2.string ? v3 : y2 && y2.decode && y2.string ? s2.bufferToString(v3) : s2.bufferTob64Url(v3);
    }
    async sign(d2, y2, v3) {
      const I3 = typeof y2 == "object" && ((k2) => {
        let M3 = true;
        return ["n", "e", "d", "p", "q", "dp", "dq", "qi"].map((S2) => !(S2 in k2) && (M3 = false)), M3;
      })(y2), N11 = typeof arweaveWallet == "object";
      if (!I3 && !N11)
        throw new Error("No valid JWK or external wallet found to sign transaction.");
      if (I3) {
        d2.setOwner(y2.n);
        let k2 = await d2.getSignatureData(), M3 = await this.crypto.sign(y2, k2, v3), S2 = await this.crypto.hash(M3);
        d2.setSignature({
          id: s2.bufferTob64Url(S2),
          owner: y2.n,
          signature: s2.bufferTob64Url(M3)
        });
      } else if (N11) {
        try {
          (await arweaveWallet.getPermissions()).includes("SIGN_TRANSACTION") || await arweaveWallet.connect(["SIGN_TRANSACTION"]);
        } catch {
        }
        const k2 = await arweaveWallet.sign(d2, v3);
        d2.setSignature({
          id: k2.id,
          owner: k2.owner,
          reward: k2.reward,
          tags: k2.tags,
          signature: k2.signature
        });
      } else
        throw new Error("An error occurred while signing. Check wallet is valid");
    }
    async verify(d2) {
      const y2 = await d2.getSignatureData(), v3 = d2.get("signature", {
        decode: true,
        string: false
      }), w3 = s2.bufferTob64Url(await this.crypto.hash(v3));
      if (d2.id !== w3)
        throw new Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
      return this.crypto.verify(d2.owner, y2, v3);
    }
    async post(d2) {
      if (typeof d2 == "string" ? d2 = new o2.default(JSON.parse(d2)) : typeof d2.readInt32BE == "function" ? d2 = new o2.default(JSON.parse(d2.toString())) : typeof d2 == "object" && !(d2 instanceof o2.default) && (d2 = new o2.default(d2)), !(d2 instanceof o2.default))
        throw new Error("Must be Transaction object");
      d2.chunks || await d2.prepareChunks(d2.data);
      const y2 = await this.getUploader(d2, d2.data);
      try {
        for (; !y2.isComplete; )
          await y2.uploadChunk();
      } catch (v3) {
        if (y2.lastResponseStatus > 0)
          return {
            status: y2.lastResponseStatus,
            statusText: y2.lastResponseError,
            data: {
              error: y2.lastResponseError
            }
          };
        throw v3;
      }
      return {
        status: 200,
        statusText: "OK",
        data: {}
      };
    }
    /**
     * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress
     * and the ability to resume.
     *
     * Usage example:
     *
     * ```
     * const uploader = arweave.transactions.getUploader(transaction);
     * while (!uploader.isComplete) {
     *   await uploader.uploadChunk();
     *   console.log(`${uploader.pctComplete}%`);
     * }
     * ```
     *
     * @param upload a Transaction object, a previously save progress object, or a transaction id.
     * @param data the data of the transaction. Required when resuming an upload.
     */
    async getUploader(d2, y2) {
      let v3;
      if (y2 instanceof ArrayBuffer && (y2 = new Uint8Array(y2)), d2 instanceof o2.default) {
        if (y2 || (y2 = d2.data), !(y2 instanceof Uint8Array))
          throw new Error("Data format is invalid");
        d2.chunks || await d2.prepareChunks(y2), v3 = new a2.TransactionUploader(this.api, d2), (!v3.data || v3.data.length === 0) && (v3.data = y2);
      } else {
        if (typeof d2 == "string" && (d2 = await a2.TransactionUploader.fromTransactionId(this.api, d2)), !y2 || !(y2 instanceof Uint8Array))
          throw new Error("Must provide data when resuming upload");
        v3 = await a2.TransactionUploader.fromSerialized(this.api, d2, y2);
      }
      return v3;
    }
    /**
     * Async generator version of uploader
     *
     * Usage example:
     *
     * ```
     * for await (const uploader of arweave.transactions.upload(tx)) {
     *  console.log(`${uploader.pctComplete}%`);
     * }
     * ```
     *
     * @param upload a Transaction object, a previously save uploader, or a transaction id.
     * @param data the data of the transaction. Required when resuming an upload.
     */
    async *upload(d2, y2) {
      const v3 = await this.getUploader(d2, y2);
      for (; !v3.isComplete; )
        await v3.uploadChunk(), yield v3;
      return v3;
    }
  }
  return $n.default = f2, $n;
}
var ys = {};
var hp = ge2 && ge2.__createBinding || (Object.create ? function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = r2);
  var i2 = Object.getOwnPropertyDescriptor(e2, r2);
  (!i2 || ("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable)) && (i2 = { enumerable: true, get: function() {
    return e2[r2];
  } }), Object.defineProperty(t2, n2, i2);
} : function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = r2), t2[n2] = e2[r2];
});
var dp = ge2 && ge2.__setModuleDefault || (Object.create ? function(t2, e2) {
  Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
} : function(t2, e2) {
  t2.default = e2;
});
var pp = ge2 && ge2.__importStar || function(t2) {
  if (t2 && t2.__esModule)
    return t2;
  var e2 = {};
  if (t2 != null)
    for (var r2 in t2)
      r2 !== "default" && Object.prototype.hasOwnProperty.call(t2, r2) && hp(e2, t2, r2);
  return dp(e2, t2), e2;
};
Object.defineProperty(ys, "__esModule", { value: true });
var Pa = pp(lt);
var mp = class {
  constructor(e2, r2) {
    pe(this, "api");
    pe(this, "crypto");
    this.api = e2, this.crypto = r2;
  }
  /**
   * Get the wallet balance for the given address.
   *
   * @param {string} address - The arweave address to get the balance for.
   *
   * @returns {Promise<string>} - Promise which resolves with a winston string balance.
   */
  getBalance(e2) {
    return this.api.get(`wallet/${e2}/balance`).then((r2) => r2.data);
  }
  /**
   * Get the last transaction ID for the given wallet address.
   *
   * @param {string} address - The arweave address to get the transaction for.
   *
   * @returns {Promise<string>} - Promise which resolves with a transaction ID.
   */
  getLastTransactionID(e2) {
    return this.api.get(`wallet/${e2}/last_tx`).then((r2) => r2.data);
  }
  generate() {
    return this.crypto.generateJWK();
  }
  async jwkToAddress(e2) {
    return !e2 || e2 === "use_wallet" ? this.getAddress() : this.getAddress(e2);
  }
  async getAddress(e2) {
    if (!e2 || e2 === "use_wallet") {
      try {
        await arweaveWallet.connect(["ACCESS_ADDRESS"]);
      } catch {
      }
      return arweaveWallet.getActiveAddress();
    } else
      return this.ownerToAddress(e2.n);
  }
  async ownerToAddress(e2) {
    return Pa.bufferTob64Url(await this.crypto.hash(Pa.b64UrlToBuffer(e2)));
  }
};
ys.default = mp;
var On = {};
var gp = ge2 && ge2.__createBinding || (Object.create ? function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = r2);
  var i2 = Object.getOwnPropertyDescriptor(e2, r2);
  (!i2 || ("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable)) && (i2 = { enumerable: true, get: function() {
    return e2[r2];
  } }), Object.defineProperty(t2, n2, i2);
} : function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = r2), t2[n2] = e2[r2];
});
var yp = ge2 && ge2.__setModuleDefault || (Object.create ? function(t2, e2) {
  Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
} : function(t2, e2) {
  t2.default = e2;
});
var vp = ge2 && ge2.__importStar || function(t2) {
  if (t2 && t2.__esModule)
    return t2;
  var e2 = {};
  if (t2 != null)
    for (var r2 in t2)
      r2 !== "default" && Object.prototype.hasOwnProperty.call(t2, r2) && gp(e2, t2, r2);
  return yp(e2, t2), e2;
};
Object.defineProperty(On, "__esModule", { value: true });
On.SiloResource = void 0;
var Ca = vp(lt);
var wp = class {
  constructor(e2, r2, n2) {
    pe(this, "api");
    pe(this, "crypto");
    pe(this, "transactions");
    this.api = e2, this.crypto = r2, this.transactions = n2;
  }
  async get(e2) {
    if (!e2)
      throw new Error("No Silo URI specified");
    const r2 = await this.parseUri(e2), n2 = await this.transactions.search("Silo-Name", r2.getAccessKey());
    if (n2.length == 0)
      throw new Error(`No data could be found for the Silo URI: ${e2}`);
    const i2 = await this.transactions.get(n2[0]);
    if (!i2)
      throw new Error(`No data could be found for the Silo URI: ${e2}`);
    const o2 = i2.get("data", { decode: true, string: false });
    return this.crypto.decrypt(o2, r2.getEncryptionKey());
  }
  async readTransactionData(e2, r2) {
    if (!r2)
      throw new Error("No Silo URI specified");
    const n2 = await this.parseUri(r2), i2 = e2.get("data", { decode: true, string: false });
    return this.crypto.decrypt(i2, n2.getEncryptionKey());
  }
  async parseUri(e2) {
    const r2 = e2.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
    if (!r2)
      throw new Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
    const n2 = r2[1], i2 = Math.pow(2, parseInt(r2[2])), o2 = await this.hash(Ca.stringToBuffer(n2), i2), s2 = Ca.bufferTob64(o2.slice(0, 15)), a2 = await this.hash(o2.slice(16, 31), 1);
    return new Jc(e2, s2, a2);
  }
  async hash(e2, r2) {
    let n2 = await this.crypto.hash(e2);
    for (let i2 = 0; i2 < r2 - 1; i2++)
      n2 = await this.crypto.hash(n2);
    return n2;
  }
};
On.default = wp;
var Jc = class {
  constructor(e2, r2, n2) {
    pe(this, "uri");
    pe(this, "accessKey");
    pe(this, "encryptionKey");
    this.uri = e2, this.accessKey = r2, this.encryptionKey = n2;
  }
  getUri() {
    return this.uri;
  }
  getAccessKey() {
    return this.accessKey;
  }
  getEncryptionKey() {
    return this.encryptionKey;
  }
};
On.SiloResource = Jc;
var vs = {};
var _p = ge2 && ge2.__createBinding || (Object.create ? function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = r2);
  var i2 = Object.getOwnPropertyDescriptor(e2, r2);
  (!i2 || ("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable)) && (i2 = { enumerable: true, get: function() {
    return e2[r2];
  } }), Object.defineProperty(t2, n2, i2);
} : function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = r2), t2[n2] = e2[r2];
});
var bp = ge2 && ge2.__setModuleDefault || (Object.create ? function(t2, e2) {
  Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
} : function(t2, e2) {
  t2.default = e2;
});
var xp = ge2 && ge2.__importStar || function(t2) {
  if (t2 && t2.__esModule)
    return t2;
  var e2 = {};
  if (t2 != null)
    for (var r2 in t2)
      r2 !== "default" && Object.prototype.hasOwnProperty.call(t2, r2) && _p(e2, t2, r2);
  return bp(e2, t2), e2;
};
Object.defineProperty(vs, "__esModule", { value: true });
var Oa = Ar2;
var Tp = xp(lt);
var Ep = class {
  constructor(e2) {
    pe(this, "api");
    this.api = e2;
  }
  async getTransactionOffset(e2) {
    const r2 = await this.api.get(`tx/${e2}/offset`);
    if (r2.status === 200)
      return r2.data;
    throw new Error(`Unable to get transaction offset: ${(0, Oa.getError)(r2)}`);
  }
  async getChunk(e2) {
    const r2 = await this.api.get(`chunk/${e2}`);
    if (r2.status === 200)
      return r2.data;
    throw new Error(`Unable to get chunk: ${(0, Oa.getError)(r2)}`);
  }
  async getChunkData(e2) {
    const r2 = await this.getChunk(e2);
    return Tp.b64UrlToBuffer(r2.chunk);
  }
  firstChunkOffset(e2) {
    return parseInt(e2.offset) - parseInt(e2.size) + 1;
  }
  async downloadChunkedData(e2) {
    const r2 = await this.getTransactionOffset(e2), n2 = parseInt(r2.size), o2 = parseInt(r2.offset) - n2 + 1, s2 = new Uint8Array(n2);
    let a2 = 0;
    for (; a2 < n2; ) {
      this.api.config.logging && console.log(`[chunk] ${a2}/${n2}`);
      let f2;
      try {
        f2 = await this.getChunkData(o2 + a2);
      } catch {
        console.error(`[chunk] Failed to fetch chunk at offset ${o2 + a2}`), console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
      }
      if (f2)
        s2.set(f2, a2), a2 += f2.length;
      else
        throw new Error(`Couldn't complete data download at ${a2}/${n2}`);
    }
    return s2;
  }
};
vs.default = Ep;
var ws = {};
var Ap = ge2 && ge2.__importDefault || function(t2) {
  return t2 && t2.__esModule ? t2 : { default: t2 };
};
Object.defineProperty(ws, "__esModule", { value: true });
var Ra = Ap(Ar2);
var Lr = class Lr2 {
  constructor(e2, r2) {
    pe(this, "api");
    pe(this, "network");
    this.api = e2, this.network = r2;
  }
  /**
   * Gets a block by its "indep_hash"
   */
  async get(e2) {
    const r2 = await this.api.get(`${Lr2.HASH_ENDPOINT}${e2}`);
    if (r2.status === 200)
      return r2.data;
    throw r2.status === 404 ? new Ra.default(
      "BLOCK_NOT_FOUND"
      /* ArweaveErrorType.BLOCK_NOT_FOUND */
    ) : new Error(`Error while loading block data: ${r2}`);
  }
  /**
   * Gets a block by its "height"
   */
  async getByHeight(e2) {
    const r2 = await this.api.get(`${Lr2.HEIGHT_ENDPOINT}${e2}`);
    if (r2.status === 200)
      return r2.data;
    throw r2.status === 404 ? new Ra.default(
      "BLOCK_NOT_FOUND"
      /* ArweaveErrorType.BLOCK_NOT_FOUND */
    ) : new Error(`Error while loading block data: ${r2}`);
  }
  /**
   * Gets current block data (ie. block with indep_hash = Network.getInfo().current)
   */
  async getCurrent() {
    const { current: e2 } = await this.network.getInfo();
    return await this.get(e2);
  }
};
pe(Lr, "HASH_ENDPOINT", "block/hash/"), pe(Lr, "HEIGHT_ENDPOINT", "block/height/");
var mo = Lr;
ws.default = mo;
var Ia;
function _s() {
  if (Ia)
    return jn;
  Ia = 1;
  var t2 = ge2 && ge2.__createBinding || (Object.create ? function(M3, S2, Y2, W2) {
    W2 === void 0 && (W2 = Y2);
    var Q3 = Object.getOwnPropertyDescriptor(S2, Y2);
    (!Q3 || ("get" in Q3 ? !S2.__esModule : Q3.writable || Q3.configurable)) && (Q3 = { enumerable: true, get: function() {
      return S2[Y2];
    } }), Object.defineProperty(M3, W2, Q3);
  } : function(M3, S2, Y2, W2) {
    W2 === void 0 && (W2 = Y2), M3[W2] = S2[Y2];
  }), e2 = ge2 && ge2.__setModuleDefault || (Object.create ? function(M3, S2) {
    Object.defineProperty(M3, "default", { enumerable: true, value: S2 });
  } : function(M3, S2) {
    M3.default = S2;
  }), r2 = ge2 && ge2.__importStar || function(M3) {
    if (M3 && M3.__esModule)
      return M3;
    var S2 = {};
    if (M3 != null)
      for (var Y2 in M3)
        Y2 !== "default" && Object.prototype.hasOwnProperty.call(M3, Y2) && t2(S2, M3, Y2);
    return e2(S2, M3), S2;
  }, n2 = ge2 && ge2.__importDefault || function(M3) {
    return M3 && M3.__esModule ? M3 : { default: M3 };
  };
  Object.defineProperty(jn, "__esModule", { value: true });
  const i2 = n2(Qo), o2 = n2(es), s2 = n2(ts), a2 = n2(ms), f2 = n2(fp()), p2 = n2(ys), d2 = n2(gs()), y2 = r2(lt), v3 = n2(On), w3 = n2(vs), I3 = n2(ws), k2 = class k3 {
    constructor(S2) {
      pe(this, "api");
      pe(this, "wallets");
      pe(this, "transactions");
      pe(this, "network");
      pe(this, "blocks");
      pe(this, "ar");
      pe(this, "silo");
      pe(this, "chunks");
      this.api = new o2.default(S2), this.wallets = new p2.default(this.api, k3.crypto), this.chunks = new w3.default(this.api), this.transactions = new f2.default(this.api, k3.crypto, this.chunks), this.silo = new v3.default(this.api, this.crypto, this.transactions), this.network = new a2.default(this.api), this.blocks = new I3.default(this.api, this.network), this.ar = new i2.default();
    }
    /** @deprecated */
    get crypto() {
      return k3.crypto;
    }
    /** @deprecated */
    get utils() {
      return k3.utils;
    }
    getConfig() {
      return {
        api: this.api.getConfig(),
        crypto: null
      };
    }
    async createTransaction(S2, Y2) {
      const W2 = {};
      if (Object.assign(W2, S2), !S2.data && !(S2.target && S2.quantity))
        throw new Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
      if (S2.owner == null && Y2 && Y2 !== "use_wallet" && (W2.owner = Y2.n), S2.last_tx == null && (W2.last_tx = await this.transactions.getTransactionAnchor()), typeof S2.data == "string" && (S2.data = y2.stringToBuffer(S2.data)), S2.data instanceof ArrayBuffer && (S2.data = new Uint8Array(S2.data)), S2.data && !(S2.data instanceof Uint8Array))
        throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
      if (S2.reward == null) {
        const X3 = S2.data ? S2.data.byteLength : 0;
        W2.reward = await this.transactions.getPrice(X3, W2.target);
      }
      W2.data_root = "", W2.data_size = S2.data ? S2.data.byteLength.toString() : "0", W2.data = S2.data || new Uint8Array(0);
      const Q3 = new d2.default(W2);
      return await Q3.getSignatureData(), Q3;
    }
    async createSiloTransaction(S2, Y2, W2) {
      const Q3 = {};
      if (Object.assign(Q3, S2), !S2.data)
        throw new Error("Silo transactions must have a 'data' value");
      if (!W2)
        throw new Error("No Silo URI specified.");
      if (S2.target || S2.quantity)
        throw new Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
      if (S2.owner == null) {
        if (!Y2 || !Y2.n)
          throw new Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
        Q3.owner = Y2.n;
      }
      S2.last_tx == null && (Q3.last_tx = await this.transactions.getTransactionAnchor());
      const X3 = await this.silo.parseUri(W2);
      if (typeof S2.data == "string") {
        const ue = await this.crypto.encrypt(y2.stringToBuffer(S2.data), X3.getEncryptionKey());
        Q3.reward = await this.transactions.getPrice(ue.byteLength), Q3.data = y2.bufferTob64Url(ue);
      }
      if (S2.data instanceof Uint8Array) {
        const ue = await this.crypto.encrypt(S2.data, X3.getEncryptionKey());
        Q3.reward = await this.transactions.getPrice(ue.byteLength), Q3.data = y2.bufferTob64Url(ue);
      }
      const ne = new d2.default(Q3);
      return ne.addTag("Silo-Name", X3.getAccessKey()), ne.addTag("Silo-Version", "0.1.0"), ne;
    }
    arql(S2) {
      return this.api.post("/arql", S2).then((Y2) => Y2.data || []);
    }
  };
  pe(k2, "init"), pe(k2, "crypto", new s2.default()), pe(k2, "utils", y2);
  let N11 = k2;
  return jn.default = N11, jn;
}
var Mp = _s();
var Sp = Pn(Mp);
function Qc() {
  const [t2, e2] = (0, import_react.useState)(0), { state: r2 } = xt2();
  return (0, import_react.useEffect)(() => {
    (async () => {
      var o2;
      if (!r2.activeAddress)
        return;
      const n2 = new Sp(
        ((o2 = r2 == null ? void 0 : r2.config) == null ? void 0 : o2.gatewayConfig) || {
          host: "arweave.net",
          port: 443,
          protocol: "https"
        }
      ), i2 = n2.ar.winstonToAr(
        await n2.wallets.getBalance(r2.activeAddress)
      );
      e2(Number(i2));
    })();
  }, [r2 == null ? void 0 : r2.activeAddress]), t2;
}
function Pp(t2) {
  var e2 = /* @__PURE__ */ Object.create(null);
  return function(r2) {
    return e2[r2] === void 0 && (e2[r2] = t2(r2)), e2[r2];
  };
}
var Cp = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var $i = Pp(
  function(t2) {
    return Cp.test(t2) || t2.charCodeAt(0) === 111 && t2.charCodeAt(1) === 110 && t2.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var Op = function() {
  const e2 = Array.prototype.slice.call(arguments).filter(Boolean), r2 = {}, n2 = [];
  e2.forEach((o2) => {
    (o2 ? o2.split(" ") : []).forEach((a2) => {
      if (a2.startsWith("atm_")) {
        const [, f2] = a2.split("_");
        r2[f2] = a2;
      } else
        n2.push(a2);
    });
  });
  const i2 = [];
  for (const o2 in r2)
    Object.prototype.hasOwnProperty.call(r2, o2) && i2.push(r2[o2]);
  return i2.push(...n2), i2.join(" ");
};
var Ba = Op;
var Rp = (t2) => t2.toUpperCase() === t2;
var Ip = (t2) => (e2) => t2.indexOf(e2) === -1;
var el = (t2, e2) => {
  const r2 = {};
  return Object.keys(t2).filter(Ip(e2)).forEach((n2) => {
    r2[n2] = t2[n2];
  }), r2;
};
function Bp(t2, e2, r2) {
  const n2 = el(e2, r2);
  if (!t2) {
    const i2 = typeof $i == "function" ? { default: $i } : $i;
    Object.keys(n2).forEach((o2) => {
      i2.default(o2) || delete n2[o2];
    });
  }
  return n2;
}
var kp = (t2, e2) => {
  if (true) {
    if (typeof t2 == "string" || typeof t2 == "number" && isFinite(t2))
      return;
    const r2 = typeof t2 == "object" ? JSON.stringify(t2) : String(t2);
    console.warn(
      `An interpolation evaluated to '${r2}' in the component '${e2}', which is probably a mistake. You should explicitly cast or transform the value to a string.`
    );
  }
};
function ka(t2) {
  var e2;
  let r2 = "";
  return false, (n2) => {
    if (Array.isArray(n2))
      throw new Error(
        'Using the "styled" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly. See https://github.com/callstack/linaria#setup'
      );
    const i2 = (s2, a2) => {
      const { as: f2 = t2, class: p2 = r2 } = s2, d2 = n2.propsAsIs === void 0 ? !(typeof f2 == "string" && f2.indexOf("-") === -1 && !Rp(f2[0])) : n2.propsAsIs, y2 = Bp(d2, s2, [
        "as",
        "class"
      ]);
      y2.ref = a2, y2.className = n2.atomic ? Ba(n2.class, y2.className || p2) : Ba(y2.className || p2, n2.class);
      const { vars: v3 } = n2;
      if (v3) {
        const w3 = {};
        for (const k2 in v3) {
          const M3 = v3[k2], S2 = M3[0], Y2 = M3[1] || "", W2 = typeof S2 == "function" ? S2(s2) : S2;
          kp(W2, n2.name), w3[`--${k2}`] = `${W2}${Y2}`;
        }
        const I3 = y2.style || {}, N11 = Object.keys(I3);
        N11.length > 0 && N11.forEach((k2) => {
          w3[k2] = I3[k2];
        }), y2.style = w3;
      }
      return t2.__linaria && t2 !== f2 ? (y2.as = f2, import_react.default.createElement(t2, y2)) : import_react.default.createElement(f2, y2);
    }, o2 = import_react.default.forwardRef ? import_react.default.forwardRef(i2) : (s2) => {
      const a2 = el(s2, ["innerRef"]);
      return i2(a2, s2.innerRef);
    };
    return o2.displayName = n2.name, o2.__linaria = {
      className: n2.class || r2,
      extends: t2
    }, o2;
  };
}
var Ce = true ? new Proxy(ka, {
  get(t2, e2) {
    return t2(e2);
  }
}) : ka;
function bs() {
  var r2;
  const { state: t2 } = xt2();
  return (0, import_react.useMemo)(() => {
    var i2;
    const n2 = (i2 = t2 == null ? void 0 : t2.config) == null ? void 0 : i2.gatewayConfig;
    return n2 ? `${n2.protocol}://${n2.host}:${n2.port}` : "https://arweave.net";
  }, [(r2 = t2 == null ? void 0 : t2.config) == null ? void 0 : r2.gatewayConfig]);
}
function tl() {
  const [t2, e2] = (0, import_react.useState)(), r2 = di(), n2 = bs();
  return (0, import_react.useEffect)(() => {
    (async () => {
      if (!r2)
        return e2(void 0);
      try {
        const o2 = await (await fetch(
          `https://ans-stats.decent.land/profile/${r2}`
        )).json();
        if (!(o2 != null && o2.currentLabel))
          return e2(void 0);
        e2({
          ...o2,
          currentLabel: o2.currentLabel + ".ar",
          avatar: o2.avatar ? `${n2}/${o2.avatar}` : void 0
        });
      } catch (i2) {
        console.error(
          `[Arweave Wallet Kit] Failed to fetch ans profile
${(i2 == null ? void 0 : i2.message) || i2}`
        );
      }
    })();
  }, [r2, n2]), t2;
}
var Lp = () => (t2) => t2.theme.themeConfig.font.fontFamily;
var Np = () => (t2) => t2.theme.theme;
var Up = () => (t2) => ({
  default: 30,
  minimal: 6,
  none: 0
})[t2.theme.themeConfig.radius] + "px";
var Fp = () => (t2) => t2.theme.displayTheme === "light" ? `0px 0px 2px rgba(${t2.theme.displayTheme === "light" ? "0, 0, 0" : "255, 255, 255"}, .15), 0px 4px 7px rgba(${t2.theme.displayTheme === "light" ? "0, 0, 0" : "255, 255, 255"}, .1)` : "none";
var ur = st(Ce("button")({
  name: "Button",
  class: "b1cb9caz",
  propsAsIs: false,
  vars: {
    "b1cb9caz-0": [Lp()],
    "b1cb9caz-1": [Np()],
    "b1cb9caz-2": [Up()],
    "b1cb9caz-3": [Fp()]
  }
}));
function j1({
  accent: t2,
  showBalance: e2 = true,
  showProfilePicture: r2 = true,
  onClick: n2,
  useAns: i2 = true,
  profileModal: o2 = true,
  ...s2
}) {
  const {
    connected: a2,
    connect: f2,
    disconnect: p2
  } = Jo(), d2 = di(), y2 = Qc(), v3 = tl(), w3 = td();
  return Me(qp, {
    accent: t2,
    onClick: async (I3) => {
      if (a2 ? o2 ? w3.setOpen(true) : await p2() : await f2(), n2)
        return n2(I3);
    },
    ...s2,
    children: a2 && Fe(_n, {
      children: [e2 && Me(Gp, {
        children: y2.toLocaleString(void 0, {
          maximumFractionDigits: 2
        }) + " AR"
      }), Fe(zp, {
        showBalance: e2,
        children: [r2 && Me(_n, {
          children: (v3 == null ? void 0 : v3.avatar) && i2 && Me(Jp, {
            src: v3 == null ? void 0 : v3.avatar,
            draggable: false
          }) || Me(r0, {
            children: Me(e0, {})
          })
        }), i2 && (v3 == null ? void 0 : v3.currentLabel) || ac(d2 || "", 5), Me(Xp, {})]
      })]
    }) || Me(Wp, {
      children: "Connect Wallet"
    })
  });
}
var jp = () => ur;
var $p = () => (t2) => ({
  default: 18,
  minimal: 10,
  none: 0
})[t2.theme.themeConfig.radius] + "px";
var Vp = () => (t2) => t2.accent || `rgb(${t2.theme.theme})`;
var qp = st(Ce(jp())({
  name: "Wrapper",
  class: "w14emrir",
  propsAsIs: true,
  vars: {
    "w14emrir-0": [$p()],
    "w14emrir-1": [Vp()]
  }
}));
var Wp = Ce("span")({
  name: "ConnectText",
  class: "czh4f0e",
  propsAsIs: false
});
var Hp = () => (t2) => t2.showBalance ? t2.theme.background : "transparent";
var Kp = () => (t2) => ({
  default: 18,
  minimal: 10,
  none: 0
})[t2.theme.themeConfig.radius] - 3 + "px";
var zp = st(Ce("div")({
  name: "ProfileSection",
  class: "pwkn5es",
  propsAsIs: false,
  vars: {
    "pwkn5es-0": [Hp()],
    "pwkn5es-1": [Kp()]
  }
}));
var Gp = Ce("span")({
  name: "Balance",
  class: "bdt02oh",
  propsAsIs: false
});
var Yp = () => dh;
var Xp = Ce(Yp())({
  name: "ExpandIcon",
  class: "e3hlv71",
  propsAsIs: true
});
var Zp = () => (t2) => ({
  default: "100%",
  minimal: "5px",
  none: "0px"
})[t2.theme.themeConfig.radius];
var Jp = st(Ce("img")({
  name: "Avatar",
  class: "a1jsmwxp",
  propsAsIs: false,
  vars: {
    "a1jsmwxp-0": [Zp()]
  }
}));
var Qp = () => lc;
var e0 = Ce(Qp())({
  name: "AvatarIcon",
  class: "as6ir6f",
  propsAsIs: true
});
var t0 = () => (t2) => ({
  default: "100%",
  minimal: "5px",
  none: "0px"
})[t2.theme.themeConfig.radius];
var r0 = st(Ce("span")({
  name: "AvatarPlaceholder",
  class: "av7js2i",
  propsAsIs: false,
  vars: {
    "av7js2i-0": [t0()]
  }
}));
var n0 = "1.0.8";
function i0(t2 = 720) {
  const [e2, r2] = (0, import_react.useState)(false), n2 = (0, import_react.useMemo)(() => typeof window > "u" ? null : window.matchMedia(`(max-width: ${t2}px)`), [t2]);
  return (0, import_react.useEffect)(() => {
    if (!n2)
      return;
    const i2 = (o2) => r2(o2.matches);
    return n2.addEventListener("change", i2), r2(n2.matches), () => n2.removeEventListener("change", i2);
  }, [n2]), e2;
}
var xs = (0, import_react.createContext)({
  transformPagePoint: (t2) => t2,
  isStatic: false,
  reducedMotion: "never"
});
var _i = (0, import_react.createContext)({});
function o0() {
  return (0, import_react.useContext)(_i).visualElement;
}
var Rn = (0, import_react.createContext)(null);
var bi = typeof document < "u";
var ei = bi ? import_react.useLayoutEffect : import_react.useEffect;
var rl = (0, import_react.createContext)({ strict: false });
function s0(t2, e2, r2, n2) {
  const i2 = o0(), o2 = (0, import_react.useContext)(rl), s2 = (0, import_react.useContext)(Rn), a2 = (0, import_react.useContext)(xs).reducedMotion, f2 = (0, import_react.useRef)();
  n2 = n2 || o2.renderer, !f2.current && n2 && (f2.current = n2(t2, {
    visualState: e2,
    parent: i2,
    props: r2,
    presenceId: s2 ? s2.id : void 0,
    blockInitialAnimation: s2 ? s2.initial === false : false,
    reducedMotionConfig: a2
  }));
  const p2 = f2.current;
  return ei(() => {
    p2 && p2.render();
  }), (window.HandoffAppearAnimations ? ei : import_react.useEffect)(() => {
    p2 && p2.animationState && p2.animationState.animateChanges();
  }), p2;
}
function Br2(t2) {
  return typeof t2 == "object" && Object.prototype.hasOwnProperty.call(t2, "current");
}
function a0(t2, e2, r2) {
  return (0, import_react.useCallback)(
    (n2) => {
      n2 && t2.mount && t2.mount(n2), e2 && (n2 ? e2.mount(n2) : e2.unmount()), r2 && (typeof r2 == "function" ? r2(n2) : Br2(r2) && (r2.current = n2));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [e2]
  );
}
function bn(t2) {
  return typeof t2 == "string" || Array.isArray(t2);
}
function xi(t2) {
  return typeof t2 == "object" && typeof t2.start == "function";
}
var u0 = [
  "initial",
  "animate",
  "exit",
  "whileHover",
  "whileDrag",
  "whileTap",
  "whileFocus",
  "whileInView"
];
function Ti(t2) {
  return xi(t2.animate) || u0.some((e2) => bn(t2[e2]));
}
function nl(t2) {
  return !!(Ti(t2) || t2.variants);
}
function c0(t2, e2) {
  if (Ti(t2)) {
    const { initial: r2, animate: n2 } = t2;
    return {
      initial: r2 === false || bn(r2) ? r2 : void 0,
      animate: bn(n2) ? n2 : void 0
    };
  }
  return t2.inherit !== false ? e2 : {};
}
function l0(t2) {
  const { initial: e2, animate: r2 } = c0(t2, (0, import_react.useContext)(_i));
  return (0, import_react.useMemo)(() => ({ initial: e2, animate: r2 }), [Da(e2), Da(r2)]);
}
function Da(t2) {
  return Array.isArray(t2) ? t2.join(" ") : t2;
}
var Xt = (t2) => ({
  isEnabled: (e2) => t2.some((r2) => !!e2[r2])
});
var xn = {
  measureLayout: Xt(["layout", "layoutId", "drag"]),
  animation: Xt([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag",
    "whileInView"
  ]),
  exit: Xt(["exit"]),
  drag: Xt(["drag", "dragControls"]),
  focus: Xt(["whileFocus"]),
  hover: Xt(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: Xt(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: Xt([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  inView: Xt([
    "whileInView",
    "onViewportEnter",
    "onViewportLeave"
  ])
};
function f0(t2) {
  for (const e2 in t2)
    e2 === "projectionNodeConstructor" ? xn.projectionNodeConstructor = t2[e2] : xn[e2].Component = t2[e2];
}
function Ei(t2) {
  const e2 = (0, import_react.useRef)(null);
  return e2.current === null && (e2.current = t2()), e2.current;
}
var pn = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
var h0 = 1;
function d0() {
  return Ei(() => {
    if (pn.hasEverUpdated)
      return h0++;
  });
}
var Ts = (0, import_react.createContext)({});
var p0 = class extends import_react.default.Component {
  /**
   * Update visual element props as soon as we know this update is going to be commited.
   */
  getSnapshotBeforeUpdate() {
    const { visualElement: e2, props: r2 } = this.props;
    return e2 && e2.setProps(r2), null;
  }
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
};
var il = (0, import_react.createContext)({});
var m0 = Symbol.for("motionComponentSymbol");
function g0({ preloadedFeatures: t2, createVisualElement: e2, projectionNodeConstructor: r2, useRender: n2, useVisualState: i2, Component: o2 }) {
  t2 && f0(t2);
  function s2(f2, p2) {
    const d2 = {
      ...(0, import_react.useContext)(xs),
      ...f2,
      layoutId: y0(f2)
    }, { isStatic: y2 } = d2;
    let v3 = null;
    const w3 = l0(f2), I3 = y2 ? void 0 : d0(), N11 = i2(f2, y2);
    if (!y2 && bi) {
      w3.visualElement = s0(o2, N11, d2, e2);
      const k2 = (0, import_react.useContext)(rl).strict, M3 = (0, import_react.useContext)(il);
      w3.visualElement && (v3 = w3.visualElement.loadFeatures(
        // Note: Pass the full new combined props to correctly re-render dynamic feature components.
        d2,
        k2,
        t2,
        I3,
        r2 || xn.projectionNodeConstructor,
        M3
      ));
    }
    return ke.createElement(
      p0,
      { visualElement: w3.visualElement, props: d2 },
      v3,
      ke.createElement(_i.Provider, { value: w3 }, n2(o2, f2, I3, a0(N11, w3.visualElement, p2), N11, y2, w3.visualElement))
    );
  }
  const a2 = (0, import_react.forwardRef)(s2);
  return a2[m0] = o2, a2;
}
function y0({ layoutId: t2 }) {
  const e2 = (0, import_react.useContext)(Ts).id;
  return e2 && t2 !== void 0 ? e2 + "-" + t2 : t2;
}
function v0(t2) {
  function e2(n2, i2 = {}) {
    return g0(t2(n2, i2));
  }
  if (typeof Proxy > "u")
    return e2;
  const r2 = /* @__PURE__ */ new Map();
  return new Proxy(e2, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (n2, i2) => (r2.has(i2) || r2.set(i2, e2(i2)), r2.get(i2))
  });
}
var w0 = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Es(t2) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof t2 != "string" || /**
    * If it contains a dash, the element is a custom HTML webcomponent.
    */
    t2.includes("-") ? false : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(w0.indexOf(t2) > -1 || /**
      * If it contains a capital letter, it's an SVG component
      */
      /[A-Z]/.test(t2))
    )
  );
}
var ti = {};
function _0(t2) {
  Object.assign(ti, t2);
}
var ri = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
var Yr = new Set(ri);
function ol(t2, { layout: e2, layoutId: r2 }) {
  return Yr.has(t2) || t2.startsWith("origin") || (e2 || r2 !== void 0) && (!!ti[t2] || t2 === "opacity");
}
var St = (t2) => !!(t2 != null && t2.getVelocity);
var b0 = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
var x0 = (t2, e2) => ri.indexOf(t2) - ri.indexOf(e2);
function T0({ transform: t2, transformKeys: e2 }, { enableHardwareAcceleration: r2 = true, allowTransformNone: n2 = true }, i2, o2) {
  let s2 = "";
  e2.sort(x0);
  for (const a2 of e2)
    s2 += `${b0[a2] || a2}(${t2[a2]}) `;
  return r2 && !t2.z && (s2 += "translateZ(0)"), s2 = s2.trim(), o2 ? s2 = o2(t2, i2 ? "" : s2) : n2 && i2 && (s2 = "none"), s2;
}
function sl(t2) {
  return t2.startsWith("--");
}
var E0 = (t2, e2) => e2 && typeof t2 == "number" ? e2.transform(t2) : t2;
var zr = (t2, e2, r2) => Math.min(Math.max(r2, t2), e2);
var Mr = {
  test: (t2) => typeof t2 == "number",
  parse: parseFloat,
  transform: (t2) => t2
};
var mn = {
  ...Mr,
  transform: (t2) => zr(0, 1, t2)
};
var qn = {
  ...Mr,
  default: 1
};
var gn = (t2) => Math.round(t2 * 1e5) / 1e5;
var Tn = /(-)?([\d]*\.?[\d])+/g;
var go = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
var A0 = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function In(t2) {
  return typeof t2 == "string";
}
var Bn = (t2) => ({
  test: (e2) => In(e2) && e2.endsWith(t2) && e2.split(" ").length === 1,
  parse: parseFloat,
  transform: (e2) => `${e2}${t2}`
});
var or2 = Bn("deg");
var zt2 = Bn("%");
var Se = Bn("px");
var M0 = Bn("vh");
var S0 = Bn("vw");
var La = {
  ...zt2,
  parse: (t2) => zt2.parse(t2) / 100,
  transform: (t2) => zt2.transform(t2 * 100)
};
var Na = {
  ...Mr,
  transform: Math.round
};
var al = {
  // Border props
  borderWidth: Se,
  borderTopWidth: Se,
  borderRightWidth: Se,
  borderBottomWidth: Se,
  borderLeftWidth: Se,
  borderRadius: Se,
  radius: Se,
  borderTopLeftRadius: Se,
  borderTopRightRadius: Se,
  borderBottomRightRadius: Se,
  borderBottomLeftRadius: Se,
  // Positioning props
  width: Se,
  maxWidth: Se,
  height: Se,
  maxHeight: Se,
  size: Se,
  top: Se,
  right: Se,
  bottom: Se,
  left: Se,
  // Spacing props
  padding: Se,
  paddingTop: Se,
  paddingRight: Se,
  paddingBottom: Se,
  paddingLeft: Se,
  margin: Se,
  marginTop: Se,
  marginRight: Se,
  marginBottom: Se,
  marginLeft: Se,
  // Transform props
  rotate: or2,
  rotateX: or2,
  rotateY: or2,
  rotateZ: or2,
  scale: qn,
  scaleX: qn,
  scaleY: qn,
  scaleZ: qn,
  skew: or2,
  skewX: or2,
  skewY: or2,
  distance: Se,
  translateX: Se,
  translateY: Se,
  translateZ: Se,
  x: Se,
  y: Se,
  z: Se,
  perspective: Se,
  transformPerspective: Se,
  opacity: mn,
  originX: La,
  originY: La,
  originZ: Se,
  // Misc
  zIndex: Na,
  // SVG
  fillOpacity: mn,
  strokeOpacity: mn,
  numOctaves: Na
};
function As(t2, e2, r2, n2) {
  const { style: i2, vars: o2, transform: s2, transformKeys: a2, transformOrigin: f2 } = t2;
  a2.length = 0;
  let p2 = false, d2 = false, y2 = true;
  for (const v3 in e2) {
    const w3 = e2[v3];
    if (sl(v3)) {
      o2[v3] = w3;
      continue;
    }
    const I3 = al[v3], N11 = E0(w3, I3);
    if (Yr.has(v3)) {
      if (p2 = true, s2[v3] = N11, a2.push(v3), !y2)
        continue;
      w3 !== (I3.default || 0) && (y2 = false);
    } else
      v3.startsWith("origin") ? (d2 = true, f2[v3] = N11) : i2[v3] = N11;
  }
  if (e2.transform || (p2 || n2 ? i2.transform = T0(t2, r2, y2, n2) : i2.transform && (i2.transform = "none")), d2) {
    const { originX: v3 = "50%", originY: w3 = "50%", originZ: I3 = 0 } = f2;
    i2.transformOrigin = `${v3} ${w3} ${I3}`;
  }
}
var Ms = () => ({
  style: {},
  transform: {},
  transformKeys: [],
  transformOrigin: {},
  vars: {}
});
function ul(t2, e2, r2) {
  for (const n2 in e2)
    !St(e2[n2]) && !ol(n2, r2) && (t2[n2] = e2[n2]);
}
function P0({ transformTemplate: t2 }, e2, r2) {
  return (0, import_react.useMemo)(() => {
    const n2 = Ms();
    return As(n2, e2, { enableHardwareAcceleration: !r2 }, t2), Object.assign({}, n2.vars, n2.style);
  }, [e2]);
}
function C0(t2, e2, r2) {
  const n2 = t2.style || {}, i2 = {};
  return ul(i2, n2, t2), Object.assign(i2, P0(t2, e2, r2)), t2.transformValues ? t2.transformValues(i2) : i2;
}
function O0(t2, e2, r2) {
  const n2 = {}, i2 = C0(t2, e2, r2);
  return t2.drag && t2.dragListener !== false && (n2.draggable = false, i2.userSelect = i2.WebkitUserSelect = i2.WebkitTouchCallout = "none", i2.touchAction = t2.drag === true ? "none" : `pan-${t2.drag === "x" ? "y" : "x"}`), n2.style = i2, n2;
}
var R0 = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "viewport"
]);
function ni(t2) {
  return t2.startsWith("while") || t2.startsWith("drag") && t2 !== "draggable" || t2.startsWith("layout") || t2.startsWith("onTap") || t2.startsWith("onPan") || R0.has(t2);
}
var cl = (t2) => !ni(t2);
function I0(t2) {
  t2 && (cl = (e2) => e2.startsWith("on") ? !ni(e2) : t2(e2));
}
try {
  I0((init_emotion_is_prop_valid_esm(), __toCommonJS(emotion_is_prop_valid_esm_exports)).default);
} catch {
}
function B0(t2, e2, r2) {
  const n2 = {};
  for (const i2 in t2)
    i2 === "values" && typeof t2.values == "object" || (cl(i2) || r2 === true && ni(i2) || !e2 && !ni(i2) || // If trying to use native HTML drag events, forward drag listeners
    t2.draggable && i2.startsWith("onDrag")) && (n2[i2] = t2[i2]);
  return n2;
}
function Ua(t2, e2, r2) {
  return typeof t2 == "string" ? t2 : Se.transform(e2 + r2 * t2);
}
function k0(t2, e2, r2) {
  const n2 = Ua(e2, t2.x, t2.width), i2 = Ua(r2, t2.y, t2.height);
  return `${n2} ${i2}`;
}
var D0 = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var L0 = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function N0(t2, e2, r2 = 1, n2 = 0, i2 = true) {
  t2.pathLength = 1;
  const o2 = i2 ? D0 : L0;
  t2[o2.offset] = Se.transform(-n2);
  const s2 = Se.transform(e2), a2 = Se.transform(r2);
  t2[o2.array] = `${s2} ${a2}`;
}
function Ss(t2, {
  attrX: e2,
  attrY: r2,
  originX: n2,
  originY: i2,
  pathLength: o2,
  pathSpacing: s2 = 1,
  pathOffset: a2 = 0,
  // This is object creation, which we try to avoid per-frame.
  ...f2
}, p2, d2, y2) {
  if (As(t2, f2, p2, y2), d2) {
    t2.style.viewBox && (t2.attrs.viewBox = t2.style.viewBox);
    return;
  }
  t2.attrs = t2.style, t2.style = {};
  const { attrs: v3, style: w3, dimensions: I3 } = t2;
  v3.transform && (I3 && (w3.transform = v3.transform), delete v3.transform), I3 && (n2 !== void 0 || i2 !== void 0 || w3.transform) && (w3.transformOrigin = k0(I3, n2 !== void 0 ? n2 : 0.5, i2 !== void 0 ? i2 : 0.5)), e2 !== void 0 && (v3.x = e2), r2 !== void 0 && (v3.y = r2), o2 !== void 0 && N0(v3, o2, s2, a2, false);
}
var ll = () => ({
  ...Ms(),
  attrs: {}
});
var Ps = (t2) => typeof t2 == "string" && t2.toLowerCase() === "svg";
function U0(t2, e2, r2, n2) {
  const i2 = (0, import_react.useMemo)(() => {
    const o2 = ll();
    return Ss(o2, e2, { enableHardwareAcceleration: false }, Ps(n2), t2.transformTemplate), {
      ...o2.attrs,
      style: { ...o2.style }
    };
  }, [e2]);
  if (t2.style) {
    const o2 = {};
    ul(o2, t2.style, t2), i2.style = { ...o2, ...i2.style };
  }
  return i2;
}
function F0(t2 = false) {
  return (r2, n2, i2, o2, { latestValues: s2 }, a2) => {
    const p2 = (Es(r2) ? U0 : O0)(n2, s2, a2, r2), y2 = {
      ...B0(n2, typeof r2 == "string", t2),
      ...p2,
      ref: o2
    }, { children: v3 } = n2, w3 = (0, import_react.useMemo)(() => St(v3) ? v3.get() : v3, [v3]);
    return i2 && (y2["data-projection-id"] = i2), (0, import_react.createElement)(r2, {
      ...y2,
      children: w3
    });
  };
}
var Cs = (t2) => t2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function fl(t2, { style: e2, vars: r2 }, n2, i2) {
  Object.assign(t2.style, e2, i2 && i2.getProjectionStyles(n2));
  for (const o2 in r2)
    t2.style.setProperty(o2, r2[o2]);
}
var hl = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function dl(t2, e2, r2, n2) {
  fl(t2, e2, void 0, n2);
  for (const i2 in e2.attrs)
    t2.setAttribute(hl.has(i2) ? i2 : Cs(i2), e2.attrs[i2]);
}
function Os(t2, e2) {
  const { style: r2 } = t2, n2 = {};
  for (const i2 in r2)
    (St(r2[i2]) || e2.style && St(e2.style[i2]) || ol(i2, t2)) && (n2[i2] = r2[i2]);
  return n2;
}
function pl(t2, e2) {
  const r2 = Os(t2, e2);
  for (const n2 in t2)
    if (St(t2[n2]) || St(e2[n2])) {
      const i2 = n2 === "x" || n2 === "y" ? "attr" + n2.toUpperCase() : n2;
      r2[i2] = t2[n2];
    }
  return r2;
}
function Rs(t2, e2, r2, n2 = {}, i2 = {}) {
  return typeof e2 == "function" && (e2 = e2(r2 !== void 0 ? r2 : t2.custom, n2, i2)), typeof e2 == "string" && (e2 = t2.variants && t2.variants[e2]), typeof e2 == "function" && (e2 = e2(r2 !== void 0 ? r2 : t2.custom, n2, i2)), e2;
}
var ii = (t2) => Array.isArray(t2);
var j0 = (t2) => !!(t2 && typeof t2 == "object" && t2.mix && t2.toValue);
var $0 = (t2) => ii(t2) ? t2[t2.length - 1] || 0 : t2;
function Yn(t2) {
  const e2 = St(t2) ? t2.get() : t2;
  return j0(e2) ? e2.toValue() : e2;
}
function V0({ scrapeMotionValuesFromProps: t2, createRenderState: e2, onMount: r2 }, n2, i2, o2) {
  const s2 = {
    latestValues: q0(n2, i2, o2, t2),
    renderState: e2()
  };
  return r2 && (s2.mount = (a2) => r2(n2, a2, s2)), s2;
}
var ml = (t2) => (e2, r2) => {
  const n2 = (0, import_react.useContext)(_i), i2 = (0, import_react.useContext)(Rn), o2 = () => V0(t2, e2, n2, i2);
  return r2 ? o2() : Ei(o2);
};
function q0(t2, e2, r2, n2) {
  const i2 = {}, o2 = n2(t2, {});
  for (const v3 in o2)
    i2[v3] = Yn(o2[v3]);
  let { initial: s2, animate: a2 } = t2;
  const f2 = Ti(t2), p2 = nl(t2);
  e2 && p2 && !f2 && t2.inherit !== false && (s2 === void 0 && (s2 = e2.initial), a2 === void 0 && (a2 = e2.animate));
  let d2 = r2 ? r2.initial === false : false;
  d2 = d2 || s2 === false;
  const y2 = d2 ? a2 : s2;
  return y2 && typeof y2 != "boolean" && !xi(y2) && (Array.isArray(y2) ? y2 : [y2]).forEach((w3) => {
    const I3 = Rs(t2, w3);
    if (!I3)
      return;
    const { transitionEnd: N11, transition: k2, ...M3 } = I3;
    for (const S2 in M3) {
      let Y2 = M3[S2];
      if (Array.isArray(Y2)) {
        const W2 = d2 ? Y2.length - 1 : 0;
        Y2 = Y2[W2];
      }
      Y2 !== null && (i2[S2] = Y2);
    }
    for (const S2 in N11)
      i2[S2] = N11[S2];
  }), i2;
}
var W0 = {
  useVisualState: ml({
    scrapeMotionValuesFromProps: pl,
    createRenderState: ll,
    onMount: (t2, e2, { renderState: r2, latestValues: n2 }) => {
      try {
        r2.dimensions = typeof e2.getBBox == "function" ? e2.getBBox() : e2.getBoundingClientRect();
      } catch {
        r2.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      Ss(r2, n2, { enableHardwareAcceleration: false }, Ps(e2.tagName), t2.transformTemplate), dl(e2, r2);
    }
  })
};
var H0 = {
  useVisualState: ml({
    scrapeMotionValuesFromProps: Os,
    createRenderState: Ms
  })
};
function K0(t2, { forwardMotionProps: e2 = false }, r2, n2, i2) {
  return {
    ...Es(t2) ? W0 : H0,
    preloadedFeatures: r2,
    useRender: F0(e2),
    createVisualElement: n2,
    projectionNodeConstructor: i2,
    Component: t2
  };
}
var $e;
(function(t2) {
  t2.Animate = "animate", t2.Hover = "whileHover", t2.Tap = "whileTap", t2.Drag = "whileDrag", t2.Focus = "whileFocus", t2.InView = "whileInView", t2.Exit = "exit";
})($e || ($e = {}));
function Ai(t2, e2, r2, n2 = { passive: true }) {
  return t2.addEventListener(e2, r2, n2), () => t2.removeEventListener(e2, r2);
}
function yo(t2, e2, r2, n2) {
  (0, import_react.useEffect)(() => {
    const i2 = t2.current;
    if (r2 && i2)
      return Ai(i2, e2, r2, n2);
  }, [t2, e2, r2, n2]);
}
function z0({ whileFocus: t2, visualElement: e2 }) {
  const { animationState: r2 } = e2, n2 = (0, import_react.useCallback)(() => {
    r2 && r2.setActive($e.Focus, true);
  }, [r2]), i2 = (0, import_react.useCallback)(() => {
    r2 && r2.setActive($e.Focus, false);
  }, [r2]);
  yo(e2, "focus", t2 ? n2 : void 0), yo(e2, "blur", t2 ? i2 : void 0);
}
var gl = (t2) => t2.pointerType === "mouse" ? typeof t2.button != "number" || t2.button <= 0 : t2.isPrimary !== false;
function Is(t2, e2 = "page") {
  return {
    point: {
      x: t2[e2 + "X"],
      y: t2[e2 + "Y"]
    }
  };
}
var yl = (t2) => (e2) => gl(e2) && t2(e2, Is(e2));
function Fr(t2, e2, r2, n2) {
  return Ai(t2, e2, yl(r2), n2);
}
function oi(t2, e2, r2, n2) {
  return yo(t2, e2, r2 && yl(r2), n2);
}
function vl(t2) {
  let e2 = null;
  return () => {
    const r2 = () => {
      e2 = null;
    };
    return e2 === null ? (e2 = t2, r2) : false;
  };
}
var Fa = vl("dragHorizontal");
var ja = vl("dragVertical");
function wl(t2) {
  let e2 = false;
  if (t2 === "y")
    e2 = ja();
  else if (t2 === "x")
    e2 = Fa();
  else {
    const r2 = Fa(), n2 = ja();
    r2 && n2 ? e2 = () => {
      r2(), n2();
    } : (r2 && r2(), n2 && n2());
  }
  return e2;
}
function _l() {
  const t2 = wl(true);
  return t2 ? (t2(), false) : true;
}
function $a(t2, e2, r2, n2) {
  return (i2, o2) => {
    i2.type === "touch" || _l() || (r2 && t2.animationState && t2.animationState.setActive($e.Hover, e2), n2 && n2(i2, o2));
  };
}
function G0({ onHoverStart: t2, onHoverEnd: e2, whileHover: r2, visualElement: n2 }) {
  oi(n2, "pointerenter", (0, import_react.useMemo)(() => t2 || r2 ? $a(n2, true, !!r2, t2) : void 0, [t2, !!r2, n2]), { passive: !t2 }), oi(n2, "pointerleave", (0, import_react.useMemo)(() => e2 || r2 ? $a(n2, false, !!r2, e2) : void 0, [t2, !!r2, n2]), { passive: !e2 });
}
var bl = (t2, e2) => e2 ? t2 === e2 ? true : bl(t2, e2.parentElement) : false;
function Bs(t2) {
  return (0, import_react.useEffect)(() => () => t2(), []);
}
var Y0 = (t2, e2) => (r2) => e2(t2(r2));
var Mi = (...t2) => t2.reduce(Y0);
function X0({ onTap: t2, onTapStart: e2, onTapCancel: r2, whileTap: n2, visualElement: i2, ...o2 }) {
  const s2 = t2 || e2 || r2 || n2, a2 = (0, import_react.useRef)(false), f2 = (0, import_react.useRef)(null), p2 = {
    passive: !(e2 || t2 || r2 || o2.onPointerDown)
  };
  function d2() {
    f2.current && f2.current(), f2.current = null;
  }
  function y2() {
    return d2(), a2.current = false, i2.getProps().whileTap && i2.animationState && i2.animationState.setActive($e.Tap, false), !_l();
  }
  function v3(N11, k2) {
    var M3, S2, Y2, W2;
    y2() && (bl(i2.current, N11.target) ? (W2 = (Y2 = i2.getProps()).onTap) === null || W2 === void 0 || W2.call(Y2, N11, k2) : (S2 = (M3 = i2.getProps()).onTapCancel) === null || S2 === void 0 || S2.call(M3, N11, k2));
  }
  function w3(N11, k2) {
    var M3, S2;
    y2() && ((S2 = (M3 = i2.getProps()).onTapCancel) === null || S2 === void 0 || S2.call(M3, N11, k2));
  }
  const I3 = (0, import_react.useCallback)((N11, k2) => {
    var M3;
    if (d2(), a2.current)
      return;
    a2.current = true, f2.current = Mi(Fr(window, "pointerup", v3, p2), Fr(window, "pointercancel", w3, p2));
    const S2 = i2.getProps();
    S2.whileTap && i2.animationState && i2.animationState.setActive($e.Tap, true), (M3 = S2.onTapStart) === null || M3 === void 0 || M3.call(S2, N11, k2);
  }, [!!e2, i2]);
  oi(i2, "pointerdown", s2 ? I3 : void 0, p2), Bs(d2);
}
var Va = /* @__PURE__ */ new Set();
function Si(t2, e2, r2) {
  t2 || Va.has(e2) || (console.warn(e2), r2 && console.warn(r2), Va.add(e2));
}
var vo = /* @__PURE__ */ new WeakMap();
var Vi = /* @__PURE__ */ new WeakMap();
var Z0 = (t2) => {
  const e2 = vo.get(t2.target);
  e2 && e2(t2);
};
var J0 = (t2) => {
  t2.forEach(Z0);
};
function Q0({ root: t2, ...e2 }) {
  const r2 = t2 || document;
  Vi.has(r2) || Vi.set(r2, {});
  const n2 = Vi.get(r2), i2 = JSON.stringify(e2);
  return n2[i2] || (n2[i2] = new IntersectionObserver(J0, { root: t2, ...e2 })), n2[i2];
}
function em(t2, e2, r2) {
  const n2 = Q0(e2);
  return vo.set(t2, r2), n2.observe(t2), () => {
    vo.delete(t2), n2.unobserve(t2);
  };
}
function tm({ visualElement: t2, whileInView: e2, onViewportEnter: r2, onViewportLeave: n2, viewport: i2 = {} }) {
  const o2 = (0, import_react.useRef)({
    hasEnteredView: false,
    isInView: false
  });
  let s2 = !!(e2 || r2 || n2);
  i2.once && o2.current.hasEnteredView && (s2 = false), (typeof IntersectionObserver > "u" ? im : nm)(s2, o2.current, t2, i2);
}
var rm = {
  some: 0,
  all: 1
};
function nm(t2, e2, r2, { root: n2, margin: i2, amount: o2 = "some", once: s2 }) {
  (0, import_react.useEffect)(() => {
    if (!t2 || !r2.current)
      return;
    const a2 = {
      root: n2 == null ? void 0 : n2.current,
      rootMargin: i2,
      threshold: typeof o2 == "number" ? o2 : rm[o2]
    }, f2 = (p2) => {
      const { isIntersecting: d2 } = p2;
      if (e2.isInView === d2 || (e2.isInView = d2, s2 && !d2 && e2.hasEnteredView))
        return;
      d2 && (e2.hasEnteredView = true), r2.animationState && r2.animationState.setActive($e.InView, d2);
      const y2 = r2.getProps(), v3 = d2 ? y2.onViewportEnter : y2.onViewportLeave;
      v3 && v3(p2);
    };
    return em(r2.current, a2, f2);
  }, [t2, n2, i2, o2]);
}
function im(t2, e2, r2, { fallback: n2 = true }) {
  (0, import_react.useEffect)(() => {
    !t2 || !n2 || (Si(false, "IntersectionObserver not available on this device. whileInView animations will trigger on mount."), requestAnimationFrame(() => {
      e2.hasEnteredView = true;
      const { onViewportEnter: i2 } = r2.getProps();
      i2 && i2(null), r2.animationState && r2.animationState.setActive($e.InView, true);
    }));
  }, [t2]);
}
var ar = (t2) => (e2) => (t2(e2), null);
var om = {
  inView: ar(tm),
  tap: ar(X0),
  focus: ar(z0),
  hover: ar(G0)
};
function xl() {
  const t2 = (0, import_react.useContext)(Rn);
  if (t2 === null)
    return [true, null];
  const { isPresent: e2, onExitComplete: r2, register: n2 } = t2, i2 = (0, import_react.useId)();
  return (0, import_react.useEffect)(() => n2(i2), []), !e2 && r2 ? [false, () => r2 && r2(i2)] : [true];
}
function Tl(t2, e2) {
  if (!Array.isArray(e2))
    return false;
  const r2 = e2.length;
  if (r2 !== t2.length)
    return false;
  for (let n2 = 0; n2 < r2; n2++)
    if (e2[n2] !== t2[n2])
      return false;
  return true;
}
var sm = (t2) => /^\-?\d*\.?\d+$/.test(t2);
var am = (t2) => /^0[^.\s]+$/.test(t2);
var tr = {
  delta: 0,
  timestamp: 0
};
var El = 1 / 60 * 1e3;
var um = typeof performance < "u" ? () => performance.now() : () => Date.now();
var Al = typeof window < "u" ? (t2) => window.requestAnimationFrame(t2) : (t2) => setTimeout(() => t2(um()), El);
function cm(t2) {
  let e2 = [], r2 = [], n2 = 0, i2 = false, o2 = false;
  const s2 = /* @__PURE__ */ new WeakSet(), a2 = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (f2, p2 = false, d2 = false) => {
      const y2 = d2 && i2, v3 = y2 ? e2 : r2;
      return p2 && s2.add(f2), v3.indexOf(f2) === -1 && (v3.push(f2), y2 && i2 && (n2 = e2.length)), f2;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (f2) => {
      const p2 = r2.indexOf(f2);
      p2 !== -1 && r2.splice(p2, 1), s2.delete(f2);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (f2) => {
      if (i2) {
        o2 = true;
        return;
      }
      if (i2 = true, [e2, r2] = [r2, e2], r2.length = 0, n2 = e2.length, n2)
        for (let p2 = 0; p2 < n2; p2++) {
          const d2 = e2[p2];
          d2(f2), s2.has(d2) && (a2.schedule(d2), t2());
        }
      i2 = false, o2 && (o2 = false, a2.process(f2));
    }
  };
  return a2;
}
var lm = 40;
var wo = true;
var En = false;
var _o = false;
var kn = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
var Pi = kn.reduce((t2, e2) => (t2[e2] = cm(() => En = true), t2), {});
var _t2 = kn.reduce((t2, e2) => {
  const r2 = Pi[e2];
  return t2[e2] = (n2, i2 = false, o2 = false) => (En || hm(), r2.schedule(n2, i2, o2)), t2;
}, {});
var cr = kn.reduce((t2, e2) => (t2[e2] = Pi[e2].cancel, t2), {});
var qi = kn.reduce((t2, e2) => (t2[e2] = () => Pi[e2].process(tr), t2), {});
var fm = (t2) => Pi[t2].process(tr);
var Ml = (t2) => {
  En = false, tr.delta = wo ? El : Math.max(Math.min(t2 - tr.timestamp, lm), 1), tr.timestamp = t2, _o = true, kn.forEach(fm), _o = false, En && (wo = false, Al(Ml));
};
var hm = () => {
  En = true, wo = true, _o || Al(Ml);
};
function ks(t2, e2) {
  t2.indexOf(e2) === -1 && t2.push(e2);
}
function Ds(t2, e2) {
  const r2 = t2.indexOf(e2);
  r2 > -1 && t2.splice(r2, 1);
}
var Ls = class {
  constructor() {
    this.subscriptions = [];
  }
  add(e2) {
    return ks(this.subscriptions, e2), () => Ds(this.subscriptions, e2);
  }
  notify(e2, r2, n2) {
    const i2 = this.subscriptions.length;
    if (i2)
      if (i2 === 1)
        this.subscriptions[0](e2, r2, n2);
      else
        for (let o2 = 0; o2 < i2; o2++) {
          const s2 = this.subscriptions[o2];
          s2 && s2(e2, r2, n2);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
};
function Ns(t2, e2) {
  return e2 ? t2 * (1e3 / e2) : 0;
}
var dm = (t2) => !isNaN(parseFloat(t2));
var pm = class {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(e2, r2 = {}) {
    this.version = "8.5.5", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = false, this.events = {}, this.updateAndNotify = (n2, i2 = true) => {
      this.prev = this.current, this.current = n2;
      const { delta: o2, timestamp: s2 } = tr;
      this.lastUpdated !== s2 && (this.timeDelta = o2, this.lastUpdated = s2, _t2.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), i2 && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.scheduleVelocityCheck = () => _t2.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: n2 }) => {
      n2 !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()));
    }, this.hasAnimated = false, this.prev = this.current = e2, this.canTrackVelocity = dm(this.current), this.owner = r2.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e2) {
    return this.on("change", e2);
  }
  on(e2, r2) {
    this.events[e2] || (this.events[e2] = new Ls());
    const n2 = this.events[e2].add(r2);
    return e2 === "change" ? () => {
      n2(), _t2.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : n2;
  }
  clearListeners() {
    for (const e2 in this.events)
      this.events[e2].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(e2, r2) {
    this.passiveEffect = e2, this.stopPassiveEffect = r2;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e2, r2 = true) {
    !r2 || !this.passiveEffect ? this.updateAndNotify(e2, r2) : this.passiveEffect(e2, this.updateAndNotify);
  }
  setWithVelocity(e2, r2, n2) {
    this.set(r2), this.prev = e2, this.timeDelta = n2;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e2) {
    this.updateAndNotify(e2), this.prev = e2, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      Ns(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(e2) {
    return this.stop(), new Promise((r2) => {
      this.hasAnimated = true, this.animation = e2(r2) || null, this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    this.animation = null;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
};
function Gr(t2, e2) {
  return new pm(t2, e2);
}
var Us = (t2, e2) => (r2) => !!(In(r2) && A0.test(r2) && r2.startsWith(t2) || e2 && Object.prototype.hasOwnProperty.call(r2, e2));
var Sl = (t2, e2, r2) => (n2) => {
  if (!In(n2))
    return n2;
  const [i2, o2, s2, a2] = n2.match(Tn);
  return {
    [t2]: parseFloat(i2),
    [e2]: parseFloat(o2),
    [r2]: parseFloat(s2),
    alpha: a2 !== void 0 ? parseFloat(a2) : 1
  };
};
var mm = (t2) => zr(0, 255, t2);
var Wi = {
  ...Mr,
  transform: (t2) => Math.round(mm(t2))
};
var yr2 = {
  test: Us("rgb", "red"),
  parse: Sl("red", "green", "blue"),
  transform: ({ red: t2, green: e2, blue: r2, alpha: n2 = 1 }) => "rgba(" + Wi.transform(t2) + ", " + Wi.transform(e2) + ", " + Wi.transform(r2) + ", " + gn(mn.transform(n2)) + ")"
};
function gm(t2) {
  let e2 = "", r2 = "", n2 = "", i2 = "";
  return t2.length > 5 ? (e2 = t2.substring(1, 3), r2 = t2.substring(3, 5), n2 = t2.substring(5, 7), i2 = t2.substring(7, 9)) : (e2 = t2.substring(1, 2), r2 = t2.substring(2, 3), n2 = t2.substring(3, 4), i2 = t2.substring(4, 5), e2 += e2, r2 += r2, n2 += n2, i2 += i2), {
    red: parseInt(e2, 16),
    green: parseInt(r2, 16),
    blue: parseInt(n2, 16),
    alpha: i2 ? parseInt(i2, 16) / 255 : 1
  };
}
var bo = {
  test: Us("#"),
  parse: gm,
  transform: yr2.transform
};
var kr = {
  test: Us("hsl", "hue"),
  parse: Sl("hue", "saturation", "lightness"),
  transform: ({ hue: t2, saturation: e2, lightness: r2, alpha: n2 = 1 }) => "hsla(" + Math.round(t2) + ", " + zt2.transform(gn(e2)) + ", " + zt2.transform(gn(r2)) + ", " + gn(mn.transform(n2)) + ")"
};
var Tt = {
  test: (t2) => yr2.test(t2) || bo.test(t2) || kr.test(t2),
  parse: (t2) => yr2.test(t2) ? yr2.parse(t2) : kr.test(t2) ? kr.parse(t2) : bo.parse(t2),
  transform: (t2) => In(t2) ? t2 : t2.hasOwnProperty("red") ? yr2.transform(t2) : kr.transform(t2)
};
var Pl = "${c}";
var Cl = "${n}";
function ym(t2) {
  var e2, r2;
  return isNaN(t2) && In(t2) && (((e2 = t2.match(Tn)) === null || e2 === void 0 ? void 0 : e2.length) || 0) + (((r2 = t2.match(go)) === null || r2 === void 0 ? void 0 : r2.length) || 0) > 0;
}
function si(t2) {
  typeof t2 == "number" && (t2 = `${t2}`);
  const e2 = [];
  let r2 = 0, n2 = 0;
  const i2 = t2.match(go);
  i2 && (r2 = i2.length, t2 = t2.replace(go, Pl), e2.push(...i2.map(Tt.parse)));
  const o2 = t2.match(Tn);
  return o2 && (n2 = o2.length, t2 = t2.replace(Tn, Cl), e2.push(...o2.map(Mr.parse))), { values: e2, numColors: r2, numNumbers: n2, tokenised: t2 };
}
function Ol(t2) {
  return si(t2).values;
}
function Rl(t2) {
  const { values: e2, numColors: r2, tokenised: n2 } = si(t2), i2 = e2.length;
  return (o2) => {
    let s2 = n2;
    for (let a2 = 0; a2 < i2; a2++)
      s2 = s2.replace(a2 < r2 ? Pl : Cl, a2 < r2 ? Tt.transform(o2[a2]) : gn(o2[a2]));
    return s2;
  };
}
var vm = (t2) => typeof t2 == "number" ? 0 : t2;
function wm(t2) {
  const e2 = Ol(t2);
  return Rl(t2)(e2.map(vm));
}
var lr2 = { test: ym, parse: Ol, createTransformer: Rl, getAnimatableNone: wm };
var _m = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function bm(t2) {
  const [e2, r2] = t2.slice(0, -1).split("(");
  if (e2 === "drop-shadow")
    return t2;
  const [n2] = r2.match(Tn) || [];
  if (!n2)
    return t2;
  const i2 = r2.replace(n2, "");
  let o2 = _m.has(e2) ? 1 : 0;
  return n2 !== r2 && (o2 *= 100), e2 + "(" + o2 + i2 + ")";
}
var xm = /([a-z-]*)\(.*?\)/g;
var xo = {
  ...lr2,
  getAnimatableNone: (t2) => {
    const e2 = t2.match(xm);
    return e2 ? e2.map(bm).join(" ") : t2;
  }
};
var Tm = {
  ...al,
  // Color props
  color: Tt,
  backgroundColor: Tt,
  outlineColor: Tt,
  fill: Tt,
  stroke: Tt,
  // Border props
  borderColor: Tt,
  borderTopColor: Tt,
  borderRightColor: Tt,
  borderBottomColor: Tt,
  borderLeftColor: Tt,
  filter: xo,
  WebkitFilter: xo
};
var Fs = (t2) => Tm[t2];
function js(t2, e2) {
  var r2;
  let n2 = Fs(t2);
  return n2 !== xo && (n2 = lr2), (r2 = n2.getAnimatableNone) === null || r2 === void 0 ? void 0 : r2.call(n2, e2);
}
var Il = (t2) => (e2) => e2.test(t2);
var Em = {
  test: (t2) => t2 === "auto",
  parse: (t2) => t2
};
var Bl = [Mr, Se, zt2, or2, S0, M0, Em];
var sn = (t2) => Bl.find(Il(t2));
var Am = [...Bl, Tt, lr2];
var Mm = (t2) => Am.find(Il(t2));
function Sm(t2) {
  const e2 = {};
  return t2.values.forEach((r2, n2) => e2[n2] = r2.get()), e2;
}
function Pm(t2) {
  const e2 = {};
  return t2.values.forEach((r2, n2) => e2[n2] = r2.getVelocity()), e2;
}
function Ci(t2, e2, r2) {
  const n2 = t2.getProps();
  return Rs(n2, e2, r2 !== void 0 ? r2 : n2.custom, Sm(t2), Pm(t2));
}
function Cm(t2, e2, r2) {
  t2.hasValue(e2) ? t2.getValue(e2).set(r2) : t2.addValue(e2, Gr(r2));
}
function Om(t2, e2) {
  const r2 = Ci(t2, e2);
  let { transitionEnd: n2 = {}, transition: i2 = {}, ...o2 } = r2 ? t2.makeTargetAnimatable(r2, false) : {};
  o2 = { ...o2, ...n2 };
  for (const s2 in o2) {
    const a2 = $0(o2[s2]);
    Cm(t2, s2, a2);
  }
}
function Rm(t2, e2, r2) {
  var n2, i2;
  const o2 = Object.keys(e2).filter((a2) => !t2.hasValue(a2)), s2 = o2.length;
  if (s2)
    for (let a2 = 0; a2 < s2; a2++) {
      const f2 = o2[a2], p2 = e2[f2];
      let d2 = null;
      Array.isArray(p2) && (d2 = p2[0]), d2 === null && (d2 = (i2 = (n2 = r2[f2]) !== null && n2 !== void 0 ? n2 : t2.readValue(f2)) !== null && i2 !== void 0 ? i2 : e2[f2]), d2 != null && (typeof d2 == "string" && (sm(d2) || am(d2)) ? d2 = parseFloat(d2) : !Mm(d2) && lr2.test(p2) && (d2 = js(f2, p2)), t2.addValue(f2, Gr(d2, { owner: t2 })), r2[f2] === void 0 && (r2[f2] = d2), d2 !== null && t2.setBaseTarget(f2, d2));
    }
}
function Im(t2, e2) {
  return e2 ? (e2[t2] || e2.default || e2).from : void 0;
}
function Bm(t2, e2, r2) {
  var n2;
  const i2 = {};
  for (const o2 in t2) {
    const s2 = Im(o2, e2);
    i2[o2] = s2 !== void 0 ? s2 : (n2 = r2.getValue(o2)) === null || n2 === void 0 ? void 0 : n2.get();
  }
  return i2;
}
function ai(t2) {
  return !!(St(t2) && t2.add);
}
var km = "framerAppearId";
var Dm = "data-" + Cs(km);
var Oi = function() {
};
var Vt2 = function() {
};
Oi = function(t2, e2) {
  !t2 && typeof console < "u" && console.warn(e2);
}, Vt2 = function(t2, e2) {
  if (!t2)
    throw new Error(e2);
};
var Xn = (t2) => t2 * 1e3;
var Lm = {
  current: false
};
var $s = (t2) => (e2) => e2 <= 0.5 ? t2(2 * e2) / 2 : (2 - t2(2 * (1 - e2))) / 2;
var Vs = (t2) => (e2) => 1 - t2(1 - e2);
var qs = (t2) => t2 * t2;
var Nm = Vs(qs);
var Ws = $s(qs);
var ot2 = (t2, e2, r2) => -r2 * t2 + r2 * e2 + t2;
function Hi(t2, e2, r2) {
  return r2 < 0 && (r2 += 1), r2 > 1 && (r2 -= 1), r2 < 1 / 6 ? t2 + (e2 - t2) * 6 * r2 : r2 < 1 / 2 ? e2 : r2 < 2 / 3 ? t2 + (e2 - t2) * (2 / 3 - r2) * 6 : t2;
}
function Um({ hue: t2, saturation: e2, lightness: r2, alpha: n2 }) {
  t2 /= 360, e2 /= 100, r2 /= 100;
  let i2 = 0, o2 = 0, s2 = 0;
  if (!e2)
    i2 = o2 = s2 = r2;
  else {
    const a2 = r2 < 0.5 ? r2 * (1 + e2) : r2 + e2 - r2 * e2, f2 = 2 * r2 - a2;
    i2 = Hi(f2, a2, t2 + 1 / 3), o2 = Hi(f2, a2, t2), s2 = Hi(f2, a2, t2 - 1 / 3);
  }
  return {
    red: Math.round(i2 * 255),
    green: Math.round(o2 * 255),
    blue: Math.round(s2 * 255),
    alpha: n2
  };
}
var Ki = (t2, e2, r2) => {
  const n2 = t2 * t2;
  return Math.sqrt(Math.max(0, r2 * (e2 * e2 - n2) + n2));
};
var Fm = [bo, yr2, kr];
var jm = (t2) => Fm.find((e2) => e2.test(t2));
function qa(t2) {
  const e2 = jm(t2);
  Vt2(!!e2, `'${t2}' is not an animatable color. Use the equivalent color code instead.`);
  let r2 = e2.parse(t2);
  return e2 === kr && (r2 = Um(r2)), r2;
}
var kl = (t2, e2) => {
  const r2 = qa(t2), n2 = qa(e2), i2 = { ...r2 };
  return (o2) => (i2.red = Ki(r2.red, n2.red, o2), i2.green = Ki(r2.green, n2.green, o2), i2.blue = Ki(r2.blue, n2.blue, o2), i2.alpha = ot2(r2.alpha, n2.alpha, o2), yr2.transform(i2));
};
function Dl(t2, e2) {
  return typeof t2 == "number" ? (r2) => ot2(t2, e2, r2) : Tt.test(t2) ? kl(t2, e2) : Nl(t2, e2);
}
var Ll = (t2, e2) => {
  const r2 = [...t2], n2 = r2.length, i2 = t2.map((o2, s2) => Dl(o2, e2[s2]));
  return (o2) => {
    for (let s2 = 0; s2 < n2; s2++)
      r2[s2] = i2[s2](o2);
    return r2;
  };
};
var $m = (t2, e2) => {
  const r2 = { ...t2, ...e2 }, n2 = {};
  for (const i2 in r2)
    t2[i2] !== void 0 && e2[i2] !== void 0 && (n2[i2] = Dl(t2[i2], e2[i2]));
  return (i2) => {
    for (const o2 in n2)
      r2[o2] = n2[o2](i2);
    return r2;
  };
};
var Nl = (t2, e2) => {
  const r2 = lr2.createTransformer(e2), n2 = si(t2), i2 = si(e2);
  return n2.numColors === i2.numColors && n2.numNumbers >= i2.numNumbers ? Mi(Ll(n2.values, i2.values), r2) : (Oi(true, `Complex values '${t2}' and '${e2}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), (s2) => `${s2 > 0 ? e2 : t2}`);
};
var ui = (t2, e2, r2) => {
  const n2 = e2 - t2;
  return n2 === 0 ? 1 : (r2 - t2) / n2;
};
var Wa = (t2, e2) => (r2) => ot2(t2, e2, r2);
function Vm(t2) {
  return typeof t2 == "number" ? Wa : typeof t2 == "string" ? Tt.test(t2) ? kl : Nl : Array.isArray(t2) ? Ll : typeof t2 == "object" ? $m : Wa;
}
function qm(t2, e2, r2) {
  const n2 = [], i2 = r2 || Vm(t2[0]), o2 = t2.length - 1;
  for (let s2 = 0; s2 < o2; s2++) {
    let a2 = i2(t2[s2], t2[s2 + 1]);
    if (e2) {
      const f2 = Array.isArray(e2) ? e2[s2] : e2;
      a2 = Mi(f2, a2);
    }
    n2.push(a2);
  }
  return n2;
}
function Ul(t2, e2, { clamp: r2 = true, ease: n2, mixer: i2 } = {}) {
  const o2 = t2.length;
  Vt2(o2 === e2.length, "Both input and output ranges must be the same length"), Vt2(!n2 || !Array.isArray(n2) || n2.length === o2 - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values."), t2[0] > t2[o2 - 1] && (t2 = [...t2].reverse(), e2 = [...e2].reverse());
  const s2 = qm(e2, n2, i2), a2 = s2.length, f2 = (p2) => {
    let d2 = 0;
    if (a2 > 1)
      for (; d2 < t2.length - 2 && !(p2 < t2[d2 + 1]); d2++)
        ;
    const y2 = ui(t2[d2], t2[d2 + 1], p2);
    return s2[d2](y2);
  };
  return r2 ? (p2) => f2(zr(t2[0], t2[o2 - 1], p2)) : f2;
}
var Hs = (t2) => t2;
var Fl = (t2, e2, r2) => (((1 - 3 * r2 + 3 * e2) * t2 + (3 * r2 - 6 * e2)) * t2 + 3 * e2) * t2;
var Wm = 1e-7;
var Hm = 12;
function Km(t2, e2, r2, n2, i2) {
  let o2, s2, a2 = 0;
  do
    s2 = e2 + (r2 - e2) / 2, o2 = Fl(s2, n2, i2) - t2, o2 > 0 ? r2 = s2 : e2 = s2;
  while (Math.abs(o2) > Wm && ++a2 < Hm);
  return s2;
}
function jl(t2, e2, r2, n2) {
  if (t2 === e2 && r2 === n2)
    return Hs;
  const i2 = (o2) => Km(o2, 0, 1, t2, r2);
  return (o2) => o2 === 0 || o2 === 1 ? o2 : Fl(i2(o2), e2, n2);
}
var $l = (t2) => 1 - Math.sin(Math.acos(t2));
var Ks = Vs($l);
var zm = $s(Ks);
var Vl = jl(0.33, 1.53, 0.69, 0.99);
var zs = Vs(Vl);
var Gm = $s(zs);
var Ym = (t2) => (t2 *= 2) < 1 ? 0.5 * zs(t2) : 0.5 * (2 - Math.pow(2, -10 * (t2 - 1)));
var Ha = {
  linear: Hs,
  easeIn: qs,
  easeInOut: Ws,
  easeOut: Nm,
  circIn: $l,
  circInOut: zm,
  circOut: Ks,
  backIn: zs,
  backInOut: Gm,
  backOut: Vl,
  anticipate: Ym
};
var Ka = (t2) => {
  if (Array.isArray(t2)) {
    Vt2(t2.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [e2, r2, n2, i2] = t2;
    return jl(e2, r2, n2, i2);
  } else if (typeof t2 == "string")
    return Vt2(Ha[t2] !== void 0, `Invalid easing type '${t2}'`), Ha[t2];
  return t2;
};
var Xm = (t2) => Array.isArray(t2) && typeof t2[0] != "number";
function Zm(t2, e2) {
  return t2.map(() => e2 || Ws).splice(0, t2.length - 1);
}
function Jm(t2) {
  const e2 = t2.length;
  return t2.map((r2, n2) => n2 !== 0 ? n2 / (e2 - 1) : 0);
}
function Qm(t2, e2) {
  return t2.map((r2) => r2 * e2);
}
function To({ keyframes: t2, ease: e2 = Ws, times: r2, duration: n2 = 300 }) {
  t2 = [...t2];
  const i2 = Xm(e2) ? e2.map(Ka) : Ka(e2), o2 = {
    done: false,
    value: t2[0]
  }, s2 = Qm(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    r2 && r2.length === t2.length ? r2 : Jm(t2),
    n2
  );
  function a2() {
    return Ul(s2, t2, {
      ease: Array.isArray(i2) ? i2 : Zm(t2, i2)
    });
  }
  let f2 = a2();
  return {
    next: (p2) => (o2.value = f2(p2), o2.done = p2 >= n2, o2),
    flipTarget: () => {
      t2.reverse(), f2 = a2();
    }
  };
}
var zi = 1e-3;
var eg = 0.01;
var za = 10;
var tg = 0.05;
var rg = 1;
function ng({ duration: t2 = 800, bounce: e2 = 0.25, velocity: r2 = 0, mass: n2 = 1 }) {
  let i2, o2;
  Oi(t2 <= za * 1e3, "Spring duration must be 10 seconds or less");
  let s2 = 1 - e2;
  s2 = zr(tg, rg, s2), t2 = zr(eg, za, t2 / 1e3), s2 < 1 ? (i2 = (p2) => {
    const d2 = p2 * s2, y2 = d2 * t2, v3 = d2 - r2, w3 = Eo(p2, s2), I3 = Math.exp(-y2);
    return zi - v3 / w3 * I3;
  }, o2 = (p2) => {
    const y2 = p2 * s2 * t2, v3 = y2 * r2 + r2, w3 = Math.pow(s2, 2) * Math.pow(p2, 2) * t2, I3 = Math.exp(-y2), N11 = Eo(Math.pow(p2, 2), s2);
    return (-i2(p2) + zi > 0 ? -1 : 1) * ((v3 - w3) * I3) / N11;
  }) : (i2 = (p2) => {
    const d2 = Math.exp(-p2 * t2), y2 = (p2 - r2) * t2 + 1;
    return -zi + d2 * y2;
  }, o2 = (p2) => {
    const d2 = Math.exp(-p2 * t2), y2 = (r2 - p2) * (t2 * t2);
    return d2 * y2;
  });
  const a2 = 5 / t2, f2 = og(i2, o2, a2);
  if (t2 = t2 * 1e3, isNaN(f2))
    return {
      stiffness: 100,
      damping: 10,
      duration: t2
    };
  {
    const p2 = Math.pow(f2, 2) * n2;
    return {
      stiffness: p2,
      damping: s2 * 2 * Math.sqrt(n2 * p2),
      duration: t2
    };
  }
}
var ig = 12;
function og(t2, e2, r2) {
  let n2 = r2;
  for (let i2 = 1; i2 < ig; i2++)
    n2 = n2 - t2(n2) / e2(n2);
  return n2;
}
function Eo(t2, e2) {
  return t2 * Math.sqrt(1 - e2 * e2);
}
var sg = ["duration", "bounce"];
var ag = ["stiffness", "damping", "mass"];
function Ga(t2, e2) {
  return e2.some((r2) => t2[r2] !== void 0);
}
function ug(t2) {
  let e2 = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: false,
    ...t2
  };
  if (!Ga(t2, ag) && Ga(t2, sg)) {
    const r2 = ng(t2);
    e2 = {
      ...e2,
      ...r2,
      velocity: 0,
      mass: 1
    }, e2.isResolvedFromDuration = true;
  }
  return e2;
}
var cg = 5;
function ql({ keyframes: t2, restDelta: e2, restSpeed: r2, ...n2 }) {
  let i2 = t2[0], o2 = t2[t2.length - 1];
  const s2 = { done: false, value: i2 }, { stiffness: a2, damping: f2, mass: p2, velocity: d2, duration: y2, isResolvedFromDuration: v3 } = ug(n2);
  let w3 = lg, I3 = d2 ? -(d2 / 1e3) : 0;
  const N11 = f2 / (2 * Math.sqrt(a2 * p2));
  function k2() {
    const M3 = o2 - i2, S2 = Math.sqrt(a2 / p2) / 1e3, Y2 = Math.abs(M3) < 5;
    if (r2 || (r2 = Y2 ? 0.01 : 2), e2 || (e2 = Y2 ? 5e-3 : 0.5), N11 < 1) {
      const W2 = Eo(S2, N11);
      w3 = (Q3) => {
        const X3 = Math.exp(-N11 * S2 * Q3);
        return o2 - X3 * ((I3 + N11 * S2 * M3) / W2 * Math.sin(W2 * Q3) + M3 * Math.cos(W2 * Q3));
      };
    } else if (N11 === 1)
      w3 = (W2) => o2 - Math.exp(-S2 * W2) * (M3 + (I3 + S2 * M3) * W2);
    else {
      const W2 = S2 * Math.sqrt(N11 * N11 - 1);
      w3 = (Q3) => {
        const X3 = Math.exp(-N11 * S2 * Q3), ne = Math.min(W2 * Q3, 300);
        return o2 - X3 * ((I3 + N11 * S2 * M3) * Math.sinh(ne) + W2 * M3 * Math.cosh(ne)) / W2;
      };
    }
  }
  return k2(), {
    next: (M3) => {
      const S2 = w3(M3);
      if (v3)
        s2.done = M3 >= y2;
      else {
        let Y2 = I3;
        if (M3 !== 0)
          if (N11 < 1) {
            const X3 = Math.max(0, M3 - cg);
            Y2 = Ns(S2 - w3(X3), M3 - X3);
          } else
            Y2 = 0;
        const W2 = Math.abs(Y2) <= r2, Q3 = Math.abs(o2 - S2) <= e2;
        s2.done = W2 && Q3;
      }
      return s2.value = s2.done ? o2 : S2, s2;
    },
    flipTarget: () => {
      I3 = -I3, [i2, o2] = [o2, i2], k2();
    }
  };
}
ql.needsInterpolation = (t2, e2) => typeof t2 == "string" || typeof e2 == "string";
var lg = (t2) => 0;
function fg({
  /**
   * The decay animation dynamically calculates an end of the animation
   * based on the initial keyframe, so we only need to define a single keyframe
   * as default.
   */
  keyframes: t2 = [0],
  velocity: e2 = 0,
  power: r2 = 0.8,
  timeConstant: n2 = 350,
  restDelta: i2 = 0.5,
  modifyTarget: o2
}) {
  const s2 = t2[0], a2 = { done: false, value: s2 };
  let f2 = r2 * e2;
  const p2 = s2 + f2, d2 = o2 === void 0 ? p2 : o2(p2);
  return d2 !== p2 && (f2 = d2 - s2), {
    next: (y2) => {
      const v3 = -f2 * Math.exp(-y2 / n2);
      return a2.done = !(v3 > i2 || v3 < -i2), a2.value = a2.done ? d2 : d2 + v3, a2;
    },
    flipTarget: () => {
    }
  };
}
var hg = {
  decay: fg,
  keyframes: To,
  tween: To,
  spring: ql
};
function Wl(t2, e2, r2 = 0) {
  return t2 - e2 - r2;
}
function dg(t2, e2 = 0, r2 = 0, n2 = true) {
  return n2 ? Wl(e2 + -t2, e2, r2) : e2 - (t2 - e2) + r2;
}
function pg(t2, e2, r2, n2) {
  return n2 ? t2 >= e2 + r2 : t2 <= -r2;
}
var mg = (t2) => {
  const e2 = ({ delta: r2 }) => t2(r2);
  return {
    start: () => _t2.update(e2, true),
    stop: () => cr.update(e2)
  };
};
function ci({ duration: t2, driver: e2 = mg, elapsed: r2 = 0, repeat: n2 = 0, repeatType: i2 = "loop", repeatDelay: o2 = 0, keyframes: s2, autoplay: a2 = true, onPlay: f2, onStop: p2, onComplete: d2, onRepeat: y2, onUpdate: v3, type: w3 = "keyframes", ...I3 }) {
  var N11, k2;
  const M3 = r2;
  let S2, Y2 = 0, W2 = t2, Q3 = false, X3 = true, ne;
  const ue = hg[s2.length > 2 ? "keyframes" : w3] || To, se = s2[0], ie = s2[s2.length - 1];
  let O2 = { done: false, value: se };
  !((k2 = (N11 = ue).needsInterpolation) === null || k2 === void 0) && k2.call(N11, se, ie) && (ne = Ul([0, 100], [se, ie], {
    clamp: false
  }), s2 = [0, 100]);
  const c2 = ue({
    ...I3,
    duration: t2,
    keyframes: s2
  });
  function m2() {
    Y2++, i2 === "reverse" ? (X3 = Y2 % 2 === 0, r2 = dg(r2, W2, o2, X3)) : (r2 = Wl(r2, W2, o2), i2 === "mirror" && c2.flipTarget()), Q3 = false, y2 && y2();
  }
  function _3() {
    S2 && S2.stop(), d2 && d2();
  }
  function T3(L2) {
    X3 || (L2 = -L2), r2 += L2, Q3 || (O2 = c2.next(Math.max(0, r2)), ne && (O2.value = ne(O2.value)), Q3 = X3 ? O2.done : r2 <= 0), v3 && v3(O2.value), Q3 && (Y2 === 0 && (W2 = W2 !== void 0 ? W2 : r2), Y2 < n2 ? pg(r2, W2, o2, X3) && m2() : _3());
  }
  function C3() {
    f2 && f2(), S2 = e2(T3), S2.start();
  }
  return a2 && C3(), {
    stop: () => {
      p2 && p2(), S2 && S2.stop();
    },
    /**
     * Set the current time of the animation. This is purposefully
     * mirroring the WAAPI animation API to make them interchanagable.
     * Going forward this file should be ported more towards
     * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts
     * Which behaviourally adheres to WAAPI as far as possible.
     *
     * WARNING: This is not safe to use for most animations. We currently
     * only use it for handoff from WAAPI within Framer.
     *
     * This animation function consumes time every frame rather than being sampled for time.
     * So the sample() method performs some headless frames to ensure
     * repeats are handled correctly. Ideally in the future we will replace
     * that method with this, once repeat calculations are pure.
     */
    set currentTime(L2) {
      r2 = M3, T3(L2);
    },
    /**
     * animate() can't yet be sampled for time, instead it
     * consumes time. So to sample it we have to run a low
     * temporal-resolution version.
     */
    sample: (L2) => {
      r2 = M3;
      const H2 = t2 && typeof t2 == "number" ? Math.max(t2 * 0.5, 50) : 50;
      let P3 = 0;
      for (T3(0); P3 <= L2; ) {
        const l2 = L2 - P3;
        T3(Math.min(l2, H2)), P3 += H2;
      }
      return O2;
    }
  };
}
function gg(t2) {
  return !t2 || // Default easing
  Array.isArray(t2) || // Bezier curve
  typeof t2 == "string" && Hl[t2];
}
var fn = ([t2, e2, r2, n2]) => `cubic-bezier(${t2}, ${e2}, ${r2}, ${n2})`;
var Hl = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: fn([0, 0.65, 0.55, 1]),
  circOut: fn([0.55, 0, 1, 0.45]),
  backIn: fn([0.31, 0.01, 0.66, -0.59]),
  backOut: fn([0.33, 1.53, 0.69, 0.99])
};
function yg(t2) {
  if (t2)
    return Array.isArray(t2) ? fn(t2) : Hl[t2];
}
function vg(t2, e2, r2, { delay: n2 = 0, duration: i2, repeat: o2 = 0, repeatType: s2 = "loop", ease: a2, times: f2 } = {}) {
  return t2.animate({ [e2]: r2, offset: f2 }, {
    delay: n2,
    duration: i2,
    easing: yg(a2),
    fill: "both",
    iterations: o2 + 1,
    direction: s2 === "reverse" ? "alternate" : "normal"
  });
}
var Ya = {
  waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate")
};
var Gi = {};
var Kl = {};
for (const t2 in Ya)
  Kl[t2] = () => (Gi[t2] === void 0 && (Gi[t2] = Ya[t2]()), Gi[t2]);
function wg(t2, { repeat: e2, repeatType: r2 = "loop" }) {
  const n2 = e2 && r2 !== "loop" && e2 % 2 === 1 ? 0 : t2.length - 1;
  return t2[n2];
}
var _g = /* @__PURE__ */ new Set(["opacity"]);
var Wn = 10;
function bg(t2, e2, { onUpdate: r2, onComplete: n2, ...i2 }) {
  if (!(Kl.waapi() && _g.has(e2) && !i2.repeatDelay && i2.repeatType !== "mirror" && i2.damping !== 0))
    return false;
  let { keyframes: s2, duration: a2 = 300, elapsed: f2 = 0, ease: p2 } = i2;
  if (i2.type === "spring" || !gg(i2.ease)) {
    if (i2.repeat === 1 / 0)
      return;
    const y2 = ci({ ...i2, elapsed: 0 });
    let v3 = { done: false, value: s2[0] };
    const w3 = [];
    let I3 = 0;
    for (; !v3.done && I3 < 2e4; )
      v3 = y2.sample(I3), w3.push(v3.value), I3 += Wn;
    s2 = w3, a2 = I3 - Wn, p2 = "linear";
  }
  const d2 = vg(t2.owner.current, e2, s2, {
    ...i2,
    delay: -f2,
    duration: a2,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: p2
  });
  return d2.onfinish = () => {
    t2.set(wg(s2, i2)), _t2.update(() => d2.cancel()), n2 && n2();
  }, {
    get currentTime() {
      return d2.currentTime || 0;
    },
    set currentTime(y2) {
      d2.currentTime = y2;
    },
    stop: () => {
      const { currentTime: y2 } = d2;
      if (y2) {
        const v3 = ci({ ...i2, autoplay: false });
        t2.setWithVelocity(v3.sample(y2 - Wn).value, v3.sample(y2).value, Wn);
      }
      _t2.update(() => d2.cancel());
    }
  };
}
function zl(t2, e2) {
  const r2 = performance.now(), n2 = ({ timestamp: i2 }) => {
    const o2 = i2 - r2;
    o2 >= e2 && (cr.read(n2), t2(o2 - e2));
  };
  return _t2.read(n2, true), () => cr.read(n2);
}
function xg({ keyframes: t2, elapsed: e2, onUpdate: r2, onComplete: n2 }) {
  const i2 = () => {
    r2 && r2(t2[t2.length - 1]), n2 && n2();
  };
  return e2 ? { stop: zl(i2, -e2) } : i2();
}
function Tg({ keyframes: t2, velocity: e2 = 0, min: r2, max: n2, power: i2 = 0.8, timeConstant: o2 = 750, bounceStiffness: s2 = 500, bounceDamping: a2 = 10, restDelta: f2 = 1, modifyTarget: p2, driver: d2, onUpdate: y2, onComplete: v3, onStop: w3 }) {
  const I3 = t2[0];
  let N11;
  function k2(W2) {
    return r2 !== void 0 && W2 < r2 || n2 !== void 0 && W2 > n2;
  }
  function M3(W2) {
    return r2 === void 0 ? n2 : n2 === void 0 || Math.abs(r2 - W2) < Math.abs(n2 - W2) ? r2 : n2;
  }
  function S2(W2) {
    N11 == null || N11.stop(), N11 = ci({
      keyframes: [0, 1],
      velocity: 0,
      ...W2,
      driver: d2,
      onUpdate: (Q3) => {
        var X3;
        y2 == null || y2(Q3), (X3 = W2.onUpdate) === null || X3 === void 0 || X3.call(W2, Q3);
      },
      onComplete: v3,
      onStop: w3
    });
  }
  function Y2(W2) {
    S2({
      type: "spring",
      stiffness: s2,
      damping: a2,
      restDelta: f2,
      ...W2
    });
  }
  if (k2(I3))
    Y2({
      velocity: e2,
      keyframes: [I3, M3(I3)]
    });
  else {
    let W2 = i2 * e2 + I3;
    typeof p2 < "u" && (W2 = p2(W2));
    const Q3 = M3(W2), X3 = Q3 === r2 ? -1 : 1;
    let ne, ue;
    const se = (ie) => {
      ne = ue, ue = ie, e2 = Ns(ie - ne, tr.delta), (X3 === 1 && ie > Q3 || X3 === -1 && ie < Q3) && Y2({ keyframes: [ie, Q3], velocity: e2 });
    };
    S2({
      type: "decay",
      keyframes: [I3, 0],
      velocity: e2,
      timeConstant: o2,
      power: i2,
      restDelta: f2,
      modifyTarget: p2,
      onUpdate: k2(W2) ? se : void 0
    });
  }
  return {
    stop: () => N11 == null ? void 0 : N11.stop()
  };
}
var hr = () => ({
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
});
var Hn = (t2) => ({
  type: "spring",
  stiffness: 550,
  damping: t2 === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
var Yi = () => ({
  type: "keyframes",
  ease: "linear",
  duration: 0.3
});
var Eg = {
  type: "keyframes",
  duration: 0.8
};
var Xa = {
  x: hr,
  y: hr,
  z: hr,
  rotate: hr,
  rotateX: hr,
  rotateY: hr,
  rotateZ: hr,
  scaleX: Hn,
  scaleY: Hn,
  scale: Hn,
  opacity: Yi,
  backgroundColor: Yi,
  color: Yi,
  default: Hn
};
var Ag = (t2, { keyframes: e2 }) => e2.length > 2 ? Eg : (Xa[t2] || Xa.default)(e2[1]);
var Ao = (t2, e2) => t2 === "zIndex" ? false : !!(typeof e2 == "number" || Array.isArray(e2) || typeof e2 == "string" && // It's animatable if we have a string
lr2.test(e2) && // And it contains numbers and/or colors
!e2.startsWith("url("));
function Mg({ when: t2, delay: e2, delayChildren: r2, staggerChildren: n2, staggerDirection: i2, repeat: o2, repeatType: s2, repeatDelay: a2, from: f2, elapsed: p2, ...d2 }) {
  return !!Object.keys(d2).length;
}
function Za(t2) {
  return t2 === 0 || typeof t2 == "string" && parseFloat(t2) === 0 && t2.indexOf(" ") === -1;
}
function Ja(t2) {
  return typeof t2 == "number" ? 0 : js("", t2);
}
function Gl(t2, e2) {
  return t2[e2] || t2.default || t2;
}
function Sg(t2, e2, r2, n2) {
  const i2 = Ao(e2, r2);
  let o2 = n2.from !== void 0 ? n2.from : t2.get();
  return o2 === "none" && i2 && typeof r2 == "string" ? o2 = js(e2, r2) : Za(o2) && typeof r2 == "string" ? o2 = Ja(r2) : !Array.isArray(r2) && Za(r2) && typeof o2 == "string" && (r2 = Ja(o2)), Array.isArray(r2) ? (r2[0] === null && (r2[0] = o2), r2) : [o2, r2];
}
var Gs = (t2, e2, r2, n2 = {}) => (i2) => {
  const o2 = Gl(n2, t2) || {}, s2 = o2.delay || n2.delay || 0;
  let { elapsed: a2 = 0 } = n2;
  a2 = a2 - Xn(s2);
  const f2 = Sg(e2, t2, r2, o2), p2 = f2[0], d2 = f2[f2.length - 1], y2 = Ao(t2, p2), v3 = Ao(t2, d2);
  Oi(y2 === v3, `You are trying to animate ${t2} from "${p2}" to "${d2}". ${p2} is not an animatable value - to enable this animation set ${p2} to a value animatable to ${d2} via the \`style\` property.`);
  let w3 = {
    keyframes: f2,
    velocity: e2.getVelocity(),
    ...o2,
    elapsed: a2,
    onUpdate: (k2) => {
      e2.set(k2), o2.onUpdate && o2.onUpdate(k2);
    },
    onComplete: () => {
      i2(), o2.onComplete && o2.onComplete();
    }
  };
  if (!y2 || !v3 || Lm.current || o2.type === false)
    return xg(w3);
  if (o2.type === "inertia")
    return Tg(w3);
  Mg(o2) || (w3 = {
    ...w3,
    ...Ag(t2, w3)
  }), w3.duration && (w3.duration = Xn(w3.duration)), w3.repeatDelay && (w3.repeatDelay = Xn(w3.repeatDelay));
  const I3 = e2.owner, N11 = I3 && I3.current;
  if (I3 && N11 instanceof HTMLElement && !(I3 != null && I3.getProps().onUpdate)) {
    const k2 = bg(e2, t2, w3);
    if (k2)
      return k2;
  }
  return ci(w3);
};
function Pg(t2, e2, r2 = {}) {
  t2.notify("AnimationStart", e2);
  let n2;
  if (Array.isArray(e2)) {
    const i2 = e2.map((o2) => Mo(t2, o2, r2));
    n2 = Promise.all(i2);
  } else if (typeof e2 == "string")
    n2 = Mo(t2, e2, r2);
  else {
    const i2 = typeof e2 == "function" ? Ci(t2, e2, r2.custom) : e2;
    n2 = Yl(t2, i2, r2);
  }
  return n2.then(() => t2.notify("AnimationComplete", e2));
}
function Mo(t2, e2, r2 = {}) {
  var n2;
  const i2 = Ci(t2, e2, r2.custom);
  let { transition: o2 = t2.getDefaultTransition() || {} } = i2 || {};
  r2.transitionOverride && (o2 = r2.transitionOverride);
  const s2 = i2 ? () => Yl(t2, i2, r2) : () => Promise.resolve(), a2 = !((n2 = t2.variantChildren) === null || n2 === void 0) && n2.size ? (p2 = 0) => {
    const { delayChildren: d2 = 0, staggerChildren: y2, staggerDirection: v3 } = o2;
    return Cg(t2, e2, d2 + p2, y2, v3, r2);
  } : () => Promise.resolve(), { when: f2 } = o2;
  if (f2) {
    const [p2, d2] = f2 === "beforeChildren" ? [s2, a2] : [a2, s2];
    return p2().then(d2);
  } else
    return Promise.all([s2(), a2(r2.delay)]);
}
function Yl(t2, e2, { delay: r2 = 0, transitionOverride: n2, type: i2 } = {}) {
  var o2;
  let { transition: s2 = t2.getDefaultTransition(), transitionEnd: a2, ...f2 } = t2.makeTargetAnimatable(e2);
  const p2 = t2.getValue("willChange");
  n2 && (s2 = n2);
  const d2 = [], y2 = i2 && ((o2 = t2.animationState) === null || o2 === void 0 ? void 0 : o2.getState()[i2]);
  for (const v3 in f2) {
    const w3 = t2.getValue(v3), I3 = f2[v3];
    if (!w3 || I3 === void 0 || y2 && Rg(y2, v3))
      continue;
    const N11 = { delay: r2, elapsed: 0, ...s2 };
    if (window.HandoffAppearAnimations && !w3.hasAnimated) {
      const M3 = t2.getProps()[Dm];
      M3 && (N11.elapsed = window.HandoffAppearAnimations(M3, v3, w3, _t2));
    }
    let k2 = w3.start(Gs(v3, w3, I3, t2.shouldReduceMotion && Yr.has(v3) ? { type: false } : N11));
    ai(p2) && (p2.add(v3), k2 = k2.then(() => p2.remove(v3))), d2.push(k2);
  }
  return Promise.all(d2).then(() => {
    a2 && Om(t2, a2);
  });
}
function Cg(t2, e2, r2 = 0, n2 = 0, i2 = 1, o2) {
  const s2 = [], a2 = (t2.variantChildren.size - 1) * n2, f2 = i2 === 1 ? (p2 = 0) => p2 * n2 : (p2 = 0) => a2 - p2 * n2;
  return Array.from(t2.variantChildren).sort(Og).forEach((p2, d2) => {
    p2.notify("AnimationStart", e2), s2.push(Mo(p2, e2, {
      ...o2,
      delay: r2 + f2(d2)
    }).then(() => p2.notify("AnimationComplete", e2)));
  }), Promise.all(s2);
}
function Og(t2, e2) {
  return t2.sortNodePosition(e2);
}
function Rg({ protectedKeys: t2, needsAnimating: e2 }, r2) {
  const n2 = t2.hasOwnProperty(r2) && e2[r2] !== true;
  return e2[r2] = false, n2;
}
var Ys = [
  $e.Animate,
  $e.InView,
  $e.Focus,
  $e.Hover,
  $e.Tap,
  $e.Drag,
  $e.Exit
];
var Ig = [...Ys].reverse();
var Bg = Ys.length;
function kg(t2) {
  return (e2) => Promise.all(e2.map(({ animation: r2, options: n2 }) => Pg(t2, r2, n2)));
}
function Dg(t2) {
  let e2 = kg(t2);
  const r2 = Ng();
  let n2 = true;
  const i2 = (f2, p2) => {
    const d2 = Ci(t2, p2);
    if (d2) {
      const { transition: y2, transitionEnd: v3, ...w3 } = d2;
      f2 = { ...f2, ...w3, ...v3 };
    }
    return f2;
  };
  function o2(f2) {
    e2 = f2(t2);
  }
  function s2(f2, p2) {
    const d2 = t2.getProps(), y2 = t2.getVariantContext(true) || {}, v3 = [], w3 = /* @__PURE__ */ new Set();
    let I3 = {}, N11 = 1 / 0;
    for (let M3 = 0; M3 < Bg; M3++) {
      const S2 = Ig[M3], Y2 = r2[S2], W2 = d2[S2] !== void 0 ? d2[S2] : y2[S2], Q3 = bn(W2), X3 = S2 === p2 ? Y2.isActive : null;
      X3 === false && (N11 = M3);
      let ne = W2 === y2[S2] && W2 !== d2[S2] && Q3;
      if (ne && n2 && t2.manuallyAnimateOnMount && (ne = false), Y2.protectedKeys = { ...I3 }, // If it isn't active and hasn't *just* been set as inactive
      !Y2.isActive && X3 === null || // If we didn't and don't have any defined prop for this animation type
      !W2 && !Y2.prevProp || // Or if the prop doesn't define an animation
      xi(W2) || typeof W2 == "boolean")
        continue;
      const ue = Lg(Y2.prevProp, W2);
      let se = ue || // If we're making this variant active, we want to always make it active
      S2 === p2 && Y2.isActive && !ne && Q3 || // If we removed a higher-priority variant (i is in reverse order)
      M3 > N11 && Q3;
      const ie = Array.isArray(W2) ? W2 : [W2];
      let O2 = ie.reduce(i2, {});
      X3 === false && (O2 = {});
      const { prevResolvedValues: c2 = {} } = Y2, m2 = {
        ...c2,
        ...O2
      }, _3 = (T3) => {
        se = true, w3.delete(T3), Y2.needsAnimating[T3] = true;
      };
      for (const T3 in m2) {
        const C3 = O2[T3], L2 = c2[T3];
        I3.hasOwnProperty(T3) || (C3 !== L2 ? ii(C3) && ii(L2) ? !Tl(C3, L2) || ue ? _3(T3) : Y2.protectedKeys[T3] = true : C3 !== void 0 ? _3(T3) : w3.add(T3) : C3 !== void 0 && w3.has(T3) ? _3(T3) : Y2.protectedKeys[T3] = true);
      }
      Y2.prevProp = W2, Y2.prevResolvedValues = O2, Y2.isActive && (I3 = { ...I3, ...O2 }), n2 && t2.blockInitialAnimation && (se = false), se && !ne && v3.push(...ie.map((T3) => ({
        animation: T3,
        options: { type: S2, ...f2 }
      })));
    }
    if (w3.size) {
      const M3 = {};
      w3.forEach((S2) => {
        const Y2 = t2.getBaseTarget(S2);
        Y2 !== void 0 && (M3[S2] = Y2);
      }), v3.push({ animation: M3 });
    }
    let k2 = !!v3.length;
    return n2 && d2.initial === false && !t2.manuallyAnimateOnMount && (k2 = false), n2 = false, k2 ? e2(v3) : Promise.resolve();
  }
  function a2(f2, p2, d2) {
    var y2;
    if (r2[f2].isActive === p2)
      return Promise.resolve();
    (y2 = t2.variantChildren) === null || y2 === void 0 || y2.forEach((w3) => {
      var I3;
      return (I3 = w3.animationState) === null || I3 === void 0 ? void 0 : I3.setActive(f2, p2);
    }), r2[f2].isActive = p2;
    const v3 = s2(d2, f2);
    for (const w3 in r2)
      r2[w3].protectedKeys = {};
    return v3;
  }
  return {
    animateChanges: s2,
    setActive: a2,
    setAnimateFunction: o2,
    getState: () => r2
  };
}
function Lg(t2, e2) {
  return typeof e2 == "string" ? e2 !== t2 : Array.isArray(e2) ? !Tl(e2, t2) : false;
}
function dr(t2 = false) {
  return {
    isActive: t2,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function Ng() {
  return {
    [$e.Animate]: dr(true),
    [$e.InView]: dr(),
    [$e.Hover]: dr(),
    [$e.Tap]: dr(),
    [$e.Drag]: dr(),
    [$e.Focus]: dr(),
    [$e.Exit]: dr()
  };
}
var Ug = {
  animation: ar(({ visualElement: t2, animate: e2 }) => {
    t2.animationState || (t2.animationState = Dg(t2)), xi(e2) && (0, import_react.useEffect)(() => e2.subscribe(t2), [e2]);
  }),
  exit: ar((t2) => {
    const { custom: e2, visualElement: r2 } = t2, [n2, i2] = xl(), o2 = (0, import_react.useContext)(Rn);
    (0, import_react.useEffect)(() => {
      r2.isPresent = n2;
      const s2 = r2.animationState && r2.animationState.setActive($e.Exit, !n2, {
        custom: o2 && o2.custom || e2
      });
      s2 && !n2 && s2.then(i2);
    }, [n2]);
  })
};
var Qa = (t2, e2) => Math.abs(t2 - e2);
function Fg(t2, e2) {
  const r2 = Qa(t2.x, e2.x), n2 = Qa(t2.y, e2.y);
  return Math.sqrt(r2 ** 2 + n2 ** 2);
}
var Xl = class {
  constructor(e2, r2, { transformPagePoint: n2 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const p2 = Zi(this.lastMoveEventInfo, this.history), d2 = this.startEvent !== null, y2 = Fg(p2.offset, { x: 0, y: 0 }) >= 3;
      if (!d2 && !y2)
        return;
      const { point: v3 } = p2, { timestamp: w3 } = tr;
      this.history.push({ ...v3, timestamp: w3 });
      const { onStart: I3, onMove: N11 } = this.handlers;
      d2 || (I3 && I3(this.lastMoveEvent, p2), this.startEvent = this.lastMoveEvent), N11 && N11(this.lastMoveEvent, p2);
    }, this.handlePointerMove = (p2, d2) => {
      this.lastMoveEvent = p2, this.lastMoveEventInfo = Xi(d2, this.transformPagePoint), _t2.update(this.updatePoint, true);
    }, this.handlePointerUp = (p2, d2) => {
      if (this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const { onEnd: y2, onSessionEnd: v3 } = this.handlers, w3 = Zi(p2.type === "pointercancel" ? this.lastMoveEventInfo : Xi(d2, this.transformPagePoint), this.history);
      this.startEvent && y2 && y2(p2, w3), v3 && v3(p2, w3);
    }, !gl(e2))
      return;
    this.handlers = r2, this.transformPagePoint = n2;
    const i2 = Is(e2), o2 = Xi(i2, this.transformPagePoint), { point: s2 } = o2, { timestamp: a2 } = tr;
    this.history = [{ ...s2, timestamp: a2 }];
    const { onSessionStart: f2 } = r2;
    f2 && f2(e2, Zi(o2, this.history)), this.removeListeners = Mi(Fr(window, "pointermove", this.handlePointerMove), Fr(window, "pointerup", this.handlePointerUp), Fr(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(e2) {
    this.handlers = e2;
  }
  end() {
    this.removeListeners && this.removeListeners(), cr.update(this.updatePoint);
  }
};
function Xi(t2, e2) {
  return e2 ? { point: e2(t2.point) } : t2;
}
function eu(t2, e2) {
  return { x: t2.x - e2.x, y: t2.y - e2.y };
}
function Zi({ point: t2 }, e2) {
  return {
    point: t2,
    delta: eu(t2, Zl(e2)),
    offset: eu(t2, jg(e2)),
    velocity: $g(e2, 0.1)
  };
}
function jg(t2) {
  return t2[0];
}
function Zl(t2) {
  return t2[t2.length - 1];
}
function $g(t2, e2) {
  if (t2.length < 2)
    return { x: 0, y: 0 };
  let r2 = t2.length - 1, n2 = null;
  const i2 = Zl(t2);
  for (; r2 >= 0 && (n2 = t2[r2], !(i2.timestamp - n2.timestamp > Xn(e2))); )
    r2--;
  if (!n2)
    return { x: 0, y: 0 };
  const o2 = (i2.timestamp - n2.timestamp) / 1e3;
  if (o2 === 0)
    return { x: 0, y: 0 };
  const s2 = {
    x: (i2.x - n2.x) / o2,
    y: (i2.y - n2.y) / o2
  };
  return s2.x === 1 / 0 && (s2.x = 0), s2.y === 1 / 0 && (s2.y = 0), s2;
}
function Rt2(t2) {
  return t2.max - t2.min;
}
function So(t2, e2 = 0, r2 = 0.01) {
  return Math.abs(t2 - e2) <= r2;
}
function tu(t2, e2, r2, n2 = 0.5) {
  t2.origin = n2, t2.originPoint = ot2(e2.min, e2.max, t2.origin), t2.scale = Rt2(r2) / Rt2(e2), (So(t2.scale, 1, 1e-4) || isNaN(t2.scale)) && (t2.scale = 1), t2.translate = ot2(r2.min, r2.max, t2.origin) - t2.originPoint, (So(t2.translate) || isNaN(t2.translate)) && (t2.translate = 0);
}
function yn(t2, e2, r2, n2) {
  tu(t2.x, e2.x, r2.x, n2 == null ? void 0 : n2.originX), tu(t2.y, e2.y, r2.y, n2 == null ? void 0 : n2.originY);
}
function ru(t2, e2, r2) {
  t2.min = r2.min + e2.min, t2.max = t2.min + Rt2(e2);
}
function Vg(t2, e2, r2) {
  ru(t2.x, e2.x, r2.x), ru(t2.y, e2.y, r2.y);
}
function nu(t2, e2, r2) {
  t2.min = e2.min - r2.min, t2.max = t2.min + Rt2(e2);
}
function vn(t2, e2, r2) {
  nu(t2.x, e2.x, r2.x), nu(t2.y, e2.y, r2.y);
}
function qg(t2, { min: e2, max: r2 }, n2) {
  return e2 !== void 0 && t2 < e2 ? t2 = n2 ? ot2(e2, t2, n2.min) : Math.max(t2, e2) : r2 !== void 0 && t2 > r2 && (t2 = n2 ? ot2(r2, t2, n2.max) : Math.min(t2, r2)), t2;
}
function iu(t2, e2, r2) {
  return {
    min: e2 !== void 0 ? t2.min + e2 : void 0,
    max: r2 !== void 0 ? t2.max + r2 - (t2.max - t2.min) : void 0
  };
}
function Wg(t2, { top: e2, left: r2, bottom: n2, right: i2 }) {
  return {
    x: iu(t2.x, r2, i2),
    y: iu(t2.y, e2, n2)
  };
}
function ou(t2, e2) {
  let r2 = e2.min - t2.min, n2 = e2.max - t2.max;
  return e2.max - e2.min < t2.max - t2.min && ([r2, n2] = [n2, r2]), { min: r2, max: n2 };
}
function Hg(t2, e2) {
  return {
    x: ou(t2.x, e2.x),
    y: ou(t2.y, e2.y)
  };
}
function Kg(t2, e2) {
  let r2 = 0.5;
  const n2 = Rt2(t2), i2 = Rt2(e2);
  return i2 > n2 ? r2 = ui(e2.min, e2.max - n2, t2.min) : n2 > i2 && (r2 = ui(t2.min, t2.max - i2, e2.min)), zr(0, 1, r2);
}
function zg(t2, e2) {
  const r2 = {};
  return e2.min !== void 0 && (r2.min = e2.min - t2.min), e2.max !== void 0 && (r2.max = e2.max - t2.min), r2;
}
var Po = 0.35;
function Gg(t2 = Po) {
  return t2 === false ? t2 = 0 : t2 === true && (t2 = Po), {
    x: su(t2, "left", "right"),
    y: su(t2, "top", "bottom")
  };
}
function su(t2, e2, r2) {
  return {
    min: au(t2, e2),
    max: au(t2, r2)
  };
}
function au(t2, e2) {
  return typeof t2 == "number" ? t2 : t2[e2] || 0;
}
var uu = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
var wn = () => ({
  x: uu(),
  y: uu()
});
var cu = () => ({ min: 0, max: 0 });
var ct2 = () => ({
  x: cu(),
  y: cu()
});
function Ht(t2) {
  return [t2("x"), t2("y")];
}
function Jl({ top: t2, left: e2, right: r2, bottom: n2 }) {
  return {
    x: { min: e2, max: r2 },
    y: { min: t2, max: n2 }
  };
}
function Yg({ x: t2, y: e2 }) {
  return { top: e2.min, right: t2.max, bottom: e2.max, left: t2.min };
}
function Xg(t2, e2) {
  if (!e2)
    return t2;
  const r2 = e2({ x: t2.left, y: t2.top }), n2 = e2({ x: t2.right, y: t2.bottom });
  return {
    top: r2.y,
    left: r2.x,
    bottom: n2.y,
    right: n2.x
  };
}
function Ji(t2) {
  return t2 === void 0 || t2 === 1;
}
function Co({ scale: t2, scaleX: e2, scaleY: r2 }) {
  return !Ji(t2) || !Ji(e2) || !Ji(r2);
}
function pr2(t2) {
  return Co(t2) || Ql(t2) || t2.z || t2.rotate || t2.rotateX || t2.rotateY;
}
function Ql(t2) {
  return lu(t2.x) || lu(t2.y);
}
function lu(t2) {
  return t2 && t2 !== "0%";
}
function li(t2, e2, r2) {
  const n2 = t2 - r2, i2 = e2 * n2;
  return r2 + i2;
}
function fu(t2, e2, r2, n2, i2) {
  return i2 !== void 0 && (t2 = li(t2, i2, n2)), li(t2, r2, n2) + e2;
}
function Oo(t2, e2 = 0, r2 = 1, n2, i2) {
  t2.min = fu(t2.min, e2, r2, n2, i2), t2.max = fu(t2.max, e2, r2, n2, i2);
}
function ef(t2, { x: e2, y: r2 }) {
  Oo(t2.x, e2.translate, e2.scale, e2.originPoint), Oo(t2.y, r2.translate, r2.scale, r2.originPoint);
}
function Zg(t2, e2, r2, n2 = false) {
  var i2, o2;
  const s2 = r2.length;
  if (!s2)
    return;
  e2.x = e2.y = 1;
  let a2, f2;
  for (let p2 = 0; p2 < s2; p2++)
    a2 = r2[p2], f2 = a2.projectionDelta, ((o2 = (i2 = a2.instance) === null || i2 === void 0 ? void 0 : i2.style) === null || o2 === void 0 ? void 0 : o2.display) !== "contents" && (n2 && a2.options.layoutScroll && a2.scroll && a2 !== a2.root && Dr(t2, {
      x: -a2.scroll.offset.x,
      y: -a2.scroll.offset.y
    }), f2 && (e2.x *= f2.x.scale, e2.y *= f2.y.scale, ef(t2, f2)), n2 && pr2(a2.latestValues) && Dr(t2, a2.latestValues));
  e2.x = hu(e2.x), e2.y = hu(e2.y);
}
function hu(t2) {
  return Number.isInteger(t2) || t2 > 1.0000000000001 || t2 < 0.999999999999 ? t2 : 1;
}
function sr(t2, e2) {
  t2.min = t2.min + e2, t2.max = t2.max + e2;
}
function du(t2, e2, [r2, n2, i2]) {
  const o2 = e2[i2] !== void 0 ? e2[i2] : 0.5, s2 = ot2(t2.min, t2.max, o2);
  Oo(t2, e2[r2], e2[n2], s2, e2.scale);
}
var Jg = ["x", "scaleX", "originX"];
var Qg = ["y", "scaleY", "originY"];
function Dr(t2, e2) {
  du(t2.x, e2, Jg), du(t2.y, e2, Qg);
}
function tf(t2, e2) {
  return Jl(Xg(t2.getBoundingClientRect(), e2));
}
function ey(t2, e2, r2) {
  const n2 = tf(t2, r2), { scroll: i2 } = e2;
  return i2 && (sr(n2.x, i2.offset.x), sr(n2.y, i2.offset.y)), n2;
}
var ty = /* @__PURE__ */ new WeakMap();
var ry = class {
  constructor(e2) {
    this.openGlobalLock = null, this.isDragging = false, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = false, this.hasMutatedConstraints = false, this.elastic = ct2(), this.visualElement = e2;
  }
  start(e2, { snapToCursor: r2 = false } = {}) {
    if (this.visualElement.isPresent === false)
      return;
    const n2 = (a2) => {
      this.stopAnimation(), r2 && this.snapToCursor(Is(a2, "page").point);
    }, i2 = (a2, f2) => {
      var p2;
      const { drag: d2, dragPropagation: y2, onDragStart: v3 } = this.getProps();
      d2 && !y2 && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = wl(d2), !this.openGlobalLock) || (this.isDragging = true, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = true, this.visualElement.projection.target = void 0), Ht((w3) => {
        var I3, N11;
        let k2 = this.getAxisMotionValue(w3).get() || 0;
        if (zt2.test(k2)) {
          const M3 = (N11 = (I3 = this.visualElement.projection) === null || I3 === void 0 ? void 0 : I3.layout) === null || N11 === void 0 ? void 0 : N11.layoutBox[w3];
          M3 && (k2 = Rt2(M3) * (parseFloat(k2) / 100));
        }
        this.originPoint[w3] = k2;
      }), v3 == null || v3(a2, f2), (p2 = this.visualElement.animationState) === null || p2 === void 0 || p2.setActive($e.Drag, true));
    }, o2 = (a2, f2) => {
      const { dragPropagation: p2, dragDirectionLock: d2, onDirectionLock: y2, onDrag: v3 } = this.getProps();
      if (!p2 && !this.openGlobalLock)
        return;
      const { offset: w3 } = f2;
      if (d2 && this.currentDirection === null) {
        this.currentDirection = ny(w3), this.currentDirection !== null && (y2 == null || y2(this.currentDirection));
        return;
      }
      this.updateAxis("x", f2.point, w3), this.updateAxis("y", f2.point, w3), this.visualElement.render(), v3 == null || v3(a2, f2);
    }, s2 = (a2, f2) => this.stop(a2, f2);
    this.panSession = new Xl(e2, {
      onSessionStart: n2,
      onStart: i2,
      onMove: o2,
      onSessionEnd: s2
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(e2, r2) {
    const n2 = this.isDragging;
    if (this.cancel(), !n2)
      return;
    const { velocity: i2 } = r2;
    this.startAnimation(i2);
    const { onDragEnd: o2 } = this.getProps();
    o2 == null || o2(e2, r2);
  }
  cancel() {
    var e2, r2;
    this.isDragging = false, this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = false), (e2 = this.panSession) === null || e2 === void 0 || e2.end(), this.panSession = void 0;
    const { dragPropagation: n2 } = this.getProps();
    !n2 && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), (r2 = this.visualElement.animationState) === null || r2 === void 0 || r2.setActive($e.Drag, false);
  }
  updateAxis(e2, r2, n2) {
    const { drag: i2 } = this.getProps();
    if (!n2 || !Kn(e2, i2, this.currentDirection))
      return;
    const o2 = this.getAxisMotionValue(e2);
    let s2 = this.originPoint[e2] + n2[e2];
    this.constraints && this.constraints[e2] && (s2 = qg(s2, this.constraints[e2], this.elastic[e2])), o2.set(s2);
  }
  resolveConstraints() {
    const { dragConstraints: e2, dragElastic: r2 } = this.getProps(), { layout: n2 } = this.visualElement.projection || {}, i2 = this.constraints;
    e2 && Br2(e2) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e2 && n2 ? this.constraints = Wg(n2.layoutBox, e2) : this.constraints = false, this.elastic = Gg(r2), i2 !== this.constraints && n2 && this.constraints && !this.hasMutatedConstraints && Ht((o2) => {
      this.getAxisMotionValue(o2) && (this.constraints[o2] = zg(n2.layoutBox[o2], this.constraints[o2]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e2, onMeasureDragConstraints: r2 } = this.getProps();
    if (!e2 || !Br2(e2))
      return false;
    const n2 = e2.current;
    Vt2(n2 !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: i2 } = this.visualElement;
    if (!i2 || !i2.layout)
      return false;
    const o2 = ey(n2, i2.root, this.visualElement.getTransformPagePoint());
    let s2 = Hg(i2.layout.layoutBox, o2);
    if (r2) {
      const a2 = r2(Yg(s2));
      this.hasMutatedConstraints = !!a2, a2 && (s2 = Jl(a2));
    }
    return s2;
  }
  startAnimation(e2) {
    const { drag: r2, dragMomentum: n2, dragElastic: i2, dragTransition: o2, dragSnapToOrigin: s2, onDragTransitionEnd: a2 } = this.getProps(), f2 = this.constraints || {}, p2 = Ht((d2) => {
      if (!Kn(d2, r2, this.currentDirection))
        return;
      let y2 = (f2 == null ? void 0 : f2[d2]) || {};
      s2 && (y2 = { min: 0, max: 0 });
      const v3 = i2 ? 200 : 1e6, w3 = i2 ? 40 : 1e7, I3 = {
        type: "inertia",
        velocity: n2 ? e2[d2] : 0,
        bounceStiffness: v3,
        bounceDamping: w3,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...o2,
        ...y2
      };
      return this.startAxisValueAnimation(d2, I3);
    });
    return Promise.all(p2).then(a2);
  }
  startAxisValueAnimation(e2, r2) {
    const n2 = this.getAxisMotionValue(e2);
    return n2.start(Gs(e2, n2, 0, r2));
  }
  stopAnimation() {
    Ht((e2) => this.getAxisMotionValue(e2).stop());
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e2) {
    var r2;
    const n2 = "_drag" + e2.toUpperCase(), i2 = this.visualElement.getProps()[n2];
    return i2 || this.visualElement.getValue(e2, ((r2 = this.visualElement.getProps().initial) === null || r2 === void 0 ? void 0 : r2[e2]) || 0);
  }
  snapToCursor(e2) {
    Ht((r2) => {
      const { drag: n2 } = this.getProps();
      if (!Kn(r2, n2, this.currentDirection))
        return;
      const { projection: i2 } = this.visualElement, o2 = this.getAxisMotionValue(r2);
      if (i2 && i2.layout) {
        const { min: s2, max: a2 } = i2.layout.layoutBox[r2];
        o2.set(e2[r2] - ot2(s2, a2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    var e2;
    if (!this.visualElement.current)
      return;
    const { drag: r2, dragConstraints: n2 } = this.getProps(), { projection: i2 } = this.visualElement;
    if (!Br2(n2) || !i2 || !this.constraints)
      return;
    this.stopAnimation();
    const o2 = { x: 0, y: 0 };
    Ht((a2) => {
      const f2 = this.getAxisMotionValue(a2);
      if (f2) {
        const p2 = f2.get();
        o2[a2] = Kg({ min: p2, max: p2 }, this.constraints[a2]);
      }
    });
    const { transformTemplate: s2 } = this.visualElement.getProps();
    this.visualElement.current.style.transform = s2 ? s2({}, "") : "none", (e2 = i2.root) === null || e2 === void 0 || e2.updateScroll(), i2.updateLayout(), this.resolveConstraints(), Ht((a2) => {
      if (!Kn(a2, r2, null))
        return;
      const f2 = this.getAxisMotionValue(a2), { min: p2, max: d2 } = this.constraints[a2];
      f2.set(ot2(p2, d2, o2[a2]));
    });
  }
  addListeners() {
    var e2;
    if (!this.visualElement.current)
      return;
    ty.set(this.visualElement, this);
    const r2 = this.visualElement.current, n2 = Fr(r2, "pointerdown", (p2) => {
      const { drag: d2, dragListener: y2 = true } = this.getProps();
      d2 && y2 && this.start(p2);
    }), i2 = () => {
      const { dragConstraints: p2 } = this.getProps();
      Br2(p2) && (this.constraints = this.resolveRefConstraints());
    }, { projection: o2 } = this.visualElement, s2 = o2.addEventListener("measure", i2);
    o2 && !o2.layout && ((e2 = o2.root) === null || e2 === void 0 || e2.updateScroll(), o2.updateLayout()), i2();
    const a2 = Ai(window, "resize", () => this.scalePositionWithinConstraints()), f2 = o2.addEventListener("didUpdate", ({ delta: p2, hasLayoutChanged: d2 }) => {
      this.isDragging && d2 && (Ht((y2) => {
        const v3 = this.getAxisMotionValue(y2);
        v3 && (this.originPoint[y2] += p2[y2].translate, v3.set(v3.get() + p2[y2].translate));
      }), this.visualElement.render());
    });
    return () => {
      a2(), n2(), s2(), f2 == null || f2();
    };
  }
  getProps() {
    const e2 = this.visualElement.getProps(), { drag: r2 = false, dragDirectionLock: n2 = false, dragPropagation: i2 = false, dragConstraints: o2 = false, dragElastic: s2 = Po, dragMomentum: a2 = true } = e2;
    return {
      ...e2,
      drag: r2,
      dragDirectionLock: n2,
      dragPropagation: i2,
      dragConstraints: o2,
      dragElastic: s2,
      dragMomentum: a2
    };
  }
};
function Kn(t2, e2, r2) {
  return (e2 === true || e2 === t2) && (r2 === null || r2 === t2);
}
function ny(t2, e2 = 10) {
  let r2 = null;
  return Math.abs(t2.y) > e2 ? r2 = "y" : Math.abs(t2.x) > e2 && (r2 = "x"), r2;
}
function iy(t2) {
  const { dragControls: e2, visualElement: r2 } = t2, n2 = Ei(() => new ry(r2));
  (0, import_react.useEffect)(() => e2 && e2.subscribe(n2), [n2, e2]), (0, import_react.useEffect)(() => n2.addListeners(), [n2]);
}
function oy({ onPan: t2, onPanStart: e2, onPanEnd: r2, onPanSessionStart: n2, visualElement: i2 }) {
  const o2 = t2 || e2 || r2 || n2, s2 = (0, import_react.useRef)(null), { transformPagePoint: a2 } = (0, import_react.useContext)(xs), f2 = {
    onSessionStart: n2,
    onStart: e2,
    onMove: t2,
    onEnd: (d2, y2) => {
      s2.current = null, r2 && r2(d2, y2);
    }
  };
  (0, import_react.useEffect)(() => {
    s2.current !== null && s2.current.updateHandlers(f2);
  });
  function p2(d2) {
    s2.current = new Xl(d2, f2, {
      transformPagePoint: a2
    });
  }
  oi(i2, "pointerdown", o2 && p2), Bs(() => s2.current && s2.current.end());
}
var sy = {
  pan: ar(oy),
  drag: ar(iy)
};
function Ro(t2) {
  return typeof t2 == "string" && t2.startsWith("var(--");
}
var rf = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function ay(t2) {
  const e2 = rf.exec(t2);
  if (!e2)
    return [,];
  const [, r2, n2] = e2;
  return [r2, n2];
}
var uy = 4;
function Io(t2, e2, r2 = 1) {
  Vt2(r2 <= uy, `Max CSS variable fallback depth detected in property "${t2}". This may indicate a circular fallback dependency.`);
  const [n2, i2] = ay(t2);
  if (!n2)
    return;
  const o2 = window.getComputedStyle(e2).getPropertyValue(n2);
  return o2 ? o2.trim() : Ro(i2) ? Io(i2, e2, r2 + 1) : i2;
}
function cy(t2, { ...e2 }, r2) {
  const n2 = t2.current;
  if (!(n2 instanceof Element))
    return { target: e2, transitionEnd: r2 };
  r2 && (r2 = { ...r2 }), t2.values.forEach((i2) => {
    const o2 = i2.get();
    if (!Ro(o2))
      return;
    const s2 = Io(o2, n2);
    s2 && i2.set(s2);
  });
  for (const i2 in e2) {
    const o2 = e2[i2];
    if (!Ro(o2))
      continue;
    const s2 = Io(o2, n2);
    s2 && (e2[i2] = s2, r2 && r2[i2] === void 0 && (r2[i2] = o2));
  }
  return { target: e2, transitionEnd: r2 };
}
var ly = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
var nf = (t2) => ly.has(t2);
var fy = (t2) => Object.keys(t2).some(nf);
var zn = (t2) => t2 === Mr || t2 === Se;
var pu;
(function(t2) {
  t2.width = "width", t2.height = "height", t2.left = "left", t2.right = "right", t2.top = "top", t2.bottom = "bottom";
})(pu || (pu = {}));
var mu = (t2, e2) => parseFloat(t2.split(", ")[e2]);
var gu = (t2, e2) => (r2, { transform: n2 }) => {
  if (n2 === "none" || !n2)
    return 0;
  const i2 = n2.match(/^matrix3d\((.+)\)$/);
  if (i2)
    return mu(i2[1], e2);
  {
    const o2 = n2.match(/^matrix\((.+)\)$/);
    return o2 ? mu(o2[1], t2) : 0;
  }
};
var hy = /* @__PURE__ */ new Set(["x", "y", "z"]);
var dy = ri.filter((t2) => !hy.has(t2));
function py(t2) {
  const e2 = [];
  return dy.forEach((r2) => {
    const n2 = t2.getValue(r2);
    n2 !== void 0 && (e2.push([r2, n2.get()]), n2.set(r2.startsWith("scale") ? 1 : 0));
  }), e2.length && t2.render(), e2;
}
var yu = {
  // Dimensions
  width: ({ x: t2 }, { paddingLeft: e2 = "0", paddingRight: r2 = "0" }) => t2.max - t2.min - parseFloat(e2) - parseFloat(r2),
  height: ({ y: t2 }, { paddingTop: e2 = "0", paddingBottom: r2 = "0" }) => t2.max - t2.min - parseFloat(e2) - parseFloat(r2),
  top: (t2, { top: e2 }) => parseFloat(e2),
  left: (t2, { left: e2 }) => parseFloat(e2),
  bottom: ({ y: t2 }, { top: e2 }) => parseFloat(e2) + (t2.max - t2.min),
  right: ({ x: t2 }, { left: e2 }) => parseFloat(e2) + (t2.max - t2.min),
  // Transform
  x: gu(4, 13),
  y: gu(5, 14)
};
var my = (t2, e2, r2) => {
  const n2 = e2.measureViewportBox(), i2 = e2.current, o2 = getComputedStyle(i2), { display: s2 } = o2, a2 = {};
  s2 === "none" && e2.setStaticValue("display", t2.display || "block"), r2.forEach((p2) => {
    a2[p2] = yu[p2](n2, o2);
  }), e2.render();
  const f2 = e2.measureViewportBox();
  return r2.forEach((p2) => {
    const d2 = e2.getValue(p2);
    d2 && d2.jump(a2[p2]), t2[p2] = yu[p2](f2, o2);
  }), t2;
};
var gy = (t2, e2, r2 = {}, n2 = {}) => {
  e2 = { ...e2 }, n2 = { ...n2 };
  const i2 = Object.keys(e2).filter(nf);
  let o2 = [], s2 = false;
  const a2 = [];
  if (i2.forEach((f2) => {
    const p2 = t2.getValue(f2);
    if (!t2.hasValue(f2))
      return;
    let d2 = r2[f2], y2 = sn(d2);
    const v3 = e2[f2];
    let w3;
    if (ii(v3)) {
      const I3 = v3.length, N11 = v3[0] === null ? 1 : 0;
      d2 = v3[N11], y2 = sn(d2);
      for (let k2 = N11; k2 < I3; k2++)
        w3 ? Vt2(sn(v3[k2]) === w3, "All keyframes must be of the same type") : (w3 = sn(v3[k2]), Vt2(w3 === y2 || zn(y2) && zn(w3), "Keyframes must be of the same dimension as the current value"));
    } else
      w3 = sn(v3);
    if (y2 !== w3)
      if (zn(y2) && zn(w3)) {
        const I3 = p2.get();
        typeof I3 == "string" && p2.set(parseFloat(I3)), typeof v3 == "string" ? e2[f2] = parseFloat(v3) : Array.isArray(v3) && w3 === Se && (e2[f2] = v3.map(parseFloat));
      } else
        y2 != null && y2.transform && (w3 != null && w3.transform) && (d2 === 0 || v3 === 0) ? d2 === 0 ? p2.set(w3.transform(d2)) : e2[f2] = y2.transform(v3) : (s2 || (o2 = py(t2), s2 = true), a2.push(f2), n2[f2] = n2[f2] !== void 0 ? n2[f2] : e2[f2], p2.jump(v3));
  }), a2.length) {
    const f2 = a2.indexOf("height") >= 0 ? window.pageYOffset : null, p2 = my(e2, t2, a2);
    return o2.length && o2.forEach(([d2, y2]) => {
      t2.getValue(d2).set(y2);
    }), t2.render(), bi && f2 !== null && window.scrollTo({ top: f2 }), { target: p2, transitionEnd: n2 };
  } else
    return { target: e2, transitionEnd: n2 };
};
function yy(t2, e2, r2, n2) {
  return fy(e2) ? gy(t2, e2, r2, n2) : { target: e2, transitionEnd: n2 };
}
var vy = (t2, e2, r2, n2) => {
  const i2 = cy(t2, e2, n2);
  return e2 = i2.target, n2 = i2.transitionEnd, yy(t2, e2, r2, n2);
};
var Bo = { current: null };
var of = { current: false };
function wy() {
  if (of.current = true, !!bi)
    if (window.matchMedia) {
      const t2 = window.matchMedia("(prefers-reduced-motion)"), e2 = () => Bo.current = t2.matches;
      t2.addListener(e2), e2();
    } else
      Bo.current = false;
}
function _y(t2, e2, r2) {
  const { willChange: n2 } = e2;
  for (const i2 in e2) {
    const o2 = e2[i2], s2 = r2[i2];
    if (St(o2))
      t2.addValue(i2, o2), ai(n2) && n2.add(i2), Si(o2.version === "8.5.5", `Attempting to mix Framer Motion versions ${o2.version} with 8.5.5 may not work as expected.`);
    else if (St(s2))
      t2.addValue(i2, Gr(o2, { owner: t2 })), ai(n2) && n2.remove(i2);
    else if (s2 !== o2)
      if (t2.hasValue(i2)) {
        const a2 = t2.getValue(i2);
        !a2.hasAnimated && a2.set(o2);
      } else {
        const a2 = t2.getStaticValue(i2);
        t2.addValue(i2, Gr(a2 !== void 0 ? a2 : o2, { owner: t2 }));
      }
  }
  for (const i2 in r2)
    e2[i2] === void 0 && t2.removeValue(i2);
  return e2;
}
var sf = Object.keys(xn);
var by = sf.length;
var vu = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
var xy = class {
  constructor({ parent: e2, props: r2, reducedMotionConfig: n2, visualState: i2 }, o2 = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = false, this.isControllingVariants = false, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.isPresent = true, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.scheduleRender = () => _t2.render(this.render, false, true);
    const { latestValues: s2, renderState: a2 } = i2;
    this.latestValues = s2, this.baseTarget = { ...s2 }, this.initialValues = r2.initial ? { ...s2 } : {}, this.renderState = a2, this.parent = e2, this.props = r2, this.depth = e2 ? e2.depth + 1 : 0, this.reducedMotionConfig = n2, this.options = o2, this.isControllingVariants = Ti(r2), this.isVariantNode = nl(r2), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e2 && e2.current);
    const { willChange: f2, ...p2 } = this.scrapeMotionValuesFromProps(r2, {});
    for (const d2 in p2) {
      const y2 = p2[d2];
      s2[d2] !== void 0 && St(y2) && (y2.set(s2[d2], false), ai(f2) && f2.add(d2));
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e2, r2) {
    return {};
  }
  mount(e2) {
    var r2;
    this.current = e2, this.projection && this.projection.mount(e2), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = (r2 = this.parent) === null || r2 === void 0 ? void 0 : r2.addVariantChild(this)), this.values.forEach((n2, i2) => this.bindToMotionValue(i2, n2)), of.current || wy(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : Bo.current, Si(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.setProps(this.props);
  }
  unmount() {
    var e2, r2, n2;
    (e2 = this.projection) === null || e2 === void 0 || e2.unmount(), cr.update(this.notifyUpdate), cr.render(this.render), this.valueSubscriptions.forEach((i2) => i2()), (r2 = this.removeFromVariantTree) === null || r2 === void 0 || r2.call(this), (n2 = this.parent) === null || n2 === void 0 || n2.children.delete(this);
    for (const i2 in this.events)
      this.events[i2].clear();
    this.current = null;
  }
  bindToMotionValue(e2, r2) {
    const n2 = Yr.has(e2), i2 = r2.on("change", (s2) => {
      this.latestValues[e2] = s2, this.props.onUpdate && _t2.update(this.notifyUpdate, false, true), n2 && this.projection && (this.projection.isTransformDirty = true);
    }), o2 = r2.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(e2, () => {
      i2(), o2();
    });
  }
  sortNodePosition(e2) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e2.type ? 0 : this.sortInstanceNodePosition(this.current, e2.current);
  }
  loadFeatures({ children: e2, ...r2 }, n2, i2, o2, s2, a2) {
    const f2 = [];
    i2 && n2 && Vt2(false, "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.");
    for (let p2 = 0; p2 < by; p2++) {
      const d2 = sf[p2], { isEnabled: y2, Component: v3 } = xn[d2];
      y2(r2) && v3 && f2.push((0, import_react.createElement)(v3, {
        key: d2,
        ...r2,
        visualElement: this
      }));
    }
    if (!this.projection && s2) {
      this.projection = new s2(o2, this.latestValues, this.parent && this.parent.projection);
      const { layoutId: p2, layout: d2, drag: y2, dragConstraints: v3, layoutScroll: w3, layoutRoot: I3 } = r2;
      this.projection.setOptions({
        layoutId: p2,
        layout: d2,
        alwaysMeasureLayout: !!y2 || v3 && Br2(v3),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof d2 == "string" ? d2 : "both",
        initialPromotionConfig: a2,
        layoutScroll: w3,
        layoutRoot: I3
      });
    }
    return f2;
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ct2();
  }
  getStaticValue(e2) {
    return this.latestValues[e2];
  }
  setStaticValue(e2, r2) {
    this.latestValues[e2] = r2;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(e2, r2 = true) {
    return this.makeTargetAnimatableFromInstance(e2, this.props, r2);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  setProps(e2) {
    (e2.transformTemplate || this.props.transformTemplate) && this.scheduleRender();
    const r2 = this.props;
    this.props = e2;
    for (let n2 = 0; n2 < vu.length; n2++) {
      const i2 = vu[n2];
      this.propEventSubscriptions[i2] && (this.propEventSubscriptions[i2](), delete this.propEventSubscriptions[i2]);
      const o2 = e2["on" + i2];
      o2 && (this.propEventSubscriptions[i2] = this.on(i2, o2));
    }
    this.prevMotionValues = _y(this, this.scrapeMotionValuesFromProps(e2, r2), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e2) {
    var r2;
    return (r2 = this.props.variants) === null || r2 === void 0 ? void 0 : r2[e2];
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    var e2;
    return this.isVariantNode ? this : (e2 = this.parent) === null || e2 === void 0 ? void 0 : e2.getClosestVariantNode();
  }
  getVariantContext(e2 = false) {
    var r2, n2;
    if (e2)
      return (r2 = this.parent) === null || r2 === void 0 ? void 0 : r2.getVariantContext();
    if (!this.isControllingVariants) {
      const o2 = ((n2 = this.parent) === null || n2 === void 0 ? void 0 : n2.getVariantContext()) || {};
      return this.props.initial !== void 0 && (o2.initial = this.props.initial), o2;
    }
    const i2 = {};
    for (let o2 = 0; o2 < Ty; o2++) {
      const s2 = af[o2], a2 = this.props[s2];
      (bn(a2) || a2 === false) && (i2[s2] = a2);
    }
    return i2;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e2) {
    var r2;
    const n2 = this.getClosestVariantNode();
    if (n2)
      return (r2 = n2.variantChildren) === null || r2 === void 0 || r2.add(e2), () => n2.variantChildren.delete(e2);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e2, r2) {
    r2 !== this.values.get(e2) && (this.removeValue(e2), this.bindToMotionValue(e2, r2)), this.values.set(e2, r2), this.latestValues[e2] = r2.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e2) {
    var r2;
    this.values.delete(e2), (r2 = this.valueSubscriptions.get(e2)) === null || r2 === void 0 || r2(), this.valueSubscriptions.delete(e2), delete this.latestValues[e2], this.removeValueFromRenderState(e2, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e2) {
    return this.values.has(e2);
  }
  getValue(e2, r2) {
    if (this.props.values && this.props.values[e2])
      return this.props.values[e2];
    let n2 = this.values.get(e2);
    return n2 === void 0 && r2 !== void 0 && (n2 = Gr(r2, { owner: this }), this.addValue(e2, n2)), n2;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e2) {
    return this.latestValues[e2] !== void 0 || !this.current ? this.latestValues[e2] : this.readValueFromInstance(this.current, e2, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e2, r2) {
    this.baseTarget[e2] = r2;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e2) {
    var r2;
    const { initial: n2 } = this.props, i2 = typeof n2 == "string" || typeof n2 == "object" ? (r2 = Rs(this.props, n2)) === null || r2 === void 0 ? void 0 : r2[e2] : void 0;
    if (n2 && i2 !== void 0)
      return i2;
    const o2 = this.getBaseTargetFromProps(this.props, e2);
    return o2 !== void 0 && !St(o2) ? o2 : this.initialValues[e2] !== void 0 && i2 === void 0 ? void 0 : this.baseTarget[e2];
  }
  on(e2, r2) {
    return this.events[e2] || (this.events[e2] = new Ls()), this.events[e2].add(r2);
  }
  notify(e2, ...r2) {
    var n2;
    (n2 = this.events[e2]) === null || n2 === void 0 || n2.notify(...r2);
  }
};
var af = ["initial", ...Ys];
var Ty = af.length;
var uf = class extends xy {
  sortInstanceNodePosition(e2, r2) {
    return e2.compareDocumentPosition(r2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e2, r2) {
    var n2;
    return (n2 = e2.style) === null || n2 === void 0 ? void 0 : n2[r2];
  }
  removeValueFromRenderState(e2, { vars: r2, style: n2 }) {
    delete r2[e2], delete n2[e2];
  }
  makeTargetAnimatableFromInstance({ transition: e2, transitionEnd: r2, ...n2 }, { transformValues: i2 }, o2) {
    let s2 = Bm(n2, e2 || {}, this);
    if (i2 && (r2 && (r2 = i2(r2)), n2 && (n2 = i2(n2)), s2 && (s2 = i2(s2))), o2) {
      Rm(this, n2, s2);
      const a2 = vy(this, n2, s2, r2);
      r2 = a2.transitionEnd, n2 = a2.target;
    }
    return {
      transition: e2,
      transitionEnd: r2,
      ...n2
    };
  }
};
function Ey(t2) {
  return window.getComputedStyle(t2);
}
var Ay = class extends uf {
  readValueFromInstance(e2, r2) {
    if (Yr.has(r2)) {
      const n2 = Fs(r2);
      return n2 && n2.default || 0;
    } else {
      const n2 = Ey(e2), i2 = (sl(r2) ? n2.getPropertyValue(r2) : n2[r2]) || 0;
      return typeof i2 == "string" ? i2.trim() : i2;
    }
  }
  measureInstanceViewportBox(e2, { transformPagePoint: r2 }) {
    return tf(e2, r2);
  }
  build(e2, r2, n2, i2) {
    As(e2, r2, n2, i2.transformTemplate);
  }
  scrapeMotionValuesFromProps(e2, r2) {
    return Os(e2, r2);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e2 } = this.props;
    St(e2) && (this.childSubscription = e2.on("change", (r2) => {
      this.current && (this.current.textContent = `${r2}`);
    }));
  }
  renderInstance(e2, r2, n2, i2) {
    fl(e2, r2, n2, i2);
  }
};
var My = class extends uf {
  constructor() {
    super(...arguments), this.isSVGTag = false;
  }
  getBaseTargetFromProps(e2, r2) {
    return e2[r2];
  }
  readValueFromInstance(e2, r2) {
    var n2;
    return Yr.has(r2) ? ((n2 = Fs(r2)) === null || n2 === void 0 ? void 0 : n2.default) || 0 : (r2 = hl.has(r2) ? r2 : Cs(r2), e2.getAttribute(r2));
  }
  measureInstanceViewportBox() {
    return ct2();
  }
  scrapeMotionValuesFromProps(e2, r2) {
    return pl(e2, r2);
  }
  build(e2, r2, n2, i2) {
    Ss(e2, r2, n2, this.isSVGTag, i2.transformTemplate);
  }
  renderInstance(e2, r2, n2, i2) {
    dl(e2, r2, n2, i2);
  }
  mount(e2) {
    this.isSVGTag = Ps(e2.tagName), super.mount(e2);
  }
};
var Sy = (t2, e2) => Es(t2) ? new My(e2, { enableHardwareAcceleration: false }) : new Ay(e2, { enableHardwareAcceleration: true });
function wu(t2, e2) {
  return e2.max === e2.min ? 0 : t2 / (e2.max - e2.min) * 100;
}
var an = {
  correct: (t2, e2) => {
    if (!e2.target)
      return t2;
    if (typeof t2 == "string")
      if (Se.test(t2))
        t2 = parseFloat(t2);
      else
        return t2;
    const r2 = wu(t2, e2.target.x), n2 = wu(t2, e2.target.y);
    return `${r2}% ${n2}%`;
  }
};
var _u = "_$css";
var Py = {
  correct: (t2, { treeScale: e2, projectionDelta: r2 }) => {
    const n2 = t2, i2 = t2.includes("var("), o2 = [];
    i2 && (t2 = t2.replace(rf, (w3) => (o2.push(w3), _u)));
    const s2 = lr2.parse(t2);
    if (s2.length > 5)
      return n2;
    const a2 = lr2.createTransformer(t2), f2 = typeof s2[0] != "number" ? 1 : 0, p2 = r2.x.scale * e2.x, d2 = r2.y.scale * e2.y;
    s2[0 + f2] /= p2, s2[1 + f2] /= d2;
    const y2 = ot2(p2, d2, 0.5);
    typeof s2[2 + f2] == "number" && (s2[2 + f2] /= y2), typeof s2[3 + f2] == "number" && (s2[3 + f2] /= y2);
    let v3 = a2(s2);
    if (i2) {
      let w3 = 0;
      v3 = v3.replace(_u, () => {
        const I3 = o2[w3];
        return w3++, I3;
      });
    }
    return v3;
  }
};
var Cy = class extends import_react.default.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e2, layoutGroup: r2, switchLayoutGroup: n2, layoutId: i2 } = this.props, { projection: o2 } = e2;
    _0(Ry), o2 && (r2.group && r2.group.add(o2), n2 && n2.register && i2 && n2.register(o2), o2.root.didUpdate(), o2.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), o2.setOptions({
      ...o2.options,
      onExitComplete: () => this.safeToRemove()
    })), pn.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(e2) {
    const { layoutDependency: r2, visualElement: n2, drag: i2, isPresent: o2 } = this.props, s2 = n2.projection;
    return s2 && (s2.isPresent = o2, i2 || e2.layoutDependency !== r2 || r2 === void 0 ? s2.willUpdate() : this.safeToRemove(), e2.isPresent !== o2 && (o2 ? s2.promote() : s2.relegate() || _t2.postRender(() => {
      var a2;
      !((a2 = s2.getStack()) === null || a2 === void 0) && a2.members.length || this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e2 } = this.props.visualElement;
    e2 && (e2.root.didUpdate(), !e2.currentAnimation && e2.isLead() && this.safeToRemove());
  }
  componentWillUnmount() {
    const { visualElement: e2, layoutGroup: r2, switchLayoutGroup: n2 } = this.props, { projection: i2 } = e2;
    i2 && (i2.scheduleCheckAfterUnmount(), r2 != null && r2.group && r2.group.remove(i2), n2 != null && n2.deregister && n2.deregister(i2));
  }
  safeToRemove() {
    const { safeToRemove: e2 } = this.props;
    e2 == null || e2();
  }
  render() {
    return null;
  }
};
function Oy(t2) {
  const [e2, r2] = xl(), n2 = (0, import_react.useContext)(Ts);
  return import_react.default.createElement(Cy, { ...t2, layoutGroup: n2, switchLayoutGroup: (0, import_react.useContext)(il), isPresent: e2, safeToRemove: r2 });
}
var Ry = {
  borderRadius: {
    ...an,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: an,
  borderTopRightRadius: an,
  borderBottomLeftRadius: an,
  borderBottomRightRadius: an,
  boxShadow: Py
};
var Iy = {
  measureLayout: Oy
};
function By(t2, e2, r2 = {}) {
  const n2 = St(t2) ? t2 : Gr(t2);
  return n2.start(Gs("", n2, e2, r2)), {
    stop: () => n2.stop(),
    isAnimating: () => n2.isAnimating()
  };
}
var cf = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var ky = cf.length;
var bu = (t2) => typeof t2 == "string" ? parseFloat(t2) : t2;
var xu = (t2) => typeof t2 == "number" || Se.test(t2);
function Dy(t2, e2, r2, n2, i2, o2) {
  i2 ? (t2.opacity = ot2(
    0,
    // TODO Reinstate this if only child
    r2.opacity !== void 0 ? r2.opacity : 1,
    Ly(n2)
  ), t2.opacityExit = ot2(e2.opacity !== void 0 ? e2.opacity : 1, 0, Ny(n2))) : o2 && (t2.opacity = ot2(e2.opacity !== void 0 ? e2.opacity : 1, r2.opacity !== void 0 ? r2.opacity : 1, n2));
  for (let s2 = 0; s2 < ky; s2++) {
    const a2 = `border${cf[s2]}Radius`;
    let f2 = Tu(e2, a2), p2 = Tu(r2, a2);
    if (f2 === void 0 && p2 === void 0)
      continue;
    f2 || (f2 = 0), p2 || (p2 = 0), f2 === 0 || p2 === 0 || xu(f2) === xu(p2) ? (t2[a2] = Math.max(ot2(bu(f2), bu(p2), n2), 0), (zt2.test(p2) || zt2.test(f2)) && (t2[a2] += "%")) : t2[a2] = p2;
  }
  (e2.rotate || r2.rotate) && (t2.rotate = ot2(e2.rotate || 0, r2.rotate || 0, n2));
}
function Tu(t2, e2) {
  return t2[e2] !== void 0 ? t2[e2] : t2.borderRadius;
}
var Ly = lf(0, 0.5, Ks);
var Ny = lf(0.5, 0.95, Hs);
function lf(t2, e2, r2) {
  return (n2) => n2 < t2 ? 0 : n2 > e2 ? 1 : r2(ui(t2, e2, n2));
}
function Eu(t2, e2) {
  t2.min = e2.min, t2.max = e2.max;
}
function jt(t2, e2) {
  Eu(t2.x, e2.x), Eu(t2.y, e2.y);
}
function Au(t2, e2, r2, n2, i2) {
  return t2 -= e2, t2 = li(t2, 1 / r2, n2), i2 !== void 0 && (t2 = li(t2, 1 / i2, n2)), t2;
}
function Uy(t2, e2 = 0, r2 = 1, n2 = 0.5, i2, o2 = t2, s2 = t2) {
  if (zt2.test(e2) && (e2 = parseFloat(e2), e2 = ot2(s2.min, s2.max, e2 / 100) - s2.min), typeof e2 != "number")
    return;
  let a2 = ot2(o2.min, o2.max, n2);
  t2 === o2 && (a2 -= e2), t2.min = Au(t2.min, e2, r2, a2, i2), t2.max = Au(t2.max, e2, r2, a2, i2);
}
function Mu(t2, e2, [r2, n2, i2], o2, s2) {
  Uy(t2, e2[r2], e2[n2], e2[i2], e2.scale, o2, s2);
}
var Fy = ["x", "scaleX", "originX"];
var jy = ["y", "scaleY", "originY"];
function Su(t2, e2, r2, n2) {
  Mu(t2.x, e2, Fy, r2 == null ? void 0 : r2.x, n2 == null ? void 0 : n2.x), Mu(t2.y, e2, jy, r2 == null ? void 0 : r2.y, n2 == null ? void 0 : n2.y);
}
function Pu(t2) {
  return t2.translate === 0 && t2.scale === 1;
}
function ff(t2) {
  return Pu(t2.x) && Pu(t2.y);
}
function hf(t2, e2) {
  return t2.x.min === e2.x.min && t2.x.max === e2.x.max && t2.y.min === e2.y.min && t2.y.max === e2.y.max;
}
function Cu(t2) {
  return Rt2(t2.x) / Rt2(t2.y);
}
var $y = class {
  constructor() {
    this.members = [];
  }
  add(e2) {
    ks(this.members, e2), e2.scheduleRender();
  }
  remove(e2) {
    if (Ds(this.members, e2), e2 === this.prevLead && (this.prevLead = void 0), e2 === this.lead) {
      const r2 = this.members[this.members.length - 1];
      r2 && this.promote(r2);
    }
  }
  relegate(e2) {
    const r2 = this.members.findIndex((i2) => e2 === i2);
    if (r2 === 0)
      return false;
    let n2;
    for (let i2 = r2; i2 >= 0; i2--) {
      const o2 = this.members[i2];
      if (o2.isPresent !== false) {
        n2 = o2;
        break;
      }
    }
    return n2 ? (this.promote(n2), true) : false;
  }
  promote(e2, r2) {
    var n2;
    const i2 = this.lead;
    if (e2 !== i2 && (this.prevLead = i2, this.lead = e2, e2.show(), i2)) {
      i2.instance && i2.scheduleRender(), e2.scheduleRender(), e2.resumeFrom = i2, r2 && (e2.resumeFrom.preserveOpacity = true), i2.snapshot && (e2.snapshot = i2.snapshot, e2.snapshot.latestValues = i2.animationValues || i2.latestValues), !((n2 = e2.root) === null || n2 === void 0) && n2.isUpdating && (e2.isLayoutDirty = true);
      const { crossfade: o2 } = e2.options;
      o2 === false && i2.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e2) => {
      var r2, n2, i2, o2, s2;
      (n2 = (r2 = e2.options).onExitComplete) === null || n2 === void 0 || n2.call(r2), (s2 = (i2 = e2.resumingFrom) === null || i2 === void 0 ? void 0 : (o2 = i2.options).onExitComplete) === null || s2 === void 0 || s2.call(o2);
    });
  }
  scheduleRender() {
    this.members.forEach((e2) => {
      e2.instance && e2.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
};
function Ou(t2, e2, r2) {
  let n2 = "";
  const i2 = t2.x.translate / e2.x, o2 = t2.y.translate / e2.y;
  if ((i2 || o2) && (n2 = `translate3d(${i2}px, ${o2}px, 0) `), (e2.x !== 1 || e2.y !== 1) && (n2 += `scale(${1 / e2.x}, ${1 / e2.y}) `), r2) {
    const { rotate: f2, rotateX: p2, rotateY: d2 } = r2;
    f2 && (n2 += `rotate(${f2}deg) `), p2 && (n2 += `rotateX(${p2}deg) `), d2 && (n2 += `rotateY(${d2}deg) `);
  }
  const s2 = t2.x.scale * e2.x, a2 = t2.y.scale * e2.y;
  return (s2 !== 1 || a2 !== 1) && (n2 += `scale(${s2}, ${a2})`), n2 || "none";
}
var Vy = (t2, e2) => t2.depth - e2.depth;
var qy = class {
  constructor() {
    this.children = [], this.isDirty = false;
  }
  add(e2) {
    ks(this.children, e2), this.isDirty = true;
  }
  remove(e2) {
    Ds(this.children, e2), this.isDirty = true;
  }
  forEach(e2) {
    this.isDirty && this.children.sort(Vy), this.isDirty = false, this.children.forEach(e2);
  }
};
var Ru = ["", "X", "Y", "Z"];
var Iu = 1e3;
var Wy = 0;
function df({ attachResizeListener: t2, defaultParent: e2, measureScroll: r2, checkIsScrollRoot: n2, resetTransform: i2 }) {
  return class {
    constructor(s2, a2 = {}, f2 = e2 == null ? void 0 : e2()) {
      this.id = Wy++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = false, this.isAnimationBlocked = false, this.isLayoutDirty = false, this.isTransformDirty = false, this.isProjectionDirty = false, this.updateManuallyBlocked = false, this.updateBlockedByResize = false, this.isUpdating = false, this.isSVG = false, this.needsReset = false, this.shouldResetTransform = false, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.potentialNodes = /* @__PURE__ */ new Map(), this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = false, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.nodes.forEach(zy), this.nodes.forEach(Xy), this.nodes.forEach(Zy);
      }, this.hasProjected = false, this.isVisible = true, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.elementId = s2, this.latestValues = a2, this.root = f2 ? f2.root || f2 : this, this.path = f2 ? [...f2.path, f2] : [], this.parent = f2, this.depth = f2 ? f2.depth + 1 : 0, s2 && this.root.registerPotentialNode(s2, this);
      for (let p2 = 0; p2 < this.path.length; p2++)
        this.path[p2].shouldResetTransform = true;
      this.root === this && (this.nodes = new qy());
    }
    addEventListener(s2, a2) {
      return this.eventHandlers.has(s2) || this.eventHandlers.set(s2, new Ls()), this.eventHandlers.get(s2).add(a2);
    }
    notifyListeners(s2, ...a2) {
      const f2 = this.eventHandlers.get(s2);
      f2 == null || f2.notify(...a2);
    }
    hasListeners(s2) {
      return this.eventHandlers.has(s2);
    }
    registerPotentialNode(s2, a2) {
      this.potentialNodes.set(s2, a2);
    }
    /**
     * Lifecycles
     */
    mount(s2, a2 = false) {
      var f2;
      if (this.instance)
        return;
      this.isSVG = s2 instanceof SVGElement && s2.tagName !== "svg", this.instance = s2;
      const { layoutId: p2, layout: d2, visualElement: y2 } = this.options;
      if (y2 && !y2.current && y2.mount(s2), this.root.nodes.add(this), (f2 = this.parent) === null || f2 === void 0 || f2.children.add(this), this.elementId && this.root.potentialNodes.delete(this.elementId), a2 && (d2 || p2) && (this.isLayoutDirty = true), t2) {
        let v3;
        const w3 = () => this.root.updateBlockedByResize = false;
        t2(s2, () => {
          this.root.updateBlockedByResize = true, v3 && v3(), v3 = zl(w3, 250), pn.hasAnimatedSinceResize && (pn.hasAnimatedSinceResize = false, this.nodes.forEach(ku));
        });
      }
      p2 && this.root.registerSharedNode(p2, this), this.options.animate !== false && y2 && (p2 || d2) && this.addEventListener("didUpdate", ({ delta: v3, hasLayoutChanged: w3, hasRelativeTargetChanged: I3, layout: N11 }) => {
        var k2, M3, S2, Y2, W2;
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const Q3 = (M3 = (k2 = this.options.transition) !== null && k2 !== void 0 ? k2 : y2.getDefaultTransition()) !== null && M3 !== void 0 ? M3 : rv, { onLayoutAnimationStart: X3, onLayoutAnimationComplete: ne } = y2.getProps(), ue = !this.targetLayout || !hf(this.targetLayout, N11) || I3, se = !w3 && I3;
        if (this.options.layoutRoot || !((S2 = this.resumeFrom) === null || S2 === void 0) && S2.instance || se || w3 && (ue || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(v3, se);
          const ie = {
            ...Gl(Q3, "layout"),
            onPlay: X3,
            onComplete: ne
          };
          (y2.shouldReduceMotion || this.options.layoutRoot) && (ie.delay = 0, ie.type = false), this.startAnimation(ie);
        } else
          !w3 && this.animationProgress === 0 && ku(this), this.isLead() && ((W2 = (Y2 = this.options).onExitComplete) === null || W2 === void 0 || W2.call(Y2));
        this.targetLayout = N11;
      });
    }
    unmount() {
      var s2, a2;
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this), (s2 = this.getStack()) === null || s2 === void 0 || s2.remove(this), (a2 = this.parent) === null || a2 === void 0 || a2.children.delete(this), this.instance = void 0, cr.preRender(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      var s2;
      return this.isAnimationBlocked || ((s2 = this.parent) === null || s2 === void 0 ? void 0 : s2.isTreeAnimationBlocked()) || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      var s2;
      this.isUpdateBlocked() || (this.isUpdating = true, (s2 = this.nodes) === null || s2 === void 0 || s2.forEach(Jy), this.animationId++);
    }
    getTransformTemplate() {
      var s2;
      return (s2 = this.options.visualElement) === null || s2 === void 0 ? void 0 : s2.getProps().transformTemplate;
    }
    willUpdate(s2 = true) {
      var a2, f2, p2;
      if (this.root.isUpdateBlocked()) {
        (f2 = (a2 = this.options).onExitComplete) === null || f2 === void 0 || f2.call(a2);
        return;
      }
      if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let v3 = 0; v3 < this.path.length; v3++) {
        const w3 = this.path[v3];
        w3.shouldResetTransform = true, w3.updateScroll("snapshot"), w3.options.layoutRoot && w3.willUpdate(false);
      }
      const { layoutId: d2, layout: y2 } = this.options;
      d2 === void 0 && !y2 || (this.prevTransformTemplateValue = (p2 = this.getTransformTemplate()) === null || p2 === void 0 ? void 0 : p2(this.latestValues, ""), this.updateSnapshot(), s2 && this.notifyListeners("willUpdate"));
    }
    // Note: Currently only running on root node
    didUpdate() {
      if (this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Bu);
        return;
      }
      this.isUpdating && (this.isUpdating = false, this.potentialNodes.size && (this.potentialNodes.forEach(nv), this.potentialNodes.clear()), this.nodes.forEach(Yy), this.nodes.forEach(Hy), this.nodes.forEach(Ky), this.clearAllSnapshots(), qi.update(), qi.preRender(), qi.render());
    }
    clearAllSnapshots() {
      this.nodes.forEach(Gy), this.sharedNodes.forEach(Qy);
    }
    scheduleUpdateProjection() {
      _t2.preRender(this.updateProjection, false, true);
    }
    scheduleCheckAfterUnmount() {
      _t2.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      var s2;
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let f2 = 0; f2 < this.path.length; f2++)
          this.path[f2].updateScroll();
      const a2 = this.layout;
      this.layout = this.measure(false), this.layoutCorrected = ct2(), this.isLayoutDirty = false, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox), (s2 = this.options.visualElement) === null || s2 === void 0 || s2.notify("LayoutMeasure", this.layout.layoutBox, a2 == null ? void 0 : a2.layoutBox);
    }
    updateScroll(s2 = "measure") {
      let a2 = !!(this.options.layoutScroll && this.instance);
      this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s2 && (a2 = false), a2 && (this.scroll = {
        animationId: this.root.animationId,
        phase: s2,
        isRoot: n2(this.instance),
        offset: r2(this.instance)
      });
    }
    resetTransform() {
      var s2;
      if (!i2)
        return;
      const a2 = this.isLayoutDirty || this.shouldResetTransform, f2 = this.projectionDelta && !ff(this.projectionDelta), p2 = (s2 = this.getTransformTemplate()) === null || s2 === void 0 ? void 0 : s2(this.latestValues, ""), d2 = p2 !== this.prevTransformTemplateValue;
      a2 && (f2 || pr2(this.latestValues) || d2) && (i2(this.instance, p2), this.shouldResetTransform = false, this.scheduleRender());
    }
    measure(s2 = true) {
      const a2 = this.measurePageBox();
      let f2 = this.removeElementScroll(a2);
      return s2 && (f2 = this.removeTransform(f2)), iv(f2), {
        animationId: this.root.animationId,
        measuredBox: a2,
        layoutBox: f2,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: s2 } = this.options;
      if (!s2)
        return ct2();
      const a2 = s2.measureViewportBox(), { scroll: f2 } = this.root;
      return f2 && (sr(a2.x, f2.offset.x), sr(a2.y, f2.offset.y)), a2;
    }
    removeElementScroll(s2) {
      const a2 = ct2();
      jt(a2, s2);
      for (let f2 = 0; f2 < this.path.length; f2++) {
        const p2 = this.path[f2], { scroll: d2, options: y2 } = p2;
        if (p2 !== this.root && d2 && y2.layoutScroll) {
          if (d2.isRoot) {
            jt(a2, s2);
            const { scroll: v3 } = this.root;
            v3 && (sr(a2.x, -v3.offset.x), sr(a2.y, -v3.offset.y));
          }
          sr(a2.x, d2.offset.x), sr(a2.y, d2.offset.y);
        }
      }
      return a2;
    }
    applyTransform(s2, a2 = false) {
      const f2 = ct2();
      jt(f2, s2);
      for (let p2 = 0; p2 < this.path.length; p2++) {
        const d2 = this.path[p2];
        !a2 && d2.options.layoutScroll && d2.scroll && d2 !== d2.root && Dr(f2, {
          x: -d2.scroll.offset.x,
          y: -d2.scroll.offset.y
        }), pr2(d2.latestValues) && Dr(f2, d2.latestValues);
      }
      return pr2(this.latestValues) && Dr(f2, this.latestValues), f2;
    }
    removeTransform(s2) {
      var a2;
      const f2 = ct2();
      jt(f2, s2);
      for (let p2 = 0; p2 < this.path.length; p2++) {
        const d2 = this.path[p2];
        if (!d2.instance || !pr2(d2.latestValues))
          continue;
        Co(d2.latestValues) && d2.updateSnapshot();
        const y2 = ct2(), v3 = d2.measurePageBox();
        jt(y2, v3), Su(f2, d2.latestValues, (a2 = d2.snapshot) === null || a2 === void 0 ? void 0 : a2.layoutBox, y2);
      }
      return pr2(this.latestValues) && Su(f2, this.latestValues), f2;
    }
    /**
     *
     */
    setTargetDelta(s2) {
      this.targetDelta = s2, this.isProjectionDirty = true, this.root.scheduleUpdateProjection();
    }
    setOptions(s2) {
      this.options = {
        ...this.options,
        ...s2,
        crossfade: s2.crossfade !== void 0 ? s2.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = false;
    }
    /**
     * Frame calculations
     */
    resolveTargetDelta() {
      var s2;
      const a2 = this.getLead();
      if (this.isProjectionDirty || (this.isProjectionDirty = a2.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a2.isTransformDirty), !this.isProjectionDirty && !this.attemptToResolveRelativeTarget)
        return;
      const { layout: f2, layoutId: p2 } = this.options;
      if (!(!this.layout || !(f2 || p2))) {
        if (!this.targetDelta && !this.relativeTarget) {
          const d2 = this.getClosestProjectingParent();
          d2 && d2.layout ? (this.relativeParent = d2, this.relativeTarget = ct2(), this.relativeTargetOrigin = ct2(), vn(this.relativeTargetOrigin, this.layout.layoutBox, d2.layout.layoutBox), jt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = ct2(), this.targetWithTransforms = ct2()), this.relativeTarget && this.relativeTargetOrigin && (!((s2 = this.relativeParent) === null || s2 === void 0) && s2.target) ? Vg(this.target, this.relativeTarget, this.relativeParent.target) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : jt(this.target, this.layout.layoutBox), ef(this.target, this.targetDelta)) : jt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {
          this.attemptToResolveRelativeTarget = false;
          const d2 = this.getClosestProjectingParent();
          d2 && !!d2.resumingFrom == !!this.resumingFrom && !d2.options.layoutScroll && d2.target ? (this.relativeParent = d2, this.relativeTarget = ct2(), this.relativeTargetOrigin = ct2(), vn(this.relativeTargetOrigin, this.target, d2.target), jt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || Co(this.parent.latestValues) || Ql(this.parent.latestValues)))
        return (this.parent.relativeTarget || this.parent.targetDelta || this.parent.options.layoutRoot) && this.parent.layout ? this.parent : this.parent.getClosestProjectingParent();
    }
    calcProjection() {
      var s2;
      const { isProjectionDirty: a2, isTransformDirty: f2 } = this;
      this.isProjectionDirty = this.isTransformDirty = false;
      const p2 = this.getLead(), d2 = !!this.resumingFrom || this !== p2;
      let y2 = true;
      if (a2 && (y2 = false), d2 && f2 && (y2 = false), y2)
        return;
      const { layout: v3, layoutId: w3 } = this.options;
      if (this.isTreeAnimating = !!(!((s2 = this.parent) === null || s2 === void 0) && s2.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(v3 || w3))
        return;
      jt(this.layoutCorrected, this.layout.layoutBox), Zg(this.layoutCorrected, this.treeScale, this.path, d2);
      const { target: I3 } = p2;
      if (!I3)
        return;
      this.projectionDelta || (this.projectionDelta = wn(), this.projectionDeltaWithTransform = wn());
      const N11 = this.treeScale.x, k2 = this.treeScale.y, M3 = this.projectionTransform;
      yn(this.projectionDelta, this.layoutCorrected, I3, this.latestValues), this.projectionTransform = Ou(this.projectionDelta, this.treeScale), (this.projectionTransform !== M3 || this.treeScale.x !== N11 || this.treeScale.y !== k2) && (this.hasProjected = true, this.scheduleRender(), this.notifyListeners("projectionUpdate", I3));
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(s2 = true) {
      var a2, f2, p2;
      (f2 = (a2 = this.options).scheduleRender) === null || f2 === void 0 || f2.call(a2), s2 && ((p2 = this.getStack()) === null || p2 === void 0 || p2.scheduleRender()), this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    setAnimationOrigin(s2, a2 = false) {
      var f2, p2;
      const d2 = this.snapshot, y2 = (d2 == null ? void 0 : d2.latestValues) || {}, v3 = { ...this.latestValues }, w3 = wn();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a2;
      const I3 = ct2(), N11 = (d2 == null ? void 0 : d2.source) !== ((f2 = this.layout) === null || f2 === void 0 ? void 0 : f2.source), k2 = (((p2 = this.getStack()) === null || p2 === void 0 ? void 0 : p2.members.length) || 0) <= 1, M3 = !!(N11 && !k2 && this.options.crossfade === true && !this.path.some(tv));
      this.animationProgress = 0, this.mixTargetDelta = (S2) => {
        var Y2;
        const W2 = S2 / 1e3;
        Du(w3.x, s2.x, W2), Du(w3.y, s2.y, W2), this.setTargetDelta(w3), this.relativeTarget && this.relativeTargetOrigin && this.layout && (!((Y2 = this.relativeParent) === null || Y2 === void 0) && Y2.layout) && (vn(I3, this.layout.layoutBox, this.relativeParent.layout.layoutBox), ev(this.relativeTarget, this.relativeTargetOrigin, I3, W2)), N11 && (this.animationValues = v3, Dy(v3, y2, this.latestValues, W2, M3, k2)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = W2;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(s2) {
      var a2, f2;
      this.notifyListeners("animationStart"), (a2 = this.currentAnimation) === null || a2 === void 0 || a2.stop(), this.resumingFrom && ((f2 = this.resumingFrom.currentAnimation) === null || f2 === void 0 || f2.stop()), this.pendingAnimation && (cr.update(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = _t2.update(() => {
        pn.hasAnimatedSinceResize = true, this.currentAnimation = By(0, Iu, {
          ...s2,
          onUpdate: (p2) => {
            var d2;
            this.mixTargetDelta(p2), (d2 = s2.onUpdate) === null || d2 === void 0 || d2.call(s2, p2);
          },
          onComplete: () => {
            var p2;
            (p2 = s2.onComplete) === null || p2 === void 0 || p2.call(s2), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      var s2;
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0), (s2 = this.getStack()) === null || s2 === void 0 || s2.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      var s2;
      this.currentAnimation && ((s2 = this.mixTargetDelta) === null || s2 === void 0 || s2.call(this, Iu), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const s2 = this.getLead();
      let { targetWithTransforms: a2, target: f2, layout: p2, latestValues: d2 } = s2;
      if (!(!a2 || !f2 || !p2)) {
        if (this !== s2 && this.layout && p2 && pf(this.options.animationType, this.layout.layoutBox, p2.layoutBox)) {
          f2 = this.target || ct2();
          const y2 = Rt2(this.layout.layoutBox.x);
          f2.x.min = s2.target.x.min, f2.x.max = f2.x.min + y2;
          const v3 = Rt2(this.layout.layoutBox.y);
          f2.y.min = s2.target.y.min, f2.y.max = f2.y.min + v3;
        }
        jt(a2, f2), Dr(a2, d2), yn(this.projectionDeltaWithTransform, this.layoutCorrected, a2, d2);
      }
    }
    registerSharedNode(s2, a2) {
      var f2, p2, d2;
      this.sharedNodes.has(s2) || this.sharedNodes.set(s2, new $y()), this.sharedNodes.get(s2).add(a2), a2.promote({
        transition: (f2 = a2.options.initialPromotionConfig) === null || f2 === void 0 ? void 0 : f2.transition,
        preserveFollowOpacity: (d2 = (p2 = a2.options.initialPromotionConfig) === null || p2 === void 0 ? void 0 : p2.shouldPreserveFollowOpacity) === null || d2 === void 0 ? void 0 : d2.call(p2, a2)
      });
    }
    isLead() {
      const s2 = this.getStack();
      return s2 ? s2.lead === this : true;
    }
    getLead() {
      var s2;
      const { layoutId: a2 } = this.options;
      return a2 ? ((s2 = this.getStack()) === null || s2 === void 0 ? void 0 : s2.lead) || this : this;
    }
    getPrevLead() {
      var s2;
      const { layoutId: a2 } = this.options;
      return a2 ? (s2 = this.getStack()) === null || s2 === void 0 ? void 0 : s2.prevLead : void 0;
    }
    getStack() {
      const { layoutId: s2 } = this.options;
      if (s2)
        return this.root.sharedNodes.get(s2);
    }
    promote({ needsReset: s2, transition: a2, preserveFollowOpacity: f2 } = {}) {
      const p2 = this.getStack();
      p2 && p2.promote(this, f2), s2 && (this.projectionDelta = void 0, this.needsReset = true), a2 && this.setOptions({ transition: a2 });
    }
    relegate() {
      const s2 = this.getStack();
      return s2 ? s2.relegate(this) : false;
    }
    resetRotation() {
      const { visualElement: s2 } = this.options;
      if (!s2)
        return;
      let a2 = false;
      const { latestValues: f2 } = s2;
      if ((f2.rotate || f2.rotateX || f2.rotateY || f2.rotateZ) && (a2 = true), !a2)
        return;
      const p2 = {};
      for (let d2 = 0; d2 < Ru.length; d2++) {
        const y2 = "rotate" + Ru[d2];
        f2[y2] && (p2[y2] = f2[y2], s2.setStaticValue(y2, 0));
      }
      s2 == null || s2.render();
      for (const d2 in p2)
        s2.setStaticValue(d2, p2[d2]);
      s2.scheduleRender();
    }
    getProjectionStyles(s2 = {}) {
      var a2, f2;
      const p2 = {};
      if (!this.instance || this.isSVG)
        return p2;
      if (this.isVisible)
        p2.visibility = "";
      else
        return { visibility: "hidden" };
      const d2 = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = false, p2.opacity = "", p2.pointerEvents = Yn(s2.pointerEvents) || "", p2.transform = d2 ? d2(this.latestValues, "") : "none", p2;
      const y2 = this.getLead();
      if (!this.projectionDelta || !this.layout || !y2.target) {
        const N11 = {};
        return this.options.layoutId && (N11.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, N11.pointerEvents = Yn(s2.pointerEvents) || ""), this.hasProjected && !pr2(this.latestValues) && (N11.transform = d2 ? d2({}, "") : "none", this.hasProjected = false), N11;
      }
      const v3 = y2.animationValues || y2.latestValues;
      this.applyTransformsToTarget(), p2.transform = Ou(this.projectionDeltaWithTransform, this.treeScale, v3), d2 && (p2.transform = d2(v3, p2.transform));
      const { x: w3, y: I3 } = this.projectionDelta;
      p2.transformOrigin = `${w3.origin * 100}% ${I3.origin * 100}% 0`, y2.animationValues ? p2.opacity = y2 === this ? (f2 = (a2 = v3.opacity) !== null && a2 !== void 0 ? a2 : this.latestValues.opacity) !== null && f2 !== void 0 ? f2 : 1 : this.preserveOpacity ? this.latestValues.opacity : v3.opacityExit : p2.opacity = y2 === this ? v3.opacity !== void 0 ? v3.opacity : "" : v3.opacityExit !== void 0 ? v3.opacityExit : 0;
      for (const N11 in ti) {
        if (v3[N11] === void 0)
          continue;
        const { correct: k2, applyTo: M3 } = ti[N11], S2 = p2.transform === "none" ? v3[N11] : k2(v3[N11], y2);
        if (M3) {
          const Y2 = M3.length;
          for (let W2 = 0; W2 < Y2; W2++)
            p2[M3[W2]] = S2;
        } else
          p2[N11] = S2;
      }
      return this.options.layoutId && (p2.pointerEvents = y2 === this ? Yn(s2.pointerEvents) || "" : "none"), p2;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((s2) => {
        var a2;
        return (a2 = s2.currentAnimation) === null || a2 === void 0 ? void 0 : a2.stop();
      }), this.root.nodes.forEach(Bu), this.root.sharedNodes.clear();
    }
  };
}
function Hy(t2) {
  t2.updateLayout();
}
function Ky(t2) {
  var e2, r2, n2;
  const i2 = ((e2 = t2.resumeFrom) === null || e2 === void 0 ? void 0 : e2.snapshot) || t2.snapshot;
  if (t2.isLead() && t2.layout && i2 && t2.hasListeners("didUpdate")) {
    const { layoutBox: o2, measuredBox: s2 } = t2.layout, { animationType: a2 } = t2.options, f2 = i2.source !== t2.layout.source;
    a2 === "size" ? Ht((w3) => {
      const I3 = f2 ? i2.measuredBox[w3] : i2.layoutBox[w3], N11 = Rt2(I3);
      I3.min = o2[w3].min, I3.max = I3.min + N11;
    }) : pf(a2, i2.layoutBox, o2) && Ht((w3) => {
      const I3 = f2 ? i2.measuredBox[w3] : i2.layoutBox[w3], N11 = Rt2(o2[w3]);
      I3.max = I3.min + N11;
    });
    const p2 = wn();
    yn(p2, o2, i2.layoutBox);
    const d2 = wn();
    f2 ? yn(d2, t2.applyTransform(s2, true), i2.measuredBox) : yn(d2, o2, i2.layoutBox);
    const y2 = !ff(p2);
    let v3 = false;
    if (!t2.resumeFrom) {
      const w3 = t2.getClosestProjectingParent();
      if (w3 && !w3.resumeFrom) {
        const { snapshot: I3, layout: N11 } = w3;
        if (I3 && N11) {
          const k2 = ct2();
          vn(k2, i2.layoutBox, I3.layoutBox);
          const M3 = ct2();
          vn(M3, o2, N11.layoutBox), hf(k2, M3) || (v3 = true), w3.options.layoutRoot && (t2.relativeTarget = M3, t2.relativeTargetOrigin = k2, t2.relativeParent = w3);
        }
      }
    }
    t2.notifyListeners("didUpdate", {
      layout: o2,
      snapshot: i2,
      delta: d2,
      layoutDelta: p2,
      hasLayoutChanged: y2,
      hasRelativeTargetChanged: v3
    });
  } else
    t2.isLead() && ((n2 = (r2 = t2.options).onExitComplete) === null || n2 === void 0 || n2.call(r2));
  t2.options.transition = void 0;
}
function zy(t2) {
  t2.isProjectionDirty || (t2.isProjectionDirty = !!(t2.parent && t2.parent.isProjectionDirty)), t2.isTransformDirty || (t2.isTransformDirty = !!(t2.parent && t2.parent.isTransformDirty));
}
function Gy(t2) {
  t2.clearSnapshot();
}
function Bu(t2) {
  t2.clearMeasurements();
}
function Yy(t2) {
  const { visualElement: e2 } = t2.options;
  e2 != null && e2.getProps().onBeforeLayoutMeasure && e2.notify("BeforeLayoutMeasure"), t2.resetTransform();
}
function ku(t2) {
  t2.finishAnimation(), t2.targetDelta = t2.relativeTarget = t2.target = void 0;
}
function Xy(t2) {
  t2.resolveTargetDelta();
}
function Zy(t2) {
  t2.calcProjection();
}
function Jy(t2) {
  t2.resetRotation();
}
function Qy(t2) {
  t2.removeLeadSnapshot();
}
function Du(t2, e2, r2) {
  t2.translate = ot2(e2.translate, 0, r2), t2.scale = ot2(e2.scale, 1, r2), t2.origin = e2.origin, t2.originPoint = e2.originPoint;
}
function Lu(t2, e2, r2, n2) {
  t2.min = ot2(e2.min, r2.min, n2), t2.max = ot2(e2.max, r2.max, n2);
}
function ev(t2, e2, r2, n2) {
  Lu(t2.x, e2.x, r2.x, n2), Lu(t2.y, e2.y, r2.y, n2);
}
function tv(t2) {
  return t2.animationValues && t2.animationValues.opacityExit !== void 0;
}
var rv = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function nv(t2, e2) {
  let r2 = t2.root;
  for (let o2 = t2.path.length - 1; o2 >= 0; o2--)
    if (t2.path[o2].instance) {
      r2 = t2.path[o2];
      break;
    }
  const i2 = (r2 && r2 !== t2.root ? r2.instance : document).querySelector(`[data-projection-id="${e2}"]`);
  i2 && t2.mount(i2, true);
}
function Nu(t2) {
  t2.min = Math.round(t2.min), t2.max = Math.round(t2.max);
}
function iv(t2) {
  Nu(t2.x), Nu(t2.y);
}
function pf(t2, e2, r2) {
  return t2 === "position" || t2 === "preserve-aspect" && !So(Cu(e2), Cu(r2), 0.2);
}
var ov = df({
  attachResizeListener: (t2, e2) => Ai(t2, "resize", e2),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
var Qi = {
  current: void 0
};
var sv = df({
  measureScroll: (t2) => ({
    x: t2.scrollLeft,
    y: t2.scrollTop
  }),
  defaultParent: () => {
    if (!Qi.current) {
      const t2 = new ov(0, {});
      t2.mount(window), t2.setOptions({ layoutScroll: true }), Qi.current = t2;
    }
    return Qi.current;
  },
  resetTransform: (t2, e2) => {
    t2.style.transform = e2 !== void 0 ? e2 : "none";
  },
  checkIsScrollRoot: (t2) => window.getComputedStyle(t2).position === "fixed"
});
var av = {
  ...Ug,
  ...om,
  ...sy,
  ...Iy
};
var mf = v0((t2, e2) => K0(t2, e2, av, Sy, sv));
function gf() {
  const t2 = (0, import_react.useRef)(false);
  return ei(() => (t2.current = true, () => {
    t2.current = false;
  }), []), t2;
}
function uv() {
  const t2 = gf(), [e2, r2] = (0, import_react.useState)(0), n2 = (0, import_react.useCallback)(() => {
    t2.current && r2(e2 + 1);
  }, [e2]);
  return [(0, import_react.useCallback)(() => _t2.postRender(n2), [n2]), e2];
}
var cv = class extends ke.Component {
  getSnapshotBeforeUpdate(e2) {
    const r2 = this.props.childRef.current;
    if (r2 && e2.isPresent && !this.props.isPresent) {
      const n2 = this.props.sizeRef.current;
      n2.height = r2.offsetHeight || 0, n2.width = r2.offsetWidth || 0, n2.top = r2.offsetTop, n2.left = r2.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
};
function lv({ children: t2, isPresent: e2 }) {
  const r2 = (0, import_react.useId)(), n2 = (0, import_react.useRef)(null), i2 = (0, import_react.useRef)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  return (0, import_react.useInsertionEffect)(() => {
    const { width: o2, height: s2, top: a2, left: f2 } = i2.current;
    if (e2 || !n2.current || !o2 || !s2)
      return;
    n2.current.dataset.motionPopId = r2;
    const p2 = document.createElement("style");
    return document.head.appendChild(p2), p2.sheet && p2.sheet.insertRule(`
          [data-motion-pop-id="${r2}"] {
            position: absolute !important;
            width: ${o2}px !important;
            height: ${s2}px !important;
            top: ${a2}px !important;
            left: ${f2}px !important;
          }
        `), () => {
      document.head.removeChild(p2);
    };
  }, [e2]), ke.createElement(cv, { isPresent: e2, childRef: n2, sizeRef: i2 }, ke.cloneElement(t2, { ref: n2 }));
}
var eo = ({ children: t2, initial: e2, isPresent: r2, onExitComplete: n2, custom: i2, presenceAffectsLayout: o2, mode: s2 }) => {
  const a2 = Ei(fv), f2 = (0, import_react.useId)(), p2 = (0, import_react.useMemo)(
    () => ({
      id: f2,
      initial: e2,
      isPresent: r2,
      custom: i2,
      onExitComplete: (d2) => {
        a2.set(d2, true);
        for (const y2 of a2.values())
          if (!y2)
            return;
        n2 && n2();
      },
      register: (d2) => (a2.set(d2, false), () => a2.delete(d2))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    o2 ? void 0 : [r2]
  );
  return (0, import_react.useMemo)(() => {
    a2.forEach((d2, y2) => a2.set(y2, false));
  }, [r2]), ke.useEffect(() => {
    !r2 && !a2.size && n2 && n2();
  }, [r2]), s2 === "popLayout" && (t2 = ke.createElement(lv, { isPresent: r2 }, t2)), ke.createElement(Rn.Provider, { value: p2 }, t2);
};
function fv() {
  return /* @__PURE__ */ new Map();
}
var Rr = (t2) => t2.key || "";
function hv(t2, e2) {
  t2.forEach((r2) => {
    const n2 = Rr(r2);
    e2.set(n2, r2);
  });
}
function dv(t2) {
  const e2 = [];
  return import_react.Children.forEach(t2, (r2) => {
    (0, import_react.isValidElement)(r2) && e2.push(r2);
  }), e2;
}
var pv = ({ children: t2, custom: e2, initial: r2 = true, onExitComplete: n2, exitBeforeEnter: i2, presenceAffectsLayout: o2 = true, mode: s2 = "sync" }) => {
  i2 && (s2 = "wait", Si(false, "Replace exitBeforeEnter with mode='wait'"));
  let [a2] = uv();
  const f2 = (0, import_react.useContext)(Ts).forceRender;
  f2 && (a2 = f2);
  const p2 = gf(), d2 = dv(t2);
  let y2 = d2;
  const v3 = /* @__PURE__ */ new Set(), w3 = (0, import_react.useRef)(y2), I3 = (0, import_react.useRef)(/* @__PURE__ */ new Map()).current, N11 = (0, import_react.useRef)(true);
  if (ei(() => {
    N11.current = false, hv(d2, I3), w3.current = y2;
  }), Bs(() => {
    N11.current = true, I3.clear(), v3.clear();
  }), N11.current)
    return ke.createElement(ke.Fragment, null, y2.map((Y2) => ke.createElement(eo, { key: Rr(Y2), isPresent: true, initial: r2 ? void 0 : false, presenceAffectsLayout: o2, mode: s2 }, Y2)));
  y2 = [...y2];
  const k2 = w3.current.map(Rr), M3 = d2.map(Rr), S2 = k2.length;
  for (let Y2 = 0; Y2 < S2; Y2++) {
    const W2 = k2[Y2];
    M3.indexOf(W2) === -1 && v3.add(W2);
  }
  return s2 === "wait" && v3.size && (y2 = []), v3.forEach((Y2) => {
    if (M3.indexOf(Y2) !== -1)
      return;
    const W2 = I3.get(Y2);
    if (!W2)
      return;
    const Q3 = k2.indexOf(Y2), X3 = () => {
      I3.delete(Y2), v3.delete(Y2);
      const ne = w3.current.findIndex((ue) => ue.key === Y2);
      if (w3.current.splice(ne, 1), !v3.size) {
        if (w3.current = d2, p2.current === false)
          return;
        a2(), n2 && n2();
      }
    };
    y2.splice(Q3, 0, ke.createElement(eo, { key: Rr(W2), isPresent: false, onExitComplete: X3, custom: e2, presenceAffectsLayout: o2, mode: s2 }, W2));
  }), y2 = y2.map((Y2) => {
    const W2 = Y2.key;
    return v3.has(W2) ? Y2 : ke.createElement(eo, { key: Rr(Y2), isPresent: true, presenceAffectsLayout: o2, mode: s2 }, Y2);
  }), s2 === "wait" && y2.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`), ke.createElement(ke.Fragment, null, v3.size ? y2 : y2.map((Y2) => (0, import_react.cloneElement)(Y2)));
};
function Xs({
  open: t2,
  onClose: e2,
  children: r2,
  className: n2,
  variants: i2,
  noWatermark: o2 = false
}) {
  const s2 = i0();
  return Me(pv, {
    children: t2 && Fe(wv, {
      className: "modal-screen",
      children: [Me(yv, {
        className: "modal-background",
        variants: mv,
        initial: "hidden",
        animate: "shown",
        exit: "hidden",
        transition: {
          ease: "easeInOut",
          duration: 0.23
        },
        onClick: e2,
        children: !o2 && Fe(Pv, {
          children: ["Arweave Wallet Kit v", n0]
        })
      }, "bg"), Me(_v, {
        className: "modal-aligner",
        children: Me(Tv, {
          className: "modal-animator " + (n2 ? " " + n2 : ""),
          variants: i2 || vv(s2),
          initial: "hidden",
          animate: "shown",
          exit: "hidden",
          children: Me(Mv, {
            children: r2
          })
        }, "modal-animator")
      }, "modal-aligner")]
    }, "modal-screen")
  });
}
var mv = {
  shown: {
    opacity: 1
  },
  hidden: {
    opacity: 0
  }
};
var gv = () => mf.div;
var yv = Ce(gv())({
  name: "BackgroundLayer",
  class: "bbvkbel",
  propsAsIs: true
});
var vv = (t2 = false) => ({
  shown: {
    top: 0,
    opacity: 1,
    width: t2 ? "100vw" : "50vw",
    transition: {
      type: "spring",
      duration: 0.4,
      delayChildren: 0.2,
      staggerChildren: 0.05
    }
  },
  hidden: {
    top: "100%",
    width: t2 ? "100vw" : "50vw",
    opacity: 0.4,
    // TODO(crookse) What's the reason for stopping at 0.4? Asking because a pause in animation is seen.
    transition: {
      type: "spring",
      duration: 0.4
    }
  }
});
var wv = Ce("div")({
  name: "ModalScreen",
  class: "m1767o4q",
  propsAsIs: false
});
var _v = Ce("div")({
  name: "ModalAligner",
  class: "mzdiz37",
  propsAsIs: false
});
var bv = () => mf.div;
var xv = () => (t2) => t2.theme.themeConfig.font.fontFamily;
var Tv = st(Ce(bv())({
  name: "ModalAnimator",
  class: "m69h97z",
  propsAsIs: true,
  vars: {
    "m69h97z-0": [xv()]
  }
}));
var Ev = () => (t2) => t2.theme.background;
var Av = () => (t2) => ({
  default: 30,
  minimal: 12,
  none: 0
})[t2.theme.themeConfig.radius] + "px";
var Mv = st(Ce("div")({
  name: "ModalContents",
  class: "mh21eb7",
  propsAsIs: false,
  vars: {
    "mh21eb7-0": [Ev()],
    "mh21eb7-1": [Av()]
  }
}));
var Sv = () => (t2) => t2.theme.themeConfig.font.fontFamily;
var Pv = st(Ce("p")({
  name: "KitName",
  class: "k17wyawm",
  propsAsIs: false,
  vars: {
    "k17wyawm-0": [Sv()]
  }
}));
function Zs(t2 = false) {
  const [e2, r2] = (0, import_react.useState)(t2);
  return {
    setOpen: r2,
    open: e2,
    bindings: {
      open: e2,
      onClose: () => r2(false)
    }
  };
}
function Cv() {
  const t2 = Zs(), {
    state: e2,
    dispatch: r2
  } = xt2(), [n2, i2] = (0, import_react.useState)();
  (0, import_react.useEffect)(() => {
    (async () => {
      const f2 = await sh((e2 == null ? void 0 : e2.config.permissions) || [], !!(e2 != null && e2.config.ensurePermissions));
      f2 && f2.resumeSession ? (i2(f2), t2.setOpen(true)) : r2({
        type: "UPDATE_STRATEGY",
        payload: !!f2 && f2.id || false
      });
    })();
  }, []);
  function o2() {
    localStorage.removeItem(Sn), r2({
      type: "DISCONNECT"
    });
  }
  async function s2() {
    let f2 = false;
    if (n2 != null && n2.resumeSession) {
      f2 = n2;
      try {
        await n2.resumeSession();
      } catch {
        f2 = false;
      }
    }
    i2(void 0), t2.setOpen(false), r2({
      type: "UPDATE_STRATEGY",
      payload: !!f2 && f2.id || false
    }), f2 || o2();
  }
  function a2() {
    i2(void 0), t2.setOpen(false), o2();
  }
  return Fe(Bv, {
    variants: Ov,
    ...t2.bindings,
    onClose: a2,
    noWatermark: true,
    children: [Fe(Dv, {
      children: ["Would you like to restore your ", (n2 == null ? void 0 : n2.name) + " " || "", "session?"]
    }), Fe(Lv, {
      children: [Me(ur, {
        onClick: s2,
        children: "Restore"
      }), Me(jv, {
        onClick: a2,
        children: "Cancel"
      })]
    })]
  });
}
var Ov = {
  shown: {
    opacity: 1,
    translateY: "-1.5rem",
    transition: {
      type: "spring",
      duration: 0.4,
      delayChildren: 0.2,
      staggerChildren: 0.025
    }
  },
  hidden: {
    opacity: 0.4,
    translateY: "200%",
    transition: {
      type: "spring",
      duration: 0.4
    }
  }
};
var Rv = () => Xs;
var Iv = () => (t2) => ({
  default: 15,
  minimal: 8,
  none: 0
})[t2.theme.themeConfig.radius] + "px";
var Bv = st(Ce(Rv())({
  name: "BottomModal",
  class: "b7jc8fb",
  propsAsIs: true,
  vars: {
    "b7jc8fb-0": [Iv()]
  }
}));
var kv = () => (t2) => t2.theme.primaryText;
var Dv = st(Ce("p")({
  name: "Text",
  class: "typmncv",
  propsAsIs: false,
  vars: {
    "typmncv-0": [kv()]
  }
}));
var Lv = Ce("div")({
  name: "Buttons",
  class: "b14qolsb",
  propsAsIs: false
});
var Nv = () => ur;
var Uv = () => (t2) => t2.theme.primaryText;
var Fv = () => (t2) => t2.theme.theme;
var jv = st(Ce(Nv())({
  name: "CloseButton",
  class: "c1jq17m8",
  propsAsIs: true,
  vars: {
    "c1jq17m8-0": [Uv()],
    "c1jq17m8-1": [Fv()]
  }
}));
var $v = () => (t2) => t2.small ? ".7rem" : ".9rem";
var Vv = () => (t2) => t2.theme.secondaryText;
var jr2 = st(Ce("p")({
  name: "Paragraph",
  class: "p1jty3xq",
  propsAsIs: false,
  vars: {
    "p1jty3xq-0": [$v()],
    "p1jty3xq-1": [Vv()]
  }
}));
var qv = () => (t2) => t2.theme.themeConfig.font.fontFamily;
var Wv = () => (t2) => t2.small ? "1.05rem" : "1.2rem";
var Hv = () => (t2) => t2.themed ? uc(t2.theme.themeConfig.titleHighlight) : t2.theme.primaryText;
var Kv = () => (t2) => t2.themed ? "pointer" : "text";
var vr = st(Ce("h1")({
  name: "Title",
  class: "t1sgzzc0",
  propsAsIs: false,
  vars: {
    "t1sgzzc0-0": [qv()],
    "t1sgzzc0-1": [Wv()],
    "t1sgzzc0-2": [Hv()],
    "t1sgzzc0-3": [Kv()]
  }
}));
var zv = Ce("div")({
  name: "TitleWithParagraph",
  class: "tb205ol",
  propsAsIs: false
});
function Gv({
  logo: t2,
  name: e2,
  description: r2,
  onClick: n2,
  theme: i2
}) {
  return Fe(Yv, {
    children: [Fe(Xv, {
      children: [Me(vf, {
        colorTheme: i2,
        clickable: true,
        onClick: n2,
        children: Me(yf, {
          src: t2,
          draggable: false
        })
      }), Fe(tw, {
        children: [Me(vr, {
          small: true,
          children: e2
        }), Me(jr2, {
          small: true,
          children: r2
        })]
      })]
    }), Me(ur, {
      onClick: n2,
      children: "Go"
    })]
  });
}
var Yv = Ce("div")({
  name: "Wrapper",
  class: "wzg6vks",
  propsAsIs: false
});
var Xv = Ce("div")({
  name: "AppInfo",
  class: "a1vzc1qt",
  propsAsIs: false
});
var yf = Ce("img")({
  name: "Logo",
  class: "l1rbotc6",
  propsAsIs: false
});
var Zv = () => (t2) => ({
  default: 15,
  minimal: 6,
  none: 0
})[t2.theme.themeConfig.radius] + "px";
var Jv = () => (t2) => t2.colorTheme || t2.theme.primaryText;
var Qv = () => (t2) => t2.clickable ? "pointer" : "default";
var ew = () => (t2) => t2.clickable ? ".95" : "1";
var vf = st(Ce("div")({
  name: "AppIcon",
  class: "acuhj7u",
  propsAsIs: false,
  vars: {
    "acuhj7u-0": [Zv()],
    "acuhj7u-1": [Jv()],
    "acuhj7u-2": [Qv()],
    "acuhj7u-3": [ew()]
  }
}));
var tw = Ce("div")({
  name: "AppNameAndDescription",
  class: "a143ijem",
  propsAsIs: false
});
function rw({
  children: t2
}) {
  return Me(iw, {
    children: t2
  });
}
var nw = () => (t2) => t2.theme.light;
var iw = st(Ce("div")({
  name: "Wrapper",
  class: "wv1c1ab",
  propsAsIs: false,
  vars: {
    "wv1c1ab-0": [nw()]
  }
}));
var ow = (t2) => Fe(sw, {
  viewBox: "0 0 48 48",
  xmlns: "http://www.w3.org/2000/svg",
  ...t2,
  children: [Me("circle", {
    cx: "24",
    cy: "24",
    fill: "none",
    r: "20",
    strokeDasharray: "80",
    strokeLinecap: "round",
    stroke: "currentColor",
    strokeWidth: "4"
  }), Me("circle", {
    cx: "24",
    cy: "24",
    fill: "none",
    opacity: "0.3",
    r: "20",
    strokeLinecap: "round",
    stroke: "currentColor",
    strokeWidth: "4"
  })]
});
var sw = Ce("svg")({
  name: "SvgWrapper",
  class: "s9sva",
  propsAsIs: false
});
function wf({
  children: t2,
  onClose: e2
}) {
  return Fe(aw, {
    children: [t2, Me(lw, {
      onClick: e2,
      children: Me(mh, {})
    })]
  });
}
var aw = Ce("div")({
  name: "HeadWrapper",
  class: "h1mmuqym",
  propsAsIs: false
});
var uw = () => (t2) => t2.theme.light;
var cw = () => (t2) => t2.theme.secondaryText;
var lw = st(Ce("div")({
  name: "CloseButton",
  class: "c86k5gq",
  propsAsIs: false,
  vars: {
    "c86k5gq-0": [uw()],
    "c86k5gq-1": [cw()]
  }
}));
function fw() {
  const t2 = Zs(), {
    state: e2,
    dispatch: r2
  } = xt2();
  (0, import_react.useEffect)(() => {
    t2.setOpen((e2 == null ? void 0 : e2.activeModal) === "connect");
  }, [e2 == null ? void 0 : e2.activeModal]), (0, import_react.useEffect)(() => {
    t2.open || (o2(void 0), r2({
      type: "CLOSE_MODAL"
    }));
  }, [t2.open]);
  const {
    connected: n2
  } = Jo();
  (0, import_react.useEffect)(() => {
    !n2 || (e2 == null ? void 0 : e2.activeModal) !== "connect" || r2({
      type: "CLOSE_MODAL"
    });
  }, [n2, e2]);
  const [i2, o2] = (0, import_react.useState)(), s2 = (0, import_react.useMemo)(() => i2 ? Ir(i2) : void 0, [i2, dn]), [a2, f2] = (0, import_react.useState)(false), [p2, d2] = (0, import_react.useState)(false), [y2, v3] = (0, import_react.useState)(false), [w3, I3] = (0, import_react.useState)(false);
  async function N11(X3) {
    const ne = dn.find((se) => se.id === X3);
    if (!ne)
      return;
    d2(true), o2(X3);
    let ue = false;
    try {
      ue = await ne.isAvailable();
    } catch {
      ue = false;
    }
    v3(ue), d2(false), ue && await k2(ne);
  }
  async function k2(X3) {
    I3(false), f2(true);
    try {
      await X3.connect(e2.config.permissions, e2.config.appInfo, e2.config.gatewayConfig), window.postMessage({
        type: "connect_result",
        res: true
      }), r2({
        type: "CLOSE_MODAL"
      }), fo(X3.id), r2({
        type: "UPDATE_STRATEGY",
        payload: X3.id
      });
    } catch {
      Y2(), I3(true), r2({
        type: "UPDATE_STRATEGY",
        payload: false
      });
    }
    f2(false);
  }
  function M3() {
    window.postMessage({
      type: "connect_result",
      res: false
    }), r2({
      type: "CLOSE_MODAL"
    });
  }
  const S2 = bs();
  function Y2() {
    try {
      document.querySelectorAll(".arconnect_connect_overlay_extension_temporary").forEach((X3) => X3.remove());
    } catch {
    }
  }
  const [W2, Q3] = (0, import_react.useState)(false);
  return (0, import_react.useEffect)(() => {
    (async () => {
      const X3 = navigator.brave && await navigator.brave.isBrave();
      Q3(X3);
    })();
  }, []), Fe(Xs, {
    ...t2.bindings,
    onClose: M3,
    children: [Me(wf, {
      onClose: M3,
      children: Fe(vr, {
        themed: !!i2,
        onClick: () => {
          i2 && o2(void 0);
        },
        children: [i2 && Me(xw, {}), s2 ? s2.name : "Connect wallet"]
      })
    }), !i2 && Me(hw, {
      children: dn.map((X3, ne) => Me(Gv, {
        name: X3.name,
        description: X3.description,
        logo: `${S2}/${X3.logo}`,
        theme: X3.theme,
        onClick: () => N11(X3.id)
      }, ne))
    }) || Me(dw, {
      children: Fe(pw, {
        children: [Me(vf, {
          colorTheme: s2 == null ? void 0 : s2.theme,
          children: Me(yf, {
            src: `${S2}/${s2 == null ? void 0 : s2.logo}`,
            draggable: false
          })
        }), y2 && Fe(_n, {
          children: [Fe(vr, {
            small: true,
            children: ["Connecting to ", (s2 == null ? void 0 : s2.name) || "", "..."]
          }), Me(jr2, {
            children: "Confirm connection request in the wallet popup window"
          }), (s2 == null ? void 0 : s2.id) === "othent" && W2 && Fe(yw, {
            children: ["You might need to ", Me("b", {
              children: "disable Brave shields"
            }), " for this to work properly."]
          }), w3 && s2 && Me(ur, {
            onClick: () => k2(s2),
            children: "Retry"
          })]
        }) || !p2 && Fe(_n, {
          children: [
            Fe(vr, {
              small: true,
              children: [(s2 == null ? void 0 : s2.name) || "", " is not available."]
            }),
            Me(jr2, {
              children: "If you don't have it yet, you can try to download it"
            }),
            // @ts-expect-error
            (s2 == null ? void 0 : s2.url) && Me(ur, {
              onClick: () => {
                window.open(s2.url);
              },
              children: "Download"
            })
          ]
        }), (a2 || p2) && Me(_w, {})]
      })
    }), Fe(rw, {
      children: [Fe(zv, {
        children: [Me(vr, {
          small: true,
          children: "Don't have a wallet?"
        }), Me(jr2, {
          small: true,
          children: "Click to learn more about the permaweb & wallets."
        })]
      }), Me(ur, {
        onClick: () => window.open("https://arwiki.wiki/#/en/wallets"),
        children: "Get"
      })]
    })]
  });
}
var hw = Ce("div")({
  name: "Apps",
  class: "a1osnke6",
  propsAsIs: false
});
var dw = Ce("div")({
  name: "Connecting",
  class: "c15u83h7",
  propsAsIs: false
});
var pw = Ce("div")({
  name: "WalletData",
  class: "w5r445t",
  propsAsIs: false
});
var mw = () => jr2;
var gw = () => (t2) => ({
  default: 14,
  minimal: 8,
  none: 0
})[t2.theme.themeConfig.radius] + "px";
var yw = st(Ce(mw())({
  name: "BraveParagraph",
  class: "bukrfi8",
  propsAsIs: true,
  vars: {
    "bukrfi8-0": [gw()]
  }
}));
var vw = () => ow;
var ww = () => (t2) => t2.theme.primaryText;
var _w = st(Ce(vw())({
  name: "ConnectLoading",
  class: "c13sms3",
  propsAsIs: true,
  vars: {
    "c13sms3-0": [ww()]
  }
}));
var bw = () => ph;
var xw = Ce(bw())({
  name: "BackButton",
  class: "b1r2gdr0",
  propsAsIs: true
});
function Tw() {
  const t2 = Zs(), {
    state: e2,
    dispatch: r2
  } = xt2();
  (0, import_react.useEffect)(() => {
    t2.setOpen((e2 == null ? void 0 : e2.activeModal) === "profile");
  }, [e2 == null ? void 0 : e2.activeModal]), (0, import_react.useEffect)(() => {
    t2.open || r2({
      type: "CLOSE_MODAL"
    });
  }, [t2.open, r2]);
  function n2() {
    r2({
      type: "CLOSE_MODAL"
    });
  }
  const i2 = Qc(), o2 = tl(), s2 = bs(), {
    disconnect: a2
  } = Jo(), f2 = Gt2();
  return Fe(Xs, {
    ...t2.bindings,
    onClose: n2,
    children: [Me(wf, {
      onClose: n2,
      children: Me(vr, {
        children: "Profile"
      })
    }), Fe(Aw, {
      children: [Fe(Cw, {
        profilePicture: o2 == null ? void 0 : o2.avatar,
        children: [!(o2 != null && o2.avatar) && Me(kw, {}), Me(Iw, {
          strategyTheme: f2 == null ? void 0 : f2.theme,
          children: Me("img", {
            src: f2 != null && f2.logo ? `${s2}/${f2.logo}` : "",
            alt: (f2 == null ? void 0 : f2.name) || "active strategy logo",
            draggable: false
          })
        })]
      }), Fe(vr, {
        children: [(o2 == null ? void 0 : o2.currentLabel) || ac((e2 == null ? void 0 : e2.activeAddress) || "", 8), Me(gh, {
          onClick: () => navigator.clipboard.writeText(e2.activeAddress || "")
        })]
      }), Fe(jr2, {
        children: [i2.toLocaleString(void 0, {
          maximumFractionDigits: 4
        }), " AR"]
      }), Fe(ur, {
        onClick: a2,
        children: [Me(yh, {}), "Disconnect"]
      })]
    })]
  });
}
var Ew = () => (t2) => ({
  default: 18,
  minimal: 10,
  none: 0
})[t2.theme.themeConfig.radius] + "px";
var Aw = st(Ce("div")({
  name: "ProfileData",
  class: "p1hjgol5",
  propsAsIs: false,
  vars: {
    "p1hjgol5-0": [Ew()]
  }
}));
var Mw = () => (t2) => ({
  default: "100%",
  minimal: "8px",
  none: "none"
})[t2.theme.themeConfig.radius];
var Sw = () => (t2) => t2.theme.theme;
var Pw = () => (t2) => t2.profilePicture ? `background-image: url(${t2.profilePicture});` : "";
var Cw = st(Ce("div")({
  name: "ProfilePicture",
  class: "publs4f",
  propsAsIs: false,
  vars: {
    "publs4f-0": [Mw()],
    "publs4f-1": [Sw()],
    "publs4f-2": [Pw()]
  }
}));
var Ow = () => (t2) => t2.strategyTheme || t2.theme.theme;
var Rw = () => (t2) => t2.theme.background;
var Iw = st(Ce("div")({
  name: "ActiveStrategy",
  class: "alzinag",
  propsAsIs: false,
  vars: {
    "alzinag-0": [Ow()],
    "alzinag-1": [Rw()]
  }
}));
var Bw = () => lc;
var kw = Ce(Bw())({
  name: "ProfileIcon",
  class: "p1qewrlg",
  propsAsIs: true
});
function Dw(t2 = Wo, e2) {
  switch (e2.type) {
    case "OPEN_MODAL":
      return {
        ...t2,
        activeModal: e2.payload
      };
    case "CLOSE_MODAL":
      return {
        ...t2,
        activeModal: false
      };
    case "DISCONNECT":
      return {
        ...t2,
        activeStrategy: false,
        activeAddress: void 0,
        givenPermissions: []
      };
    case "UPDATE_STRATEGY":
      return {
        ...t2,
        activeStrategy: e2.payload
      };
    case "UPDATE_CONFIG":
      return {
        ...t2,
        config: e2.payload
      };
    case "UPDATE_ADDRESS":
      return {
        ...t2,
        activeAddress: e2.payload
      };
    case "UPDATE_PERMISSIONS":
      return {
        ...t2,
        givenPermissions: e2.payload
      };
  }
  return t2;
}
var ko = { exports: {} };
var Uu = Object.getOwnPropertySymbols;
var Lw = Object.prototype.hasOwnProperty;
var Nw = Object.prototype.propertyIsEnumerable;
function Uw(t2) {
  if (t2 == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(t2);
}
function Fw() {
  try {
    if (!Object.assign)
      return false;
    var t2 = new String("abc");
    if (t2[5] = "de", Object.getOwnPropertyNames(t2)[0] === "5")
      return false;
    for (var e2 = {}, r2 = 0; r2 < 10; r2++)
      e2["_" + String.fromCharCode(r2)] = r2;
    var n2 = Object.getOwnPropertyNames(e2).map(function(o2) {
      return e2[o2];
    });
    if (n2.join("") !== "0123456789")
      return false;
    var i2 = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(o2) {
      i2[o2] = o2;
    }), Object.keys(Object.assign({}, i2)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return false;
  }
}
var _f = Fw() ? Object.assign : function(t2, e2) {
  for (var r2, n2 = Uw(t2), i2, o2 = 1; o2 < arguments.length; o2++) {
    r2 = Object(arguments[o2]);
    for (var s2 in r2)
      Lw.call(r2, s2) && (n2[s2] = r2[s2]);
    if (Uu) {
      i2 = Uu(r2);
      for (var a2 = 0; a2 < i2.length; a2++)
        Nw.call(r2, i2[a2]) && (n2[i2[a2]] = r2[i2[a2]]);
    }
  }
  return n2;
};
var jw = Pn(_f);
var to;
var Fu;
function Js() {
  if (Fu)
    return to;
  Fu = 1;
  var t2 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return to = t2, to;
}
var ro;
var ju;
function bf() {
  return ju || (ju = 1, ro = Function.call.bind(Object.prototype.hasOwnProperty)), ro;
}
var no;
var $u;
function $w() {
  if ($u)
    return no;
  $u = 1;
  var t2 = function() {
  };
  if (true) {
    var e2 = Js(), r2 = {}, n2 = bf();
    t2 = function(o2) {
      var s2 = "Warning: " + o2;
      typeof console < "u" && console.error(s2);
      try {
        throw new Error(s2);
      } catch {
      }
    };
  }
  function i2(o2, s2, a2, f2, p2) {
    if (true) {
      for (var d2 in o2)
        if (n2(o2, d2)) {
          var y2;
          try {
            if (typeof o2[d2] != "function") {
              var v3 = Error(
                (f2 || "React class") + ": " + a2 + " type `" + d2 + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o2[d2] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw v3.name = "Invariant Violation", v3;
            }
            y2 = o2[d2](s2, d2, f2, a2, null, e2);
          } catch (I3) {
            y2 = I3;
          }
          if (y2 && !(y2 instanceof Error) && t2(
            (f2 || "React class") + ": type specification of " + a2 + " `" + d2 + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof y2 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), y2 instanceof Error && !(y2.message in r2)) {
            r2[y2.message] = true;
            var w3 = p2 ? p2() : "";
            t2(
              "Failed " + a2 + " type: " + y2.message + (w3 ?? "")
            );
          }
        }
    }
  }
  return i2.resetWarningCache = function() {
    r2 = {};
  }, no = i2, no;
}
var io;
var Vu;
function Vw() {
  if (Vu)
    return io;
  Vu = 1;
  var t2 = zo(), e2 = _f, r2 = Js(), n2 = bf(), i2 = $w(), o2 = function() {
  };
  o2 = function(a2) {
    var f2 = "Warning: " + a2;
    typeof console < "u" && console.error(f2);
    try {
      throw new Error(f2);
    } catch {
    }
  };
  function s2() {
    return null;
  }
  return io = function(a2, f2) {
    var p2 = typeof Symbol == "function" && Symbol.iterator, d2 = "@@iterator";
    function y2(l2) {
      var x3 = l2 && (p2 && l2[p2] || l2[d2]);
      if (typeof x3 == "function")
        return x3;
    }
    var v3 = "<<anonymous>>", w3 = {
      array: M3("array"),
      bigint: M3("bigint"),
      bool: M3("boolean"),
      func: M3("function"),
      number: M3("number"),
      object: M3("object"),
      string: M3("string"),
      symbol: M3("symbol"),
      any: S2(),
      arrayOf: Y2,
      element: W2(),
      elementType: Q3(),
      instanceOf: X3,
      node: ie(),
      objectOf: ue,
      oneOf: ne,
      oneOfType: se,
      shape: c2,
      exact: m2
    };
    function I3(l2, x3) {
      return l2 === x3 ? l2 !== 0 || 1 / l2 === 1 / x3 : l2 !== l2 && x3 !== x3;
    }
    function N11(l2, x3) {
      this.message = l2, this.data = x3 && typeof x3 == "object" ? x3 : {}, this.stack = "";
    }
    N11.prototype = Error.prototype;
    function k2(l2) {
      if (true)
        var x3 = {}, re = 0;
      function ae(ce, me, ye, xe, ve, b2, R2) {
        if (xe = xe || v3, b2 = b2 || ye, R2 !== r2) {
          if (f2) {
            var E3 = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw E3.name = "Invariant Violation", E3;
          } else if (typeof console < "u") {
            var V2 = xe + ":" + ye;
            !x3[V2] && // Avoid spamming the console because they are often not actionable except for lib authors
            re < 3 && (o2(
              "You are manually calling a React.PropTypes validation function for the `" + b2 + "` prop on `" + xe + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), x3[V2] = true, re++);
          }
        }
        return me[ye] == null ? ce ? me[ye] === null ? new N11("The " + ve + " `" + b2 + "` is marked as required " + ("in `" + xe + "`, but its value is `null`.")) : new N11("The " + ve + " `" + b2 + "` is marked as required in " + ("`" + xe + "`, but its value is `undefined`.")) : null : l2(me, ye, xe, ve, b2);
      }
      var G2 = ae.bind(null, false);
      return G2.isRequired = ae.bind(null, true), G2;
    }
    function M3(l2) {
      function x3(re, ae, G2, ce, me, ye) {
        var xe = re[ae], ve = C3(xe);
        if (ve !== l2) {
          var b2 = L2(xe);
          return new N11(
            "Invalid " + ce + " `" + me + "` of type " + ("`" + b2 + "` supplied to `" + G2 + "`, expected ") + ("`" + l2 + "`."),
            { expectedType: l2 }
          );
        }
        return null;
      }
      return k2(x3);
    }
    function S2() {
      return k2(s2);
    }
    function Y2(l2) {
      function x3(re, ae, G2, ce, me) {
        if (typeof l2 != "function")
          return new N11("Property `" + me + "` of component `" + G2 + "` has invalid PropType notation inside arrayOf.");
        var ye = re[ae];
        if (!Array.isArray(ye)) {
          var xe = C3(ye);
          return new N11("Invalid " + ce + " `" + me + "` of type " + ("`" + xe + "` supplied to `" + G2 + "`, expected an array."));
        }
        for (var ve = 0; ve < ye.length; ve++) {
          var b2 = l2(ye, ve, G2, ce, me + "[" + ve + "]", r2);
          if (b2 instanceof Error)
            return b2;
        }
        return null;
      }
      return k2(x3);
    }
    function W2() {
      function l2(x3, re, ae, G2, ce) {
        var me = x3[re];
        if (!a2(me)) {
          var ye = C3(me);
          return new N11("Invalid " + G2 + " `" + ce + "` of type " + ("`" + ye + "` supplied to `" + ae + "`, expected a single ReactElement."));
        }
        return null;
      }
      return k2(l2);
    }
    function Q3() {
      function l2(x3, re, ae, G2, ce) {
        var me = x3[re];
        if (!t2.isValidElementType(me)) {
          var ye = C3(me);
          return new N11("Invalid " + G2 + " `" + ce + "` of type " + ("`" + ye + "` supplied to `" + ae + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return k2(l2);
    }
    function X3(l2) {
      function x3(re, ae, G2, ce, me) {
        if (!(re[ae] instanceof l2)) {
          var ye = l2.name || v3, xe = P3(re[ae]);
          return new N11("Invalid " + ce + " `" + me + "` of type " + ("`" + xe + "` supplied to `" + G2 + "`, expected ") + ("instance of `" + ye + "`."));
        }
        return null;
      }
      return k2(x3);
    }
    function ne(l2) {
      if (!Array.isArray(l2))
        return arguments.length > 1 ? o2(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o2("Invalid argument supplied to oneOf, expected an array."), s2;
      function x3(re, ae, G2, ce, me) {
        for (var ye = re[ae], xe = 0; xe < l2.length; xe++)
          if (I3(ye, l2[xe]))
            return null;
        var ve = JSON.stringify(l2, function(R2, E3) {
          var V2 = L2(E3);
          return V2 === "symbol" ? String(E3) : E3;
        });
        return new N11("Invalid " + ce + " `" + me + "` of value `" + String(ye) + "` " + ("supplied to `" + G2 + "`, expected one of " + ve + "."));
      }
      return k2(x3);
    }
    function ue(l2) {
      function x3(re, ae, G2, ce, me) {
        if (typeof l2 != "function")
          return new N11("Property `" + me + "` of component `" + G2 + "` has invalid PropType notation inside objectOf.");
        var ye = re[ae], xe = C3(ye);
        if (xe !== "object")
          return new N11("Invalid " + ce + " `" + me + "` of type " + ("`" + xe + "` supplied to `" + G2 + "`, expected an object."));
        for (var ve in ye)
          if (n2(ye, ve)) {
            var b2 = l2(ye, ve, G2, ce, me + "." + ve, r2);
            if (b2 instanceof Error)
              return b2;
          }
        return null;
      }
      return k2(x3);
    }
    function se(l2) {
      if (!Array.isArray(l2))
        return o2("Invalid argument supplied to oneOfType, expected an instance of array."), s2;
      for (var x3 = 0; x3 < l2.length; x3++) {
        var re = l2[x3];
        if (typeof re != "function")
          return o2(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + H2(re) + " at index " + x3 + "."
          ), s2;
      }
      function ae(G2, ce, me, ye, xe) {
        for (var ve = [], b2 = 0; b2 < l2.length; b2++) {
          var R2 = l2[b2], E3 = R2(G2, ce, me, ye, xe, r2);
          if (E3 == null)
            return null;
          E3.data && n2(E3.data, "expectedType") && ve.push(E3.data.expectedType);
        }
        var V2 = ve.length > 0 ? ", expected one of type [" + ve.join(", ") + "]" : "";
        return new N11("Invalid " + ye + " `" + xe + "` supplied to " + ("`" + me + "`" + V2 + "."));
      }
      return k2(ae);
    }
    function ie() {
      function l2(x3, re, ae, G2, ce) {
        return _3(x3[re]) ? null : new N11("Invalid " + G2 + " `" + ce + "` supplied to " + ("`" + ae + "`, expected a ReactNode."));
      }
      return k2(l2);
    }
    function O2(l2, x3, re, ae, G2) {
      return new N11(
        (l2 || "React class") + ": " + x3 + " type `" + re + "." + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + G2 + "`."
      );
    }
    function c2(l2) {
      function x3(re, ae, G2, ce, me) {
        var ye = re[ae], xe = C3(ye);
        if (xe !== "object")
          return new N11("Invalid " + ce + " `" + me + "` of type `" + xe + "` " + ("supplied to `" + G2 + "`, expected `object`."));
        for (var ve in l2) {
          var b2 = l2[ve];
          if (typeof b2 != "function")
            return O2(G2, ce, me, ve, L2(b2));
          var R2 = b2(ye, ve, G2, ce, me + "." + ve, r2);
          if (R2)
            return R2;
        }
        return null;
      }
      return k2(x3);
    }
    function m2(l2) {
      function x3(re, ae, G2, ce, me) {
        var ye = re[ae], xe = C3(ye);
        if (xe !== "object")
          return new N11("Invalid " + ce + " `" + me + "` of type `" + xe + "` " + ("supplied to `" + G2 + "`, expected `object`."));
        var ve = e2({}, re[ae], l2);
        for (var b2 in ve) {
          var R2 = l2[b2];
          if (n2(l2, b2) && typeof R2 != "function")
            return O2(G2, ce, me, b2, L2(R2));
          if (!R2)
            return new N11(
              "Invalid " + ce + " `" + me + "` key `" + b2 + "` supplied to `" + G2 + "`.\nBad object: " + JSON.stringify(re[ae], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(l2), null, "  ")
            );
          var E3 = R2(ye, b2, G2, ce, me + "." + b2, r2);
          if (E3)
            return E3;
        }
        return null;
      }
      return k2(x3);
    }
    function _3(l2) {
      switch (typeof l2) {
        case "number":
        case "string":
        case "undefined":
          return true;
        case "boolean":
          return !l2;
        case "object":
          if (Array.isArray(l2))
            return l2.every(_3);
          if (l2 === null || a2(l2))
            return true;
          var x3 = y2(l2);
          if (x3) {
            var re = x3.call(l2), ae;
            if (x3 !== l2.entries) {
              for (; !(ae = re.next()).done; )
                if (!_3(ae.value))
                  return false;
            } else
              for (; !(ae = re.next()).done; ) {
                var G2 = ae.value;
                if (G2 && !_3(G2[1]))
                  return false;
              }
          } else
            return false;
          return true;
        default:
          return false;
      }
    }
    function T3(l2, x3) {
      return l2 === "symbol" ? true : x3 ? x3["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && x3 instanceof Symbol : false;
    }
    function C3(l2) {
      var x3 = typeof l2;
      return Array.isArray(l2) ? "array" : l2 instanceof RegExp ? "object" : T3(x3, l2) ? "symbol" : x3;
    }
    function L2(l2) {
      if (typeof l2 > "u" || l2 === null)
        return "" + l2;
      var x3 = C3(l2);
      if (x3 === "object") {
        if (l2 instanceof Date)
          return "date";
        if (l2 instanceof RegExp)
          return "regexp";
      }
      return x3;
    }
    function H2(l2) {
      var x3 = L2(l2);
      switch (x3) {
        case "array":
        case "object":
          return "an " + x3;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + x3;
        default:
          return x3;
      }
    }
    function P3(l2) {
      return !l2.constructor || !l2.constructor.name ? v3 : l2.constructor.name;
    }
    return w3.checkPropTypes = i2, w3.resetWarningCache = i2.resetWarningCache, w3.PropTypes = w3, w3;
  }, io;
}
if (true) {
  Ww = zo(), Hw = true;
  ko.exports = Vw()(Ww.isElement, Hw);
} else
  ko.exports = qw()();
var Ww;
var Hw;
var Kw = ko.exports;
var ze = Pn(Kw);
function zw(t2) {
  return t2 && typeof t2 == "object" && "default" in t2 ? t2.default : t2;
}
var xf = import_react.default;
var Gw = zw(xf);
function Wu(t2, e2, r2) {
  return e2 in t2 ? Object.defineProperty(t2, e2, {
    value: r2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : t2[e2] = r2, t2;
}
function Yw(t2, e2) {
  t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, t2.__proto__ = e2;
}
var Xw = !!(typeof window < "u" && window.document && window.document.createElement);
function Zw(t2, e2, r2) {
  if (typeof t2 != "function")
    throw new Error("Expected reducePropsToState to be a function.");
  if (typeof e2 != "function")
    throw new Error("Expected handleStateChangeOnClient to be a function.");
  if (typeof r2 < "u" && typeof r2 != "function")
    throw new Error("Expected mapStateOnServer to either be undefined or a function.");
  function n2(i2) {
    return i2.displayName || i2.name || "Component";
  }
  return function(o2) {
    if (typeof o2 != "function")
      throw new Error("Expected WrappedComponent to be a React component.");
    var s2 = [], a2;
    function f2() {
      a2 = t2(s2.map(function(d2) {
        return d2.props;
      })), p2.canUseDOM ? e2(a2) : r2 && (a2 = r2(a2));
    }
    var p2 = function(d2) {
      Yw(y2, d2);
      function y2() {
        return d2.apply(this, arguments) || this;
      }
      y2.peek = function() {
        return a2;
      }, y2.rewind = function() {
        if (y2.canUseDOM)
          throw new Error("You may only call rewind() on the server. Call peek() to read the current state.");
        var I3 = a2;
        return a2 = void 0, s2 = [], I3;
      };
      var v3 = y2.prototype;
      return v3.UNSAFE_componentWillMount = function() {
        s2.push(this), f2();
      }, v3.componentDidUpdate = function() {
        f2();
      }, v3.componentWillUnmount = function() {
        var I3 = s2.indexOf(this);
        s2.splice(I3, 1), f2();
      }, v3.render = function() {
        return Gw.createElement(o2, this.props);
      }, y2;
    }(xf.PureComponent);
    return Wu(p2, "displayName", "SideEffect(" + n2(o2) + ")"), Wu(p2, "canUseDOM", Xw), p2;
  };
}
var Jw = Zw;
var Qw = Pn(Jw);
var e1 = typeof Element < "u";
var t1 = typeof Map == "function";
var r1 = typeof Set == "function";
var n1 = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function Zn(t2, e2) {
  if (t2 === e2)
    return true;
  if (t2 && e2 && typeof t2 == "object" && typeof e2 == "object") {
    if (t2.constructor !== e2.constructor)
      return false;
    var r2, n2, i2;
    if (Array.isArray(t2)) {
      if (r2 = t2.length, r2 != e2.length)
        return false;
      for (n2 = r2; n2-- !== 0; )
        if (!Zn(t2[n2], e2[n2]))
          return false;
      return true;
    }
    var o2;
    if (t1 && t2 instanceof Map && e2 instanceof Map) {
      if (t2.size !== e2.size)
        return false;
      for (o2 = t2.entries(); !(n2 = o2.next()).done; )
        if (!e2.has(n2.value[0]))
          return false;
      for (o2 = t2.entries(); !(n2 = o2.next()).done; )
        if (!Zn(n2.value[1], e2.get(n2.value[0])))
          return false;
      return true;
    }
    if (r1 && t2 instanceof Set && e2 instanceof Set) {
      if (t2.size !== e2.size)
        return false;
      for (o2 = t2.entries(); !(n2 = o2.next()).done; )
        if (!e2.has(n2.value[0]))
          return false;
      return true;
    }
    if (n1 && ArrayBuffer.isView(t2) && ArrayBuffer.isView(e2)) {
      if (r2 = t2.length, r2 != e2.length)
        return false;
      for (n2 = r2; n2-- !== 0; )
        if (t2[n2] !== e2[n2])
          return false;
      return true;
    }
    if (t2.constructor === RegExp)
      return t2.source === e2.source && t2.flags === e2.flags;
    if (t2.valueOf !== Object.prototype.valueOf && typeof t2.valueOf == "function" && typeof e2.valueOf == "function")
      return t2.valueOf() === e2.valueOf();
    if (t2.toString !== Object.prototype.toString && typeof t2.toString == "function" && typeof e2.toString == "function")
      return t2.toString() === e2.toString();
    if (i2 = Object.keys(t2), r2 = i2.length, r2 !== Object.keys(e2).length)
      return false;
    for (n2 = r2; n2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(e2, i2[n2]))
        return false;
    if (e1 && t2 instanceof Element)
      return false;
    for (n2 = r2; n2-- !== 0; )
      if (!((i2[n2] === "_owner" || i2[n2] === "__v" || i2[n2] === "__o") && t2.$$typeof) && !Zn(t2[i2[n2]], e2[i2[n2]]))
        return false;
    return true;
  }
  return t2 !== t2 && e2 !== e2;
}
var i1 = function(e2, r2) {
  try {
    return Zn(e2, r2);
  } catch (n2) {
    if ((n2.message || "").match(/stack|recursion/i))
      return console.warn("react-fast-compare cannot handle circular refs"), false;
    throw n2;
  }
};
var o1 = Pn(i1);
var br2 = {
  BODY: "bodyAttributes",
  HTML: "htmlAttributes",
  TITLE: "titleAttributes"
};
var Pe = {
  BASE: "base",
  BODY: "body",
  HEAD: "head",
  HTML: "html",
  LINK: "link",
  META: "meta",
  NOSCRIPT: "noscript",
  SCRIPT: "script",
  STYLE: "style",
  TITLE: "title"
};
var Hu = Object.keys(Pe).map(function(t2) {
  return Pe[t2];
});
var Ge = {
  CHARSET: "charset",
  CSS_TEXT: "cssText",
  HREF: "href",
  HTTPEQUIV: "http-equiv",
  INNER_HTML: "innerHTML",
  ITEM_PROP: "itemprop",
  NAME: "name",
  PROPERTY: "property",
  REL: "rel",
  SRC: "src",
  TARGET: "target"
};
var fi = {
  accesskey: "accessKey",
  charset: "charSet",
  class: "className",
  contenteditable: "contentEditable",
  contextmenu: "contextMenu",
  "http-equiv": "httpEquiv",
  itemprop: "itemProp",
  tabindex: "tabIndex"
};
var An = {
  DEFAULT_TITLE: "defaultTitle",
  DEFER: "defer",
  ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
  ON_CHANGE_CLIENT_STATE: "onChangeClientState",
  TITLE_TEMPLATE: "titleTemplate"
};
var s1 = Object.keys(fi).reduce(function(t2, e2) {
  return t2[fi[e2]] = e2, t2;
}, {});
var a1 = [Pe.NOSCRIPT, Pe.SCRIPT, Pe.STYLE];
var $t = "data-react-helmet";
var u1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t2) {
  return typeof t2;
} : function(t2) {
  return t2 && typeof Symbol == "function" && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
};
var c1 = function(t2, e2) {
  if (!(t2 instanceof e2))
    throw new TypeError("Cannot call a class as a function");
};
var l1 = /* @__PURE__ */ function() {
  function t2(e2, r2) {
    for (var n2 = 0; n2 < r2.length; n2++) {
      var i2 = r2[n2];
      i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e2, i2.key, i2);
    }
  }
  return function(e2, r2, n2) {
    return r2 && t2(e2.prototype, r2), n2 && t2(e2, n2), e2;
  };
}();
var At = Object.assign || function(t2) {
  for (var e2 = 1; e2 < arguments.length; e2++) {
    var r2 = arguments[e2];
    for (var n2 in r2)
      Object.prototype.hasOwnProperty.call(r2, n2) && (t2[n2] = r2[n2]);
  }
  return t2;
};
var f1 = function(t2, e2) {
  if (typeof e2 != "function" && e2 !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e2);
  t2.prototype = Object.create(e2 && e2.prototype, {
    constructor: {
      value: t2,
      enumerable: false,
      writable: true,
      configurable: true
    }
  }), e2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t2, e2) : t2.__proto__ = e2);
};
var Ku = function(t2, e2) {
  var r2 = {};
  for (var n2 in t2)
    e2.indexOf(n2) >= 0 || Object.prototype.hasOwnProperty.call(t2, n2) && (r2[n2] = t2[n2]);
  return r2;
};
var h1 = function(t2, e2) {
  if (!t2)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2 && (typeof e2 == "object" || typeof e2 == "function") ? e2 : t2;
};
var Do = function(e2) {
  var r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return r2 === false ? String(e2) : String(e2).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
};
var d1 = function(e2) {
  var r2 = $r2(e2, Pe.TITLE), n2 = $r2(e2, An.TITLE_TEMPLATE);
  if (n2 && r2)
    return n2.replace(/%s/g, function() {
      return Array.isArray(r2) ? r2.join("") : r2;
    });
  var i2 = $r2(e2, An.DEFAULT_TITLE);
  return r2 || i2 || void 0;
};
var p1 = function(e2) {
  return $r2(e2, An.ON_CHANGE_CLIENT_STATE) || function() {
  };
};
var so = function(e2, r2) {
  return r2.filter(function(n2) {
    return typeof n2[e2] < "u";
  }).map(function(n2) {
    return n2[e2];
  }).reduce(function(n2, i2) {
    return At({}, n2, i2);
  }, {});
};
var m1 = function(e2, r2) {
  return r2.filter(function(n2) {
    return typeof n2[Pe.BASE] < "u";
  }).map(function(n2) {
    return n2[Pe.BASE];
  }).reverse().reduce(function(n2, i2) {
    if (!n2.length)
      for (var o2 = Object.keys(i2), s2 = 0; s2 < o2.length; s2++) {
        var a2 = o2[s2], f2 = a2.toLowerCase();
        if (e2.indexOf(f2) !== -1 && i2[f2])
          return n2.concat(i2);
      }
    return n2;
  }, []);
};
var un = function(e2, r2, n2) {
  var i2 = {};
  return n2.filter(function(o2) {
    return Array.isArray(o2[e2]) ? true : (typeof o2[e2] < "u" && No("Helmet: " + e2 + ' should be of type "Array". Instead found type "' + u1(o2[e2]) + '"'), false);
  }).map(function(o2) {
    return o2[e2];
  }).reverse().reduce(function(o2, s2) {
    var a2 = {};
    s2.filter(function(v3) {
      for (var w3 = void 0, I3 = Object.keys(v3), N11 = 0; N11 < I3.length; N11++) {
        var k2 = I3[N11], M3 = k2.toLowerCase();
        r2.indexOf(M3) !== -1 && !(w3 === Ge.REL && v3[w3].toLowerCase() === "canonical") && !(M3 === Ge.REL && v3[M3].toLowerCase() === "stylesheet") && (w3 = M3), r2.indexOf(k2) !== -1 && (k2 === Ge.INNER_HTML || k2 === Ge.CSS_TEXT || k2 === Ge.ITEM_PROP) && (w3 = k2);
      }
      if (!w3 || !v3[w3])
        return false;
      var S2 = v3[w3].toLowerCase();
      return i2[w3] || (i2[w3] = {}), a2[w3] || (a2[w3] = {}), i2[w3][S2] ? false : (a2[w3][S2] = true, true);
    }).reverse().forEach(function(v3) {
      return o2.push(v3);
    });
    for (var f2 = Object.keys(a2), p2 = 0; p2 < f2.length; p2++) {
      var d2 = f2[p2], y2 = jw({}, i2[d2], a2[d2]);
      i2[d2] = y2;
    }
    return o2;
  }, []).reverse();
};
var $r2 = function(e2, r2) {
  for (var n2 = e2.length - 1; n2 >= 0; n2--) {
    var i2 = e2[n2];
    if (i2.hasOwnProperty(r2))
      return i2[r2];
  }
  return null;
};
var g1 = function(e2) {
  return {
    baseTag: m1([Ge.HREF, Ge.TARGET], e2),
    bodyAttributes: so(br2.BODY, e2),
    defer: $r2(e2, An.DEFER),
    encode: $r2(e2, An.ENCODE_SPECIAL_CHARACTERS),
    htmlAttributes: so(br2.HTML, e2),
    linkTags: un(Pe.LINK, [Ge.REL, Ge.HREF], e2),
    metaTags: un(Pe.META, [Ge.NAME, Ge.CHARSET, Ge.HTTPEQUIV, Ge.PROPERTY, Ge.ITEM_PROP], e2),
    noscriptTags: un(Pe.NOSCRIPT, [Ge.INNER_HTML], e2),
    onChangeClientState: p1(e2),
    scriptTags: un(Pe.SCRIPT, [Ge.SRC, Ge.INNER_HTML], e2),
    styleTags: un(Pe.STYLE, [Ge.CSS_TEXT], e2),
    title: d1(e2),
    titleAttributes: so(br2.TITLE, e2)
  };
};
var Lo = function() {
  var t2 = Date.now();
  return function(e2) {
    var r2 = Date.now();
    r2 - t2 > 16 ? (t2 = r2, e2(r2)) : setTimeout(function() {
      Lo(e2);
    }, 0);
  };
}();
var zu = function(e2) {
  return clearTimeout(e2);
};
var y1 = typeof window < "u" ? window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || Lo : global.requestAnimationFrame || Lo;
var v1 = typeof window < "u" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || zu : global.cancelAnimationFrame || zu;
var No = function(e2) {
  return console && typeof console.warn == "function" && console.warn(e2);
};
var cn = null;
var w1 = function(e2) {
  cn && v1(cn), e2.defer ? cn = y1(function() {
    Gu(e2, function() {
      cn = null;
    });
  }) : (Gu(e2), cn = null);
};
var Gu = function(e2, r2) {
  var n2 = e2.baseTag, i2 = e2.bodyAttributes, o2 = e2.htmlAttributes, s2 = e2.linkTags, a2 = e2.metaTags, f2 = e2.noscriptTags, p2 = e2.onChangeClientState, d2 = e2.scriptTags, y2 = e2.styleTags, v3 = e2.title, w3 = e2.titleAttributes;
  Uo(Pe.BODY, i2), Uo(Pe.HTML, o2), _1(v3, w3);
  var I3 = {
    baseTag: Or(Pe.BASE, n2),
    linkTags: Or(Pe.LINK, s2),
    metaTags: Or(Pe.META, a2),
    noscriptTags: Or(Pe.NOSCRIPT, f2),
    scriptTags: Or(Pe.SCRIPT, d2),
    styleTags: Or(Pe.STYLE, y2)
  }, N11 = {}, k2 = {};
  Object.keys(I3).forEach(function(M3) {
    var S2 = I3[M3], Y2 = S2.newTags, W2 = S2.oldTags;
    Y2.length && (N11[M3] = Y2), W2.length && (k2[M3] = I3[M3].oldTags);
  }), r2 && r2(), p2(e2, N11, k2);
};
var Tf = function(e2) {
  return Array.isArray(e2) ? e2.join("") : e2;
};
var _1 = function(e2, r2) {
  typeof e2 < "u" && document.title !== e2 && (document.title = Tf(e2)), Uo(Pe.TITLE, r2);
};
var Uo = function(e2, r2) {
  var n2 = document.getElementsByTagName(e2)[0];
  if (n2) {
    for (var i2 = n2.getAttribute($t), o2 = i2 ? i2.split(",") : [], s2 = [].concat(o2), a2 = Object.keys(r2), f2 = 0; f2 < a2.length; f2++) {
      var p2 = a2[f2], d2 = r2[p2] || "";
      n2.getAttribute(p2) !== d2 && n2.setAttribute(p2, d2), o2.indexOf(p2) === -1 && o2.push(p2);
      var y2 = s2.indexOf(p2);
      y2 !== -1 && s2.splice(y2, 1);
    }
    for (var v3 = s2.length - 1; v3 >= 0; v3--)
      n2.removeAttribute(s2[v3]);
    o2.length === s2.length ? n2.removeAttribute($t) : n2.getAttribute($t) !== a2.join(",") && n2.setAttribute($t, a2.join(","));
  }
};
var Or = function(e2, r2) {
  var n2 = document.head || document.querySelector(Pe.HEAD), i2 = n2.querySelectorAll(e2 + "[" + $t + "]"), o2 = Array.prototype.slice.call(i2), s2 = [], a2 = void 0;
  return r2 && r2.length && r2.forEach(function(f2) {
    var p2 = document.createElement(e2);
    for (var d2 in f2)
      if (f2.hasOwnProperty(d2))
        if (d2 === Ge.INNER_HTML)
          p2.innerHTML = f2.innerHTML;
        else if (d2 === Ge.CSS_TEXT)
          p2.styleSheet ? p2.styleSheet.cssText = f2.cssText : p2.appendChild(document.createTextNode(f2.cssText));
        else {
          var y2 = typeof f2[d2] > "u" ? "" : f2[d2];
          p2.setAttribute(d2, y2);
        }
    p2.setAttribute($t, "true"), o2.some(function(v3, w3) {
      return a2 = w3, p2.isEqualNode(v3);
    }) ? o2.splice(a2, 1) : s2.push(p2);
  }), o2.forEach(function(f2) {
    return f2.parentNode.removeChild(f2);
  }), s2.forEach(function(f2) {
    return n2.appendChild(f2);
  }), {
    oldTags: o2,
    newTags: s2
  };
};
var Ef = function(e2) {
  return Object.keys(e2).reduce(function(r2, n2) {
    var i2 = typeof e2[n2] < "u" ? n2 + '="' + e2[n2] + '"' : "" + n2;
    return r2 ? r2 + " " + i2 : i2;
  }, "");
};
var b1 = function(e2, r2, n2, i2) {
  var o2 = Ef(n2), s2 = Tf(r2);
  return o2 ? "<" + e2 + " " + $t + '="true" ' + o2 + ">" + Do(s2, i2) + "</" + e2 + ">" : "<" + e2 + " " + $t + '="true">' + Do(s2, i2) + "</" + e2 + ">";
};
var x1 = function(e2, r2, n2) {
  return r2.reduce(function(i2, o2) {
    var s2 = Object.keys(o2).filter(function(p2) {
      return !(p2 === Ge.INNER_HTML || p2 === Ge.CSS_TEXT);
    }).reduce(function(p2, d2) {
      var y2 = typeof o2[d2] > "u" ? d2 : d2 + '="' + Do(o2[d2], n2) + '"';
      return p2 ? p2 + " " + y2 : y2;
    }, ""), a2 = o2.innerHTML || o2.cssText || "", f2 = a1.indexOf(e2) === -1;
    return i2 + "<" + e2 + " " + $t + '="true" ' + s2 + (f2 ? "/>" : ">" + a2 + "</" + e2 + ">");
  }, "");
};
var Af = function(e2) {
  var r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Object.keys(e2).reduce(function(n2, i2) {
    return n2[fi[i2] || i2] = e2[i2], n2;
  }, r2);
};
var T1 = function(e2) {
  var r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Object.keys(e2).reduce(function(n2, i2) {
    return n2[s1[i2] || i2] = e2[i2], n2;
  }, r2);
};
var E1 = function(e2, r2, n2) {
  var i2, o2 = (i2 = {
    key: r2
  }, i2[$t] = true, i2), s2 = Af(n2, o2);
  return [import_react.default.createElement(Pe.TITLE, s2, r2)];
};
var A1 = function(e2, r2) {
  return r2.map(function(n2, i2) {
    var o2, s2 = (o2 = {
      key: i2
    }, o2[$t] = true, o2);
    return Object.keys(n2).forEach(function(a2) {
      var f2 = fi[a2] || a2;
      if (f2 === Ge.INNER_HTML || f2 === Ge.CSS_TEXT) {
        var p2 = n2.innerHTML || n2.cssText;
        s2.dangerouslySetInnerHTML = { __html: p2 };
      } else
        s2[f2] = n2[a2];
    }), import_react.default.createElement(e2, s2);
  });
};
var Zt = function(e2, r2, n2) {
  switch (e2) {
    case Pe.TITLE:
      return {
        toComponent: function() {
          return E1(e2, r2.title, r2.titleAttributes);
        },
        toString: function() {
          return b1(e2, r2.title, r2.titleAttributes, n2);
        }
      };
    case br2.BODY:
    case br2.HTML:
      return {
        toComponent: function() {
          return Af(r2);
        },
        toString: function() {
          return Ef(r2);
        }
      };
    default:
      return {
        toComponent: function() {
          return A1(e2, r2);
        },
        toString: function() {
          return x1(e2, r2, n2);
        }
      };
  }
};
var Mf = function(e2) {
  var r2 = e2.baseTag, n2 = e2.bodyAttributes, i2 = e2.encode, o2 = e2.htmlAttributes, s2 = e2.linkTags, a2 = e2.metaTags, f2 = e2.noscriptTags, p2 = e2.scriptTags, d2 = e2.styleTags, y2 = e2.title, v3 = y2 === void 0 ? "" : y2, w3 = e2.titleAttributes;
  return {
    base: Zt(Pe.BASE, r2, i2),
    bodyAttributes: Zt(br2.BODY, n2, i2),
    htmlAttributes: Zt(br2.HTML, o2, i2),
    link: Zt(Pe.LINK, s2, i2),
    meta: Zt(Pe.META, a2, i2),
    noscript: Zt(Pe.NOSCRIPT, f2, i2),
    script: Zt(Pe.SCRIPT, p2, i2),
    style: Zt(Pe.STYLE, d2, i2),
    title: Zt(Pe.TITLE, { title: v3, titleAttributes: w3 }, i2)
  };
};
var M1 = function(e2) {
  var r2, n2;
  return n2 = r2 = function(i2) {
    f1(o2, i2);
    function o2() {
      return c1(this, o2), h1(this, i2.apply(this, arguments));
    }
    return o2.prototype.shouldComponentUpdate = function(a2) {
      return !o1(this.props, a2);
    }, o2.prototype.mapNestedChildrenToProps = function(a2, f2) {
      if (!f2)
        return null;
      switch (a2.type) {
        case Pe.SCRIPT:
        case Pe.NOSCRIPT:
          return {
            innerHTML: f2
          };
        case Pe.STYLE:
          return {
            cssText: f2
          };
      }
      throw new Error("<" + a2.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.");
    }, o2.prototype.flattenArrayTypeChildren = function(a2) {
      var f2, p2 = a2.child, d2 = a2.arrayTypeChildren, y2 = a2.newChildProps, v3 = a2.nestedChildren;
      return At({}, d2, (f2 = {}, f2[p2.type] = [].concat(d2[p2.type] || [], [At({}, y2, this.mapNestedChildrenToProps(p2, v3))]), f2));
    }, o2.prototype.mapObjectTypeChildren = function(a2) {
      var f2, p2, d2 = a2.child, y2 = a2.newProps, v3 = a2.newChildProps, w3 = a2.nestedChildren;
      switch (d2.type) {
        case Pe.TITLE:
          return At({}, y2, (f2 = {}, f2[d2.type] = w3, f2.titleAttributes = At({}, v3), f2));
        case Pe.BODY:
          return At({}, y2, {
            bodyAttributes: At({}, v3)
          });
        case Pe.HTML:
          return At({}, y2, {
            htmlAttributes: At({}, v3)
          });
      }
      return At({}, y2, (p2 = {}, p2[d2.type] = At({}, v3), p2));
    }, o2.prototype.mapArrayTypeChildrenToProps = function(a2, f2) {
      var p2 = At({}, f2);
      return Object.keys(a2).forEach(function(d2) {
        var y2;
        p2 = At({}, p2, (y2 = {}, y2[d2] = a2[d2], y2));
      }), p2;
    }, o2.prototype.warnOnInvalidChildren = function(a2, f2) {
      if (true) {
        if (!Hu.some(function(p2) {
          return a2.type === p2;
        }))
          return typeof a2.type == "function" ? No("You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.") : No("Only elements types " + Hu.join(", ") + " are allowed. Helmet does not support rendering <" + a2.type + "> elements. Refer to our API for more information.");
        if (f2 && typeof f2 != "string" && (!Array.isArray(f2) || f2.some(function(p2) {
          return typeof p2 != "string";
        })))
          throw new Error("Helmet expects a string as a child of <" + a2.type + ">. Did you forget to wrap your children in braces? ( <" + a2.type + ">{``}</" + a2.type + "> ) Refer to our API for more information.");
      }
      return true;
    }, o2.prototype.mapChildrenToProps = function(a2, f2) {
      var p2 = this, d2 = {};
      return import_react.default.Children.forEach(a2, function(y2) {
        if (!(!y2 || !y2.props)) {
          var v3 = y2.props, w3 = v3.children, I3 = Ku(v3, ["children"]), N11 = T1(I3);
          switch (p2.warnOnInvalidChildren(y2, w3), y2.type) {
            case Pe.LINK:
            case Pe.META:
            case Pe.NOSCRIPT:
            case Pe.SCRIPT:
            case Pe.STYLE:
              d2 = p2.flattenArrayTypeChildren({
                child: y2,
                arrayTypeChildren: d2,
                newChildProps: N11,
                nestedChildren: w3
              });
              break;
            default:
              f2 = p2.mapObjectTypeChildren({
                child: y2,
                newProps: f2,
                newChildProps: N11,
                nestedChildren: w3
              });
              break;
          }
        }
      }), f2 = this.mapArrayTypeChildrenToProps(d2, f2), f2;
    }, o2.prototype.render = function() {
      var a2 = this.props, f2 = a2.children, p2 = Ku(a2, ["children"]), d2 = At({}, p2);
      return f2 && (d2 = this.mapChildrenToProps(f2, d2)), import_react.default.createElement(e2, d2);
    }, l1(o2, null, [{
      key: "canUseDOM",
      // Component.peek comes from react-side-effect:
      // For testing, you may use a static peek() method available on the returned component.
      // It lets you get the current state without resetting the mounted instance stack.
      // Don’t use it for anything other than testing.
      /**
       * @param {Object} base: {"target": "_blank", "href": "http://mysite.com/"}
       * @param {Object} bodyAttributes: {"className": "root"}
       * @param {String} defaultTitle: "Default Title"
       * @param {Boolean} defer: true
       * @param {Boolean} encodeSpecialCharacters: true
       * @param {Object} htmlAttributes: {"lang": "en", "amp": undefined}
       * @param {Array} link: [{"rel": "canonical", "href": "http://mysite.com/example"}]
       * @param {Array} meta: [{"name": "description", "content": "Test description"}]
       * @param {Array} noscript: [{"innerHTML": "<img src='http://mysite.com/js/test.js'"}]
       * @param {Function} onChangeClientState: "(newState) => console.log(newState)"
       * @param {Array} script: [{"type": "text/javascript", "src": "http://mysite.com/js/test.js"}]
       * @param {Array} style: [{"type": "text/css", "cssText": "div { display: block; color: blue; }"}]
       * @param {String} title: "Title"
       * @param {Object} titleAttributes: {"itemprop": "name"}
       * @param {String} titleTemplate: "MySite.com - %s"
       */
      set: function(a2) {
        e2.canUseDOM = a2;
      }
    }]), o2;
  }(import_react.default.Component), r2.propTypes = {
    base: ze.object,
    bodyAttributes: ze.object,
    children: ze.oneOfType([ze.arrayOf(ze.node), ze.node]),
    defaultTitle: ze.string,
    defer: ze.bool,
    encodeSpecialCharacters: ze.bool,
    htmlAttributes: ze.object,
    link: ze.arrayOf(ze.object),
    meta: ze.arrayOf(ze.object),
    noscript: ze.arrayOf(ze.object),
    onChangeClientState: ze.func,
    script: ze.arrayOf(ze.object),
    style: ze.arrayOf(ze.object),
    title: ze.string,
    titleAttributes: ze.object,
    titleTemplate: ze.string
  }, r2.defaultProps = {
    defer: true,
    encodeSpecialCharacters: true
  }, r2.peek = e2.peek, r2.rewind = function() {
    var i2 = e2.rewind();
    return i2 || (i2 = Mf({
      baseTag: [],
      bodyAttributes: {},
      encodeSpecialCharacters: true,
      htmlAttributes: {},
      linkTags: [],
      metaTags: [],
      noscriptTags: [],
      scriptTags: [],
      styleTags: [],
      title: "",
      titleAttributes: {}
    })), i2;
  }, n2;
};
var S1 = function() {
  return null;
};
var P1 = Qw(g1, w1, Mf)(S1);
var Fo = M1(P1);
Fo.renderStatic = Fo.rewind;
function V1({
  children: t2,
  theme: e2 = Yu,
  config: r2 = O1
}) {
  const [n2, i2] = (0, import_react.useReducer)(Dw, {
    ...Wo,
    config: r2
  });
  (0, import_react.useEffect)(() => {
    i2({
      type: "UPDATE_CONFIG",
      payload: r2
    });
  }, [r2]);
  const o2 = (0, import_react.useMemo)(
    () => ({
      ...Yu,
      ...e2
    }),
    [e2]
  );
  return Me(cc.Provider, { value: { state: n2, dispatch: i2 }, children: Me(
    Xh,
    {
      theme: {
        ...o2.displayTheme === "light" ? gc : Gh,
        displayTheme: o2.displayTheme || "light",
        theme: uc(o2.accent),
        themeConfig: o2
      },
      children: Fe(C1, { children: [
        Fe(Fo, { children: [
          Me("link", { rel: "preconnect", href: "https://fonts.googleapis.com" }),
          Me(
            "link",
            {
              rel: "preconnect",
              href: "https://fonts.gstatic.com",
              crossOrigin: ""
            }
          ),
          Me(
            "link",
            {
              href: "https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap",
              rel: "stylesheet"
            }
          )
        ] }),
        t2,
        Me(fw, {}),
        Me(Tw, {}),
        Me(Cv, {})
      ] })
    }
  ) });
}
var C1 = ({ children: t2 }) => (Jh(), uh(), Me(_n, { children: t2 }));
var Yu = {
  displayTheme: "light",
  accent: {
    r: 0,
    g: 0,
    b: 0
  },
  titleHighlight: {
    r: 0,
    g: 122,
    b: 255
  },
  radius: "default",
  font: {
    fontFamily: "Manrope"
  }
};
var O1 = {
  permissions: ["ACCESS_ADDRESS", "ACCESS_ALL_ADDRESSES"],
  ensurePermissions: false
};
export {
  V1 as ArweaveWalletKit,
  j1 as ConnectButton,
  di as useActiveAddress,
  ch as useAddresses,
  D1 as useApi,
  Jo as useConnection,
  Zh as usePermissions,
  td as useProfileModal,
  L1 as usePublicKey,
  ah as useStrategy,
  N12 as useWalletNames
};
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

shallow-clone/index.js:
  (*!
   * shallow-clone <https://github.com/jonschlinkert/shallow-clone>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

isobject/index.js:
  (*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-plain-object/index.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

warp-arbundles/build/web/esm/bundle.js:
  (*! Bundled license information:
  
  ieee754/index.js:
    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  
  buffer/index.js:
    (*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     *)
  *)

arweave-wallet-kit/dist/index.es.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

arweave-wallet-kit/dist/index.es.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

arweave-wallet-kit/dist/index.es.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

arweave-wallet-kit/dist/index.es.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

arweave-wallet-kit/dist/index.es.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

arweave-wallet-kit/dist/index.es.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/
//# sourceMappingURL=arweave-wallet-kit.js.map
